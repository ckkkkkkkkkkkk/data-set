package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class ValueReferencePtg extends Ptg { private final static int SIZE = 5 ; public final static byte sid = 0x44 ; private short field_1_row ; private short field_2_col ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public ValueReferencePtg ( ) { } public ValueReferencePtg ( byte [ ] data , int offset ) { offset ++ ; field_1_row = LittleEndian . getShort ( data , offset + 0 ) ; field_2_col = LittleEndian . getShort ( data , offset + 2 ) ; System . out . println ( toString ( ) ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( "[ValueReferencePtg]\n" ) ; buffer . append ( "row = " ) . append ( getRow ( ) ) . append ( "\n" ) ; buffer . append ( "col = " ) . append ( getColumnRaw ( ) ) . append ( "\n" ) ; buffer . append ( "rowrelative = " ) . append ( isRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "colrelative = " ) . append ( isColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { } public void setRow ( short row ) { field_1_row = row ; } public short getRow ( ) { return field_1_row ; } public boolean isRowRelative ( ) { return rowRelative . isSet ( field_2_col ) ; } public boolean isColRelative ( ) { return rowRelative . isSet ( field_2_col ) ; } public void setColumnRaw ( short col ) { field_2_col = col ; } public short getColumnRaw ( ) { return field_2_col ; } public void setColumn ( short col ) { field_2_col = col ; } public short getColumn ( ) { return field_2_col ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( ) { return "NO IDEA YET VALUE REF" ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class LineFormatRecord extends Record { public final static short sid = 0x1007 ; private int field_1_lineColor ; private short field_2_linePattern ; public final static short LINE_PATTERN_SOLID = 0 ; public final static short LINE_PATTERN_DASH = 1 ; public final static short LINE_PATTERN_DOT = 2 ; public final static short LINE_PATTERN_DASH_DOT = 3 ; public final static short LINE_PATTERN_DASH_DOT_DOT = 4 ; public final static short LINE_PATTERN_NONE = 5 ; public final static short LINE_PATTERN_DARK_GRAY_PATTERN = 6 ; public final static short LINE_PATTERN_MEDIUM_GRAY_PATTERN = 7 ; public final static short LINE_PATTERN_LIGHT_GRAY_PATTERN = 8 ; private short field_3_weight ; public final static short WEIGHT_HAIRLINE = - 1 ; public final static short WEIGHT_NARROW = 0 ; public final static short WEIGHT_MEDIUM = 1 ; public final static short WEIGHT_WIDE = 2 ; private short field_4_format ; private BitField auto = new BitField ( 0x1 ) ; private BitField drawTicks = new BitField ( 0x4 ) ; private BitField unknown = new BitField ( 0x4 ) ; private short field_5_colourPaletteIndex ; public LineFormatRecord ( ) { } public LineFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LineFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a LineFormat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_lineColor = LittleEndian . getInt ( data , 0x0 + offset ) ; field_2_linePattern = LittleEndian . getShort ( data , 0x4 + offset ) ; field_3_weight = LittleEndian . getShort ( data , 0x6 + offset ) ; field_4_format = LittleEndian . getShort ( data , 0x8 + offset ) ; field_5_colourPaletteIndex = LittleEndian . getShort ( data , 0xa + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[LineFormat]\n" ) ; buffer . append ( "    .lineColor            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getLineColor ( ) ) ) . append ( " (" ) . append ( getLineColor ( ) ) . append ( " )\n" ) ; buffer . append ( "    .linePattern          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getLinePattern ( ) ) ) . append ( " (" ) . append ( getLinePattern ( ) ) . append ( " )\n" ) ; buffer . append ( "    .weight               = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getWeight ( ) ) ) . append ( " (" ) . append ( getWeight ( ) ) . append ( " )\n" ) ; buffer . append ( "    .format               = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFormat ( ) ) ) . append ( " (" ) . append ( getFormat ( ) ) . append ( " )\n" ) ; buffer . append ( "         .auto                     = " ) . append ( isAuto ( ) ) . append ( '\n' ) ; buffer . append ( "         .drawTicks                = " ) . append ( isDrawTicks ( ) ) . append ( '\n' ) ; buffer . append ( "         .unknown                  = " ) . append ( isUnknown ( ) ) . append ( '\n' ) ; buffer . append ( "    .colourPaletteIndex   = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getColourPaletteIndex ( ) ) ) . append ( " (" ) . append ( getColourPaletteIndex ( ) ) . append ( " )\n" ) ; buffer . append ( "[/LineFormat]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset , field_1_lineColor ) ; LittleEndian . putShort ( data , 8 + offset , field_2_linePattern ) ; LittleEndian . putShort ( data , 10 + offset , field_3_weight ) ; LittleEndian . putShort ( data , 12 + offset , field_4_format ) ; LittleEndian . putShort ( data , 14 + offset , field_5_colourPaletteIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public int getLineColor ( ) { return field_1_lineColor ; } public void setLineColor ( int field_1_lineColor ) { this . field_1_lineColor = field_1_lineColor ; } public short getLinePattern ( ) { return field_2_linePattern ; } public void setLinePattern ( short field_2_linePattern ) { this . field_2_linePattern = field_2_linePattern ; } public short getWeight ( ) { return field_3_weight ; } public void setWeight ( short field_3_weight ) { this . field_3_weight = field_3_weight ; } public short getFormat ( ) { return field_4_format ; } public void setFormat ( short field_4_format ) { this . field_4_format = field_4_format ; } public short getColourPaletteIndex ( ) { return field_5_colourPaletteIndex ; } public void setColourPaletteIndex ( short field_5_colourPaletteIndex ) { this . field_5_colourPaletteIndex = field_5_colourPaletteIndex ; } public void setAuto ( boolean value ) { field_4_format = auto . setShortBoolean ( field_4_format , value ) ; } public boolean isAuto ( ) { return auto . isSet ( field_4_format ) ; } public void setDrawTicks ( boolean value ) { field_4_format = drawTicks . setShortBoolean ( field_4_format , value ) ; } public boolean isDrawTicks ( ) { return drawTicks . isSet ( field_4_format ) ; } public void setUnknown ( boolean value ) { field_4_format = unknown . setShortBoolean ( field_4_format , value ) ; } public boolean isUnknown ( ) { return unknown . isSet ( field_4_format ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class InterfaceHdrRecord extends Record { public final static short sid = 0xe1 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public InterfaceHdrRecord ( ) { } public InterfaceHdrRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public InterfaceHdrRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A INTERFACEHDR RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INTERFACEHDR]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/INTERFACEHDR]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class AttrPtg extends Ptg implements OperationPtg { public final static short sid = 0x19 ; private final static int SIZE = 4 ; private byte field_1_options ; private short field_2_data ; private BitField semiVolatile = new BitField ( 0x01 ) ; private BitField optiIf = new BitField ( 0x02 ) ; private BitField optiChoose = new BitField ( 0x04 ) ; private BitField optGoto = new BitField ( 0x08 ) ; private BitField sum = new BitField ( 0x10 ) ; private BitField baxcel = new BitField ( 0x20 ) ; private BitField space = new BitField ( 0x40 ) ; public AttrPtg ( ) { } public AttrPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_options = data [ offset + 0 ] ; field_2_data = LittleEndian . getShort ( data , offset + 1 ) ; System . out . println ( "OPTIONS = " + Integer . toHexString ( getOptions ( ) ) ) ; System . out . println ( "OPTIONS & 0x10 = " + ( getOptions ( ) & 0x10 ) ) ; System . out . println ( toString ( ) ) ; } public void setOptions ( byte options ) { field_1_options = options ; } public byte getOptions ( ) { return field_1_options ; } public boolean isSemiVolatile ( ) { return semiVolatile . isSet ( getOptions ( ) ) ; } public boolean isOptimizedIf ( ) { return optiIf . isSet ( getOptions ( ) ) ; } public boolean isOptimizedChoose ( ) { return optiChoose . isSet ( getOptions ( ) ) ; } public boolean isGoto ( ) { return optGoto . isSet ( getOptions ( ) ) ; } public boolean isSum ( ) { return sum . isSet ( getOptions ( ) ) ; } public boolean isBaxcel ( ) { return baxcel . isSet ( getOptions ( ) ) ; } public boolean isSpace ( ) { return space . isSet ( getOptions ( ) ) ; } public void setData ( short data ) { field_2_data = data ; } public short getData ( ) { return field_2_data ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AttrPtg\n" ) ; buffer . append ( "options=" ) . append ( field_1_options ) . append ( "\n" ) ; buffer . append ( "data   =" ) . append ( field_2_data ) . append ( "\n" ) ; buffer . append ( "semi   =" ) . append ( isSemiVolatile ( ) ) . append ( "\n" ) ; buffer . append ( "optimif=" ) . append ( isOptimizedIf ( ) ) . append ( "\n" ) ; buffer . append ( "optchos=" ) . append ( isOptimizedChoose ( ) ) . append ( "\n" ) ; buffer . append ( "isGoto =" ) . append ( isGoto ( ) ) . append ( "\n" ) ; buffer . append ( "isSum  =" ) . append ( isSum ( ) ) . append ( "\n" ) ; buffer . append ( "isBaxce=" ) . append ( isBaxcel ( ) ) . append ( "\n" ) ; buffer . append ( "isSpace=" ) . append ( isSpace ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return SIZE ; } public String toFormulaString ( ) { return "SUM()" ; } public String toFormulaString ( Ptg [ ] operands ) { return "SUM(" + operands [ 0 ] . toFormulaString ( ) + ")" ; } public int getNumberOfOperands ( ) { return 1 ; } public int getType ( ) { return - 1 ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class WindowProtectRecord extends Record { public final static short sid = 0x19 ; private short field_1_protect ; public WindowProtectRecord ( ) { } public WindowProtectRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowProtectRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WINDOWPROTECT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect == true ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public boolean getProtect ( ) { return ( field_1_protect == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOWPROTECT]\n" ) ; buffer . append ( "    .protect         = " ) . append ( getProtect ( ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOWPROTECT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_protect ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RKUtil ; public class RKRecord extends Record implements CellValueRecordInterface { public final static short sid = 0x27e ; public final static short RK_IEEE_NUMBER = 0 ; public final static short RK_IEEE_NUMBER_TIMES_100 = 1 ; public final static short RK_INTEGER = 2 ; public final static short RK_INTEGER_TIMES_100 = 3 ; private short field_1_row ; private short field_2_col ; private short field_3_xf_index ; private int field_4_rk_number ; public RKRecord ( ) { } public RKRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RKRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid RK RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_rk_number = LittleEndian . getInt ( data , 6 + offset ) ; } public short getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_col ; } public short getXFIndex ( ) { return field_3_xf_index ; } public int getRKField ( ) { return field_4_rk_number ; } public short getRKType ( ) { return ( short ) ( field_4_rk_number & 3 ) ; } public double getRKNumber ( ) { return RKUtil . decodeNumber ( field_4_rk_number ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[RK]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .col            = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .rknumber       = " ) . append ( Integer . toHexString ( getRKField ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .rktype     = " ) . append ( Integer . toHexString ( getRKType ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .rknumber   = " ) . append ( getRKNumber ( ) ) . append ( "\n" ) ; buffer . append ( "[/RK]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { NumberRecord rec = new NumberRecord ( ) ; rec . setColumn ( getColumn ( ) ) ; rec . setRow ( getRow ( ) ) ; rec . setValue ( getRKNumber ( ) ) ; rec . setXFIndex ( getXFIndex ( ) ) ; return rec . serialize ( offset , data ) ; } public static void main ( String ignored_args [ ] ) { int [ ] values = { 0x3FF00000 , 0x405EC001 , 0x02F1853A , 0x02F1853B , 0xFCDD699A } ; double [ ] rvalues = { 1 , 1.23 , 12345678 , 123456.78 , - 13149594 } ; for ( int j = 0 ; j < values . length ; j ++ ) { System . out . println ( "input = " + Integer . toHexString ( values [ j ] ) + " -> " + rvalues [ j ] + ": " + RKUtil . decodeNumber ( values [ j ] ) ) ; } } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public void setColumn ( short col ) { } public void setRow ( short row ) { } public void setXFIndex ( short xf ) { } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class FnGroupCountRecord extends Record { public final static short sid = 0x9c ; public final static short COUNT = 14 ; private short field_1_count ; public FnGroupCountRecord ( ) { } public FnGroupCountRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FnGroupCountRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FNGROUPCOUNT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_count = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCount ( short count ) { field_1_count = count ; } public short getCount ( ) { return field_1_count ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FNGROUPCOUNT]\n" ) ; buffer . append ( "    .count            = " ) . append ( getCount ( ) ) . append ( "\n" ) ; buffer . append ( "[/FNGROUPCOUNT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCount ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class UnicodeString extends Record implements Comparable { public final static short sid = 0xFFF ; private short field_1_charCount ; private byte field_2_optionflags ; private String field_3_string ; public int hashCode ( ) { return field_1_charCount ; } public boolean equals ( Object o ) { if ( ( o == null ) || ( o . getClass ( ) != this . getClass ( ) ) ) { return false ; } UnicodeString other = ( UnicodeString ) o ; return ( ( field_1_charCount == other . field_1_charCount ) && ( field_2_optionflags == other . field_2_optionflags ) && field_3_string . equals ( other . field_3_string ) ) ; } public UnicodeString ( ) { } public UnicodeString ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public UnicodeString ( short id , short size , byte [ ] data , String prefix ) { this ( id , size , data ) ; field_3_string = prefix + field_3_string ; setCharCount ( ) ; } protected void validateSid ( short id ) { } protected void fillFields ( byte [ ] data , short size ) { field_1_charCount = LittleEndian . getShort ( data , 0 ) ; field_2_optionflags = data [ 2 ] ; if ( ( field_2_optionflags & 1 ) == 0 ) { field_3_string = new String ( data , 3 , getCharCount ( ) ) ; } else { char [ ] array = new char [ getCharCount ( ) ] ; for ( int j = 0 ; j < array . length ; j ++ ) { array [ j ] = ( char ) LittleEndian . getShort ( data , 3 + ( j * 2 ) ) ; } field_3_string = new String ( array ) ; } } public short getCharCount ( ) { return field_1_charCount ; } public void setCharCount ( short cc ) { field_1_charCount = cc ; } public void setCharCount ( ) { field_1_charCount = ( short ) field_3_string . length ( ) ; } public byte getOptionFlags ( ) { return field_2_optionflags ; } public void setOptionFlags ( byte of ) { field_2_optionflags = of ; } public String getString ( ) { return field_3_string ; } public void setString ( String string ) { field_3_string = string ; if ( getCharCount ( ) < field_3_string . length ( ) ) { setCharCount ( ) ; } } public String toString ( ) { return getString ( ) ; } public String getDebugInfo ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[UNICODESTRING]\n" ) ; buffer . append ( "    .charcount       = " ) . append ( Integer . toHexString ( getCharCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .optionflags     = " ) . append ( Integer . toHexString ( getOptionFlags ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .string          = " ) . append ( getString ( ) ) . append ( "\n" ) ; buffer . append ( "[/UNICODESTRING]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int charsize = 1 ; if ( getOptionFlags ( ) == 1 ) { charsize = 2 ; } LittleEndian . putShort ( data , 0 + offset , getCharCount ( ) ) ; data [ 2 + offset ] = getOptionFlags ( ) ; if ( getOptionFlags ( ) == 0 ) { StringUtil . putCompressedUnicode ( getString ( ) , data , 0x3 + offset ) ; } else { StringUtil . putUncompressedUnicode ( getString ( ) , data , 0x3 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int charsize = 1 ; if ( getOptionFlags ( ) == 1 ) { charsize = 2 ; } return 3 + ( getString ( ) . length ( ) * charsize ) ; } public short getSid ( ) { return this . sid ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } public int compareTo ( Object obj ) { UnicodeString str = ( UnicodeString ) obj ; return this . getString ( ) . compareTo ( str . getString ( ) ) ; } int maxBrokenLength ( final int proposedBrokenLength ) { int rval = proposedBrokenLength ; if ( ( field_2_optionflags & 1 ) == 1 ) { int proposedStringLength = proposedBrokenLength - 3 ; if ( ( proposedStringLength % 2 ) == 1 ) { proposedStringLength -- ; } rval = proposedStringLength + 3 ; } return rval ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; public class SmallDocumentBlock implements BlockWritable , ListManagedBlock { private byte [ ] _data ; private static final byte _default_fill = ( byte ) 0xff ; private static final int _block_size = 64 ; private static final int _blocks_per_big_block = POIFSConstants . BIG_BLOCK_SIZE / _block_size ; private SmallDocumentBlock ( final byte [ ] data , final int index ) { this ( ) ; System . arraycopy ( data , index * _block_size , _data , 0 , _block_size ) ; } private SmallDocumentBlock ( ) { _data = new byte [ _block_size ] ; } public static SmallDocumentBlock [ ] convert ( final byte [ ] array , final int size ) { SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ ( size + _block_size - 1 ) / _block_size ] ; int offset = 0 ; for ( int k = 0 ; k < rval . length ; k ++ ) { rval [ k ] = new SmallDocumentBlock ( ) ; if ( offset < array . length ) { int length = Math . min ( _block_size , array . length - offset ) ; System . arraycopy ( array , offset , rval [ k ] . _data , 0 , length ) ; if ( length != _block_size ) { Arrays . fill ( rval [ k ] . _data , length , _block_size , _default_fill ) ; } } else { Arrays . fill ( rval [ k ] . _data , _default_fill ) ; } offset += _block_size ; } return rval ; } public static int fill ( final List blocks ) { int count = blocks . size ( ) ; int big_block_count = ( count + _blocks_per_big_block - 1 ) / _blocks_per_big_block ; int full_count = big_block_count * _blocks_per_big_block ; for ( ; count < full_count ; count ++ ) { blocks . add ( makeEmptySmallDocumentBlock ( ) ) ; } return big_block_count ; } public static SmallDocumentBlock [ ] convert ( final BlockWritable [ ] store , final int size ) throws IOException , ArrayIndexOutOfBoundsException { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; for ( int j = 0 ; j < store . length ; j ++ ) { store [ j ] . writeBlocks ( stream ) ; } byte [ ] data = stream . toByteArray ( ) ; SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ convertToBlockCount ( size ) ] ; for ( int index = 0 ; index < rval . length ; index ++ ) { rval [ index ] = new SmallDocumentBlock ( data , index ) ; } return rval ; } public static List extract ( ListManagedBlock [ ] blocks ) throws IOException { List sdbs = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; for ( int k = 0 ; k < _blocks_per_big_block ; k ++ ) { sdbs . add ( new SmallDocumentBlock ( data , k ) ) ; } } return sdbs ; } public static void read ( final BlockWritable [ ] blocks , final byte [ ] buffer , final int offset ) { int firstBlockIndex = offset / _block_size ; int firstBlockOffset = offset % _block_size ; int lastBlockIndex = ( offset + buffer . length - 1 ) / _block_size ; if ( firstBlockIndex == lastBlockIndex ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , 0 , buffer . length ) ; } else { int buffer_offset = 0 ; System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , buffer_offset , _block_size - firstBlockOffset ) ; buffer_offset += _block_size - firstBlockOffset ; for ( int j = firstBlockIndex + 1 ; j < lastBlockIndex ; j ++ ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ j ] ) . _data , 0 , buffer , buffer_offset , _block_size ) ; buffer_offset += _block_size ; } System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ lastBlockIndex ] ) . _data , 0 , buffer , buffer_offset , buffer . length - buffer_offset ) ; } } public static int calcSize ( int size ) { return size * _block_size ; } private static SmallDocumentBlock makeEmptySmallDocumentBlock ( ) { SmallDocumentBlock block = new SmallDocumentBlock ( ) ; Arrays . fill ( block . _data , _default_fill ) ; return block ; } private static int convertToBlockCount ( final int size ) { return ( size + _block_size - 1 ) / _block_size ; } public void writeBlocks ( final OutputStream stream ) throws IOException { stream . write ( _data ) ; } public byte [ ] getData ( ) throws IOException { return _data ; } } 	0
package org . apache . poi . hpsf ; public class MarkUnsupportedException extends HPSFException { public MarkUnsupportedException ( ) { super ( ) ; } public MarkUnsupportedException ( final String msg ) { super ( msg ) ; } public MarkUnsupportedException ( final Throwable reason ) { super ( reason ) ; } public MarkUnsupportedException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; public class RawDataBlockList extends BlockListImpl { public RawDataBlockList ( final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; while ( true ) { RawDataBlock block = new RawDataBlock ( stream ) ; if ( block . eof ( ) ) { break ; } blocks . add ( block ) ; } setBlocks ( ( RawDataBlock [ ] ) blocks . toArray ( new RawDataBlock [ 0 ] ) ) ; } } 	0
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LongField ; import org . apache . poi . util . ShortField ; public class HeaderBlockReader implements HeaderBlockConstants { private IntegerField _bat_count ; private IntegerField _property_start ; private IntegerField _sbat_start ; private IntegerField _xbat_start ; private IntegerField _xbat_count ; private byte [ ] _data ; public HeaderBlockReader ( final InputStream stream ) throws IOException { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; int byte_count = stream . read ( _data ) ; if ( byte_count != POIFSConstants . BIG_BLOCK_SIZE ) { String type = " byte" + ( ( byte_count == 1 ) ? ( "" ) : ( "s" ) ) ; throw new IOException ( "Unable to read entire header; " + byte_count + type + " read; expected " + POIFSConstants . BIG_BLOCK_SIZE + " bytes" ) ; } LongField signature = new LongField ( _signature_offset , _data ) ; if ( signature . get ( ) != _signature ) { throw new IOException ( "Invalid header signature; read " + signature . get ( ) + ", expected " + _signature ) ; } _bat_count = new IntegerField ( _bat_count_offset , _data ) ; _property_start = new IntegerField ( _property_start_offset , _data ) ; _sbat_start = new IntegerField ( _sbat_start_offset , _data ) ; _xbat_start = new IntegerField ( _xbat_start_offset , _data ) ; _xbat_count = new IntegerField ( _xbat_count_offset , _data ) ; } public int getPropertyStart ( ) { return _property_start . get ( ) ; } public int getSBATStart ( ) { return _sbat_start . get ( ) ; } public int getBATCount ( ) { return _bat_count . get ( ) ; } public int [ ] getBATArray ( ) { int [ ] result = new int [ _max_bats_in_header ] ; int offset = _bat_array_offset ; for ( int j = 0 ; j < _max_bats_in_header ; j ++ ) { result [ j ] = LittleEndian . getInt ( _data , offset ) ; offset += LittleEndianConsts . INT_SIZE ; } return result ; } public int getXBATCount ( ) { return _xbat_count . get ( ) ; } public int getXBATIndex ( ) { return _xbat_start . get ( ) ; } } 	1
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . record . Record ; public interface HSSFListener { public void processRecord ( Record record ) ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class UnitsRecord extends Record { public final static short sid = 0x1001 ; private short field_1_units ; public UnitsRecord ( ) { } public UnitsRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public UnitsRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Units record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_units = LittleEndian . getShort ( data , 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[Units]\n" ) ; buffer . append ( "    .units                = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getUnits ( ) ) ) . append ( " (" ) . append ( getUnits ( ) ) . append ( " )\n" ) ; buffer . append ( "[/Units]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_units ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public short getUnits ( ) { return field_1_units ; } public void setUnits ( short field_1_units ) { this . field_1_units = field_1_units ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . InputStream ; import java . io . IOException ; import java . io . ByteArrayInputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . util . Random ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . model . * ; import org . apache . poi . hssf . usermodel . * ; import org . apache . poi . hssf . util . * ; public class HSSF { private String filename = null ; private InputStream stream = null ; private Record [ ] records = null ; protected HSSFWorkbook hssfworkbook = null ; public HSSF ( String filename ) throws IOException { this . filename = filename ; POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; hssfworkbook = new HSSFWorkbook ( fs ) ; } public HSSF ( String filename , boolean write ) throws IOException { short rownum = 0 ; FileOutputStream out = new FileOutputStream ( filename ) ; HSSFWorkbook wb = new HSSFWorkbook ( ) ; HSSFSheet s = wb . createSheet ( ) ; HSSFRow r = null ; HSSFCell c = null ; HSSFCellStyle cs = wb . createCellStyle ( ) ; HSSFCellStyle cs2 = wb . createCellStyle ( ) ; HSSFCellStyle cs3 = wb . createCellStyle ( ) ; HSSFFont f = wb . createFont ( ) ; HSSFFont f2 = wb . createFont ( ) ; f . setFontHeightInPoints ( ( short ) 12 ) ; f . setColor ( ( short ) 0xA ) ; f . setBoldweight ( f . BOLDWEIGHT_BOLD ) ; f2 . setFontHeightInPoints ( ( short ) 10 ) ; f2 . setColor ( ( short ) 0xf ) ; f2 . setBoldweight ( f2 . BOLDWEIGHT_BOLD ) ; cs . setFont ( f ) ; cs . setDataFormat ( HSSFDataFormat . getFormat ( "($#,##0_);[Red]($#,##0)" ) ) ; cs2 . setBorderBottom ( cs2 . BORDER_THIN ) ; cs2 . setFillPattern ( ( short ) 1 ) ; cs2 . setFillForegroundColor ( ( short ) 0xA ) ; cs2 . setFont ( f2 ) ; wb . setSheetName ( 0 , "HSSF Test" ) ; for ( rownum = ( short ) 0 ; rownum < 300 ; rownum ++ ) { r = s . createRow ( rownum ) ; if ( ( rownum % 2 ) == 0 ) { r . setHeight ( ( short ) 0x249 ) ; } for ( short cellnum = ( short ) 0 ; cellnum < 50 ; cellnum += 2 ) { c = r . createCell ( cellnum , HSSFCell . CELL_TYPE_NUMERIC ) ; c . setCellValue ( rownum * 10000 + cellnum + ( ( ( double ) rownum / 1000 ) + ( ( double ) cellnum / 10000 ) ) ) ; if ( ( rownum % 2 ) == 0 ) { c . setCellStyle ( cs ) ; } c = r . createCell ( ( short ) ( cellnum + 1 ) , HSSFCell . CELL_TYPE_STRING ) ; c . setCellValue ( "TEST" ) ; s . setColumnWidth ( ( short ) ( cellnum + 1 ) , ( short ) ( ( 50 * 8 ) / ( ( double ) 1 / 20 ) ) ) ; if ( ( rownum % 2 ) == 0 ) { c . setCellStyle ( cs2 ) ; } } } rownum ++ ; rownum ++ ; r = s . createRow ( rownum ) ; cs3 . setBorderBottom ( cs3 . BORDER_THICK ) ; for ( short cellnum = ( short ) 0 ; cellnum < 50 ; cellnum ++ ) { c = r . createCell ( cellnum , HSSFCell . CELL_TYPE_BLANK ) ; c . setCellStyle ( cs3 ) ; } s . addMergedRegion ( new Region ( ( short ) 0 , ( short ) 0 , ( short ) 3 , ( short ) 3 ) ) ; s . addMergedRegion ( new Region ( ( short ) 100 , ( short ) 100 , ( short ) 110 , ( short ) 110 ) ) ; s = wb . createSheet ( ) ; wb . setSheetName ( 1 , "DeletedSheet" ) ; wb . removeSheetAt ( 1 ) ; wb . write ( out ) ; out . close ( ) ; } public HSSF ( String infile , String outfile , boolean write ) throws IOException { this . filename = filename ; POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; hssfworkbook = new HSSFWorkbook ( fs ) ; } public static void main ( String [ ] args ) { if ( args . length < 2 ) { } else if ( args . length == 2 ) { if ( args [ 1 ] . toLowerCase ( ) . equals ( "write" ) ) { System . out . println ( "Write mode" ) ; try { long time = System . currentTimeMillis ( ) ; HSSF hssf = new HSSF ( args [ 0 ] , true ) ; System . out . println ( "" + ( System . currentTimeMillis ( ) - time ) + " ms generation time" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "readwrite test" ) ; try { HSSF hssf = new HSSF ( args [ 0 ] ) ; HSSFWorkbook wb = hssf . hssfworkbook ; FileOutputStream stream = new FileOutputStream ( args [ 1 ] ) ; wb . write ( stream ) ; stream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } else if ( ( args . length == 3 ) && args [ 2 ] . toLowerCase ( ) . equals ( "modify1" ) ) { try { HSSF hssf = new HSSF ( args [ 0 ] ) ; HSSFWorkbook wb = hssf . hssfworkbook ; FileOutputStream stream = new FileOutputStream ( args [ 1 ] ) ; HSSFSheet sheet = wb . getSheetAt ( 0 ) ; for ( int k = 0 ; k < 25 ; k ++ ) { HSSFRow row = sheet . getRow ( k ) ; sheet . removeRow ( row ) ; } for ( int k = 74 ; k < 100 ; k ++ ) { HSSFRow row = sheet . getRow ( k ) ; sheet . removeRow ( row ) ; } HSSFRow row = sheet . getRow ( 39 ) ; HSSFCell cell = row . getCell ( ( short ) 3 ) ; cell . setCellType ( HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( "MODIFIED CELL!!!!!" ) ; wb . write ( stream ) ; stream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } 	1
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; public class POIFSViewer { public static void main ( final String args [ ] ) { if ( args . length < 0 ) { System . err . println ( "Must specify at least one file to view" ) ; System . exit ( 1 ) ; } boolean printNames = ( args . length > 1 ) ; for ( int j = 0 ; j < args . length ; j ++ ) { viewFile ( args [ j ] , printNames ) ; } } private static void viewFile ( final String filename , final boolean printName ) { if ( printName ) { StringBuffer flowerbox = new StringBuffer ( ) ; flowerbox . append ( "." ) ; for ( int j = 0 ; j < filename . length ( ) ; j ++ ) { flowerbox . append ( "-" ) ; } flowerbox . append ( "." ) ; System . out . println ( flowerbox ) ; System . out . println ( "|" + filename + "|" ) ; System . out . println ( flowerbox ) ; } try { POIFSViewable fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; List strings = POIFSViewEngine . inspectViewable ( fs , true , 0 , "  " ) ; Iterator iter = strings . iterator ( ) ; while ( iter . hasNext ( ) ) { System . out . print ( iter . next ( ) ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class DocumentSummaryInformation extends SpecialPropertySet { public DocumentSummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isDocumentSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getCategory ( ) { return ( String ) getProperty ( PropertyIDMap . PID_CATEGORY ) ; } public String getPresentationFormat ( ) { return ( String ) getProperty ( PropertyIDMap . PID_PRESFORMAT ) ; } public int getByteCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_BYTECOUNT ) ; } public int getLineCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_LINECOUNT ) ; } public int getParCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PARCOUNT ) ; } public int getSlideCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SLIDECOUNT ) ; } public int getNoteCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_NOTECOUNT ) ; } public int getHiddenCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_HIDDENCOUNT ) ; } public int getMMClipCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_MMCLIPCOUNT ) ; } public byte [ ] getScale ( ) { if ( true ) throw new UnsupportedOperationException ( "FIXME" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_SCALE ) ; } public byte [ ] getHeadingPair ( ) { if ( true ) throw new UnsupportedOperationException ( "FIXME" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_HEADINGPAIR ) ; } public byte [ ] getDocparts ( ) { if ( true ) throw new UnsupportedOperationException ( "FIXME" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_DOCPARTS ) ; } public String getManager ( ) { return ( String ) getProperty ( PropertyIDMap . PID_MANAGER ) ; } public String getCompany ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMPANY ) ; } public byte [ ] getLinksDirty ( ) { if ( true ) throw new UnsupportedOperationException ( "FIXME" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_LINKSDIRTY ) ; } } 	1
package org . apache . poi . poifs . dev ; import java . util . Iterator ; public interface POIFSViewable { public Object [ ] getViewableArray ( ) ; public Iterator getViewableIterator ( ) ; public boolean preferArray ( ) ; public String getShortDescription ( ) ; } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import org . apache . poi . util . LittleEndian ; public class MergeCellsRecord extends Record { public final static short sid = 0xe5 ; private short field_1_num_areas ; private ArrayList field_2_regions ; public MergeCellsRecord ( ) { } public MergeCellsRecord ( short sid , short size , byte [ ] data ) { super ( sid , size , data ) ; } public MergeCellsRecord ( short sid , short size , byte [ ] data , int offset ) { super ( sid , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_num_areas = LittleEndian . getShort ( data , 0 + offset ) ; field_2_regions = new ArrayList ( field_1_num_areas + 10 ) ; int pos = 2 ; for ( int k = 0 ; k < field_1_num_areas ; k ++ ) { MergedRegion region = new MergedRegion ( LittleEndian . getShort ( data , pos + offset ) , LittleEndian . getShort ( data , pos + 2 + offset ) , LittleEndian . getShort ( data , pos + 4 + offset ) , LittleEndian . getShort ( data , pos + 6 + offset ) ) ; pos += 8 ; field_2_regions . add ( region ) ; } } public short getNumAreas ( ) { return field_1_num_areas ; } public void setNumAreas ( short numareas ) { field_1_num_areas = numareas ; } public int addArea ( short rowfrom , short colfrom , short rowto , short colto ) { if ( field_2_regions == null ) { field_2_regions = new ArrayList ( 10 ) ; } MergedRegion region = new MergedRegion ( rowfrom , rowto , colfrom , colto ) ; field_2_regions . add ( region ) ; field_1_num_areas ++ ; return field_2_regions . size ( ) - 1 ; } public void removeAreaAt ( int area ) { field_2_regions . remove ( area ) ; field_1_num_areas -- ; } public MergedRegion getAreaAt ( int index ) { return ( MergedRegion ) field_2_regions . get ( index ) ; } public int getRecordSize ( ) { int retValue ; retValue = 6 + ( 8 * field_2_regions . size ( ) ) ; return retValue ; } public short getSid ( ) { return sid ; } public int serialize ( int offset , byte [ ] data ) { int recordsize = getRecordSize ( ) ; int pos = 6 ; LittleEndian . putShort ( data , offset + 0 , sid ) ; LittleEndian . putShort ( data , offset + 2 , ( short ) ( recordsize - 4 ) ) ; LittleEndian . putShort ( data , offset + 4 , getNumAreas ( ) ) ; for ( int k = 0 ; k < getNumAreas ( ) ; k ++ ) { MergedRegion region = getAreaAt ( k ) ; LittleEndian . putShort ( data , offset + pos , region . row_from ) ; pos += 2 ; LittleEndian . putShort ( data , offset + pos , region . row_to ) ; pos += 2 ; LittleEndian . putShort ( data , offset + pos , region . col_from ) ; pos += 2 ; LittleEndian . putShort ( data , offset + pos , region . col_to ) ; pos += 2 ; } return recordsize ; } public String toString ( ) { StringBuffer retval = new StringBuffer ( ) ; retval . append ( "[MERGEDCELLS]" ) . append ( "\n" ) ; retval . append ( "     .sid        =" ) . append ( sid ) . append ( "\n" ) ; retval . append ( "     .numregions =" ) . append ( field_1_num_areas ) . append ( "\n" ) ; for ( int k = 0 ; k < field_1_num_areas ; k ++ ) { MergedRegion region = ( MergedRegion ) field_2_regions . get ( k ) ; retval . append ( "     .rowfrom    =" ) . append ( region . row_from ) . append ( "\n" ) ; retval . append ( "     .colfrom    =" ) . append ( region . col_from ) . append ( "\n" ) ; retval . append ( "     .rowto      =" ) . append ( region . row_to ) . append ( "\n" ) ; retval . append ( "     .colto      =" ) . append ( region . col_to ) . append ( "\n" ) ; } retval . append ( "[MERGEDCELLS]" ) . append ( "\n" ) ; return retval . toString ( ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A MERGEDCELLS RECORD!! " + id ) ; } } public class MergedRegion { public MergedRegion ( short row_from , short row_to , short col_from , short col_to ) { this . row_from = row_from ; this . row_to = row_to ; this . col_from = col_from ; this . col_to = col_to ; } public short row_from ; public short row_to ; public short col_from ; public short col_to ; } } 	1
package org . apache . poi . poifs . filesystem ; public interface POIFSWriterListener { public void processPOIFSWriterEvent ( POIFSWriterEvent event ) ; } 	0
package org . apache . poi . hssf . record . formula ; public class UnknownPtg extends Ptg { private short size ; public UnknownPtg ( ) { } public UnknownPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return size ; } public String toFormulaString ( ) { return "UNKNOWN" ; } } 	1
package org . apache . poi . poifs . filesystem ; public class DocumentDescriptor { private POIFSDocumentPath path ; private String name ; private int hashcode = 0 ; public DocumentDescriptor ( final POIFSDocumentPath path , final String name ) { if ( path == null ) { throw new NullPointerException ( "path must not be null" ) ; } if ( name == null ) { throw new NullPointerException ( "name must not be null" ) ; } if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "name cannot be empty" ) ; } this . path = path ; this . name = name ; } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { DocumentDescriptor descriptor = ( DocumentDescriptor ) o ; rval = this . path . equals ( descriptor . path ) && this . name . equals ( descriptor . name ) ; } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { hashcode = path . hashCode ( ) ^ name . hashCode ( ) ; } return hashcode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( 40 * ( path . length ( ) + 1 ) ) ; for ( int j = 0 ; j < path . length ( ) ; j ++ ) { buffer . append ( path . getComponent ( j ) ) . append ( "/" ) ; } buffer . append ( name ) ; return buffer . toString ( ) ; } } 	0
package org . apache . poi . hssf . dev ; import org . apache . poi . hssf . record . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; public class BiffViewer { String filename ; private boolean dump ; public BiffViewer ( String [ ] args ) { if ( args . length > 0 ) { filename = args [ 0 ] ; } else { System . out . println ( "BIFFVIEWER REQUIRES A FILENAME***" ) ; } } public void run ( ) { try { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; Record [ ] records = createRecords ( stream , dump ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static Record [ ] createRecords ( InputStream in , boolean dump ) throws RecordFormatException { ArrayList records = new ArrayList ( ) ; Record last_record = null ; int loc = 0 ; try { short rectype = 0 ; do { rectype = LittleEndian . readShort ( in ) ; System . out . println ( "============================================" ) ; System . out . println ( "Offset 0x" + Integer . toHexString ( loc ) + " (" + loc + ")" ) ; loc += 2 ; if ( rectype != 0 ) { short recsize = LittleEndian . readShort ( in ) ; loc += 2 ; byte [ ] data = new byte [ ( int ) recsize ] ; in . read ( data ) ; if ( ( rectype == WSBoolRecord . sid ) && ( recsize == 0 ) ) { System . out . println ( loc ) ; } loc += recsize ; if ( dump ) { dump ( rectype , recsize , data ) ; } Record [ ] recs = createRecord ( rectype , recsize , data ) ; Record record = recs [ 0 ] ; if ( ( record instanceof UnknownRecord ) && ! dump ) { dumpUnknownRecord ( data ) ; } if ( record != null ) { if ( rectype == ContinueRecord . sid ) { dumpContinueRecord ( last_record , dump , data ) ; } else { last_record = record ; records . add ( record ) ; } } } } while ( rectype != 0 ) ; } catch ( IOException e ) { throw new RecordFormatException ( "Error reading bytes" ) ; } Record [ ] retval = new Record [ records . size ( ) ] ; retval = ( Record [ ] ) records . toArray ( retval ) ; return retval ; } private static void dumpContinueRecord ( Record last_record , boolean dump , byte [ ] data ) throws IOException { if ( last_record == null ) { throw new RecordFormatException ( "First record is a ContinueRecord??" ) ; } if ( dump ) { System . out . println ( "-----PRECONTINUED LAST RECORD WOULD SERIALIZE LIKE:" ) ; byte [ ] lr = last_record . serialize ( ) ; if ( lr != null ) { HexDump . dump ( last_record . serialize ( ) , 0 , System . out , 0 ) ; } System . out . println ( ) ; System . out . println ( "-----PRECONTINUED----------------------------------" ) ; } last_record . processContinueRecord ( data ) ; if ( dump ) { System . out . println ( "-----CONTINUED LAST RECORD WOULD SERIALIZE LIKE:" ) ; HexDump . dump ( last_record . serialize ( ) , 0 , System . out , 0 ) ; System . out . println ( ) ; System . out . println ( "-----CONTINUED----------------------------------" ) ; } } private static void dumpUnknownRecord ( byte [ ] data ) throws IOException { System . out . println ( "-----UNKNOWN----------------------------------" ) ; if ( data . length > 0 ) { HexDump . dump ( data , 0 , System . out , 0 ) ; } else { System . out . print ( "**NO RECORD DATA**" ) ; } System . out . println ( ) ; System . out . println ( "-----UNKNOWN----------------------------------" ) ; } private static void dump ( short rectype , short recsize , byte [ ] data ) throws IOException { System . out . print ( "rectype = 0x" + Integer . toHexString ( rectype ) ) ; System . out . println ( ", recsize = 0x" + Integer . toHexString ( recsize ) ) ; System . out . println ( "-BEGIN DUMP---------------------------------" ) ; if ( data . length > 0 ) { HexDump . dump ( data , 0 , System . out , 0 ) ; } else { System . out . println ( "**NO RECORD DATA**" ) ; } System . out . println ( "-END DUMP-----------------------------------" ) ; } private static Record [ ] createRecord ( short rectype , short size , byte [ ] data ) { Record retval = null ; Record [ ] realretval = null ; switch ( rectype ) { case ChartRecord . sid : retval = new ChartRecord ( rectype , size , data ) ; break ; case ChartFormatRecord . sid : retval = new ChartFormatRecord ( rectype , size , data ) ; break ; case SeriesRecord . sid : retval = new SeriesRecord ( rectype , size , data ) ; break ; case BeginRecord . sid : retval = new BeginRecord ( rectype , size , data ) ; break ; case EndRecord . sid : retval = new EndRecord ( rectype , size , data ) ; break ; case BOFRecord . sid : retval = new BOFRecord ( rectype , size , data ) ; break ; case InterfaceHdrRecord . sid : retval = new InterfaceHdrRecord ( rectype , size , data ) ; break ; case MMSRecord . sid : retval = new MMSRecord ( rectype , size , data ) ; break ; case InterfaceEndRecord . sid : retval = new InterfaceEndRecord ( rectype , size , data ) ; break ; case WriteAccessRecord . sid : retval = new WriteAccessRecord ( rectype , size , data ) ; break ; case CodepageRecord . sid : retval = new CodepageRecord ( rectype , size , data ) ; break ; case DSFRecord . sid : retval = new DSFRecord ( rectype , size , data ) ; break ; case TabIdRecord . sid : retval = new TabIdRecord ( rectype , size , data ) ; break ; case FnGroupCountRecord . sid : retval = new FnGroupCountRecord ( rectype , size , data ) ; break ; case WindowProtectRecord . sid : retval = new WindowProtectRecord ( rectype , size , data ) ; break ; case ProtectRecord . sid : retval = new ProtectRecord ( rectype , size , data ) ; break ; case PasswordRecord . sid : retval = new PasswordRecord ( rectype , size , data ) ; break ; case ProtectionRev4Record . sid : retval = new ProtectionRev4Record ( rectype , size , data ) ; break ; case PasswordRev4Record . sid : retval = new PasswordRev4Record ( rectype , size , data ) ; break ; case WindowOneRecord . sid : retval = new WindowOneRecord ( rectype , size , data ) ; break ; case BackupRecord . sid : retval = new BackupRecord ( rectype , size , data ) ; break ; case HideObjRecord . sid : retval = new HideObjRecord ( rectype , size , data ) ; break ; case DateWindow1904Record . sid : retval = new DateWindow1904Record ( rectype , size , data ) ; break ; case PrecisionRecord . sid : retval = new PrecisionRecord ( rectype , size , data ) ; break ; case RefreshAllRecord . sid : retval = new RefreshAllRecord ( rectype , size , data ) ; break ; case BookBoolRecord . sid : retval = new BookBoolRecord ( rectype , size , data ) ; break ; case FontRecord . sid : retval = new FontRecord ( rectype , size , data ) ; break ; case FormatRecord . sid : retval = new FormatRecord ( rectype , size , data ) ; break ; case ExtendedFormatRecord . sid : retval = new ExtendedFormatRecord ( rectype , size , data ) ; break ; case StyleRecord . sid : retval = new StyleRecord ( rectype , size , data ) ; break ; case UseSelFSRecord . sid : retval = new UseSelFSRecord ( rectype , size , data ) ; break ; case BoundSheetRecord . sid : retval = new BoundSheetRecord ( rectype , size , data ) ; break ; case CountryRecord . sid : retval = new CountryRecord ( rectype , size , data ) ; break ; case SSTRecord . sid : retval = new SSTRecord ( rectype , size , data ) ; break ; case ExtSSTRecord . sid : retval = new ExtSSTRecord ( rectype , size , data ) ; break ; case EOFRecord . sid : retval = new EOFRecord ( rectype , size , data ) ; break ; case IndexRecord . sid : retval = new IndexRecord ( rectype , size , data ) ; break ; case CalcModeRecord . sid : retval = new CalcModeRecord ( rectype , size , data ) ; break ; case CalcCountRecord . sid : retval = new CalcCountRecord ( rectype , size , data ) ; break ; case RefModeRecord . sid : retval = new RefModeRecord ( rectype , size , data ) ; break ; case IterationRecord . sid : retval = new IterationRecord ( rectype , size , data ) ; break ; case DeltaRecord . sid : retval = new DeltaRecord ( rectype , size , data ) ; break ; case SaveRecalcRecord . sid : retval = new SaveRecalcRecord ( rectype , size , data ) ; break ; case PrintHeadersRecord . sid : retval = new PrintHeadersRecord ( rectype , size , data ) ; break ; case PrintGridlinesRecord . sid : retval = new PrintGridlinesRecord ( rectype , size , data ) ; break ; case GridsetRecord . sid : retval = new GridsetRecord ( rectype , size , data ) ; break ; case GutsRecord . sid : retval = new GutsRecord ( rectype , size , data ) ; break ; case DefaultRowHeightRecord . sid : retval = new DefaultRowHeightRecord ( rectype , size , data ) ; break ; case WSBoolRecord . sid : retval = new WSBoolRecord ( rectype , size , data ) ; break ; case HeaderRecord . sid : retval = new HeaderRecord ( rectype , size , data ) ; break ; case FooterRecord . sid : retval = new FooterRecord ( rectype , size , data ) ; break ; case HCenterRecord . sid : retval = new HCenterRecord ( rectype , size , data ) ; break ; case VCenterRecord . sid : retval = new VCenterRecord ( rectype , size , data ) ; break ; case PrintSetupRecord . sid : retval = new PrintSetupRecord ( rectype , size , data ) ; break ; case DefaultColWidthRecord . sid : retval = new DefaultColWidthRecord ( rectype , size , data ) ; break ; case DimensionsRecord . sid : retval = new DimensionsRecord ( rectype , size , data ) ; break ; case RowRecord . sid : retval = new RowRecord ( rectype , size , data ) ; break ; case LabelSSTRecord . sid : retval = new LabelSSTRecord ( rectype , size , data ) ; break ; case RKRecord . sid : retval = new RKRecord ( rectype , size , data ) ; break ; case NumberRecord . sid : retval = new NumberRecord ( rectype , size , data ) ; break ; case DBCellRecord . sid : retval = new DBCellRecord ( rectype , size , data ) ; break ; case WindowTwoRecord . sid : retval = new WindowTwoRecord ( rectype , size , data ) ; break ; case SelectionRecord . sid : retval = new SelectionRecord ( rectype , size , data ) ; break ; case ContinueRecord . sid : retval = new ContinueRecord ( rectype , size , data ) ; break ; case LabelRecord . sid : retval = new LabelRecord ( rectype , size , data ) ; break ; case MulRKRecord . sid : retval = new MulRKRecord ( rectype , size , data ) ; break ; case MulBlankRecord . sid : retval = new MulBlankRecord ( rectype , size , data ) ; break ; case BlankRecord . sid : retval = new BlankRecord ( rectype , size , data ) ; break ; case BoolErrRecord . sid : retval = new BoolErrRecord ( rectype , size , data ) ; break ; case ColumnInfoRecord . sid : retval = new ColumnInfoRecord ( rectype , size , data ) ; break ; case MergeCellsRecord . sid : retval = new MergeCellsRecord ( rectype , size , data ) ; break ; case AreaRecord . sid : retval = new AreaRecord ( rectype , size , data ) ; break ; case DataFormatRecord . sid : retval = new DataFormatRecord ( rectype , size , data ) ; break ; case BarRecord . sid : retval = new BarRecord ( rectype , size , data ) ; break ; case DatRecord . sid : retval = new DatRecord ( rectype , size , data ) ; break ; case PlotGrowthRecord . sid : retval = new PlotGrowthRecord ( rectype , size , data ) ; break ; case UnitsRecord . sid : retval = new UnitsRecord ( rectype , size , data ) ; break ; case FrameRecord . sid : retval = new FrameRecord ( rectype , size , data ) ; break ; case ValueRangeRecord . sid : retval = new ValueRangeRecord ( rectype , size , data ) ; break ; case SeriesListRecord . sid : retval = new SeriesListRecord ( rectype , size , data ) ; break ; case FontBasisRecord . sid : retval = new FontBasisRecord ( rectype , size , data ) ; break ; case FontIndexRecord . sid : retval = new FontIndexRecord ( rectype , size , data ) ; break ; case LineFormatRecord . sid : retval = new LineFormatRecord ( rectype , size , data ) ; break ; case AreaFormatRecord . sid : retval = new AreaFormatRecord ( rectype , size , data ) ; break ; case LinkedDataRecord . sid : retval = new LinkedDataRecord ( rectype , size , data ) ; break ; case SheetPropertiesRecord . sid : retval = new SheetPropertiesRecord ( rectype , size , data ) ; break ; default : retval = new UnknownRecord ( rectype , size , data ) ; } if ( realretval == null ) { realretval = new Record [ 1 ] ; realretval [ 0 ] = retval ; System . out . println ( "recordid = 0x" + Integer . toHexString ( rectype ) + ", size =" + size ) ; System . out . println ( realretval [ 0 ] . toString ( ) ) ; } return realretval ; } public void setDump ( boolean dump ) { this . dump = dump ; } public static void main ( String [ ] args ) { try { BiffViewer viewer = new BiffViewer ( args ) ; if ( ( args . length > 1 ) && args [ 1 ] . equals ( "on" ) ) { viewer . setDump ( true ) ; } if ( ( args . length > 1 ) && args [ 1 ] . equals ( "bfd" ) ) { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( args [ 0 ] ) ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; int size = stream . available ( ) ; byte [ ] data = new byte [ size ] ; stream . read ( data ) ; HexDump . dump ( data , 0 , System . out , 0 ) ; } else { viewer . run ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	1
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class BarRecord extends Record { public final static short sid = 0x1017 ; private short field_1_barSpace ; private short field_2_categorySpace ; private short field_3_formatFlags ; private BitField horizontal = new BitField ( 0x1 ) ; private BitField stacked = new BitField ( 0x2 ) ; private BitField displayAsPercentage = new BitField ( 0x4 ) ; private BitField shadow = new BitField ( 0x8 ) ; public BarRecord ( ) { field_2_categorySpace = 50 ; } public BarRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BarRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Bar record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_barSpace = LittleEndian . getShort ( data , 0x0 + offset ) ; field_2_categorySpace = LittleEndian . getShort ( data , 0x2 + offset ) ; field_3_formatFlags = LittleEndian . getShort ( data , 0x4 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[Bar]\n" ) ; buffer . append ( "    .barSpace             = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getBarSpace ( ) ) ) . append ( " (" ) . append ( getBarSpace ( ) ) . append ( " )\n" ) ; buffer . append ( "    .categorySpace        = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getCategorySpace ( ) ) ) . append ( " (" ) . append ( getCategorySpace ( ) ) . append ( " )\n" ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )\n" ) ; buffer . append ( "         .horizontal               = " ) . append ( isHorizontal ( ) ) . append ( '\n' ) ; buffer . append ( "         .stacked                  = " ) . append ( isStacked ( ) ) . append ( '\n' ) ; buffer . append ( "         .displayAsPercentage      = " ) . append ( isDisplayAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .shadow                   = " ) . append ( isShadow ( ) ) . append ( '\n' ) ; buffer . append ( "[/Bar]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_barSpace ) ; LittleEndian . putShort ( data , 6 + offset , field_2_categorySpace ) ; LittleEndian . putShort ( data , 8 + offset , field_3_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public short getBarSpace ( ) { return field_1_barSpace ; } public void setBarSpace ( short field_1_barSpace ) { this . field_1_barSpace = field_1_barSpace ; } public short getCategorySpace ( ) { return field_2_categorySpace ; } public void setCategorySpace ( short field_2_categorySpace ) { this . field_2_categorySpace = field_2_categorySpace ; } public short getFormatFlags ( ) { return field_3_formatFlags ; } public void setFormatFlags ( short field_3_formatFlags ) { this . field_3_formatFlags = field_3_formatFlags ; } public void setHorizontal ( boolean value ) { field_3_formatFlags = horizontal . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isHorizontal ( ) { return horizontal . isSet ( field_3_formatFlags ) ; } public void setStacked ( boolean value ) { field_3_formatFlags = stacked . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isStacked ( ) { return stacked . isSet ( field_3_formatFlags ) ; } public void setDisplayAsPercentage ( boolean value ) { field_3_formatFlags = displayAsPercentage . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isDisplayAsPercentage ( ) { return displayAsPercentage . isSet ( field_3_formatFlags ) ; } public void setShadow ( boolean value ) { field_3_formatFlags = shadow . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isShadow ( ) { return shadow . isSet ( field_3_formatFlags ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PrecisionRecord extends Record { public final static short sid = 0xE ; public short field_1_precision ; public PrecisionRecord ( ) { } public PrecisionRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PrecisionRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PRECISION RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_precision = LittleEndian . getShort ( data , 0 + offset ) ; } public void setFullPrecision ( boolean fullprecision ) { if ( fullprecision == true ) { field_1_precision = 1 ; } else { field_1_precision = 0 ; } } public boolean getFullPrecision ( ) { return ( field_1_precision == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PRECISION]\n" ) ; buffer . append ( "    .precision       = " ) . append ( getFullPrecision ( ) ) . append ( "\n" ) ; buffer . append ( "[/PRECISION]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_precision ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; public class MemErrPtg extends Ptg { public final static short sid = 0x27 ; private final static int SIZE = 7 ; private int field_1_reserved ; private short field_2_subex_len ; public MemErrPtg ( ) { } public MemErrPtg ( byte [ ] data , int offset ) { field_1_reserved = LittleEndian . getInt ( data , 0 ) ; field_2_subex_len = LittleEndian . getShort ( data , 4 ) ; } public void setReserved ( int res ) { field_1_reserved = res ; } public int getReserved ( ) { return field_1_reserved ; } public void setSubexpressionLength ( short subexlen ) { field_2_subex_len = subexlen ; } public short getSubexpressionLength ( ) { return field_2_subex_len ; } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return SIZE ; } public String toFormulaString ( ) { return "ERR#" ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CalcModeRecord extends Record { public final static short sid = 0xD ; public final static short MANUAL = 0 ; public final static short AUTOMATIC = 1 ; public final static short AUTOMATIC_EXCEPT_TABLES = - 1 ; private short field_1_calcmode ; public CalcModeRecord ( ) { } public CalcModeRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CalcModeRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Calc Mode RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_calcmode = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCalcMode ( short calcmode ) { field_1_calcmode = calcmode ; } public short getCalcMode ( ) { return field_1_calcmode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CALCMODE]\n" ) ; buffer . append ( "    .calcmode       = " ) . append ( Integer . toHexString ( getCalcMode ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CALCMODE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , getCalcMode ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . usermodel ; public interface HSSFErrorConstants { public static final byte ERROR_NULL = 0x00 ; public static final byte ERROR_DIV_0 = 0x07 ; public static final byte ERROR_VALUE = 0x0f ; public static final byte ERROR_REF = 0x17 ; public static final byte ERROR_NAME = 0x1d ; public static final byte ERROR_NUM = 0x24 ; public static final byte ERROR_NA = 0x2a ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class AreaRecord extends Record { public final static short sid = 0x101A ; private short field_1_formatFlags ; private BitField stacked = new BitField ( 0x1 ) ; private BitField displayAsPercentage = new BitField ( 0x2 ) ; private BitField shadow = new BitField ( 0x4 ) ; public AreaRecord ( ) { } public AreaRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AreaRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Area record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_formatFlags = LittleEndian . getShort ( data , 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[Area]\n" ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )\n" ) ; buffer . append ( "         .stacked                  = " ) . append ( isStacked ( ) ) . append ( '\n' ) ; buffer . append ( "         .displayAsPercentage      = " ) . append ( isDisplayAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .shadow                   = " ) . append ( isShadow ( ) ) . append ( '\n' ) ; buffer . append ( "[/Area]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public short getFormatFlags ( ) { return field_1_formatFlags ; } public void setFormatFlags ( short field_1_formatFlags ) { this . field_1_formatFlags = field_1_formatFlags ; } public void setStacked ( boolean value ) { field_1_formatFlags = stacked . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isStacked ( ) { return stacked . isSet ( field_1_formatFlags ) ; } public void setDisplayAsPercentage ( boolean value ) { field_1_formatFlags = displayAsPercentage . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isDisplayAsPercentage ( ) { return displayAsPercentage . isSet ( field_1_formatFlags ) ; } public void setShadow ( boolean value ) { field_1_formatFlags = shadow . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShadow ( ) { return shadow . isSet ( field_1_formatFlags ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class ValueRangeRecord extends Record { public final static short sid = 0x101f ; private double field_1_minimumAxisValue ; private double field_2_maximumAxisValue ; private double field_3_majorIncrement ; private double field_4_minorIncrement ; private double field_5_categoryAxisCross ; private short field_6_options ; private BitField automaticMinimum = new BitField ( 0x1 ) ; private BitField automaticMaximum = new BitField ( 0x2 ) ; private BitField automaticMajor = new BitField ( 0x4 ) ; private BitField automaticMinor = new BitField ( 0x8 ) ; private BitField automaticCategoryCrossing = new BitField ( 0x10 ) ; private BitField logarithmicScale = new BitField ( 0x20 ) ; private BitField valuesInReverse = new BitField ( 0x40 ) ; private BitField crossCategoryAxisAtMaximum = new BitField ( 0x80 ) ; private BitField reserved = new BitField ( 0x100 ) ; public ValueRangeRecord ( ) { } public ValueRangeRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ValueRangeRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a ValueRange record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_minimumAxisValue = LittleEndian . getDouble ( data , 0x0 + offset ) ; field_2_maximumAxisValue = LittleEndian . getDouble ( data , 0x8 + offset ) ; field_3_majorIncrement = LittleEndian . getDouble ( data , 0x10 + offset ) ; field_4_minorIncrement = LittleEndian . getDouble ( data , 0x18 + offset ) ; field_5_categoryAxisCross = LittleEndian . getDouble ( data , 0x20 + offset ) ; field_6_options = LittleEndian . getShort ( data , 0x28 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[ValueRange]\n" ) ; buffer . append ( "    .minimumAxisValue     = " ) . append ( " (" ) . append ( getMinimumAxisValue ( ) ) . append ( " )\n" ) ; buffer . append ( "    .maximumAxisValue     = " ) . append ( " (" ) . append ( getMaximumAxisValue ( ) ) . append ( " )\n" ) ; buffer . append ( "    .majorIncrement       = " ) . append ( " (" ) . append ( getMajorIncrement ( ) ) . append ( " )\n" ) ; buffer . append ( "    .minorIncrement       = " ) . append ( " (" ) . append ( getMinorIncrement ( ) ) . append ( " )\n" ) ; buffer . append ( "    .categoryAxisCross    = " ) . append ( " (" ) . append ( getCategoryAxisCross ( ) ) . append ( " )\n" ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )\n" ) ; buffer . append ( "         .automaticMinimum         = " ) . append ( isAutomaticMinimum ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMaximum         = " ) . append ( isAutomaticMaximum ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMajor           = " ) . append ( isAutomaticMajor ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMinor           = " ) . append ( isAutomaticMinor ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticCategoryCrossing     = " ) . append ( isAutomaticCategoryCrossing ( ) ) . append ( '\n' ) ; buffer . append ( "         .logarithmicScale         = " ) . append ( isLogarithmicScale ( ) ) . append ( '\n' ) ; buffer . append ( "         .valuesInReverse          = " ) . append ( isValuesInReverse ( ) ) . append ( '\n' ) ; buffer . append ( "         .crossCategoryAxisAtMaximum     = " ) . append ( isCrossCategoryAxisAtMaximum ( ) ) . append ( '\n' ) ; buffer . append ( "         .reserved                 = " ) . append ( isReserved ( ) ) . append ( '\n' ) ; buffer . append ( "[/ValueRange]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putDouble ( data , 4 + offset , field_1_minimumAxisValue ) ; LittleEndian . putDouble ( data , 12 + offset , field_2_maximumAxisValue ) ; LittleEndian . putDouble ( data , 20 + offset , field_3_majorIncrement ) ; LittleEndian . putDouble ( data , 28 + offset , field_4_minorIncrement ) ; LittleEndian . putDouble ( data , 36 + offset , field_5_categoryAxisCross ) ; LittleEndian . putShort ( data , 44 + offset , field_6_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 8 + 8 + 8 + 8 + 8 + 2 ; } public short getSid ( ) { return this . sid ; } public double getMinimumAxisValue ( ) { return field_1_minimumAxisValue ; } public void setMinimumAxisValue ( double field_1_minimumAxisValue ) { this . field_1_minimumAxisValue = field_1_minimumAxisValue ; } public double getMaximumAxisValue ( ) { return field_2_maximumAxisValue ; } public void setMaximumAxisValue ( double field_2_maximumAxisValue ) { this . field_2_maximumAxisValue = field_2_maximumAxisValue ; } public double getMajorIncrement ( ) { return field_3_majorIncrement ; } public void setMajorIncrement ( double field_3_majorIncrement ) { this . field_3_majorIncrement = field_3_majorIncrement ; } public double getMinorIncrement ( ) { return field_4_minorIncrement ; } public void setMinorIncrement ( double field_4_minorIncrement ) { this . field_4_minorIncrement = field_4_minorIncrement ; } public double getCategoryAxisCross ( ) { return field_5_categoryAxisCross ; } public void setCategoryAxisCross ( double field_5_categoryAxisCross ) { this . field_5_categoryAxisCross = field_5_categoryAxisCross ; } public short getOptions ( ) { return field_6_options ; } public void setOptions ( short field_6_options ) { this . field_6_options = field_6_options ; } public void setAutomaticMinimum ( boolean value ) { field_6_options = automaticMinimum . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMinimum ( ) { return automaticMinimum . isSet ( field_6_options ) ; } public void setAutomaticMaximum ( boolean value ) { field_6_options = automaticMaximum . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMaximum ( ) { return automaticMaximum . isSet ( field_6_options ) ; } public void setAutomaticMajor ( boolean value ) { field_6_options = automaticMajor . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMajor ( ) { return automaticMajor . isSet ( field_6_options ) ; } public void setAutomaticMinor ( boolean value ) { field_6_options = automaticMinor . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMinor ( ) { return automaticMinor . isSet ( field_6_options ) ; } public void setAutomaticCategoryCrossing ( boolean value ) { field_6_options = automaticCategoryCrossing . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticCategoryCrossing ( ) { return automaticCategoryCrossing . isSet ( field_6_options ) ; } public void setLogarithmicScale ( boolean value ) { field_6_options = logarithmicScale . setShortBoolean ( field_6_options , value ) ; } public boolean isLogarithmicScale ( ) { return logarithmicScale . isSet ( field_6_options ) ; } public void setValuesInReverse ( boolean value ) { field_6_options = valuesInReverse . setShortBoolean ( field_6_options , value ) ; } public boolean isValuesInReverse ( ) { return valuesInReverse . isSet ( field_6_options ) ; } public void setCrossCategoryAxisAtMaximum ( boolean value ) { field_6_options = crossCategoryAxisAtMaximum . setShortBoolean ( field_6_options , value ) ; } public boolean isCrossCategoryAxisAtMaximum ( ) { return crossCategoryAxisAtMaximum . isSet ( field_6_options ) ; } public void setReserved ( boolean value ) { field_6_options = reserved . setShortBoolean ( field_6_options , value ) ; } public boolean isReserved ( ) { return reserved . isSet ( field_6_options ) ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . hpsf . littleendian . * ; public class Property { private int id ; public int getID ( ) { return id ; } private int type ; public int getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final int offset , final int length ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length ) ; return ; } int o = offset ; type = new DWord ( src , o ) . intValue ( ) ; o += DWord . LENGTH ; switch ( type ) { case Variant . VT_I4 : { value = new Integer ( new DWord ( src , o ) . intValue ( ) ) ; break ; } case Variant . VT_FILETIME : { final int low = new DWord ( src , o ) . intValue ( ) ; o += DWord . LENGTH ; final int high = new DWord ( src , o ) . intValue ( ) ; value = Util . filetimeToDate ( high , low ) ; break ; } case Variant . VT_LPSTR : { final int first = o + DWord . LENGTH ; int last = first + new DWord ( src , o ) . intValue ( ) - 1 ; o += DWord . LENGTH ; while ( src [ last ] == 0 && first <= last ) last -- ; value = new String ( src , first , last - first + 1 ) ; break ; } default : { final byte [ ] v = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) v [ i ] = src [ offset + i ] ; value = v ; break ; } } } protected Map readDictionary ( final byte [ ] src , final int offset , final int length ) { int o = offset ; final int nrEntries = new DWord ( src , o ) . intValue ( ) ; o += DWord . LENGTH ; final Map m = new HashMap ( nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Integer id = new Integer ( new DWord ( src , o ) . intValue ( ) ) ; o += DWord . LENGTH ; final int sLength = new DWord ( src , o ) . intValue ( ) ; o += DWord . LENGTH ; int l = sLength ; while ( src [ o + l - 1 ] == 0x00 ) l -- ; final String s = new String ( src , o , l ) ; o += sLength ; m . put ( id , s ) ; } return m ; } protected int readCodePage ( final byte [ ] src , final int offset ) { throw new UnsupportedOperationException ( "FIXME" ) ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class LabelRecord extends Record implements CellValueRecordInterface { public final static short sid = 0x204 ; private short field_1_row ; private short field_2_column ; private short field_3_xf_index ; private short field_4_string_len ; private byte field_5_unicode_flag ; private String field_6_value ; public LabelRecord ( ) { } public LabelRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LabelRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != this . sid ) { throw new RecordFormatException ( "Not a valid LabelRecord" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_column = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_string_len = LittleEndian . getShort ( data , 6 + offset ) ; field_5_unicode_flag = data [ 8 + offset ] ; if ( isUnCompressedUnicode ( ) ) { field_6_value = StringUtil . getFromUnicode ( data , 8 + offset , field_4_string_len ) ; } else { field_6_value = new String ( data , 9 + offset , getStringLength ( ) ) ; } } public short getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_column ; } public short getXFIndex ( ) { return field_3_xf_index ; } public short getStringLength ( ) { return field_4_string_len ; } public boolean isUnCompressedUnicode ( ) { return ( field_5_unicode_flag == 1 ) ; } public String getValue ( ) { return field_6_value ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "Label Records are supported READ ONLY...convert to LabelSST" ) ; } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public void setColumn ( short col ) { } public void setRow ( short row ) { } public void setXFIndex ( short xf ) { } } 	1
package org . apache . poi . poifs . filesystem ; public class POIFSWriterEvent { private DocumentOutputStream stream ; private POIFSDocumentPath path ; private String documentName ; private int limit ; POIFSWriterEvent ( final DocumentOutputStream stream , final POIFSDocumentPath path , final String documentName , final int limit ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; this . limit = limit ; } public DocumentOutputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } public int getLimit ( ) { return limit ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class FontIndexRecord extends Record { public final static short sid = 0x1026 ; private short field_1_fontIndex ; public FontIndexRecord ( ) { } public FontIndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FontIndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a FontIndex record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_fontIndex = LittleEndian . getShort ( data , 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FontIndex]\n" ) ; buffer . append ( "    .fontIndex            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFontIndex ( ) ) ) . append ( " (" ) . append ( getFontIndex ( ) ) . append ( " )\n" ) ; buffer . append ( "[/FontIndex]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_fontIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public short getFontIndex ( ) { return field_1_fontIndex ; } public void setFontIndex ( short field_1_fontIndex ) { this . field_1_fontIndex = field_1_fontIndex ; } } 	1
package org . apache . poi . util ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . * ; import org . apache . commons . logging . * ; public class POILogFactory { private static LogFactory _creator = LogFactory . getFactory ( ) ; private static Map _loggers = new HashMap ( ) ; ; private POILogFactory ( ) { } public static POILogger getLogger ( final Class theclass ) { return getLogger ( theclass . getName ( ) ) ; } public static POILogger getLogger ( final String cat ) { POILogger logger = null ; if ( _loggers . containsKey ( cat ) ) { logger = ( POILogger ) _loggers . get ( cat ) ; } else { logger = new POILogger ( _creator . getInstance ( cat ) ) ; _loggers . put ( cat , logger ) ; } return logger ; } } 	0
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; public interface DirectoryEntry extends Entry { public Iterator getEntries ( ) ; public boolean isEmpty ( ) ; public int getEntryCount ( ) ; public Entry getEntry ( final String name ) throws FileNotFoundException ; public DocumentEntry createDocument ( final String name , final InputStream stream ) throws IOException ; public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException ; public DirectoryEntry createDirectory ( final String name ) throws IOException ; } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class PropertyBlock extends BigBlock { private static final int _properties_per_block = POIFSConstants . BIG_BLOCK_SIZE / POIFSConstants . PROPERTY_SIZE ; private Property [ ] _properties ; private PropertyBlock ( final Property [ ] properties , final int offset ) { _properties = new Property [ _properties_per_block ] ; for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] = properties [ j + offset ] ; } } public static BlockWritable [ ] createPropertyBlockArray ( final List properties ) { int block_count = ( properties . size ( ) + _properties_per_block - 1 ) / _properties_per_block ; Property [ ] to_be_written = new Property [ block_count * _properties_per_block ] ; System . arraycopy ( properties . toArray ( new Property [ 0 ] ) , 0 , to_be_written , 0 , properties . size ( ) ) ; for ( int j = properties . size ( ) ; j < to_be_written . length ; j ++ ) { to_be_written [ j ] = new Property ( ) { protected void preWrite ( ) { } public boolean isDirectory ( ) { return false ; } } ; } BlockWritable [ ] rvalue = new BlockWritable [ block_count ] ; for ( int j = 0 ; j < block_count ; j ++ ) { rvalue [ j ] = new PropertyBlock ( to_be_written , j * _properties_per_block ) ; } return rvalue ; } void writeData ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] . writeData ( stream ) ; } } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; public class HSSFCellStyle implements HSSFColorConstants { private ExtendedFormatRecord format = null ; private short index = 0 ; private short fontindex = 0 ; public final static short ALIGN_GENERAL = 0x0 ; public final static short ALIGN_LEFT = 0x1 ; public final static short ALIGN_CENTER = 0x2 ; public final static short ALIGN_RIGHT = 0x3 ; public final static short ALIGN_FILL = 0x4 ; public final static short ALIGN_JUSTIFY = 0x5 ; public final static short ALIGN_CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short BORDER_NONE = 0x0 ; public final static short BORDER_THIN = 0x1 ; public final static short BORDER_MEDIUM = 0x2 ; public final static short BORDER_DASHED = 0x3 ; public final static short BORDER_DOTTED = 0x4 ; public final static short BORDER_THICK = 0x5 ; public final static short BORDER_DOUBLE = 0x6 ; public final static short BORDER_HAIR = 0x7 ; public final static short BORDER_MEDIUM_DASHED = 0x8 ; public final static short BORDER_DASH_DOT = 0x9 ; public final static short BORDER_MEDIUM_DASH_DOT = 0xA ; public final static short BORDER_DASH_DOT_DOT = 0xB ; public final static short BORDER_MEDIUM_DASH_DOT_DOT = 0xC ; public final static short BORDER_SLANTED_DASH_DOT = 0xD ; public final static short NO_FILL = 0 ; public final static short SOLID_FOREGROUND = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; protected HSSFCellStyle ( short index , ExtendedFormatRecord rec ) { this . index = index ; format = rec ; } public short getIndex ( ) { return index ; } public void setDataFormat ( short fmt ) { format . setFormatIndex ( fmt ) ; } public short getDataFormat ( ) { return format . getFormatIndex ( ) ; } public void setFont ( HSSFFont font ) { format . setIndentNotParentFont ( true ) ; fontindex = font . getIndex ( ) ; format . setFontIndex ( fontindex ) ; } public short getFontIndex ( ) { return format . getFontIndex ( ) ; } public void setHidden ( boolean hidden ) { format . setIndentNotParentCellOptions ( true ) ; format . setHidden ( hidden ) ; } public boolean getHidden ( ) { return format . isHidden ( ) ; } public void setLocked ( boolean locked ) { format . setIndentNotParentCellOptions ( true ) ; format . setLocked ( locked ) ; } public boolean getLocked ( ) { return format . isLocked ( ) ; } public void setAlignment ( short align ) { format . setIndentNotParentAlignment ( true ) ; format . setAlignment ( align ) ; } public short getAlignment ( ) { return format . getAlignment ( ) ; } public void setWrapText ( boolean wrapped ) { format . setIndentNotParentAlignment ( true ) ; format . setWrapText ( wrapped ) ; } public boolean getWrapText ( ) { return format . getWrapText ( ) ; } public void setVerticalAlignment ( short align ) { format . setVerticalAlignment ( align ) ; } public short getVerticalAlignment ( ) { return format . getVerticalAlignment ( ) ; } public void setRotation ( short rotation ) { format . setRotation ( rotation ) ; } public short getRotation ( ) { return format . getRotation ( ) ; } public void setIndention ( short indent ) { format . setIndent ( indent ) ; } public short getIndention ( ) { return format . getIndent ( ) ; } public void setBorderLeft ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderLeft ( border ) ; } public short getBorderLeft ( ) { return format . getBorderLeft ( ) ; } public void setBorderRight ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderRight ( border ) ; } public short getBorderRight ( ) { return format . getBorderRight ( ) ; } public void setBorderTop ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderTop ( border ) ; } public short getBorderTop ( ) { return format . getBorderTop ( ) ; } public void setBorderBottom ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderBottom ( border ) ; } public short getBorderBottom ( ) { return format . getBorderBottom ( ) ; } public void setLeftBorderColor ( short color ) { format . setLeftBorderPaletteIdx ( color ) ; } public short getLeftBorderColor ( ) { return format . getLeftBorderPaletteIdx ( ) ; } public void setRightBorderColor ( short color ) { format . setRightBorderPaletteIdx ( color ) ; } public short getRightBorderColor ( ) { return format . getRightBorderPaletteIdx ( ) ; } public void setTopBorderColor ( short color ) { format . setTopBorderPaletteIdx ( color ) ; } public short getTopBorderColor ( ) { return format . getTopBorderPaletteIdx ( ) ; } public void setBottomBorderColor ( short color ) { format . setBottomBorderPaletteIdx ( color ) ; } public short getBottomBorderColor ( ) { return format . getBottomBorderPaletteIdx ( ) ; } public void setFillPattern ( short fp ) { format . setAdtlFillPattern ( fp ) ; } public short getFillPattern ( ) { return format . getAdtlFillPattern ( ) ; } public void setFillBackgroundColor ( short bg ) { format . setFillBackground ( bg ) ; } public short getFillBackgroundColor ( ) { return format . getFillBackground ( ) ; } public void setFillForegroundColor ( short bg ) { format . setFillForeground ( bg ) ; } public short getFillForegroundColor ( ) { return format . getFillForeground ( ) ; } } 	1
package org . apache . poi . poifs . filesystem ; public interface DocumentEntry extends Entry { public int getSize ( ) ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class UnknownRecord extends Record { private short sid = 0 ; private short size = 0 ; private byte [ ] thedata = null ; int offset = 0 ; public UnknownRecord ( ) { } public UnknownRecord ( short id , short size , byte [ ] data ) { sid = id ; size = size ; thedata = data ; } public int serialize ( int offset , byte [ ] data ) { if ( thedata == null ) { thedata = new byte [ 0 ] ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( thedata . length ) ) ; if ( thedata . length > 0 ) { System . arraycopy ( thedata , 0 , data , 4 + offset , thedata . length ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 4 ; if ( thedata != null ) { retval += thedata . length ; } return retval ; } protected void fillFields ( byte [ ] data , short sid ) { sid = sid ; thedata = data ; } protected void validateSid ( short id ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[UNKNOWN RECORD]\n" ) ; buffer . append ( "    .id        = " ) . append ( Integer . toHexString ( sid ) ) . append ( "\n" ) ; buffer . append ( "[/UNKNWON RECORD]\n" ) ; return buffer . toString ( ) ; } public short getSid ( ) { return this . sid ; } protected void fillFields ( byte [ ] data , short size , int offset ) { throw new RecordFormatException ( "Unknown record cannot be constructed via offset -- we need a copy of the data" ) ; } } 	1
package org . apache . poi . hpsf . littleendian ; public class Byte extends LittleEndian { public Byte ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 1 ; public int length ( ) { return LENGTH ; } } 	0
package org . apache . poi . hssf . record . formula ; public class DividePtg extends Ptg implements OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x06 ; public DividePtg ( ) { } public DividePtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( ) { return "/" ; } public String toFormulaString ( Ptg [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] . toFormulaString ( ) ) ; buffer . append ( "/" ) ; buffer . append ( operands [ 1 ] . toFormulaString ( ) ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class WindowOneRecord extends Record { public final static short sid = 0x3d ; private short field_1_h_hold ; private short field_2_v_hold ; private short field_3_width ; private short field_4_height ; private short field_5_options ; static final private BitField hidden = new BitField ( 0x01 ) ; static final private BitField iconic = new BitField ( 0x02 ) ; static final private BitField reserved = new BitField ( 0x04 ) ; static final private BitField hscroll = new BitField ( 0x08 ) ; static final private BitField vscroll = new BitField ( 0x10 ) ; static final private BitField tabs = new BitField ( 0x20 ) ; private short field_6_selected_tab ; private short field_7_displayed_tab ; private short field_8_num_selected_tabs ; private short field_9_tab_width_ratio ; public WindowOneRecord ( ) { } public WindowOneRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowOneRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WINDOW1 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_h_hold = LittleEndian . getShort ( data , 0 + offset ) ; field_2_v_hold = LittleEndian . getShort ( data , 2 + offset ) ; field_3_width = LittleEndian . getShort ( data , 4 + offset ) ; field_4_height = LittleEndian . getShort ( data , 6 + offset ) ; field_5_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_selected_tab = LittleEndian . getShort ( data , 10 + offset ) ; field_7_displayed_tab = LittleEndian . getShort ( data , 12 + offset ) ; field_8_num_selected_tabs = LittleEndian . getShort ( data , 14 + offset ) ; field_9_tab_width_ratio = LittleEndian . getShort ( data , 16 + offset ) ; } public void setHorizontalHold ( short h ) { field_1_h_hold = h ; } public void setVerticalHold ( short v ) { field_2_v_hold = v ; } public void setWidth ( short w ) { field_3_width = w ; } public void setHeight ( short h ) { field_4_height = h ; } public void setOptions ( short o ) { field_5_options = o ; } public void setHidden ( boolean ishidden ) { field_5_options = hidden . setShortBoolean ( field_5_options , ishidden ) ; } public void setIconic ( boolean isiconic ) { field_5_options = iconic . setShortBoolean ( field_5_options , isiconic ) ; } public void setDisplayHorizonalScrollbar ( boolean scroll ) { field_5_options = hscroll . setShortBoolean ( field_5_options , scroll ) ; } public void setDisplayVerticalScrollbar ( boolean scroll ) { field_5_options = vscroll . setShortBoolean ( field_5_options , scroll ) ; } public void setDisplayTabs ( boolean disptabs ) { field_5_options = tabs . setShortBoolean ( field_5_options , disptabs ) ; } public void setSelectedTab ( short s ) { field_6_selected_tab = s ; } public void setDisplayedTab ( short t ) { field_7_displayed_tab = t ; } public void setNumSelectedTabs ( short n ) { field_8_num_selected_tabs = n ; } public void setTabWidthRatio ( short r ) { field_9_tab_width_ratio = r ; } public short getHorizontalHold ( ) { return field_1_h_hold ; } public short getVerticalHold ( ) { return field_2_v_hold ; } public short getWidth ( ) { return field_3_width ; } public short getHeight ( ) { return field_4_height ; } public short getOptions ( ) { return field_5_options ; } public boolean getHidden ( ) { return hidden . isSet ( field_5_options ) ; } public boolean getIconic ( ) { return iconic . isSet ( field_5_options ) ; } public boolean getDisplayHorizontalScrollbar ( ) { return hscroll . isSet ( field_5_options ) ; } public boolean getDisplayVerticalScrollbar ( ) { return vscroll . isSet ( field_5_options ) ; } public boolean getDisplayTabs ( ) { return tabs . isSet ( field_5_options ) ; } public short getSelectedTab ( ) { return field_6_selected_tab ; } public short getDisplayedTab ( ) { return field_7_displayed_tab ; } public short getNumSelectedTabs ( ) { return field_8_num_selected_tabs ; } public short getTabWidthRatio ( ) { return field_9_tab_width_ratio ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOW1]\n" ) ; buffer . append ( "    .h_hold          = " ) . append ( Integer . toHexString ( getHorizontalHold ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .v_hold          = " ) . append ( Integer . toHexString ( getVerticalHold ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .width           = " ) . append ( Integer . toHexString ( getWidth ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .height          = " ) . append ( Integer . toHexString ( getHeight ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .options         = " ) . append ( Integer . toHexString ( getOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .hidden      = " ) . append ( getHidden ( ) ) . append ( "\n" ) ; buffer . append ( "        .iconic      = " ) . append ( getIconic ( ) ) . append ( "\n" ) ; buffer . append ( "        .hscroll     = " ) . append ( getDisplayHorizontalScrollbar ( ) ) . append ( "\n" ) ; buffer . append ( "        .vscroll     = " ) . append ( getDisplayVerticalScrollbar ( ) ) . append ( "\n" ) ; buffer . append ( "        .tabs        = " ) . append ( getDisplayTabs ( ) ) . append ( "\n" ) ; buffer . append ( "    .selectedtab     = " ) . append ( Integer . toHexString ( getSelectedTab ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .displayedtab    = " ) . append ( Integer . toHexString ( getDisplayedTab ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .numselectedtabs = " ) . append ( Integer . toHexString ( getNumSelectedTabs ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .tabwidthratio   = " ) . append ( Integer . toHexString ( getTabWidthRatio ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOW1]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x12 ) ) ; LittleEndian . putShort ( data , 4 + offset , getHorizontalHold ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getVerticalHold ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getWidth ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getHeight ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getSelectedTab ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getDisplayedTab ( ) ) ; LittleEndian . putShort ( data , 18 + offset , getNumSelectedTabs ( ) ) ; LittleEndian . putShort ( data , 20 + offset , getTabWidthRatio ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record . formula ; public class ExpPtg extends Ptg { private final static int SIZE = 5 ; public final static short sid = 0x1 ; public ExpPtg ( ) { } public ExpPtg ( byte [ ] array , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return SIZE ; } public String toFormulaString ( ) { return "NO IDEA SHARED FORMULA EXP PTG" ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . property . Property ; public abstract class EntryNode implements Entry { private Property _property ; private DirectoryNode _parent ; protected EntryNode ( final Property property , final DirectoryNode parent ) { _property = property ; _parent = parent ; } protected Property getProperty ( ) { return _property ; } protected boolean isRoot ( ) { return ( _parent == null ) ; } protected abstract boolean isDeleteOK ( ) ; public String getName ( ) { return _property . getName ( ) ; } public boolean isDirectoryEntry ( ) { return false ; } public boolean isDocumentEntry ( ) { return false ; } public DirectoryEntry getParent ( ) { return _parent ; } public boolean delete ( ) { boolean rval = false ; if ( ( ! isRoot ( ) ) && isDeleteOK ( ) ) { rval = _parent . deleteEntry ( this ) ; } return rval ; } public boolean renameTo ( final String newName ) { boolean rval = false ; if ( ! isRoot ( ) ) { rval = _parent . changeName ( getName ( ) , newName ) ; } return rval ; } } 	0
package org . apache . poi . hpsf ; public class HPSFException extends Exception { private Throwable reason ; public HPSFException ( ) { super ( ) ; } public HPSFException ( final String msg ) { super ( msg ) ; } public HPSFException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HPSFException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class LongField implements FixedField { private long _value ; private final int _offset ; public LongField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public LongField ( final int offset , final long value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public LongField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public LongField ( final int offset , final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public long get ( ) { return _value ; } public void set ( final long value ) { _value = value ; } public void set ( final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getLong ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readLong ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putLong ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class BoundSheetRecord extends Record { public final static short sid = 0x85 ; private int field_1_position_of_BOF ; private short field_2_option_flags ; private byte field_3_sheetname_length ; private byte field_4_compressed_unicode_flag ; private String field_5_sheetname ; public BoundSheetRecord ( ) { } public BoundSheetRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BoundSheetRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Bound Sheet RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_position_of_BOF = LittleEndian . getInt ( data , 0 + offset ) ; field_2_option_flags = LittleEndian . getShort ( data , 4 + offset ) ; field_3_sheetname_length = data [ 6 + offset ] ; field_4_compressed_unicode_flag = data [ 7 + offset ] ; field_5_sheetname = new String ( data , 8 + offset , LittleEndian . ubyteToInt ( field_3_sheetname_length ) ) ; } public void setPositionOfBof ( int pos ) { field_1_position_of_BOF = pos ; } public void setOptionFlags ( short flags ) { field_2_option_flags = flags ; } public void setSheetnameLength ( byte len ) { field_3_sheetname_length = len ; } public void setCompressedUnicodeFlag ( byte flag ) { field_4_compressed_unicode_flag = flag ; } public void setSheetname ( String sheetname ) { field_5_sheetname = sheetname ; } public int getPositionOfBof ( ) { return field_1_position_of_BOF ; } public short getOptionFlags ( ) { return field_2_option_flags ; } public byte getSheetnameLength ( ) { return field_3_sheetname_length ; } public byte getCompressedUnicodeFlag ( ) { return field_4_compressed_unicode_flag ; } public String getSheetname ( ) { return field_5_sheetname ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOUNDSHEET]\n" ) ; buffer . append ( "    .bof             = " ) . append ( Integer . toHexString ( getPositionOfBof ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .optionflags     = " ) . append ( Integer . toHexString ( getOptionFlags ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .sheetname length= " ) . append ( Integer . toHexString ( getSheetnameLength ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .unicodeflag     = " ) . append ( Integer . toHexString ( getCompressedUnicodeFlag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .sheetname       = " ) . append ( getSheetname ( ) ) . append ( "\n" ) ; buffer . append ( "[/BOUNDSHEET]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 0x08 + getSheetnameLength ( ) ) ) ; LittleEndian . putInt ( data , 4 + offset , getPositionOfBof ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getOptionFlags ( ) ) ; data [ 10 + offset ] = getSheetnameLength ( ) ; data [ 11 + offset ] = getCompressedUnicodeFlag ( ) ; StringUtil . putCompressedUnicode ( getSheetname ( ) , data , 12 + offset ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 12 + getSheetnameLength ( ) ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public interface FixedField { public void readFromBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public void readFromStream ( InputStream stream ) throws IOException , BufferUnderrunException ; public void writeToBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public String toString ( ) ; } 	0
package org . apache . poi . poifs . property ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . util . ByteField ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . ShortField ; public abstract class Property implements Child , POIFSViewable { static final private byte _default_fill = ( byte ) 0x00 ; static final private int _name_size_offset = 0x40 ; static final private int _max_name_length = ( _name_size_offset / LittleEndianConsts . SHORT_SIZE ) - 1 ; static final protected int _NO_INDEX = - 1 ; static final private int _node_color_offset = 0x43 ; static final private int _previous_property_offset = 0x44 ; static final private int _next_property_offset = 0x48 ; static final private int _child_property_offset = 0x4C ; static final private int _seconds_1_offset = 0x64 ; static final private int _days_1_offset = 0x68 ; static final private int _seconds_2_offset = 0x6C ; static final private int _days_2_offset = 0x70 ; static final private int _start_block_offset = 0x74 ; static final private int _size_offset = 0x78 ; static final protected byte _NODE_BLACK = 1 ; static final protected byte _NODE_RED = 0 ; static final private int _big_block_minimum_bytes = 4096 ; private String _name ; private ShortField _name_size ; private ByteField _property_type ; private ByteField _node_color ; private IntegerField _previous_property ; private IntegerField _next_property ; private IntegerField _child_property ; private IntegerField _seconds_1 ; private IntegerField _days_1 ; private IntegerField _seconds_2 ; private IntegerField _days_2 ; private IntegerField _start_block ; private IntegerField _size ; private byte [ ] _raw_data ; private int _index ; private Child _next_child ; private Child _previous_child ; protected Property ( ) { _raw_data = new byte [ POIFSConstants . PROPERTY_SIZE ] ; Arrays . fill ( _raw_data , _default_fill ) ; _name_size = new ShortField ( _name_size_offset ) ; _property_type = new ByteField ( PropertyConstants . PROPERTY_TYPE_OFFSET ) ; _node_color = new ByteField ( _node_color_offset ) ; _previous_property = new IntegerField ( _previous_property_offset , _NO_INDEX , _raw_data ) ; _next_property = new IntegerField ( _next_property_offset , _NO_INDEX , _raw_data ) ; _child_property = new IntegerField ( _child_property_offset , _NO_INDEX , _raw_data ) ; _seconds_1 = new IntegerField ( _seconds_1_offset , 0 , _raw_data ) ; _days_1 = new IntegerField ( _days_1_offset , 0 , _raw_data ) ; _seconds_2 = new IntegerField ( _seconds_2_offset , 0 , _raw_data ) ; _days_2 = new IntegerField ( _days_2_offset , 0 , _raw_data ) ; _start_block = new IntegerField ( _start_block_offset ) ; _size = new IntegerField ( _size_offset , 0 , _raw_data ) ; _index = _NO_INDEX ; setName ( "" ) ; setNextChild ( null ) ; setPreviousChild ( null ) ; } protected Property ( final int index , final byte [ ] array , final int offset ) { _raw_data = new byte [ POIFSConstants . PROPERTY_SIZE ] ; System . arraycopy ( array , offset , _raw_data , 0 , POIFSConstants . PROPERTY_SIZE ) ; _name_size = new ShortField ( _name_size_offset , _raw_data ) ; _property_type = new ByteField ( PropertyConstants . PROPERTY_TYPE_OFFSET , _raw_data ) ; _node_color = new ByteField ( _node_color_offset , _raw_data ) ; _previous_property = new IntegerField ( _previous_property_offset , _raw_data ) ; _next_property = new IntegerField ( _next_property_offset , _raw_data ) ; _child_property = new IntegerField ( _child_property_offset , _raw_data ) ; _seconds_1 = new IntegerField ( _seconds_1_offset , _raw_data ) ; _days_1 = new IntegerField ( _days_1_offset , _raw_data ) ; _seconds_2 = new IntegerField ( _seconds_2_offset , _raw_data ) ; _days_2 = new IntegerField ( _days_2_offset , _raw_data ) ; _start_block = new IntegerField ( _start_block_offset , _raw_data ) ; _size = new IntegerField ( _size_offset , _raw_data ) ; _index = index ; int name_length = ( _name_size . get ( ) / LittleEndianConsts . SHORT_SIZE ) - 1 ; if ( name_length < 1 ) { _name = "" ; } else { char [ ] char_array = new char [ name_length ] ; int name_offset = 0 ; for ( int j = 0 ; j < name_length ; j ++ ) { char_array [ j ] = ( char ) new ShortField ( name_offset , _raw_data ) . get ( ) ; name_offset += LittleEndianConsts . SHORT_SIZE ; } _name = new String ( char_array , 0 , name_length ) ; } _next_child = null ; _previous_child = null ; } public void writeData ( final OutputStream stream ) throws IOException { stream . write ( _raw_data ) ; } public void setStartBlock ( final int startBlock ) { _start_block . set ( startBlock , _raw_data ) ; } public int getStartBlock ( ) { return _start_block . get ( ) ; } public int getSize ( ) { return _size . get ( ) ; } public boolean shouldUseSmallBlocks ( ) { return Property . isSmall ( _size . get ( ) ) ; } public static boolean isSmall ( final int length ) { return length < _big_block_minimum_bytes ; } public String getName ( ) { return _name ; } abstract public boolean isDirectory ( ) ; protected final void setName ( final String name ) { char [ ] char_array = name . toCharArray ( ) ; int limit = Math . min ( char_array . length , _max_name_length ) ; _name = new String ( char_array , 0 , limit ) ; short offset = 0 ; int j = 0 ; for ( ; j < limit ; j ++ ) { new ShortField ( offset , ( short ) char_array [ j ] , _raw_data ) ; offset += LittleEndianConsts . SHORT_SIZE ; } for ( ; j < _max_name_length + 1 ; j ++ ) { new ShortField ( offset , ( short ) 0 , _raw_data ) ; offset += LittleEndianConsts . SHORT_SIZE ; } _name_size . set ( ( short ) ( ( limit + 1 ) * LittleEndianConsts . SHORT_SIZE ) , _raw_data ) ; } protected void setPropertyType ( final byte propertyType ) { _property_type . set ( propertyType , _raw_data ) ; } protected void setNodeColor ( final byte nodeColor ) { _node_color . set ( nodeColor , _raw_data ) ; } protected void setChildProperty ( final int child ) { _child_property . set ( child , _raw_data ) ; } protected int getChildIndex ( ) { return _child_property . get ( ) ; } protected void setSize ( final int size ) { _size . set ( size , _raw_data ) ; } protected void setIndex ( final int index ) { _index = index ; } protected int getIndex ( ) { return _index ; } abstract protected void preWrite ( ) ; int getNextChildIndex ( ) { return _next_property . get ( ) ; } int getPreviousChildIndex ( ) { return _previous_property . get ( ) ; } static boolean isValidIndex ( int index ) { return index != _NO_INDEX ; } public Child getNextChild ( ) { return _next_child ; } public Child getPreviousChild ( ) { return _previous_child ; } public void setNextChild ( final Child child ) { _next_child = child ; _next_property . set ( ( child == null ) ? _NO_INDEX : ( ( Property ) child ) . getIndex ( ) , _raw_data ) ; } public void setPreviousChild ( final Child child ) { _previous_child = child ; _previous_property . set ( ( child == null ) ? _NO_INDEX : ( ( Property ) child ) . getIndex ( ) , _raw_data ) ; } public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ 5 ] ; results [ 0 ] = "Name          = \"" + getName ( ) + "\"" ; results [ 1 ] = "Property Type = " + _property_type . get ( ) ; results [ 2 ] = "Node Color    = " + _node_color . get ( ) ; long time = _days_1 . get ( ) ; time <<= 32 ; time += ( ( long ) _seconds_1 . get ( ) ) & 0x0000FFFFL ; results [ 3 ] = "Time 1        = " + time ; time = _days_2 . get ( ) ; time <<= 32 ; time += ( ( long ) _seconds_2 . get ( ) ) & 0x0000FFFFL ; results [ 4 ] = "Time 2        = " + time ; return results ; } public Iterator getViewableIterator ( ) { return Collections . EMPTY_LIST . iterator ( ) ; } public boolean preferArray ( ) { return true ; } public String getShortDescription ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Property: \"" ) . append ( getName ( ) ) . append ( "\"" ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ByteField implements FixedField { private static final byte _default_value = 0 ; private byte _value ; private final int _offset ; public ByteField ( final int offset ) throws ArrayIndexOutOfBoundsException { this ( offset , _default_value ) ; } public ByteField ( final int offset , final byte value ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "offset cannot be negative" ) ; } _offset = offset ; set ( value ) ; } public ByteField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ByteField ( final int offset , final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset , value ) ; writeToBytes ( data ) ; } public byte get ( ) { return _value ; } public void set ( final byte value ) { _value = value ; } public void set ( final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { set ( value ) ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = data [ _offset ] ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = ( LittleEndian . readFromStream ( stream , LittleEndianConsts . BYTE_SIZE ) ) [ 0 ] ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { data [ _offset ] = _value ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import org . apache . poi . util . LittleEndian ; public class ContinueRecord extends Record { public final static short sid = 0x003C ; private byte [ ] field_1_data ; public ContinueRecord ( ) { } public ContinueRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ContinueRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public byte [ ] serialize ( ) { byte [ ] retval = new byte [ field_1_data . length + 4 ] ; LittleEndian . putShort ( retval , 0 , sid ) ; LittleEndian . putShort ( retval , 2 , ( short ) field_1_data . length ) ; System . arraycopy ( field_1_data , 0 , retval , 4 , field_1_data . length ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "You're not supposed to serialize Continue records like this directly" ) ; } public void setData ( byte [ ] data ) { field_1_data = data ; } public byte [ ] getData ( ) { return field_1_data ; } public static byte [ ] processContinue ( byte [ ] data ) { int records = ( data . length / 8214 ) ; int offset = 8214 ; ArrayList crs = new ArrayList ( records ) ; int totalsize = 8214 ; byte [ ] retval = null ; for ( int cr = 0 ; cr < records ; cr ++ ) { ContinueRecord contrec = new ContinueRecord ( ) ; int arraysize = Math . min ( ( 8214 - 4 ) , ( data . length - offset ) ) ; byte [ ] crdata = new byte [ arraysize ] ; System . arraycopy ( data , offset , crdata , 0 , arraysize ) ; offset += crdata . length ; contrec . setData ( crdata ) ; crs . add ( contrec . serialize ( ) ) ; } for ( int cr = 0 ; cr < records ; cr ++ ) { totalsize += ( ( byte [ ] ) crs . get ( cr ) ) . length ; } retval = new byte [ totalsize ] ; offset = 8214 ; System . arraycopy ( data , 0 , retval , 0 , 8214 ) ; for ( int cr = 0 ; cr < records ; cr ++ ) { byte [ ] src = ( byte [ ] ) crs . get ( cr ) ; System . arraycopy ( src , 0 , retval , offset , src . length ) ; offset += src . length ; } return retval ; } protected void fillFields ( byte [ ] ignored_parm1 , short ignored_parm2 ) { } protected void validateSid ( short id ) { if ( id != ContinueRecord . sid ) { throw new RecordFormatException ( "Not a Continue Record" ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CONTINUE RECORD]\n" ) ; buffer . append ( "    .id        = " ) . append ( Integer . toHexString ( sid ) ) . append ( "\n" ) ; buffer . append ( "[/CONTINUE RECORD]\n" ) ; return buffer . toString ( ) ; } public short getSid ( ) { return this . sid ; } protected void fillFields ( byte [ ] ignored_parm1 , short ignored_parm2 , int ignored_parm3 ) { } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ProtectionRev4Record extends Record { public final static short sid = 0x1af ; private short field_1_protect ; public ProtectionRev4Record ( ) { } public ProtectionRev4Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ProtectionRev4Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROTECTION REV 4 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public short getProtect ( ) { return field_1_protect ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROT4REV]\n" ) ; buffer . append ( "    .rowheight      = " ) . append ( Integer . toHexString ( getProtect ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/PROT4REV]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getProtect ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; abstract class BigBlock implements BlockWritable { protected void doWriteData ( final OutputStream stream , final byte [ ] data ) throws IOException { stream . write ( data ) ; } abstract void writeData ( final OutputStream stream ) throws IOException ; public void writeBlocks ( final OutputStream stream ) throws IOException { writeData ( stream ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CalcCountRecord extends Record { public final static short sid = 0xC ; private short field_1_iterations ; public CalcCountRecord ( ) { } public CalcCountRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CalcCountRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Calc Count RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_iterations = LittleEndian . getShort ( data , 0 + offset ) ; } public void setIterations ( short iterations ) { field_1_iterations = iterations ; } public short getIterations ( ) { return field_1_iterations ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CALCCOUNT]\n" ) ; buffer . append ( "    .iterations     = " ) . append ( Integer . toHexString ( getIterations ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CALCCOUNT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , getIterations ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class TabIdRecord extends Record { public final static short sid = 0x13d ; public short [ ] field_1_tabids ; public TabIdRecord ( ) { } public TabIdRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public TabIdRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A TABID RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_tabids = new short [ size / 2 ] ; for ( int k = 0 ; k < field_1_tabids . length ; k ++ ) { field_1_tabids [ k ] = LittleEndian . getShort ( data , ( k * 2 ) + offset ) ; } } public void setTabIdArray ( short [ ] array ) { field_1_tabids = array ; } public short [ ] getTabIdArray ( ) { return field_1_tabids ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[TABID]\n" ) ; buffer . append ( "    .elements        = " ) . append ( field_1_tabids . length ) . append ( "\n" ) ; for ( int k = 0 ; k < field_1_tabids . length ; k ++ ) { buffer . append ( "    .element_" + k + "       = " ) . append ( field_1_tabids [ k ] ) . append ( "\n" ) ; } buffer . append ( "[/TABID]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { short [ ] tabids = getTabIdArray ( ) ; short length = ( short ) ( tabids . length * 2 ) ; int byteoffset = 4 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) length ) ) ; for ( int k = 0 ; k < ( length / 2 ) ; k ++ ) { LittleEndian . putShort ( data , byteoffset + offset , tabids [ k ] ) ; byteoffset += 2 ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + ( getTabIdArray ( ) . length * 2 ) ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . common . POIFSConstants ; import java . io . * ; public class RawDataBlock implements ListManagedBlock { private byte [ ] _data ; private boolean _eof ; public RawDataBlock ( final InputStream stream ) throws IOException { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; int count = stream . read ( _data ) ; if ( count == - 1 ) { _eof = true ; } else if ( count != POIFSConstants . BIG_BLOCK_SIZE ) { String type = " byte" + ( ( count == 1 ) ? ( "" ) : ( "s" ) ) ; throw new IOException ( "Unable to read entire block; " + count + type + " read; expected " + POIFSConstants . BIG_BLOCK_SIZE + " bytes" ) ; } else { _eof = false ; } } public boolean eof ( ) throws IOException { return _eof ; } public byte [ ] getData ( ) throws IOException { if ( eof ( ) ) { throw new IOException ( "Cannot return empty data" ) ; } return _data ; } } 	1
package org . apache . poi . hpsf . littleendian ; public class Word extends LittleEndian { public Word ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 2 ; public int length ( ) { return LENGTH ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class SeriesChartGroupIndexRecord extends Record { public final static short sid = 0x1045 ; private short field_1_chartGroupIndex ; public SeriesChartGroupIndexRecord ( ) { } public SeriesChartGroupIndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesChartGroupIndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesChartGroupIndex record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_chartGroupIndex = LittleEndian . getShort ( data , 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SeriesChartGroupIndex]\n" ) ; buffer . append ( "    .chartGroupIndex      = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getChartGroupIndex ( ) ) ) . append ( " (" ) . append ( getChartGroupIndex ( ) ) . append ( " )\n" ) ; buffer . append ( "[/SeriesChartGroupIndex]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_chartGroupIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public short getChartGroupIndex ( ) { return field_1_chartGroupIndex ; } public void setChartGroupIndex ( short field_1_chartGroupIndex ) { this . field_1_chartGroupIndex = field_1_chartGroupIndex ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; public interface BlockWritable { public void writeBlocks ( final OutputStream stream ) throws IOException ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class IterationRecord extends Record { public final static short sid = 0x11 ; private short field_1_iteration ; public IterationRecord ( ) { } public IterationRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public IterationRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An ITERATION RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_iteration = LittleEndian . getShort ( data , 0 + offset ) ; } public void setIteration ( boolean iterate ) { if ( iterate ) { field_1_iteration = 1 ; } else { field_1_iteration = 0 ; } } public boolean getIteration ( ) { return ( field_1_iteration == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[ITERATION]\n" ) ; buffer . append ( "    .iteration      = " ) . append ( getIteration ( ) ) . append ( "\n" ) ; buffer . append ( "[/ITERATION]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_iteration ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . ListManagedBlock ; class PropertyFactory { private PropertyFactory ( ) { } static List convertToProperties ( ListManagedBlock [ ] blocks ) throws IOException { List properties = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; int property_count = data . length / POIFSConstants . PROPERTY_SIZE ; int offset = 0 ; for ( int k = 0 ; k < property_count ; k ++ ) { switch ( data [ offset + PropertyConstants . PROPERTY_TYPE_OFFSET ] ) { case PropertyConstants . DIRECTORY_TYPE : properties . add ( new DirectoryProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . DOCUMENT_TYPE : properties . add ( new DocumentProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . ROOT_TYPE : properties . add ( new RootProperty ( properties . size ( ) , data , offset ) ) ; break ; default : properties . add ( null ) ; break ; } offset += POIFSConstants . PROPERTY_SIZE ; } } return properties ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class SaveRecalcRecord extends Record { public final static short sid = 0x5f ; private short field_1_recalc ; public SaveRecalcRecord ( ) { } public SaveRecalcRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SaveRecalcRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Save Recalc RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_recalc = LittleEndian . getShort ( data , 0 + offset ) ; } public void setRecalc ( boolean recalc ) { field_1_recalc = ( short ) ( ( recalc == true ) ? 1 : 0 ) ; } public boolean getRecalc ( ) { return ( field_1_recalc == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SAVERECALC]\n" ) ; buffer . append ( "    .recalc         = " ) . append ( getRecalc ( ) ) . append ( "\n" ) ; buffer . append ( "[/SAVERECALC]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_recalc ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class IntegerField implements FixedField { private int _value ; private final int _offset ; public IntegerField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "negative offset" ) ; } _offset = offset ; } public IntegerField ( final int offset , final int value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public IntegerField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public IntegerField ( final int offset , final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public int get ( ) { return _value ; } public void set ( final int value ) { _value = value ; } public void set ( final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getInt ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readInt ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putInt ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . record ; import java . io . InputStream ; import java . io . IOException ; import java . util . * ; import java . lang . reflect . Constructor ; import org . apache . poi . util . LittleEndian ; public class RecordFactory { private static int NUM_RECORDS = 10000 ; private static final Class [ ] records ; static { if ( FormulaRecord . EXPERIMENTAL_FORMULA_SUPPORT_ENABLED ) { records = new Class [ ] { BOFRecord . class , InterfaceHdrRecord . class , MMSRecord . class , InterfaceEndRecord . class , WriteAccessRecord . class , CodepageRecord . class , DSFRecord . class , TabIdRecord . class , FnGroupCountRecord . class , WindowProtectRecord . class , ProtectRecord . class , PasswordRecord . class , ProtectionRev4Record . class , PasswordRev4Record . class , WindowOneRecord . class , BackupRecord . class , HideObjRecord . class , DateWindow1904Record . class , PrecisionRecord . class , RefreshAllRecord . class , BookBoolRecord . class , FontRecord . class , FormatRecord . class , ExtendedFormatRecord . class , StyleRecord . class , UseSelFSRecord . class , BoundSheetRecord . class , CountryRecord . class , SSTRecord . class , ExtSSTRecord . class , EOFRecord . class , IndexRecord . class , CalcModeRecord . class , CalcCountRecord . class , RefModeRecord . class , IterationRecord . class , DeltaRecord . class , SaveRecalcRecord . class , PrintHeadersRecord . class , PrintGridlinesRecord . class , GridsetRecord . class , GutsRecord . class , DefaultRowHeightRecord . class , WSBoolRecord . class , HeaderRecord . class , FooterRecord . class , HCenterRecord . class , VCenterRecord . class , PrintSetupRecord . class , DefaultColWidthRecord . class , DimensionsRecord . class , RowRecord . class , LabelSSTRecord . class , RKRecord . class , NumberRecord . class , DBCellRecord . class , WindowTwoRecord . class , SelectionRecord . class , ContinueRecord . class , LabelRecord . class , BlankRecord . class , ColumnInfoRecord . class , MulRKRecord . class , MulBlankRecord . class , MergeCellsRecord . class , FormulaRecord . class , BoolErrRecord . class } ; } else { records = new Class [ ] { BOFRecord . class , InterfaceHdrRecord . class , MMSRecord . class , InterfaceEndRecord . class , WriteAccessRecord . class , CodepageRecord . class , DSFRecord . class , TabIdRecord . class , FnGroupCountRecord . class , WindowProtectRecord . class , ProtectRecord . class , PasswordRecord . class , ProtectionRev4Record . class , PasswordRev4Record . class , WindowOneRecord . class , BackupRecord . class , HideObjRecord . class , DateWindow1904Record . class , PrecisionRecord . class , RefreshAllRecord . class , BookBoolRecord . class , FontRecord . class , FormatRecord . class , ExtendedFormatRecord . class , StyleRecord . class , UseSelFSRecord . class , BoundSheetRecord . class , CountryRecord . class , SSTRecord . class , ExtSSTRecord . class , EOFRecord . class , IndexRecord . class , CalcModeRecord . class , CalcCountRecord . class , RefModeRecord . class , IterationRecord . class , DeltaRecord . class , SaveRecalcRecord . class , PrintHeadersRecord . class , PrintGridlinesRecord . class , GridsetRecord . class , GutsRecord . class , DefaultRowHeightRecord . class , WSBoolRecord . class , HeaderRecord . class , FooterRecord . class , HCenterRecord . class , VCenterRecord . class , PrintSetupRecord . class , DefaultColWidthRecord . class , DimensionsRecord . class , RowRecord . class , LabelSSTRecord . class , RKRecord . class , NumberRecord . class , DBCellRecord . class , WindowTwoRecord . class , SelectionRecord . class , ContinueRecord . class , LabelRecord . class , BlankRecord . class , ColumnInfoRecord . class , MulRKRecord . class , MulBlankRecord . class , MergeCellsRecord . class , BoolErrRecord . class } ; } } private static Map recordsMap = recordsToMap ( records ) ; public static void setCapacity ( int capacity ) { NUM_RECORDS = capacity ; } public static List createRecords ( InputStream in ) throws RecordFormatException { ArrayList records = new ArrayList ( NUM_RECORDS ) ; Record last_record = null ; try { short rectype = 0 ; do { rectype = LittleEndian . readShort ( in ) ; if ( rectype != 0 ) { short recsize = LittleEndian . readShort ( in ) ; byte [ ] data = new byte [ ( int ) recsize ] ; in . read ( data ) ; Record [ ] recs = createRecord ( rectype , recsize , data ) ; if ( recs . length > 1 ) { for ( int k = 0 ; k < recs . length ; k ++ ) { records . add ( recs [ k ] ) ; last_record = recs [ k ] ; } } else { Record record = recs [ 0 ] ; if ( record != null ) { if ( rectype == ContinueRecord . sid ) { if ( last_record == null ) { throw new RecordFormatException ( "First record is a ContinueRecord??" ) ; } last_record . processContinueRecord ( data ) ; } else { last_record = record ; records . add ( record ) ; } } } } } while ( rectype != 0 ) ; } catch ( IOException e ) { throw new RecordFormatException ( "Error reading bytes" ) ; } return records ; } public static Record [ ] createRecord ( short rectype , short size , byte [ ] data ) { Record retval = null ; Record [ ] realretval = null ; try { Constructor constructor = ( Constructor ) recordsMap . get ( new Short ( rectype ) ) ; if ( constructor != null ) { retval = ( Record ) constructor . newInstance ( new Object [ ] { new Short ( rectype ) , new Short ( size ) , data } ) ; } else { retval = new UnknownRecord ( rectype , size , data ) ; } } catch ( Exception introspectionException ) { introspectionException . printStackTrace ( ) ; throw new RecordFormatException ( "Unable to construct record instance, the following exception occured: " + introspectionException . getMessage ( ) ) ; } if ( retval instanceof RKRecord ) { RKRecord rk = ( RKRecord ) retval ; NumberRecord num = new NumberRecord ( ) ; num . setColumn ( rk . getColumn ( ) ) ; num . setRow ( rk . getRow ( ) ) ; num . setXFIndex ( rk . getXFIndex ( ) ) ; num . setValue ( rk . getRKNumber ( ) ) ; retval = num ; } else if ( retval instanceof DBCellRecord ) { retval = null ; } else if ( retval instanceof MulRKRecord ) { MulRKRecord mrk = ( MulRKRecord ) retval ; realretval = new Record [ mrk . getNumColumns ( ) ] ; for ( int k = 0 ; k < mrk . getNumColumns ( ) ; k ++ ) { NumberRecord nr = new NumberRecord ( ) ; nr . setColumn ( ( short ) ( k + mrk . getFirstColumn ( ) ) ) ; nr . setRow ( mrk . getRow ( ) ) ; nr . setXFIndex ( mrk . getXFAt ( k ) ) ; nr . setValue ( mrk . getRKNumberAt ( k ) ) ; realretval [ k ] = nr ; } } else if ( retval instanceof MulBlankRecord ) { MulBlankRecord mb = ( MulBlankRecord ) retval ; realretval = new Record [ mb . getNumColumns ( ) ] ; for ( int k = 0 ; k < mb . getNumColumns ( ) ; k ++ ) { BlankRecord br = new BlankRecord ( ) ; br . setColumn ( ( short ) ( k + mb . getFirstColumn ( ) ) ) ; br . setRow ( mb . getRow ( ) ) ; br . setXFIndex ( mb . getXFAt ( k ) ) ; realretval [ k ] = br ; } } if ( realretval == null ) { realretval = new Record [ 1 ] ; realretval [ 0 ] = retval ; } return realretval ; } public static short [ ] getAllKnownRecordSIDs ( ) { short [ ] results = new short [ recordsMap . size ( ) ] ; int i = 0 ; for ( Iterator iterator = recordsMap . keySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Short sid = ( Short ) iterator . next ( ) ; results [ i ++ ] = sid . shortValue ( ) ; } return results ; } private static Map recordsToMap ( Class [ ] records ) { Map result = new HashMap ( ) ; Constructor constructor ; for ( int i = 0 ; i < records . length ; i ++ ) { Class record = null ; short sid = 0 ; record = records [ i ] ; try { sid = record . getField ( "sid" ) . getShort ( null ) ; constructor = record . getConstructor ( new Class [ ] { short . class , short . class , byte [ ] . class } ) ; } catch ( Exception illegalArgumentException ) { throw new RecordFormatException ( "Unable to determine record types" ) ; } result . put ( new Short ( sid ) , constructor ) ; } return result ; } } 	1
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RKUtil ; public class MulRKRecord extends Record { public final static short sid = 0xbd ; private short field_1_row ; private short field_2_first_col ; private ArrayList field_3_rks ; private short field_4_last_col ; public MulRKRecord ( ) { } public MulRKRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MulRKRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public short getRow ( ) { return field_1_row ; } public short getFirstColumn ( ) { return field_2_first_col ; } public short getLastColumn ( ) { return field_4_last_col ; } public int getNumColumns ( ) { return field_4_last_col - field_2_first_col + 1 ; } public short getXFAt ( int coffset ) { return ( ( RkRec ) field_3_rks . get ( coffset ) ) . xf ; } public double getRKNumberAt ( int coffset ) { return RKUtil . decodeNumber ( ( ( RkRec ) field_3_rks . get ( coffset ) ) . rk ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_rks = parseRKs ( data , 4 , offset , size ) ; field_4_last_col = LittleEndian . getShort ( data , ( field_3_rks . size ( ) * 6 ) + 4 + offset ) ; } private ArrayList parseRKs ( byte [ ] data , int offset , int recoffset , short size ) { ArrayList retval = new ArrayList ( ) ; for ( ; offset < size - 2 ; ) { RkRec rec = new RkRec ( ) ; rec . xf = LittleEndian . getShort ( data , offset + recoffset ) ; offset += 2 ; rec . rk = LittleEndian . getInt ( data , offset + recoffset ) ; offset += 4 ; retval . add ( rec ) ; } return retval ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MULRK]\n" ) ; buffer . append ( "firstcol  = " ) . append ( Integer . toHexString ( getFirstColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( " lastcol  = " ) . append ( Integer . toHexString ( getLastColumn ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumColumns ( ) ; k ++ ) { buffer . append ( "xf" ) . append ( k ) . append ( "        = " ) . append ( Integer . toHexString ( getXFAt ( k ) ) ) . append ( "\n" ) ; buffer . append ( "rk" ) . append ( k ) . append ( "        = " ) . append ( getRKNumberAt ( k ) ) . append ( "\n" ) ; } buffer . append ( "[/MULRK]\n" ) ; return buffer . toString ( ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a MulRKRecord!" ) ; } } public short getSid ( ) { return this . sid ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "Sorry, you can't serialize a MulRK in this release" ) ; } } class RkRec { public short xf ; public int rk ; } 	0
package org . apache . poi . hssf . model ; import java . io . OutputStream ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . FormulaUtil ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . IntList ; import org . apache . poi . util . POILogger ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet extends java . lang . Object { protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected MergeCellsRecord merged = null ; protected int mergedloc = 0 ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record" ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; } else if ( ( rec . getSid ( ) == EOFRecord . sid ) && ( -- bofEofNestingLevel == 0 ) ) { log . log ( log . DEBUG , "Hit EOF record at " ) ; records . add ( rec ) ; break ; } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . merged = ( MergeCellsRecord ) rec ; retval . mergedloc = k - offset ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( ( ColumnInfoRecord ) rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == RowRecord . sid ) { if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; retval . rows . construct ( k , recs ) ; isfirstrow = false ; } else { rec = null ; } } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; records . add ( retval . createPrintGridlines ( ) ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; records . add ( retval . createHeader ( ) ) ; records . add ( retval . createFooter ( ) ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; records . add ( retval . createPrintSetup ( ) ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; records . add ( retval . createSelection ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( short rowFrom , short colFrom , short rowTo , short colTo ) { if ( merged == null ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedloc = records . size ( ) - 1 ; records . add ( records . size ( ) - 1 , merged ) ; } return merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; } public void removeMergedRegion ( int index ) { merged . removeAreaAt ( index ) ; if ( merged . getNumAreas ( ) == 0 ) { merged = null ; records . remove ( mergedloc ) ; mergedloc = 0 ; } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { return merged . getAreaAt ( index ) ; } public int getNumMergedRegions ( ) { return merged . getNumAreas ( ) ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( short firstrow , short firstcol , short lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( ( short ) row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( short row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( short row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( ( short ) row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( short row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new short [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( ( short ) row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( short row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new short [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; Ptg [ ] ptg = FormulaUtil . parseFormula ( formula ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( short row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( short row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( short rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( ( ( double ) 0.0010 ) ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( ( double ) 0.5 ) ; retval . setFooterMargin ( ( double ) 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) >= column ) && ( ci . getLastColumn ( ) <= column ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) >= column ) && ( ci . getLastColumn ( ) <= column ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected Record createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } } 	1
package org . apache . poi . poifs . eventfilesystem ; public interface POIFSReaderListener { public void processPOIFSReaderEvent ( POIFSReaderEvent event ) ; } 	0
package org . apache . poi . hssf . usermodel ; import java . util . ArrayList ; import java . util . List ; public class HSSFDataFormat { private static ArrayList formats ; private static synchronized void populateFormats ( ) { formats = new ArrayList ( ) ; formats . add ( 0 , "General" ) ; formats . add ( 1 , "0" ) ; formats . add ( 2 , "0.00" ) ; formats . add ( 3 , "#,##0" ) ; formats . add ( 4 , "#,##0.00" ) ; formats . add ( 5 , "($#,##0_);($#,##0)" ) ; formats . add ( 6 , "($#,##0_);[Red]($#,##0)" ) ; formats . add ( 7 , "($#,##0.00);($#,##0.00)" ) ; formats . add ( 8 , "($#,##0.00_);[Red]($#,##0.00)" ) ; formats . add ( 9 , "0%" ) ; formats . add ( 0xa , "0.00%" ) ; formats . add ( 0xb , "0.00E+00" ) ; formats . add ( 0xc , "# ?/?" ) ; formats . add ( 0xd , "# ??/??" ) ; formats . add ( 0xe , "m/d/yy" ) ; formats . add ( 0xf , "d-mmm-yy" ) ; formats . add ( 0x10 , "d-mmm" ) ; formats . add ( 0x11 , "mmm-yy" ) ; formats . add ( 0x12 , "h:mm AM/PM" ) ; formats . add ( 0x13 , "h:mm:ss AM/PM" ) ; formats . add ( 0x14 , "h:mm" ) ; formats . add ( 0x15 , "h:mm:ss" ) ; formats . add ( 0x16 , "m/d/yy h:mm" ) ; formats . add ( 0x17 , "0x17" ) ; formats . add ( 0x18 , "0x18" ) ; formats . add ( 0x19 , "0x19" ) ; formats . add ( 0x1a , "0x1a" ) ; formats . add ( 0x1b , "0x1b" ) ; formats . add ( 0x1c , "0x1c" ) ; formats . add ( 0x1d , "0x1d" ) ; formats . add ( 0x1e , "0x1e" ) ; formats . add ( 0x1f , "0x1f" ) ; formats . add ( 0x20 , "0x20" ) ; formats . add ( 0x21 , "0x21" ) ; formats . add ( 0x22 , "0x22" ) ; formats . add ( 0x23 , "0x23" ) ; formats . add ( 0x24 , "0x24" ) ; formats . add ( 0x25 , "(#,##0_);(#,##0)" ) ; formats . add ( 0x26 , "(#,##0_);[Red](#,##0)" ) ; formats . add ( 0x27 , "(#,##0.00_);(#,##0.00)" ) ; formats . add ( 0x28 , "(#,##0.00_);[Red](#,##0.00)" ) ; formats . add ( 0x29 , "_(*#,##0_);_(*(#,##0);_(* \"-\"_);_(@_)" ) ; formats . add ( 0x2a , "_($*#,##0_);_($*(#,##0);_($* \"-\"_);_(@_)" ) ; formats . add ( 0x2b , "_(*#,##0.00_);_(*(#,##0.00);_(*\"-\"??_);_(@_)" ) ; formats . add ( 0x2c , "_($*#,##0.00_);_($*(#,##0.00);_($*\"-\"??_);_(@_)" ) ; formats . add ( 0x2d , "mm:ss" ) ; formats . add ( 0x2e , "[h]:mm:ss" ) ; formats . add ( 0x2f , "mm:ss.0" ) ; formats . add ( 0x30 , "##0.0E+0" ) ; formats . add ( 0x31 , "@" ) ; } public static List getFormats ( ) { if ( formats == null ) { populateFormats ( ) ; } return formats ; } public static short getFormat ( String format ) { if ( formats == null ) { populateFormats ( ) ; } short retval = - 1 ; for ( short k = 0 ; k < 0x31 ; k ++ ) { String nformat = ( String ) formats . get ( k ) ; if ( ( nformat != null ) && nformat . equals ( format ) ) { retval = k ; break ; } } return retval ; } public static String getFormat ( short index ) { if ( formats == null ) { populateFormats ( ) ; } return ( String ) formats . get ( index ) ; } public static int getNumberOfBuiltinFormats ( ) { if ( formats == null ) { populateFormats ( ) ; } return formats . size ( ) ; } } 	1
package org . apache . poi . poifs . property ; import java . util . * ; import java . io . IOException ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class DirectoryProperty extends Property implements Parent { private List _children ; private Set _children_names ; public DirectoryProperty ( String name ) { super ( ) ; _children = new ArrayList ( ) ; _children_names = new HashSet ( ) ; setName ( name ) ; setSize ( 0 ) ; setPropertyType ( PropertyConstants . DIRECTORY_TYPE ) ; setStartBlock ( 0 ) ; setNodeColor ( _NODE_BLACK ) ; } protected DirectoryProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _children = new ArrayList ( ) ; _children_names = new HashSet ( ) ; } public boolean changeName ( final Property property , final String newName ) { boolean result ; String oldName = property . getName ( ) ; property . setName ( newName ) ; String cleanNewName = property . getName ( ) ; if ( _children_names . contains ( cleanNewName ) ) { property . setName ( oldName ) ; result = false ; } else { _children_names . add ( cleanNewName ) ; _children_names . remove ( oldName ) ; result = true ; } return result ; } public boolean deleteChild ( final Property property ) { boolean result = _children . remove ( property ) ; if ( result ) { _children_names . remove ( property . getName ( ) ) ; } return result ; } private class PropertyComparator implements Comparator { public boolean equals ( Object o ) { return this == o ; } public int compare ( Object o1 , Object o2 ) { String name1 = ( ( Property ) o1 ) . getName ( ) ; String name2 = ( ( Property ) o2 ) . getName ( ) ; int result = name1 . length ( ) - name2 . length ( ) ; if ( result == 0 ) { result = name1 . compareTo ( name2 ) ; } return result ; } } public boolean isDirectory ( ) { return true ; } protected void preWrite ( ) { if ( _children . size ( ) > 0 ) { Property [ ] children = ( Property [ ] ) _children . toArray ( new Property [ 0 ] ) ; Arrays . sort ( children , new PropertyComparator ( ) ) ; int midpoint = children . length / 2 ; setChildProperty ( children [ midpoint ] . getIndex ( ) ) ; children [ 0 ] . setPreviousChild ( null ) ; children [ 0 ] . setNextChild ( null ) ; for ( int j = 1 ; j < midpoint ; j ++ ) { children [ j ] . setPreviousChild ( children [ j - 1 ] ) ; children [ j ] . setNextChild ( null ) ; } if ( midpoint != 0 ) { children [ midpoint ] . setPreviousChild ( children [ midpoint - 1 ] ) ; } if ( midpoint != ( children . length - 1 ) ) { children [ midpoint ] . setNextChild ( children [ midpoint + 1 ] ) ; for ( int j = midpoint + 1 ; j < children . length - 1 ; j ++ ) { children [ j ] . setPreviousChild ( null ) ; children [ j ] . setNextChild ( children [ j + 1 ] ) ; } children [ children . length - 1 ] . setPreviousChild ( null ) ; children [ children . length - 1 ] . setNextChild ( null ) ; } else { children [ midpoint ] . setNextChild ( null ) ; } } } public Iterator getChildren ( ) { return _children . iterator ( ) ; } public void addChild ( final Property property ) throws IOException { String name = property . getName ( ) ; if ( _children_names . contains ( name ) ) { throw new IOException ( "Duplicate name \"" + name + "\"" ) ; } _children_names . add ( name ) ; _children . add ( property ) ; } } 	0
package org . apache . poi . hssf . eventmodel ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . RecordFormatException ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . ContinueRecord ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; public class HSSFEventFactory { public HSSFEventFactory ( ) { } public void processWorkbookEvents ( HSSFRequest req , POIFSFileSystem fs ) throws IOException { InputStream in = fs . createDocumentInputStream ( "Workbook" ) ; processEvents ( req , in ) ; } public void processEvents ( HSSFRequest req , InputStream in ) throws IOException { try { byte [ ] sidbytes = new byte [ 2 ] ; int bytesread = in . read ( sidbytes ) ; Record rec = null ; while ( bytesread > 0 ) { short sid = 0 ; sid = LittleEndian . getShort ( sidbytes ) ; if ( ( rec != null ) && ( sid != ContinueRecord . sid ) ) { req . processRecord ( rec ) ; } if ( sid != ContinueRecord . sid ) { short size = LittleEndian . readShort ( in ) ; byte [ ] data = new byte [ size ] ; if ( data . length > 0 ) { in . read ( data ) ; } Record [ ] recs = RecordFactory . createRecord ( sid , size , data ) ; if ( recs . length > 1 ) { for ( int k = 0 ; k < ( recs . length - 1 ) ; k ++ ) { req . processRecord ( recs [ k ] ) ; } } rec = recs [ recs . length - 1 ] ; } else { short size = LittleEndian . readShort ( in ) ; byte [ ] data = new byte [ size ] ; if ( data . length > 0 ) { in . read ( data ) ; } rec . processContinueRecord ( data ) ; } bytesread = in . read ( sidbytes ) ; } if ( rec != null ) { req . processRecord ( rec ) ; } } catch ( IOException e ) { throw new RecordFormatException ( "Error reading bytes" ) ; } } } 	1
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; public class POIFSViewEngine { private static final String _EOL = System . getProperty ( "line.separator" ) ; public static List inspectViewable ( final Object viewable , final boolean drilldown , final int indentLevel , final String indentString ) { List objects = new ArrayList ( ) ; if ( viewable instanceof POIFSViewable ) { POIFSViewable inspected = ( POIFSViewable ) viewable ; objects . add ( indent ( indentLevel , indentString , inspected . getShortDescription ( ) ) ) ; if ( drilldown ) { if ( inspected . preferArray ( ) ) { Object [ ] data = inspected . getViewableArray ( ) ; for ( int j = 0 ; j < data . length ; j ++ ) { objects . addAll ( inspectViewable ( data [ j ] , drilldown , indentLevel + 1 , indentString ) ) ; } } else { Iterator iter = inspected . getViewableIterator ( ) ; while ( iter . hasNext ( ) ) { objects . addAll ( inspectViewable ( iter . next ( ) , drilldown , indentLevel + 1 , indentString ) ) ; } } } } else { objects . add ( indent ( indentLevel , indentString , viewable . toString ( ) ) ) ; } return objects ; } private static String indent ( final int indentLevel , final String indentString , final String data ) { StringBuffer finalBuffer = new StringBuffer ( ) ; StringBuffer indentPrefix = new StringBuffer ( ) ; for ( int j = 0 ; j < indentLevel ; j ++ ) { indentPrefix . append ( indentString ) ; } LineNumberReader reader = new LineNumberReader ( new StringReader ( data ) ) ; try { String line = reader . readLine ( ) ; while ( line != null ) { finalBuffer . append ( indentPrefix ) . append ( line ) . append ( _EOL ) ; line = reader . readLine ( ) ; } } catch ( IOException e ) { finalBuffer . append ( indentPrefix ) . append ( e . getMessage ( ) ) . append ( _EOL ) ; } return finalBuffer . toString ( ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class WindowTwoRecord extends Record { public final static short sid = 0x23e ; private short field_1_options ; private BitField displayFormulas = new BitField ( 0x01 ) ; private BitField displayGridlines = new BitField ( 0x02 ) ; private BitField displayRowColHeadings = new BitField ( 0x04 ) ; private BitField freezePanes = new BitField ( 0x08 ) ; private BitField displayZeros = new BitField ( 0x10 ) ; private BitField defaultHeader = new BitField ( 0x20 ) ; private BitField arabic = new BitField ( 0x40 ) ; private BitField displayGuts = new BitField ( 0x80 ) ; private BitField freezePanesNoSplit = new BitField ( 0x100 ) ; private BitField selected = new BitField ( 0x200 ) ; private BitField paged = new BitField ( 0x400 ) ; private BitField savedInPageBreakPreview = new BitField ( 0x800 ) ; private short field_2_top_row ; private short field_3_left_col ; private int field_4_header_color ; private short field_5_page_break_zoom ; private short field_6_normal_zoom ; private int field_7_reserved ; public WindowTwoRecord ( ) { } public WindowTwoRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowTwoRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid WindowTwo RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_options = LittleEndian . getShort ( data , 0 + offset ) ; field_2_top_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_left_col = LittleEndian . getShort ( data , 4 + offset ) ; field_4_header_color = LittleEndian . getInt ( data , 6 + offset ) ; if ( size > 10 ) { field_5_page_break_zoom = LittleEndian . getShort ( data , 10 + offset ) ; field_6_normal_zoom = LittleEndian . getShort ( data , 12 + offset ) ; } if ( size > 14 ) { field_7_reserved = LittleEndian . getInt ( data , 14 + offset ) ; } } public void setOptions ( short options ) { field_1_options = options ; } public void setDisplayFormulas ( boolean formulas ) { field_1_options = displayFormulas . setShortBoolean ( field_1_options , formulas ) ; } public void setDisplayGridlines ( boolean gridlines ) { field_1_options = displayGridlines . setShortBoolean ( field_1_options , gridlines ) ; } public void setDisplayRowColHeadings ( boolean headings ) { field_1_options = displayRowColHeadings . setShortBoolean ( field_1_options , headings ) ; } public void setFreezePanes ( boolean freezepanes ) { field_1_options = freezePanes . setShortBoolean ( field_1_options , freezepanes ) ; } public void setDisplayZeros ( boolean zeros ) { field_1_options = displayZeros . setShortBoolean ( field_1_options , zeros ) ; } public void setDefaultHeader ( boolean header ) { field_1_options = defaultHeader . setShortBoolean ( field_1_options , header ) ; } public void setArabic ( boolean isarabic ) { field_1_options = arabic . setShortBoolean ( field_1_options , isarabic ) ; } public void setDisplayGuts ( boolean guts ) { field_1_options = displayGuts . setShortBoolean ( field_1_options , guts ) ; } public void setFreezePanesNoSplit ( boolean freeze ) { field_1_options = freezePanesNoSplit . setShortBoolean ( field_1_options , freeze ) ; } public void setSelected ( boolean sel ) { field_1_options = selected . setShortBoolean ( field_1_options , sel ) ; } public void setPaged ( boolean p ) { field_1_options = paged . setShortBoolean ( field_1_options , p ) ; } public void setSavedInPageBreakPreview ( boolean p ) { field_1_options = savedInPageBreakPreview . setShortBoolean ( field_1_options , p ) ; } public void setTopRow ( short topRow ) { field_2_top_row = topRow ; } public void setLeftCol ( short leftCol ) { field_3_left_col = leftCol ; } public void setHeaderColor ( int color ) { field_4_header_color = color ; } public void setPageBreakZoom ( short zoom ) { field_5_page_break_zoom = zoom ; } public void setNormalZoom ( short zoom ) { field_6_normal_zoom = zoom ; } public void setReserved ( int reserved ) { field_7_reserved = reserved ; } public short getOptions ( ) { return field_1_options ; } public boolean getDisplayFormulas ( ) { return displayFormulas . isSet ( field_1_options ) ; } public boolean getDisplayGridlines ( ) { return displayGridlines . isSet ( field_1_options ) ; } public boolean getDisplayRowColHeadings ( ) { return displayRowColHeadings . isSet ( field_1_options ) ; } public boolean getFreezePanes ( ) { return freezePanes . isSet ( field_1_options ) ; } public boolean getDisplayZeros ( ) { return displayZeros . isSet ( field_1_options ) ; } public boolean getDefaultHeader ( ) { return defaultHeader . isSet ( field_1_options ) ; } public boolean getArabic ( ) { return arabic . isSet ( field_1_options ) ; } public boolean getDisplayGuts ( ) { return displayGuts . isSet ( field_1_options ) ; } public boolean getFreezePanesNoSplit ( ) { return freezePanesNoSplit . isSet ( field_1_options ) ; } public boolean getSelected ( ) { return selected . isSet ( field_1_options ) ; } public boolean getPaged ( ) { return paged . isSet ( field_1_options ) ; } public boolean getSavedInPageBreakPreview ( ) { return savedInPageBreakPreview . isSet ( field_1_options ) ; } public short getTopRow ( ) { return field_2_top_row ; } public short getLeftCol ( ) { return field_3_left_col ; } public int getHeaderColor ( ) { return field_4_header_color ; } public short getPageBreakZoom ( ) { return field_5_page_break_zoom ; } public short getNormalZoom ( ) { return field_6_normal_zoom ; } public int getReserved ( ) { return field_7_reserved ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOW2]\n" ) ; buffer . append ( "    .options        = " ) . append ( Integer . toHexString ( getOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "       .dispformulas= " ) . append ( getDisplayFormulas ( ) ) . append ( "\n" ) ; buffer . append ( "       .dispgridlins= " ) . append ( getDisplayGridlines ( ) ) . append ( "\n" ) ; buffer . append ( "       .disprcheadin= " ) . append ( getDisplayRowColHeadings ( ) ) . append ( "\n" ) ; buffer . append ( "       .freezepanes = " ) . append ( getFreezePanes ( ) ) . append ( "\n" ) ; buffer . append ( "       .displayzeros= " ) . append ( getDisplayZeros ( ) ) . append ( "\n" ) ; buffer . append ( "       .defaultheadr= " ) . append ( getDefaultHeader ( ) ) . append ( "\n" ) ; buffer . append ( "       .arabic      = " ) . append ( getArabic ( ) ) . append ( "\n" ) ; buffer . append ( "       .displayguts = " ) . append ( getDisplayGuts ( ) ) . append ( "\n" ) ; buffer . append ( "       .frzpnsnosplt= " ) . append ( getFreezePanesNoSplit ( ) ) . append ( "\n" ) ; buffer . append ( "       .selected    = " ) . append ( getSelected ( ) ) . append ( "\n" ) ; buffer . append ( "       .paged       = " ) . append ( getPaged ( ) ) . append ( "\n" ) ; buffer . append ( "       .svdinpgbrkpv= " ) . append ( getSavedInPageBreakPreview ( ) ) . append ( "\n" ) ; buffer . append ( "    .toprow         = " ) . append ( Integer . toHexString ( getTopRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .leftcol        = " ) . append ( Integer . toHexString ( getLeftCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .headercolor    = " ) . append ( Integer . toHexString ( getHeaderColor ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .pagebreakzoom  = " ) . append ( Integer . toHexString ( getPageBreakZoom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .normalzoom     = " ) . append ( Integer . toHexString ( getNormalZoom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .reserved       = " ) . append ( Integer . toHexString ( getReserved ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOW2]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 18 ) ; LittleEndian . putShort ( data , 4 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getTopRow ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getLeftCol ( ) ) ; LittleEndian . putInt ( data , 10 + offset , getHeaderColor ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getPageBreakZoom ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getNormalZoom ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getReserved ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class UseSelFSRecord extends Record { public final static short sid = 0x160 ; public final static short TRUE = 1 ; public final static short FALSE = 0 ; private short field_1_flag ; public UseSelFSRecord ( ) { } public UseSelFSRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public UseSelFSRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A UseSelFS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_flag = LittleEndian . getShort ( data , 0 + offset ) ; } public void setFlag ( short flag ) { field_1_flag = flag ; } public short getFlag ( ) { return field_1_flag ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[USESELFS]\n" ) ; buffer . append ( "    .flag            = " ) . append ( Integer . toHexString ( getFlag ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/USESELFS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFlag ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class HeaderRecord extends Record { public final static short sid = 0x14 ; private byte field_1_header_len ; private String field_2_header ; public HeaderRecord ( ) { } public HeaderRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public HeaderRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A HEADERRECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { if ( size > 0 ) { field_1_header_len = data [ 0 + offset ] ; field_2_header = new String ( data , 3 + offset , LittleEndian . ubyteToInt ( field_1_header_len ) ) ; } } public void setHeaderLength ( byte len ) { field_1_header_len = len ; } public void setHeader ( String header ) { field_2_header = header ; } public short getHeaderLength ( ) { return ( short ) ( 0xFF & field_1_header_len ) ; } public String getHeader ( ) { return field_2_header ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[HEADER]\n" ) ; buffer . append ( "    .length         = " ) . append ( getHeaderLength ( ) ) . append ( "\n" ) ; buffer . append ( "    .header         = " ) . append ( getHeader ( ) ) . append ( "\n" ) ; buffer . append ( "[/HEADER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int len = 4 ; if ( getHeaderLength ( ) != 0 ) { len += 3 ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( ( len - 4 ) + getHeaderLength ( ) ) ) ; if ( getHeaderLength ( ) > 0 ) { data [ 4 + offset ] = ( byte ) getHeaderLength ( ) ; StringUtil . putCompressedUnicode ( getHeader ( ) , data , 7 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 4 ; if ( getHeaderLength ( ) != 0 ) { retval += 3 ; } retval += getHeaderLength ( ) ; return retval ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . property ; import org . apache . poi . poifs . filesystem . POIFSDocument ; public class DocumentProperty extends Property { private POIFSDocument _document ; public DocumentProperty ( final String name , final int size ) { super ( ) ; _document = null ; setName ( name ) ; setSize ( size ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . DOCUMENT_TYPE ) ; } protected DocumentProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _document = null ; } public void setDocument ( POIFSDocument doc ) { _document = doc ; } public POIFSDocument getDocument ( ) { return _document ; } public boolean shouldUseSmallBlocks ( ) { return super . shouldUseSmallBlocks ( ) ; } public boolean isDirectory ( ) { return false ; } protected void preWrite ( ) { } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogger ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . List ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { sheets = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int numRecords = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( numRecords < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , numRecords ) ; numRecords += sheet . getNumRecords ( ) ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( ( new POIFSFileSystem ( s ) ) ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetName ( int sheet , String name ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } workbook . setSheetName ( sheet , name ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheet = workbook . getSheetName ( k ) ; if ( sheet . equals ( name ) ) { retval = k ; break ; } } return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } if ( totalsize < 4096 ) { totalsize = 4096 ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } for ( int k = pos ; k < totalsize ; k ++ ) { retval [ k ] = 0 ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } } 	1
package org . apache . poi . hpsf . littleendian ; public class DWord extends LittleEndian { public DWord ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 4 ; public int length ( ) { return LENGTH ; } public int intValue ( ) { int value = 0 ; final int length = length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final int b = 0xFF & bytes [ i ] ; value = value << 8 | b ; } return value ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class ColumnInfoRecord extends Record { public static final short sid = 0x7d ; private short field_1_first_col ; private short field_2_last_col ; private short field_3_col_width ; private short field_4_xf_index ; private short field_5_options ; static final private BitField hidden = new BitField ( 0x01 ) ; static final private BitField outlevel = new BitField ( 0x0700 ) ; static final private BitField collapsed = new BitField ( 0x1000 ) ; private short field_6_reserved ; public ColumnInfoRecord ( ) { } public ColumnInfoRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ColumnInfoRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_first_col = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_col_width = LittleEndian . getShort ( data , 4 + offset ) ; field_4_xf_index = LittleEndian . getShort ( data , 6 + offset ) ; field_5_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_reserved = data [ 10 + offset ] ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A COLINFO RECORD!!" ) ; } } public void setFirstColumn ( short fc ) { field_1_first_col = fc ; } public void setLastColumn ( short lc ) { field_2_last_col = lc ; } public void setColumnWidth ( short cw ) { field_3_col_width = cw ; } public void setXFIndex ( short xfi ) { field_4_xf_index = xfi ; } public void setOptions ( short options ) { field_5_options = options ; } public void setHidden ( boolean ishidden ) { field_5_options = hidden . setShortBoolean ( field_5_options , ishidden ) ; } public void setOutlineLevel ( short olevel ) { field_5_options = outlevel . setShortValue ( field_5_options , olevel ) ; } public void setCollapsed ( boolean iscollapsed ) { field_5_options = collapsed . setShortBoolean ( field_5_options , iscollapsed ) ; } public short getFirstColumn ( ) { return field_1_first_col ; } public short getLastColumn ( ) { return field_2_last_col ; } public short getColumnWidth ( ) { return field_3_col_width ; } public short getXFIndex ( ) { return field_4_xf_index ; } public short getOptions ( ) { return field_5_options ; } public boolean getHidden ( ) { return hidden . isSet ( field_5_options ) ; } public short getOutlineLevel ( ) { return outlevel . getShortValue ( field_5_options ) ; } public boolean getCollapsed ( ) { return collapsed . isSet ( field_5_options ) ; } public short getSid ( ) { return sid ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 12 ) ; LittleEndian . putShort ( data , 4 + offset , getFirstColumn ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getLastColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getColumnWidth ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getXFIndex ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , ( short ) 0x0 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 16 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[COLINFO]\n" ) ; buffer . append ( "colfirst       = " ) . append ( getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "collast        = " ) . append ( getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "colwidth       = " ) . append ( getColumnWidth ( ) ) . append ( "\n" ) ; buffer . append ( "xfindex        = " ) . append ( getXFIndex ( ) ) . append ( "\n" ) ; buffer . append ( "options        = " ) . append ( getOptions ( ) ) . append ( "\n" ) ; buffer . append ( "  hidden       = " ) . append ( getHidden ( ) ) . append ( "\n" ) ; buffer . append ( "  olevel       = " ) . append ( getOutlineLevel ( ) ) . append ( "\n" ) ; buffer . append ( "  collapsed    = " ) . append ( getCollapsed ( ) ) . append ( "\n" ) ; buffer . append ( "[/COLINFO]\n" ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BATBlock extends BigBlock { private static final int _entries_per_block = POIFSConstants . BIG_BLOCK_SIZE / LittleEndianConsts . INT_SIZE ; private static final int _entries_per_xbat_block = _entries_per_block - 1 ; private static final int _xbat_chain_offset = _entries_per_xbat_block * LittleEndianConsts . INT_SIZE ; private static final byte _default_value = ( byte ) 0xFF ; private IntegerField [ ] _fields ; private byte [ ] _data ; private BATBlock ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; _fields = new IntegerField [ _entries_per_block ] ; int offset = 0 ; for ( int j = 0 ; j < _entries_per_block ; j ++ ) { _fields [ j ] = new IntegerField ( offset ) ; offset += LittleEndianConsts . INT_SIZE ; } } public static BATBlock [ ] createBATBlocks ( final int [ ] entries ) { int block_count = calculateStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; for ( int j = 0 ; j < entries . length ; j += _entries_per_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_block ) ? j + _entries_per_block : entries . length ) ; remaining -= _entries_per_block ; } return blocks ; } public static BATBlock [ ] createXBATBlocks ( final int [ ] entries , final int startBlock ) { int block_count = calculateXBATStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; if ( block_count != 0 ) { for ( int j = 0 ; j < entries . length ; j += _entries_per_xbat_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_xbat_block ) ? j + _entries_per_xbat_block : entries . length ) ; remaining -= _entries_per_xbat_block ; } for ( index = 0 ; index < blocks . length - 1 ; index ++ ) { blocks [ index ] . setXBATChain ( startBlock + index + 1 ) ; } blocks [ index ] . setXBATChain ( POIFSConstants . END_OF_CHAIN ) ; } return blocks ; } public static int calculateStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_block - 1 ) / _entries_per_block ; } public static int calculateXBATStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_xbat_block - 1 ) / _entries_per_xbat_block ; } public static final int entriesPerBlock ( ) { return _entries_per_block ; } public static final int entriesPerXBATBlock ( ) { return _entries_per_xbat_block ; } public static final int getXBATChainOffset ( ) { return _xbat_chain_offset ; } private void setXBATChain ( int chainIndex ) { _fields [ _entries_per_xbat_block ] . set ( chainIndex , _data ) ; } private BATBlock ( final int [ ] entries , final int start_index , final int end_index ) { this ( ) ; for ( int k = start_index ; k < end_index ; k ++ ) { _fields [ k - start_index ] . set ( entries [ k ] , _data ) ; } } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0
package org . apache . poi . hssf . record . formula ; public interface OperationPtg { public final static int TYPE_UNARY = 0 ; public final static int TYPE_BINARY = 1 ; public final static int TYPE_FUNCTION = 2 ; public int getType ( ) ; public int getNumberOfOperands ( ) ; public String toFormulaString ( Ptg [ ] operands ) ; } 	1
package org . apache . poi . util ; public interface LittleEndianConsts { public static final int BYTE_SIZE = 1 ; public static final int SHORT_SIZE = 2 ; public static final int INT_SIZE = 4 ; public static final int LONG_SIZE = 8 ; public static final int DOUBLE_SIZE = 8 ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class FontBasisRecord extends Record { public final static short sid = 0x1060 ; private short field_1_xBasis ; private short field_2_yBasis ; private short field_3_heightBasis ; private short field_4_scale ; private short field_5_indexToFontTable ; public FontBasisRecord ( ) { } public FontBasisRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FontBasisRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a FontBasis record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_xBasis = LittleEndian . getShort ( data , 0x0 + offset ) ; field_2_yBasis = LittleEndian . getShort ( data , 0x2 + offset ) ; field_3_heightBasis = LittleEndian . getShort ( data , 0x4 + offset ) ; field_4_scale = LittleEndian . getShort ( data , 0x6 + offset ) ; field_5_indexToFontTable = LittleEndian . getShort ( data , 0x8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FontBasis]\n" ) ; buffer . append ( "    .xBasis               = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getXBasis ( ) ) ) . append ( " (" ) . append ( getXBasis ( ) ) . append ( " )\n" ) ; buffer . append ( "    .yBasis               = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getYBasis ( ) ) ) . append ( " (" ) . append ( getYBasis ( ) ) . append ( " )\n" ) ; buffer . append ( "    .heightBasis          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getHeightBasis ( ) ) ) . append ( " (" ) . append ( getHeightBasis ( ) ) . append ( " )\n" ) ; buffer . append ( "    .scale                = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getScale ( ) ) ) . append ( " (" ) . append ( getScale ( ) ) . append ( " )\n" ) ; buffer . append ( "    .indexToFontTable     = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getIndexToFontTable ( ) ) ) . append ( " (" ) . append ( getIndexToFontTable ( ) ) . append ( " )\n" ) ; buffer . append ( "[/FontBasis]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_xBasis ) ; LittleEndian . putShort ( data , 6 + offset , field_2_yBasis ) ; LittleEndian . putShort ( data , 8 + offset , field_3_heightBasis ) ; LittleEndian . putShort ( data , 10 + offset , field_4_scale ) ; LittleEndian . putShort ( data , 12 + offset , field_5_indexToFontTable ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public short getXBasis ( ) { return field_1_xBasis ; } public void setXBasis ( short field_1_xBasis ) { this . field_1_xBasis = field_1_xBasis ; } public short getYBasis ( ) { return field_2_yBasis ; } public void setYBasis ( short field_2_yBasis ) { this . field_2_yBasis = field_2_yBasis ; } public short getHeightBasis ( ) { return field_3_heightBasis ; } public void setHeightBasis ( short field_3_heightBasis ) { this . field_3_heightBasis = field_3_heightBasis ; } public short getScale ( ) { return field_4_scale ; } public void setScale ( short field_4_scale ) { this . field_4_scale = field_4_scale ; } public short getIndexToFontTable ( ) { return field_5_indexToFontTable ; } public void setIndexToFontTable ( short field_5_indexToFontTable ) { this . field_5_indexToFontTable = field_5_indexToFontTable ; } } 	1
package org . apache . poi . util ; import java . util . * ; public class ShortList { private short [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public ShortList ( ) { this ( _default_size ) ; } public ShortList ( final ShortList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public ShortList ( final int initialCapacity ) { _array = new short [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final short value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final short value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final ShortList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final ShortList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final ShortList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { ShortList other = ( ShortList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public short get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final short o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final short o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public short remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public short set ( final int index , final short element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public short [ ] toArray ( ) { short [ ] rval = new short [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public short [ ] toArray ( final short [ ] a ) { short [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; short [ ] new_array = new short [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DateWindow1904Record extends Record { public final static short sid = 0x22 ; private short field_1_window ; public DateWindow1904Record ( ) { } public DateWindow1904Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DateWindow1904Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A 1904 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_window = LittleEndian . getShort ( data , 0 + offset ) ; } public void setWindowing ( short window ) { field_1_window = window ; } public short getWindowing ( ) { return field_1_window ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[1904]\n" ) ; buffer . append ( "    .is1904          = " ) . append ( Integer . toHexString ( getWindowing ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/1904]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getWindowing ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ProtectRecord extends Record { public final static short sid = 0x12 ; private short field_1_protect ; public ProtectRecord ( ) { } public ProtectRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ProtectRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROTECT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public short getProtect ( ) { return field_1_protect ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROTECT]\n" ) ; buffer . append ( "    .rowheight      = " ) . append ( Integer . toHexString ( getProtect ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/PROTECT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getProtect ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class RefreshAllRecord extends Record { public final static short sid = 0x1B7 ; private short field_1_refreshall ; public RefreshAllRecord ( ) { } public RefreshAllRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RefreshAllRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A REFRESHALL RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_refreshall = LittleEndian . getShort ( data , 0 + offset ) ; } public void setRefreshAll ( boolean refreshall ) { if ( refreshall ) { field_1_refreshall = 1 ; } else { field_1_refreshall = 0 ; } } public boolean getRefreshAll ( ) { return ( field_1_refreshall == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[REFRESHALL]\n" ) ; buffer . append ( "    .refreshall      = " ) . append ( getRefreshAll ( ) ) . append ( "\n" ) ; buffer . append ( "[/REFRESHALL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_refreshall ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hpsf . wellknown ; import java . util . * ; public class PropertyIDMap extends HashMap { public static final int PID_TITLE = 2 ; public static final int PID_SUBJECT = 3 ; public static final int PID_AUTHOR = 4 ; public static final int PID_KEYWORDS = 5 ; public static final int PID_COMMENTS = 6 ; public static final int PID_TEMPLATE = 7 ; public static final int PID_LASTAUTHOR = 8 ; public static final int PID_REVNUMBER = 9 ; public static final int PID_EDITTIME = 10 ; public static final int PID_LASTPRINTED = 11 ; public static final int PID_CREATE_DTM = 12 ; public static final int PID_LASTSAVE_DTM = 13 ; public static final int PID_PAGECOUNT = 14 ; public static final int PID_WORDCOUNT = 15 ; public static final int PID_CHARCOUNT = 16 ; public static final int PID_THUMBNAIL = 17 ; public static final int PID_APPNAME = 18 ; public static final int PID_SECURITY = 19 ; public static final int PID_CATEGORY = 2 ; public static final int PID_PRESFORMAT = 3 ; public static final int PID_BYTECOUNT = 4 ; public static final int PID_LINECOUNT = 5 ; public static final int PID_PARCOUNT = 6 ; public static final int PID_SLIDECOUNT = 7 ; public static final int PID_NOTECOUNT = 8 ; public static final int PID_HIDDENCOUNT = 9 ; public static final int PID_MMCLIPCOUNT = 10 ; public static final int PID_SCALE = 11 ; public static final int PID_HEADINGPAIR = 12 ; public static final int PID_DOCPARTS = 13 ; public static final int PID_MANAGER = 14 ; public static final int PID_COMPANY = 15 ; public static final int PID_LINKSDIRTY = 16 ; private static PropertyIDMap summaryInformationProperties ; private static PropertyIDMap documentSummaryInformationProperties ; public PropertyIDMap ( int initialCapacity , float loadFactor ) { super ( initialCapacity , loadFactor ) ; } public Object put ( int id , String idString ) { return put ( new Integer ( id ) , idString ) ; } public Object get ( int id ) { return get ( new Integer ( id ) ) ; } public static PropertyIDMap getSummaryInformationProperties ( ) { if ( summaryInformationProperties == null ) { PropertyIDMap m = new PropertyIDMap ( 17 , ( float ) 1.0 ) ; m . put ( PID_TITLE , "PID_TITLE" ) ; m . put ( PID_SUBJECT , "PID_SUBJECT" ) ; m . put ( PID_AUTHOR , "PID_AUTHOR" ) ; m . put ( PID_KEYWORDS , "PID_KEYWORDS" ) ; m . put ( PID_COMMENTS , "PID_COMMENTS" ) ; m . put ( PID_TEMPLATE , "PID_TEMPLATE" ) ; m . put ( PID_LASTAUTHOR , "PID_LASTAUTHOR" ) ; m . put ( PID_REVNUMBER , "PID_REVNUMBER" ) ; m . put ( PID_EDITTIME , "PID_EDITTIME" ) ; m . put ( PID_LASTPRINTED , "PID_LASTPRINTED" ) ; m . put ( PID_CREATE_DTM , "PID_CREATE_DTM" ) ; m . put ( PID_LASTSAVE_DTM , "PID_LASTSAVE_DTM" ) ; m . put ( PID_PAGECOUNT , "PID_PAGECOUNT" ) ; m . put ( PID_WORDCOUNT , "PID_WORDCOUNT" ) ; m . put ( PID_CHARCOUNT , "PID_CHARCOUNT" ) ; m . put ( PID_THUMBNAIL , "PID_THUMBNAIL" ) ; m . put ( PID_APPNAME , "PID_APPNAME" ) ; m . put ( PID_SECURITY , "PID_SECURITY" ) ; summaryInformationProperties = m ; } return summaryInformationProperties ; } public static PropertyIDMap getDocumentSummaryInformationProperties ( ) { if ( documentSummaryInformationProperties == null ) { PropertyIDMap m = new PropertyIDMap ( 17 , ( float ) 1.0 ) ; m . put ( PID_CATEGORY , "PID_CATEGORY" ) ; m . put ( PID_PRESFORMAT , "PID_PRESFORMAT" ) ; m . put ( PID_BYTECOUNT , "PID_BYTECOUNT" ) ; m . put ( PID_LINECOUNT , "PID_LINECOUNT" ) ; m . put ( PID_PARCOUNT , "PID_PARCOUNT" ) ; m . put ( PID_SLIDECOUNT , "PID_SLIDECOUNT" ) ; m . put ( PID_NOTECOUNT , "PID_NOTECOUNT" ) ; m . put ( PID_HIDDENCOUNT , "PID_HIDDENCOUNT" ) ; m . put ( PID_MMCLIPCOUNT , "PID_MMCLIPCOUNT" ) ; m . put ( PID_SCALE , "PID_SCALE" ) ; m . put ( PID_HEADINGPAIR , "PID_HEADINGPAIR" ) ; m . put ( PID_DOCPARTS , "PID_DOCPARTS" ) ; m . put ( PID_MANAGER , "PID_MANAGER" ) ; m . put ( PID_COMPANY , "PID_COMPANY" ) ; m . put ( PID_LINKSDIRTY , "PID_LINKSDIRTY" ) ; documentSummaryInformationProperties = m ; } return documentSummaryInformationProperties ; } public static void main ( String args [ ] ) { PropertyIDMap s1 = getSummaryInformationProperties ( ) ; PropertyIDMap s2 = getDocumentSummaryInformationProperties ( ) ; System . out . println ( "s1: " + s1 ) ; System . out . println ( "s2: " + s2 ) ; } } 	1
package org . apache . poi . util ; import java . util . * ; public class IntList { private int [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public IntList ( ) { this ( _default_size ) ; } public IntList ( final IntList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public IntList ( final int initialCapacity ) { _array = new int [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final int value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final int value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final IntList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final IntList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final IntList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { IntList other = ( IntList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public int get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final int o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final int o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public int remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public int set ( final int index , final int element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public int [ ] toArray ( ) { int [ ] rval = new int [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public int [ ] toArray ( final int [ ] a ) { int [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; int [ ] new_array = new int [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class EOFRecord extends Record { public final static short sid = 0x0A ; public EOFRecord ( ) { } public EOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public EOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An EOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EOF]\n" ) ; buffer . append ( "[/EOF]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . util ; import org . apache . poi . hssf . record . MergeCellsRecord . MergedRegion ; public class Region implements Comparable { private int rowFrom ; private short colFrom ; private int rowTo ; private short colTo ; public Region ( ) { } public Region ( int rowFrom , short colFrom , int rowTo , short colTo ) { this . rowFrom = rowFrom ; this . rowTo = rowTo ; this . colFrom = colFrom ; this . colTo = colTo ; } public Region ( MergedRegion region ) { this ( region . row_from , region . col_from , region . row_to , region . col_to ) ; } public short getColumnFrom ( ) { return colFrom ; } public int getRowFrom ( ) { return rowFrom ; } public short getColumnTo ( ) { return colTo ; } public int getRowTo ( ) { return rowTo ; } public void setColumnFrom ( short colFrom ) { this . colFrom = colFrom ; } public void setRowFrom ( int rowFrom ) { this . rowFrom = rowFrom ; } public void setColumnTo ( short colTo ) { this . colTo = colTo ; } public void setRowTo ( int rowTo ) { this . rowTo = rowTo ; } public boolean contains ( int row , short col ) { if ( ( this . rowFrom <= row ) && ( this . rowTo >= row ) && ( this . colFrom <= col ) && ( this . colTo >= col ) ) { return true ; } return false ; } public boolean equals ( Region r ) { return ( compareTo ( r ) == 0 ) ; } public int compareTo ( Region r ) { if ( ( this . getRowFrom ( ) == r . getRowFrom ( ) ) && ( this . getColumnFrom ( ) == r . getColumnFrom ( ) ) && ( this . getRowTo ( ) == r . getRowTo ( ) ) && ( this . getColumnTo ( ) == r . getColumnTo ( ) ) ) { return 0 ; } if ( ( this . getRowFrom ( ) < r . getRowFrom ( ) ) || ( this . getColumnFrom ( ) < r . getColumnFrom ( ) ) || ( this . getRowTo ( ) < r . getRowTo ( ) ) || ( this . getColumnTo ( ) < r . getColumnTo ( ) ) ) { return 1 ; } return - 1 ; } public int compareTo ( Object o ) { return compareTo ( ( Region ) o ) ; } public int getArea ( ) { return ( ( 1 + ( getRowTo ( ) - getRowFrom ( ) ) ) * ( 1 + ( getColumnTo ( ) - getColumnFrom ( ) ) ) ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ValueVariableFunctionPtg extends Ptg implements OperationPtg { public final static short sid = 0x42 ; private final static short SIZE = 4 ; private byte field_1_byte_1 ; BitField numArgs = new BitField ( 0x7f ) ; BitField prompt = new BitField ( 0x80 ) ; private short field_2_bytes ; BitField functionIndex = new BitField ( 0x7FFF ) ; BitField command = new BitField ( 0x8000 ) ; public ValueVariableFunctionPtg ( ) { } public ValueVariableFunctionPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_byte_1 = data [ offset + 0 ] ; field_2_bytes = LittleEndian . getShort ( data , offset + 1 ) ; } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return SIZE ; } public short getNumArgs ( ) { return numArgs . getShortValue ( field_1_byte_1 ) ; } public int getNumberOfOperands ( ) { return getNumArgs ( ) ; } public int getType ( ) { return - 1 ; } public String toFormulaString ( ) { return "NO IDEA YET VALUE VARIABLE" ; } public String toFormulaString ( Ptg [ ] operands ) { return toFormulaString ( ) ; } } 	1
package org . apache . poi . hssf . record . formula ; public class FormulaUtil { public FormulaUtil ( ) { } public static Ptg [ ] parseFormula ( String formula ) { Ptg [ ] ptg = null ; StringBuffer f = new StringBuffer ( formula ) ; if ( isIntAddition ( formula ) ) { int loc = getLoc ( formula , '+' ) ; System . out . println ( formula . substring ( 0 , loc ) . trim ( ) + "," + formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ; ptg = formulaAddTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntSubtraction ( formula ) ) { int loc = getLoc ( formula , '-' ) ; ptg = formulaSubtractTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntMultiplication ( formula ) ) { int loc = getLoc ( formula , '*' ) ; ptg = formulaMultiplyTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntDivision ( formula ) ) { int loc = getLoc ( formula , '/' ) ; ptg = formulaDivideTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntPower ( formula ) ) { int loc = getLoc ( formula , '^' ) ; ptg = formulaPowerTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } return ptg ; } public static Ptg [ ] formulaAddTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createAdd ( ) ; return ptg ; } public static Ptg [ ] formulaSubtractTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createSubtract ( ) ; return ptg ; } public static Ptg [ ] formulaMultiplyTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createMultiply ( ) ; return ptg ; } public static Ptg [ ] formulaPowerTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( second ) ; ptg [ 1 ] = createInteger ( first ) ; ptg [ 2 ] = createPower ( ) ; return ptg ; } public static Ptg [ ] formulaDivideTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createDivide ( ) ; return ptg ; } public static Ptg createInteger ( short value ) { IntPtg ptg = new IntPtg ( ) ; ptg . setValue ( value ) ; return ptg ; } public static Ptg createAdd ( ) { AddPtg ptg = new AddPtg ( ) ; return ptg ; } public static Ptg createSubtract ( ) { SubtractPtg ptg = new SubtractPtg ( ) ; return ptg ; } public static Ptg createMultiply ( ) { MultiplyPtg ptg = new MultiplyPtg ( ) ; return ptg ; } public static Ptg createDivide ( ) { DividePtg ptg = new DividePtg ( ) ; return ptg ; } public static Ptg createPower ( ) { PowerPtg ptg = new PowerPtg ( ) ; return ptg ; } private static boolean isIntAddition ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "+" ) ) { return true ; } return false ; } private static boolean isIntSubtraction ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "-" ) ) { return true ; } return false ; } private static boolean isIntMultiplication ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "*" ) ) { return true ; } return false ; } private static boolean isIntDivision ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "/" ) ) { return true ; } return false ; } private static boolean isIntPower ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "^" ) ) { return true ; } return false ; } private static boolean instr ( String matchin , String matchon ) { int lenmatchin = matchin . length ( ) ; int lenmatchon = matchon . length ( ) ; int pos = 0 ; if ( lenmatchon > lenmatchin ) { return false ; } while ( pos + lenmatchon < lenmatchin ) { String sub = matchin . substring ( pos , pos + lenmatchon ) ; if ( sub . equals ( matchon ) ) { return true ; } pos ++ ; } return false ; } private static int getLoc ( String matchin , char matchon ) { int retval = - 1 ; for ( int pos = 0 ; pos < matchin . length ( ) ; pos ++ ) { if ( matchin . charAt ( pos ) == matchon ) { retval = pos ; break ; } } return retval ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class LegendRecord extends Record { public final static short sid = 0x1015 ; private int field_1_xPosition ; private int field_2_yPosition ; private int field_3_xSize ; private int field_4_ySize ; private byte field_5_type ; public final static byte TYPE_BOTTOM = 0 ; public final static byte TYPE_CORNER = 1 ; public final static byte TYPE_TOP = 2 ; public final static byte TYPE_RIGHT = 3 ; public final static byte TYPE_LEFT = 4 ; public final static byte TYPE_NOT_DOCKED = 7 ; private byte field_6_spacing ; public final static byte SPACING_CLOSE = 0 ; public final static byte SPACING_MEDIUM = 1 ; public final static byte SPACING_OPEN = 2 ; private short field_7_options ; private BitField autoPosition = new BitField ( 0x1 ) ; private BitField autoSeries = new BitField ( 0x2 ) ; private BitField autoPosX = new BitField ( 0x4 ) ; private BitField autoPosY = new BitField ( 0x8 ) ; private BitField vert = new BitField ( 0x10 ) ; private BitField containsDataTable = new BitField ( 0x20 ) ; public LegendRecord ( ) { } public LegendRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LegendRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Legend record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_xPosition = LittleEndian . getInt ( data , 0x0 + offset ) ; field_2_yPosition = LittleEndian . getInt ( data , 0x4 + offset ) ; field_3_xSize = LittleEndian . getInt ( data , 0x8 + offset ) ; field_4_ySize = LittleEndian . getInt ( data , 0xc + offset ) ; field_5_type = data [ 0x10 + offset ] ; field_6_spacing = data [ 0x11 + offset ] ; field_7_options = LittleEndian . getShort ( data , 0x12 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[Legend]\n" ) ; buffer . append ( "    .xPosition            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getXPosition ( ) ) ) . append ( " (" ) . append ( getXPosition ( ) ) . append ( " )\n" ) ; buffer . append ( "    .yPosition            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getYPosition ( ) ) ) . append ( " (" ) . append ( getYPosition ( ) ) . append ( " )\n" ) ; buffer . append ( "    .xSize                = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getXSize ( ) ) ) . append ( " (" ) . append ( getXSize ( ) ) . append ( " )\n" ) ; buffer . append ( "    .ySize                = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getYSize ( ) ) ) . append ( " (" ) . append ( getYSize ( ) ) . append ( " )\n" ) ; buffer . append ( "    .type                 = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( byte ) getType ( ) ) ) . append ( " (" ) . append ( getType ( ) ) . append ( " )\n" ) ; buffer . append ( "    .spacing              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( byte ) getSpacing ( ) ) ) . append ( " (" ) . append ( getSpacing ( ) ) . append ( " )\n" ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )\n" ) ; buffer . append ( "         .autoPosition             = " ) . append ( isAutoPosition ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoSeries               = " ) . append ( isAutoSeries ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoPosX                 = " ) . append ( isAutoPosX ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoPosY                 = " ) . append ( isAutoPosY ( ) ) . append ( '\n' ) ; buffer . append ( "         .vert                     = " ) . append ( isVert ( ) ) . append ( '\n' ) ; buffer . append ( "         .containsDataTable        = " ) . append ( isContainsDataTable ( ) ) . append ( '\n' ) ; buffer . append ( "[/Legend]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset , field_1_xPosition ) ; LittleEndian . putInt ( data , 8 + offset , field_2_yPosition ) ; LittleEndian . putInt ( data , 12 + offset , field_3_xSize ) ; LittleEndian . putInt ( data , 16 + offset , field_4_ySize ) ; data [ 20 + offset ] = field_5_type ; data [ 21 + offset ] = field_6_spacing ; LittleEndian . putShort ( data , 22 + offset , field_7_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 + 4 + 4 + 1 + 1 + 2 ; } public short getSid ( ) { return this . sid ; } public int getXPosition ( ) { return field_1_xPosition ; } public void setXPosition ( int field_1_xPosition ) { this . field_1_xPosition = field_1_xPosition ; } public int getYPosition ( ) { return field_2_yPosition ; } public void setYPosition ( int field_2_yPosition ) { this . field_2_yPosition = field_2_yPosition ; } public int getXSize ( ) { return field_3_xSize ; } public void setXSize ( int field_3_xSize ) { this . field_3_xSize = field_3_xSize ; } public int getYSize ( ) { return field_4_ySize ; } public void setYSize ( int field_4_ySize ) { this . field_4_ySize = field_4_ySize ; } public byte getType ( ) { return field_5_type ; } public void setType ( byte field_5_type ) { this . field_5_type = field_5_type ; } public byte getSpacing ( ) { return field_6_spacing ; } public void setSpacing ( byte field_6_spacing ) { this . field_6_spacing = field_6_spacing ; } public short getOptions ( ) { return field_7_options ; } public void setOptions ( short field_7_options ) { this . field_7_options = field_7_options ; } public void setAutoPosition ( boolean value ) { field_7_options = autoPosition . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoPosition ( ) { return autoPosition . isSet ( field_7_options ) ; } public void setAutoSeries ( boolean value ) { field_7_options = autoSeries . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoSeries ( ) { return autoSeries . isSet ( field_7_options ) ; } public void setAutoPosX ( boolean value ) { field_7_options = autoPosX . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoPosX ( ) { return autoPosX . isSet ( field_7_options ) ; } public void setAutoPosY ( boolean value ) { field_7_options = autoPosY . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoPosY ( ) { return autoPosY . isSet ( field_7_options ) ; } public void setVert ( boolean value ) { field_7_options = vert . setShortBoolean ( field_7_options , value ) ; } public boolean isVert ( ) { return vert . isSet ( field_7_options ) ; } public void setContainsDataTable ( boolean value ) { field_7_options = containsDataTable . setShortBoolean ( field_7_options , value ) ; } public boolean isContainsDataTable ( ) { return containsDataTable . isSet ( field_7_options ) ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ShortField implements FixedField { private short _value ; private final int _offset ; public ShortField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public ShortField ( final int offset , final short value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public ShortField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ShortField ( final int offset , final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public short get ( ) { return _value ; } public void set ( final short value ) { _value = value ; } public void set ( final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getShort ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readShort ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putShort ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class SeriesListRecord extends Record { public final static short sid = 0x1016 ; private short [ ] field_1_seriesNumbers ; public SeriesListRecord ( ) { } public SeriesListRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesListRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesList record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_seriesNumbers = LittleEndian . getShortArray ( data , 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SeriesList]\n" ) ; buffer . append ( "    .seriesNumbers        = " ) . append ( " (" ) . append ( getSeriesNumbers ( ) ) . append ( " )\n" ) ; buffer . append ( "[/SeriesList]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShortArray ( data , 4 + offset , field_1_seriesNumbers ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + field_1_seriesNumbers . length * 2 + 2 ; } public short getSid ( ) { return this . sid ; } public short [ ] getSeriesNumbers ( ) { return field_1_seriesNumbers ; } public void setSeriesNumbers ( short [ ] field_1_seriesNumbers ) { this . field_1_seriesNumbers = field_1_seriesNumbers ; } } 	1
package org . apache . poi . poifs . common ; public interface POIFSConstants { public static final int BIG_BLOCK_SIZE = 0x0200 ; public static final int END_OF_CHAIN = - 2 ; public static final int PROPERTY_SIZE = 0x0080 ; public static final int UNUSED_BLOCK = - 1 ; } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; public abstract class Ptg { public Ptg ( ) { } public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; System . out . println ( "PTG = " + Integer . toHexString ( id ) + " (" + id + ")" ) ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ValueReferencePtg . sid : retval = new ValueReferencePtg ( data , offset ) ; break ; case ValueVariableFunctionPtg . sid : retval = new ValueVariableFunctionPtg ( data , offset ) ; break ; case NamePtg . sid : retval = new NamePtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; default : throw new RuntimeException ( "Unknown PTG = " + Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( ) ; public int getPrecedence ( ) { return 100 ; } public int getStringLength ( ) { return 0 ; } } 	1
package org . apache . poi . poifs . property ; public interface Child { public Child getNextChild ( ) ; public Child getPreviousChild ( ) ; public void setNextChild ( final Child child ) ; public void setPreviousChild ( final Child child ) ; } 	0
package org . apache . poi . hssf . record . formula ; public class AddPtg extends Ptg implements OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x03 ; private final static String ADD = "+" ; public AddPtg ( ) { } public AddPtg ( byte [ ] data , int offset ) { } protected AddPtg ( String formula , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( ) { return "+" ; } public static boolean isNextStringToken ( String formula , int pos ) { boolean retval = false ; while ( pos < formula . length ( ) && Character . isWhitespace ( formula . charAt ( pos ) ) ) { pos ++ ; } if ( pos < formula . length ( ) ) { if ( formula . charAt ( pos ) == ADD . toCharArray ( ) [ 0 ] ) { retval = true ; } } return retval ; } public String toFormulaString ( Ptg [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] . toFormulaString ( ) ) ; buffer . append ( "+" ) ; buffer . append ( operands [ 1 ] . toFormulaString ( ) ) ; return buffer . toString ( ) ; } public int getPrecedence ( ) { return 5 ; } public int getStringLength ( ) { return 1 ; } } 	1
package org . apache . poi . hssf . record ; public class RecordFormatException extends RuntimeException { public RecordFormatException ( String exception ) { super ( exception ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class AxisUsedRecord extends Record { public final static short sid = 0x1046 ; private short field_1_numAxis ; public AxisUsedRecord ( ) { } public AxisUsedRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AxisUsedRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a AxisUsed record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numAxis = LittleEndian . getShort ( data , 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AxisUsed]\n" ) ; buffer . append ( "    .numAxis              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getNumAxis ( ) ) ) . append ( " (" ) . append ( getNumAxis ( ) ) . append ( " )\n" ) ; buffer . append ( "[/AxisUsed]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numAxis ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public short getNumAxis ( ) { return field_1_numAxis ; } public void setNumAxis ( short field_1_numAxis ) { this . field_1_numAxis = field_1_numAxis ; } } 	1
package org . apache . poi . poifs . property ; import java . util . * ; import java . io . IOException ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class RootProperty extends DirectoryProperty { RootProperty ( ) { super ( "Root Entry" ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . ROOT_TYPE ) ; setStartBlock ( POIFSConstants . END_OF_CHAIN ) ; } protected RootProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; } public void setSize ( int size ) { super . setSize ( SmallDocumentBlock . calcSize ( size ) ) ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { if ( true ) throw new UnsupportedOperationException ( "FIXME" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . util . * ; public class SmallDocumentBlockList extends BlockListImpl { public SmallDocumentBlockList ( final List blocks ) { setBlocks ( ( SmallDocumentBlock [ ] ) blocks . toArray ( new SmallDocumentBlock [ 0 ] ) ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class ChartRecord extends Record { public final static short sid = 0x1002 ; private int field_1_x ; private int field_2_y ; private int field_3_width ; private int field_4_height ; public ChartRecord ( ) { } public ChartRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ChartRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Chart record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_x = LittleEndian . getInt ( data , 0x0 + offset ) ; field_2_y = LittleEndian . getInt ( data , 0x4 + offset ) ; field_3_width = LittleEndian . getInt ( data , 0x8 + offset ) ; field_4_height = LittleEndian . getInt ( data , 0xc + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[Chart]\n" ) ; buffer . append ( "    .x                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getX ( ) ) ) . append ( " (" ) . append ( getX ( ) ) . append ( " )\n" ) ; buffer . append ( "    .y                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getY ( ) ) ) . append ( " (" ) . append ( getY ( ) ) . append ( " )\n" ) ; buffer . append ( "    .width                = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getWidth ( ) ) ) . append ( " (" ) . append ( getWidth ( ) ) . append ( " )\n" ) ; buffer . append ( "    .height               = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getHeight ( ) ) ) . append ( " (" ) . append ( getHeight ( ) ) . append ( " )\n" ) ; buffer . append ( "[/Chart]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset , field_1_x ) ; LittleEndian . putInt ( data , 8 + offset , field_2_y ) ; LittleEndian . putInt ( data , 12 + offset , field_3_width ) ; LittleEndian . putInt ( data , 16 + offset , field_4_height ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 + 4 + 4 ; } public short getSid ( ) { return this . sid ; } public int getX ( ) { return field_1_x ; } public void setX ( int field_1_x ) { this . field_1_x = field_1_x ; } public int getY ( ) { return field_2_y ; } public void setY ( int field_2_y ) { this . field_2_y = field_2_y ; } public int getWidth ( ) { return field_3_width ; } public void setWidth ( int field_3_width ) { this . field_3_width = field_3_width ; } public int getHeight ( ) { return field_4_height ; } public void setHeight ( int field_4_height ) { this . field_4_height = field_4_height ; } } 	1
package org . apache . poi . hpsf . littleendian ; public abstract class LittleEndian { protected byte [ ] bytes ; public LittleEndian ( final byte [ ] src , final int offset ) { read ( src , offset ) ; } public byte [ ] getBytes ( ) { return bytes ; } public byte [ ] read ( final byte [ ] src , final int offset ) { final int length = length ( ) ; bytes = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) bytes [ i ] = src [ offset + length - 1 - i ] ; return bytes ; } public abstract int length ( ) ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BoolErrRecord extends Record implements CellValueRecordInterface , Comparable { public final static short sid = 0x205 ; private short field_1_row ; private short field_2_column ; private short field_3_xf_index ; private byte field_4_bBoolErr ; private byte field_5_fError ; public BoolErrRecord ( ) { } public BoolErrRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BoolErrRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_column = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_bBoolErr = data [ 6 + offset ] ; field_5_fError = data [ 7 + offset ] ; } public void setRow ( short row ) { field_1_row = row ; } public void setColumn ( short col ) { field_2_column = col ; } public void setXFIndex ( short xf ) { field_3_xf_index = xf ; } public void setValue ( boolean value ) { field_4_bBoolErr = value ? ( byte ) 1 : ( byte ) 0 ; field_5_fError = ( byte ) 0 ; } public void setValue ( byte value ) { field_4_bBoolErr = value ; field_5_fError = ( byte ) 1 ; } public short getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_column ; } public short getXFIndex ( ) { return field_3_xf_index ; } public boolean getBooleanValue ( ) { return ( field_4_bBoolErr != 0 ) ; } public byte getErrorValue ( ) { return field_4_bBoolErr ; } public boolean isBoolean ( ) { return ( field_5_fError == ( byte ) 0 ) ; } public boolean isError ( ) { return ( field_5_fError != ( byte ) 0 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOOLERR]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .col            = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; if ( isBoolean ( ) ) { buffer . append ( "    .booleanValue   = " ) . append ( getBooleanValue ( ) ) . append ( "\n" ) ; } else { buffer . append ( "    .errorValue     = " ) . append ( getErrorValue ( ) ) . append ( "\n" ) ; } buffer . append ( "[/BOOLERR]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 8 ) ; LittleEndian . putShort ( data , 4 + offset , getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; data [ 10 + offset ] = field_4_bBoolErr ; data [ 11 + offset ] = field_5_fError ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 12 ; } protected void validateSid ( short id ) { if ( id != this . sid ) { throw new RecordFormatException ( "Not a valid BoolErrRecord" ) ; } } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; public class DocumentInputStream extends InputStream { private int _current_offset ; private int _marked_offset ; private int _document_size ; private boolean _closed ; private POIFSDocument _document ; private byte [ ] _tiny_buffer ; static private final int EOD = - 1 ; public DocumentInputStream ( final DocumentEntry document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; if ( document instanceof DocumentNode ) { _document = ( ( DocumentNode ) document ) . getDocument ( ) ; } else { throw new IOException ( "Cannot open internal document storage" ) ; } } public DocumentInputStream ( final POIFSDocument document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; _document = document ; } public int available ( ) throws IOException { dieIfClosed ( ) ; return _document_size - _current_offset ; } public void close ( ) throws IOException { _closed = true ; } public void mark ( int ignoredReadlimit ) { _marked_offset = _current_offset ; } public boolean markSupported ( ) { return true ; } public int read ( ) throws IOException { dieIfClosed ( ) ; if ( atEOD ( ) ) { return EOD ; } if ( _tiny_buffer == null ) { _tiny_buffer = new byte [ 1 ] ; } _document . read ( _tiny_buffer , _current_offset ++ ) ; return ( ( int ) _tiny_buffer [ 0 ] ) & 0x000000FF ; } public int read ( final byte [ ] b ) throws IOException , NullPointerException { return read ( b , 0 , b . length ) ; } public int read ( final byte [ ] b , final int off , final int len ) throws IOException , NullPointerException , IndexOutOfBoundsException { dieIfClosed ( ) ; if ( b == null ) { throw new NullPointerException ( "buffer is null" ) ; } if ( ( off < 0 ) || ( len < 0 ) || ( b . length < ( off + len ) ) ) { throw new IndexOutOfBoundsException ( "can't read past buffer boundaries" ) ; } if ( len == 0 ) { return 0 ; } if ( atEOD ( ) ) { return EOD ; } int limit = Math . min ( available ( ) , len ) ; if ( ( off == 0 ) && ( limit == b . length ) ) { _document . read ( b , _current_offset ) ; } else { byte [ ] buffer = new byte [ limit ] ; _document . read ( buffer , _current_offset ) ; System . arraycopy ( buffer , 0 , b , off , limit ) ; } _current_offset += limit ; return limit ; } public void reset ( ) { _current_offset = _marked_offset ; } public long skip ( final long n ) throws IOException { dieIfClosed ( ) ; if ( n < 0 ) { return 0 ; } int new_offset = _current_offset + ( int ) n ; if ( new_offset < _current_offset ) { new_offset = _document_size ; } else if ( new_offset > _document_size ) { new_offset = _document_size ; } long rval = new_offset - _current_offset ; _current_offset = new_offset ; return rval ; } private void dieIfClosed ( ) throws IOException { if ( _closed ) { throw new IOException ( "cannot perform requested operation on a closed stream" ) ; } } private boolean atEOD ( ) { return _current_offset == _document_size ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class FrameRecord extends Record { public final static short sid = 0x1032 ; private short field_1_borderType ; public final static short BORDER_TYPE_REGULAR = 0 ; public final static short BORDER_TYPE_SHADOW = 1 ; private short field_2_options ; private BitField autoSize = new BitField ( 0x1 ) ; private BitField autoPosition = new BitField ( 0x2 ) ; public FrameRecord ( ) { } public FrameRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FrameRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Frame record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_borderType = LittleEndian . getShort ( data , 0x0 + offset ) ; field_2_options = LittleEndian . getShort ( data , 0x2 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[Frame]\n" ) ; buffer . append ( "    .borderType           = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getBorderType ( ) ) ) . append ( " (" ) . append ( getBorderType ( ) ) . append ( " )\n" ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )\n" ) ; buffer . append ( "         .autoSize                 = " ) . append ( isAutoSize ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoPosition             = " ) . append ( isAutoPosition ( ) ) . append ( '\n' ) ; buffer . append ( "[/Frame]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_borderType ) ; LittleEndian . putShort ( data , 6 + offset , field_2_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public short getBorderType ( ) { return field_1_borderType ; } public void setBorderType ( short field_1_borderType ) { this . field_1_borderType = field_1_borderType ; } public short getOptions ( ) { return field_2_options ; } public void setOptions ( short field_2_options ) { this . field_2_options = field_2_options ; } public void setAutoSize ( boolean value ) { field_2_options = autoSize . setShortBoolean ( field_2_options , value ) ; } public boolean isAutoSize ( ) { return autoSize . isSet ( field_2_options ) ; } public void setAutoPosition ( boolean value ) { field_2_options = autoPosition . setShortBoolean ( field_2_options , value ) ; } public boolean isAutoPosition ( ) { return autoPosition . isSet ( field_2_options ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BackupRecord extends Record { public final static short sid = 0x40 ; private short field_1_backup ; public BackupRecord ( ) { } public BackupRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BackupRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BACKUP RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_backup = LittleEndian . getShort ( data , 0 + offset ) ; } public void setBackup ( short backup ) { field_1_backup = backup ; } public short getBackup ( ) { return field_1_backup ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BACKUP]\n" ) ; buffer . append ( "    .backup          = " ) . append ( Integer . toHexString ( getBackup ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BACKUP]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getBackup ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class GridsetRecord extends Record { public final static short sid = 0x82 ; public short field_1_gridset_flag ; public GridsetRecord ( ) { } public GridsetRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public GridsetRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Gridset RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_gridset_flag = LittleEndian . getShort ( data , 0 + offset ) ; } public void setGridset ( boolean gridset ) { if ( gridset == true ) { field_1_gridset_flag = 1 ; } else { field_1_gridset_flag = 0 ; } } public boolean getGridset ( ) { return ( field_1_gridset_flag == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[GRIDSET]\n" ) ; buffer . append ( "    .gridset        = " ) . append ( getGridset ( ) ) . append ( "\n" ) ; buffer . append ( "[/GRIDSET]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_gridset_flag ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BeginRecord extends Record { public static final short sid = 0x1033 ; public BeginRecord ( ) { } public BeginRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BeginRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BEGIN RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BEGIN]\n" ) ; buffer . append ( "[/BEGIN]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class LabelSSTRecord extends Record implements CellValueRecordInterface , Comparable { public final static short sid = 0xfd ; private short field_1_row ; private short field_2_column ; private short field_3_xf_index ; private int field_4_sst_index ; public LabelSSTRecord ( ) { } public LabelSSTRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LabelSSTRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid LabelSST RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_column = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_sst_index = LittleEndian . getInt ( data , 6 + offset ) ; } public void setRow ( short row ) { field_1_row = row ; } public void setColumn ( short col ) { field_2_column = col ; } public void setXFIndex ( short index ) { field_3_xf_index = index ; } public void setSSTIndex ( int index ) { field_4_sst_index = index ; } public short getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_column ; } public short getXFIndex ( ) { return field_3_xf_index ; } public int getSSTIndex ( ) { return field_4_sst_index ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[LABELSST]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .column         = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .sstindex       = " ) . append ( Integer . toHexString ( getSSTIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/LABELSST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 10 ) ; LittleEndian . putShort ( data , 4 + offset , getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; LittleEndian . putInt ( data , 10 + offset , getSSTIndex ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 14 ; } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } } 	1
package org . apache . poi . poifs . property ; import java . util . Iterator ; import java . io . IOException ; public interface Parent extends Child { public Iterator getChildren ( ) ; public void addChild ( final Property property ) throws IOException ; public void setPreviousChild ( final Child child ) ; public void setNextChild ( final Child child ) ; } 	0
package org . apache . poi . hssf . record . formula ; public class PowerPtg extends Ptg implements OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x07 ; public PowerPtg ( ) { } public PowerPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( ) { return "^" ; } public String toFormulaString ( Ptg [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 1 ] . toFormulaString ( ) ) ; buffer . append ( "^" ) ; buffer . append ( operands [ 0 ] . toFormulaString ( ) ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . poifs . eventfilesystem ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; public class POIFSReaderEvent { private DocumentInputStream stream ; private POIFSDocumentPath path ; private String documentName ; POIFSReaderEvent ( final DocumentInputStream stream , final POIFSDocumentPath path , final String documentName ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; } public DocumentInputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class AreaFormatRecord extends Record { public final static short sid = 0x100a ; private int field_1_foregroundColor ; private int field_2_backgroundColor ; private short field_3_pattern ; private short field_4_formatFlags ; private BitField automatic = new BitField ( 0x1 ) ; private BitField invert = new BitField ( 0x2 ) ; private short field_5_forecolorIndex ; private short field_6_backcolorIndex ; public AreaFormatRecord ( ) { } public AreaFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AreaFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a AreaFormat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_foregroundColor = LittleEndian . getInt ( data , 0x0 + offset ) ; field_2_backgroundColor = LittleEndian . getInt ( data , 0x4 + offset ) ; field_3_pattern = LittleEndian . getShort ( data , 0x8 + offset ) ; field_4_formatFlags = LittleEndian . getShort ( data , 0xa + offset ) ; field_5_forecolorIndex = LittleEndian . getShort ( data , 0xc + offset ) ; field_6_backcolorIndex = LittleEndian . getShort ( data , 0xe + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AreaFormat]\n" ) ; buffer . append ( "    .foregroundColor      = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getForegroundColor ( ) ) ) . append ( " (" ) . append ( getForegroundColor ( ) ) . append ( " )\n" ) ; buffer . append ( "    .backgroundColor      = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getBackgroundColor ( ) ) ) . append ( " (" ) . append ( getBackgroundColor ( ) ) . append ( " )\n" ) ; buffer . append ( "    .pattern              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getPattern ( ) ) ) . append ( " (" ) . append ( getPattern ( ) ) . append ( " )\n" ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )\n" ) ; buffer . append ( "         .automatic                = " ) . append ( isAutomatic ( ) ) . append ( '\n' ) ; buffer . append ( "         .invert                   = " ) . append ( isInvert ( ) ) . append ( '\n' ) ; buffer . append ( "    .forecolorIndex       = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getForecolorIndex ( ) ) ) . append ( " (" ) . append ( getForecolorIndex ( ) ) . append ( " )\n" ) ; buffer . append ( "    .backcolorIndex       = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getBackcolorIndex ( ) ) ) . append ( " (" ) . append ( getBackcolorIndex ( ) ) . append ( " )\n" ) ; buffer . append ( "[/AreaFormat]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset , field_1_foregroundColor ) ; LittleEndian . putInt ( data , 8 + offset , field_2_backgroundColor ) ; LittleEndian . putShort ( data , 12 + offset , field_3_pattern ) ; LittleEndian . putShort ( data , 14 + offset , field_4_formatFlags ) ; LittleEndian . putShort ( data , 16 + offset , field_5_forecolorIndex ) ; LittleEndian . putShort ( data , 18 + offset , field_6_backcolorIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public int getForegroundColor ( ) { return field_1_foregroundColor ; } public void setForegroundColor ( int field_1_foregroundColor ) { this . field_1_foregroundColor = field_1_foregroundColor ; } public int getBackgroundColor ( ) { return field_2_backgroundColor ; } public void setBackgroundColor ( int field_2_backgroundColor ) { this . field_2_backgroundColor = field_2_backgroundColor ; } public short getPattern ( ) { return field_3_pattern ; } public void setPattern ( short field_3_pattern ) { this . field_3_pattern = field_3_pattern ; } public short getFormatFlags ( ) { return field_4_formatFlags ; } public void setFormatFlags ( short field_4_formatFlags ) { this . field_4_formatFlags = field_4_formatFlags ; } public short getForecolorIndex ( ) { return field_5_forecolorIndex ; } public void setForecolorIndex ( short field_5_forecolorIndex ) { this . field_5_forecolorIndex = field_5_forecolorIndex ; } public short getBackcolorIndex ( ) { return field_6_backcolorIndex ; } public void setBackcolorIndex ( short field_6_backcolorIndex ) { this . field_6_backcolorIndex = field_6_backcolorIndex ; } public void setAutomatic ( boolean value ) { field_4_formatFlags = automatic . setShortBoolean ( field_4_formatFlags , value ) ; } public boolean isAutomatic ( ) { return automatic . isSet ( field_4_formatFlags ) ; } public void setInvert ( boolean value ) { field_4_formatFlags = invert . setShortBoolean ( field_4_formatFlags , value ) ; } public boolean isInvert ( ) { return invert . isSet ( field_4_formatFlags ) ; } } 	1
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . PropertyBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . RawDataBlockList ; public class PropertyTable implements BATManaged , BlockWritable { private int _start_block ; private List _properties ; private BlockWritable [ ] _blocks ; public PropertyTable ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _properties = new ArrayList ( ) ; addProperty ( new RootProperty ( ) ) ; _blocks = null ; } public PropertyTable ( final int startBlock , final RawDataBlockList blockList ) throws IOException { _start_block = POIFSConstants . END_OF_CHAIN ; _blocks = null ; _properties = PropertyFactory . convertToProperties ( blockList . fetchBlocks ( startBlock ) ) ; populatePropertyTree ( ( DirectoryProperty ) _properties . get ( 0 ) ) ; } public void addProperty ( final Property property ) { _properties . add ( property ) ; } public void removeProperty ( final Property property ) { _properties . remove ( property ) ; } public RootProperty getRoot ( ) { return ( RootProperty ) _properties . get ( 0 ) ; } public void preWrite ( ) { Property [ ] properties = ( Property [ ] ) _properties . toArray ( new Property [ 0 ] ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . setIndex ( k ) ; } _blocks = PropertyBlock . createPropertyBlockArray ( _properties ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . preWrite ( ) ; } } public int getStartBlock ( ) { return _start_block ; } private void populatePropertyTree ( DirectoryProperty root ) throws IOException { int index = root . getChildIndex ( ) ; if ( ! Property . isValidIndex ( index ) ) { return ; } Stack children = new Stack ( ) ; children . push ( _properties . get ( index ) ) ; while ( ! children . empty ( ) ) { Property property = ( Property ) children . pop ( ) ; root . addChild ( property ) ; if ( property . isDirectory ( ) ) { populatePropertyTree ( ( DirectoryProperty ) property ) ; } index = property . getPreviousChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } index = property . getNextChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } } } public int countBlocks ( ) { return ( _blocks == null ) ? 0 : _blocks . length ; } public void setStartBlock ( final int index ) { _start_block = index ; } public void writeBlocks ( final OutputStream stream ) throws IOException { if ( _blocks != null ) { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; import java . util . * ; public class SSTRecord extends Record { private static final int _max = 8228 ; private static final int _std_record_overhead = 2 * LittleEndianConsts . SHORT_SIZE ; private static final int _sst_record_overhead = ( _std_record_overhead + ( 2 * LittleEndianConsts . INT_SIZE ) ) ; private static final int _max_data_space = _max - _sst_record_overhead ; private static final int _string_minimal_overhead = LittleEndianConsts . SHORT_SIZE + LittleEndianConsts . BYTE_SIZE ; public static final short sid = 0xfc ; private int field_1_num_strings ; private int field_2_num_unique_strings ; private BinaryTree field_3_strings ; private int __expected_chars ; private String _unfinished_string ; private int _total_length_bytes ; private int _string_data_offset ; private boolean _wide_char ; private List _record_lengths = null ; public SSTRecord ( ) { field_1_num_strings = 0 ; field_2_num_unique_strings = 0 ; field_3_strings = new BinaryTree ( ) ; setExpectedChars ( 0 ) ; _unfinished_string = "" ; _total_length_bytes = 0 ; _string_data_offset = 0 ; _wide_char = false ; } public SSTRecord ( final short id , final short size , final byte [ ] data ) { super ( id , size , data ) ; } public SSTRecord ( final short id , final short size , final byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public int addString ( final String string ) { int rval ; if ( string == null ) { rval = addString ( "" , false ) ; } else { boolean useUTF16 = false ; int strlen = string . length ( ) ; for ( int j = 0 ; j < strlen ; j ++ ) { if ( string . charAt ( j ) > 255 ) { useUTF16 = true ; break ; } } rval = addString ( string , useUTF16 ) ; } return rval ; } public int addString ( final String string , final boolean useUTF16 ) { field_1_num_strings ++ ; String str = ( string == null ) ? "" : string ; int rval = - 1 ; UnicodeString ucs = new UnicodeString ( ) ; ucs . setString ( str ) ; ucs . setCharCount ( ( short ) str . length ( ) ) ; ucs . setOptionFlags ( ( byte ) ( useUTF16 ? 1 : 0 ) ) ; Integer integer = ( Integer ) field_3_strings . getKeyForValue ( ucs ) ; if ( integer != null ) { rval = integer . intValue ( ) ; } else { rval = field_3_strings . size ( ) ; field_2_num_unique_strings ++ ; integer = new Integer ( rval ) ; field_3_strings . put ( integer , ucs ) ; } return rval ; } public int getNumStrings ( ) { return field_1_num_strings ; } public int getNumUniqueStrings ( ) { return field_2_num_unique_strings ; } public void setNumStrings ( final int count ) { field_1_num_strings = count ; } public void getNumUniqueStrings ( final int count ) { field_2_num_unique_strings = count ; } public String getString ( final int id ) { return ( ( UnicodeString ) field_3_strings . get ( new Integer ( id ) ) ) . getString ( ) ; } public boolean getString16bit ( final int id ) { return ( ( ( UnicodeString ) field_3_strings . get ( new Integer ( id ) ) ) . getOptionFlags ( ) == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SST]\n" ) ; buffer . append ( "    .numstrings     = " ) . append ( Integer . toHexString ( getNumStrings ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .uniquestrings  = " ) . append ( Integer . toHexString ( getNumUniqueStrings ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < field_3_strings . size ( ) ; k ++ ) { buffer . append ( "    .string_" + k + "      = " ) . append ( ( ( UnicodeString ) field_3_strings . get ( new Integer ( k ) ) ) . toString ( ) ) . append ( "\n" ) ; } buffer . append ( "[/SST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int rval = getRecordSize ( ) ; int record_length_index = 0 ; int unicodesize = calculateUnicodeSize ( ) ; if ( unicodesize > _max_data_space ) { byte [ ] stringreminant = null ; int unipos = 0 ; boolean lastneedcontinue = false ; int stringbyteswritten = 0 ; boolean first_record = true ; int totalWritten = 0 ; int size = 0 ; while ( totalWritten != rval ) { int pos = 0 ; int available ; if ( first_record ) { size = ( ( Integer ) _record_lengths . get ( record_length_index ++ ) ) . intValue ( ) ; available = size - 8 ; pos = writeSSTHeader ( data , pos + offset + totalWritten , size ) ; size += _std_record_overhead ; first_record = false ; } else { pos = 0 ; int to_be_written = ( unicodesize - stringbyteswritten ) + ( lastneedcontinue ? 1 : 0 ) ; size = ( ( Integer ) _record_lengths . get ( record_length_index ++ ) ) . intValue ( ) ; available = size ; pos = writeContinueHeader ( data , pos + offset + totalWritten , size ) ; size = size + _std_record_overhead ; } if ( lastneedcontinue ) { if ( stringreminant . length <= available ) { System . arraycopy ( stringreminant , 0 , data , pos + offset + totalWritten , stringreminant . length ) ; stringbyteswritten += stringreminant . length - 1 ; pos += stringreminant . length ; lastneedcontinue = false ; available -= stringreminant . length ; } else { System . arraycopy ( stringreminant , 0 , data , pos + offset + totalWritten , available ) ; stringbyteswritten += available - 1 ; pos += available ; byte [ ] leftover = new byte [ ( stringreminant . length - available ) + LittleEndianConsts . BYTE_SIZE ] ; System . arraycopy ( stringreminant , available , leftover , LittleEndianConsts . BYTE_SIZE , stringreminant . length - available ) ; leftover [ 0 ] = stringreminant [ 0 ] ; stringreminant = leftover ; available = 0 ; lastneedcontinue = true ; } } for ( ; unipos < field_3_strings . size ( ) ; unipos ++ ) { Integer intunipos = new Integer ( unipos ) ; UnicodeString unistr = ( ( UnicodeString ) field_3_strings . get ( intunipos ) ) ; if ( unistr . getRecordSize ( ) <= available ) { unistr . serialize ( pos + offset + totalWritten , data ) ; int rsize = unistr . getRecordSize ( ) ; stringbyteswritten += rsize ; pos += rsize ; available -= rsize ; } else { if ( available >= _string_minimal_overhead ) { byte [ ] ucs = unistr . serialize ( ) ; System . arraycopy ( ucs , 0 , data , pos + offset + totalWritten , available ) ; stringbyteswritten += available ; stringreminant = new byte [ ( ucs . length - available ) + LittleEndianConsts . BYTE_SIZE ] ; System . arraycopy ( ucs , available , stringreminant , LittleEndianConsts . BYTE_SIZE , ucs . length - available ) ; stringreminant [ 0 ] = ucs [ LittleEndianConsts . SHORT_SIZE ] ; available = 0 ; lastneedcontinue = true ; unipos ++ ; } break ; } } totalWritten += size ; } } else { int datasize = _sst_record_overhead + unicodesize ; writeSSTHeader ( data , 0 + offset , _sst_record_overhead + ( ( Integer ) _record_lengths . get ( record_length_index ++ ) ) . intValue ( ) - _std_record_overhead ) ; int pos = _sst_record_overhead ; for ( int k = 0 ; k < field_3_strings . size ( ) ; k ++ ) { UnicodeString unistr = ( ( UnicodeString ) field_3_strings . get ( new Integer ( k ) ) ) ; System . arraycopy ( unistr . serialize ( ) , 0 , data , pos + offset , unistr . getRecordSize ( ) ) ; pos += unistr . getRecordSize ( ) ; } } return rval ; } private int calculateStringsize ( ) { int retval = 0 ; for ( int k = 0 ; k < field_3_strings . size ( ) ; k ++ ) { retval += ( ( UnicodeString ) field_3_strings . get ( new Integer ( k ) ) ) . getRecordSize ( ) ; } return retval ; } public void processContinueRecord ( final byte [ ] record ) { if ( getExpectedChars ( ) == 0 ) { _unfinished_string = "" ; _total_length_bytes = 0 ; _string_data_offset = 0 ; _wide_char = false ; manufactureStrings ( record , 0 , ( short ) record . length ) ; } else { int data_length = record . length - LittleEndianConsts . BYTE_SIZE ; if ( calculateByteCount ( getExpectedChars ( ) ) > data_length ) { byte [ ] input = new byte [ record . length + LittleEndianConsts . SHORT_SIZE ] ; short size = ( short ) ( ( ( record [ 0 ] & 1 ) == 1 ) ? ( data_length / LittleEndianConsts . SHORT_SIZE ) : ( data_length / LittleEndianConsts . BYTE_SIZE ) ) ; LittleEndian . putShort ( input , ( byte ) 0 , size ) ; System . arraycopy ( record , 0 , input , LittleEndianConsts . SHORT_SIZE , record . length ) ; UnicodeString ucs = new UnicodeString ( UnicodeString . sid , ( short ) input . length , input ) ; _unfinished_string = _unfinished_string + ucs . getString ( ) ; setExpectedChars ( getExpectedChars ( ) - size ) ; } else { setupStringParameters ( record , - LittleEndianConsts . SHORT_SIZE , getExpectedChars ( ) ) ; byte [ ] str_data = new byte [ _total_length_bytes ] ; int length = _string_minimal_overhead + ( calculateByteCount ( getExpectedChars ( ) ) ) ; byte [ ] bstring = new byte [ length ] ; System . arraycopy ( record , 0 , str_data , LittleEndianConsts . SHORT_SIZE , str_data . length - LittleEndianConsts . SHORT_SIZE ) ; LittleEndian . putShort ( bstring , 0 , ( short ) getExpectedChars ( ) ) ; bstring [ LittleEndianConsts . SHORT_SIZE ] = str_data [ LittleEndianConsts . SHORT_SIZE ] ; System . arraycopy ( str_data , _string_data_offset , bstring , _string_minimal_overhead , bstring . length - _string_minimal_overhead ) ; UnicodeString string = new UnicodeString ( UnicodeString . sid , ( short ) bstring . length , bstring , _unfinished_string ) ; Integer integer = new Integer ( field_3_strings . size ( ) ) ; field_3_strings . put ( integer , string ) ; manufactureStrings ( record , _total_length_bytes - LittleEndianConsts . SHORT_SIZE , ( short ) record . length ) ; } } } public short getSid ( ) { return sid ; } public int hashCode ( ) { return field_2_num_unique_strings ; } public boolean equals ( Object o ) { if ( ( o == null ) || ( o . getClass ( ) != this . getClass ( ) ) ) { return false ; } SSTRecord other = ( SSTRecord ) o ; return ( ( field_1_num_strings == other . field_1_num_strings ) && ( field_2_num_unique_strings == other . field_2_num_unique_strings ) && field_3_strings . equals ( other . field_3_strings ) ) ; } protected void validateSid ( final short id ) throws RecordFormatException { if ( id != sid ) { throw new RecordFormatException ( "NOT An SST RECORD" ) ; } } protected void fillFields ( final byte [ ] data , final short size , int offset ) { field_1_num_strings = LittleEndian . getInt ( data , 0 + offset ) ; field_2_num_unique_strings = LittleEndian . getInt ( data , 4 + offset ) ; field_3_strings = new BinaryTree ( ) ; setExpectedChars ( 0 ) ; _unfinished_string = "" ; _total_length_bytes = 0 ; _string_data_offset = 0 ; _wide_char = false ; manufactureStrings ( data , 8 + offset , size ) ; } int getExpectedChars ( ) { return __expected_chars ; } Iterator getStrings ( ) { return field_3_strings . values ( ) . iterator ( ) ; } int countStrings ( ) { return field_3_strings . size ( ) ; } String getUnfinishedString ( ) { return _unfinished_string ; } int getTotalLength ( ) { return _total_length_bytes ; } int getStringDataOffset ( ) { return _string_data_offset ; } boolean isWideChar ( ) { return _wide_char ; } private int writeSSTHeader ( final byte [ ] data , final int pos , final int recsize ) { int offset = pos ; LittleEndian . putShort ( data , offset , sid ) ; offset += LittleEndianConsts . SHORT_SIZE ; LittleEndian . putShort ( data , offset , ( short ) ( recsize ) ) ; offset += LittleEndianConsts . SHORT_SIZE ; LittleEndian . putInt ( data , offset , getNumStrings ( ) ) ; offset += LittleEndianConsts . INT_SIZE ; LittleEndian . putInt ( data , offset , getNumUniqueStrings ( ) ) ; offset += LittleEndianConsts . INT_SIZE ; return offset - pos ; } private int writeContinueHeader ( final byte [ ] data , final int pos , final int recsize ) { int offset = pos ; LittleEndian . putShort ( data , offset , ContinueRecord . sid ) ; offset += LittleEndianConsts . SHORT_SIZE ; LittleEndian . putShort ( data , offset , ( short ) ( recsize ) ) ; offset += LittleEndianConsts . SHORT_SIZE ; return offset - pos ; } private int calculateUCArrayLength ( final byte [ ] [ ] ucarray ) { int retval = 0 ; for ( int k = 0 ; k < ucarray . length ; k ++ ) { retval += ucarray [ k ] . length ; } return retval ; } private void manufactureStrings ( final byte [ ] data , final int index , short size ) { int offset = index ; while ( offset < size ) { int remaining = size - offset ; if ( ( remaining > 0 ) && ( remaining < LittleEndianConsts . SHORT_SIZE ) ) { throw new RecordFormatException ( "Cannot get length of the last string in SSTRecord" ) ; } if ( remaining == LittleEndianConsts . SHORT_SIZE ) { setExpectedChars ( LittleEndian . getShort ( data , offset ) ) ; _unfinished_string = "" ; break ; } short char_count = LittleEndian . getShort ( data , offset ) ; setupStringParameters ( data , offset , char_count ) ; if ( remaining < _total_length_bytes ) { setExpectedChars ( calculateCharCount ( _total_length_bytes - remaining ) ) ; char_count -= getExpectedChars ( ) ; _total_length_bytes = remaining ; } else { setExpectedChars ( 0 ) ; } processString ( data , offset , char_count ) ; offset += _total_length_bytes ; if ( getExpectedChars ( ) != 0 ) { break ; } } } private void setupStringParameters ( final byte [ ] data , final int index , final int char_count ) { byte flag = data [ index + LittleEndianConsts . SHORT_SIZE ] ; _wide_char = ( flag & 1 ) == 1 ; boolean extended = ( flag & 4 ) == 4 ; boolean formatted_run = ( flag & 8 ) == 8 ; _total_length_bytes = _string_minimal_overhead + calculateByteCount ( char_count ) ; _string_data_offset = _string_minimal_overhead ; if ( formatted_run ) { short run_count = LittleEndian . getShort ( data , index + _string_data_offset ) ; _string_data_offset += LittleEndianConsts . SHORT_SIZE ; _total_length_bytes += LittleEndianConsts . SHORT_SIZE + ( LittleEndianConsts . INT_SIZE * run_count ) ; } if ( extended ) { int extension_length = LittleEndian . getInt ( data , index + _string_data_offset ) ; _string_data_offset += LittleEndianConsts . INT_SIZE ; _total_length_bytes += LittleEndianConsts . INT_SIZE + extension_length ; } } private void processString ( final byte [ ] data , final int index , final short char_count ) { byte [ ] str_data = new byte [ _total_length_bytes ] ; int length = _string_minimal_overhead + calculateByteCount ( char_count ) ; byte [ ] bstring = new byte [ length ] ; System . arraycopy ( data , index , str_data , 0 , str_data . length ) ; int offset = 0 ; LittleEndian . putShort ( bstring , offset , char_count ) ; offset += LittleEndianConsts . SHORT_SIZE ; bstring [ offset ] = str_data [ offset ] ; System . arraycopy ( str_data , _string_data_offset , bstring , _string_minimal_overhead , bstring . length - _string_minimal_overhead ) ; UnicodeString string = new UnicodeString ( UnicodeString . sid , ( short ) bstring . length , bstring ) ; if ( getExpectedChars ( ) != 0 ) { _unfinished_string = string . getString ( ) ; } else { Integer integer = new Integer ( field_3_strings . size ( ) ) ; field_3_strings . put ( integer , string ) ; } } private void setExpectedChars ( final int count ) { __expected_chars = count ; } private int calculateByteCount ( final int character_count ) { return character_count * ( _wide_char ? LittleEndianConsts . SHORT_SIZE : LittleEndianConsts . BYTE_SIZE ) ; } private int calculateCharCount ( final int byte_count ) { return byte_count / ( _wide_char ? LittleEndianConsts . SHORT_SIZE : LittleEndianConsts . BYTE_SIZE ) ; } public int getRecordSize ( ) { _record_lengths = new ArrayList ( ) ; int retval = 0 ; int unicodesize = calculateUnicodeSize ( ) ; if ( unicodesize > _max_data_space ) { UnicodeString unistr = null ; int stringreminant = 0 ; int unipos = 0 ; boolean lastneedcontinue = false ; int stringbyteswritten = 0 ; boolean finished = false ; boolean first_record = true ; int totalWritten = 0 ; while ( ! finished ) { int record = 0 ; int pos = 0 ; if ( first_record ) { record = _max ; pos = 12 ; first_record = false ; _record_lengths . add ( new Integer ( record - _std_record_overhead ) ) ; } else { pos = 0 ; int to_be_written = ( unicodesize - stringbyteswritten ) + ( lastneedcontinue ? 1 : 0 ) ; int size = Math . min ( _max - _std_record_overhead , to_be_written ) ; if ( size == to_be_written ) { finished = true ; } record = size + _std_record_overhead ; _record_lengths . add ( new Integer ( size ) ) ; pos = 4 ; } if ( lastneedcontinue ) { int available = _max - pos ; if ( stringreminant <= available ) { stringbyteswritten += stringreminant - 1 ; pos += stringreminant ; lastneedcontinue = false ; } else { int toBeWritten = unistr . maxBrokenLength ( available ) ; if ( available != toBeWritten ) { int shortrecord = record - ( available - toBeWritten ) ; _record_lengths . set ( _record_lengths . size ( ) - 1 , new Integer ( shortrecord - _std_record_overhead ) ) ; record = shortrecord ; } stringbyteswritten += toBeWritten - 1 ; pos += toBeWritten ; stringreminant -= toBeWritten - 1 ; lastneedcontinue = true ; } } for ( ; unipos < field_3_strings . size ( ) ; unipos ++ ) { int available = _max - pos ; Integer intunipos = new Integer ( unipos ) ; unistr = ( ( UnicodeString ) field_3_strings . get ( intunipos ) ) ; if ( unistr . getRecordSize ( ) <= available ) { stringbyteswritten += unistr . getRecordSize ( ) ; pos += unistr . getRecordSize ( ) ; } else { if ( available >= _string_minimal_overhead ) { int toBeWritten = unistr . maxBrokenLength ( available ) ; stringbyteswritten += toBeWritten ; stringreminant = ( unistr . getRecordSize ( ) - toBeWritten ) + LittleEndianConsts . BYTE_SIZE ; if ( available != toBeWritten ) { int shortrecord = record - ( available - toBeWritten ) ; _record_lengths . set ( _record_lengths . size ( ) - 1 , new Integer ( shortrecord - _std_record_overhead ) ) ; record = shortrecord ; } lastneedcontinue = true ; unipos ++ ; } else { int shortrecord = record - available ; _record_lengths . set ( _record_lengths . size ( ) - 1 , new Integer ( shortrecord - _std_record_overhead ) ) ; record = shortrecord ; } break ; } } totalWritten += record ; } retval = totalWritten ; } else { retval = _sst_record_overhead + unicodesize ; _record_lengths . add ( new Integer ( unicodesize ) ) ; } return retval ; } private int calculateUnicodeSize ( ) { int retval = 0 ; for ( int k = 0 ; k < field_3_strings . size ( ) ; k ++ ) { UnicodeString string = ( UnicodeString ) field_3_strings . get ( new Integer ( k ) ) ; retval += string . getRecordSize ( ) ; } return retval ; } } 	1
package org . apache . poi . hssf . usermodel ; public interface HSSFColorConstants { public final static short AUTOMATIC = 0x40 ; public final static short BLACK = 0x8 ; public final static short BROWN = 0x3c ; public final static short OLIVE_GREEN = 0x3b ; public final static short DARK_GREEN = 0x3a ; public final static short DARK_TEAL = 0x38 ; public final static short DARK_BLUE = 0x12 ; public final static short INDIGO = 0x3e ; public final static short GREY_80_PERCENT = 0x3f ; public final static short DARK_RED = 0x10 ; public final static short ORANGE = 0x35 ; public final static short DARK_YELLOW = 0x13 ; public final static short GREEN = 0x11 ; public final static short TEAL = 0x15 ; public final static short BLUE = 0xc ; public final static short BLUE_GREY = 0x36 ; public final static short GREY_50_PERCENT = 0x17 ; public final static short RED = 0xa ; public final static short LIGHT_ORANGE = 0x34 ; public final static short LIME = 0x32 ; public final static short SEA_GREEN = 0x39 ; public final static short AQUA = 0x31 ; public final static short LIGHT_BLUE = 0x30 ; public final static short VIOLET = 0x14 ; public final static short GREY_40_PERCENT = 0x37 ; public final static short PINK = 0xe ; public final static short GOLD = 0x33 ; public final static short YELLOW = 0xd ; public final static short BRIGHT_GREEN = 0xb ; public final static short TURQUOISE = 0xf ; public final static short SKY_BLUE = 0x28 ; public final static short PLUM = 0x3d ; public final static short GREY_25_PERCENT = 0x16 ; public final static short ROSE = 0x2d ; public final static short TAN = 0x2f ; public final static short LIGHT_YELLOW = 0x2b ; public final static short LIGHT_GREEN = 0x2a ; public final static short LIGHT_TURQUOISE = 0x29 ; public final static short PALE_BLUE = 0x2c ; public final static short LAVENDER = 0x2e ; public final static short WHITE = 0x9 ; } 	0
package org . apache . poi . hssf . model ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . util . POILogger ; import org . apache . poi . util . POILogFactory ; public class Workbook { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected ArrayList records = null ; protected SSTRecord sst = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected int bspos = 0 ; protected int tabpos = 0 ; protected int fontpos = 0 ; protected int numfonts = 0 ; protected int xfpos = 0 ; protected int numxfs = 0 ; private int backuppos = 0 ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . bspos = k ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . fontpos = k ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . xfpos = k ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . tabpos = k ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . backuppos = k ; break ; default : } records . add ( rec ) ; } retval . records = records ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . tabpos = records . size ( ) - 1 ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . backuppos = records . size ( ) - 1 ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . fontpos = records . size ( ) - 1 ; retval . numfonts = 4 ; records . add ( retval . createFormat ( 0 ) ) ; records . add ( retval . createFormat ( 1 ) ) ; records . add ( retval . createFormat ( 2 ) ) ; records . add ( retval . createFormat ( 3 ) ) ; records . add ( retval . createFormat ( 4 ) ) ; records . add ( retval . createFormat ( 5 ) ) ; records . add ( retval . createFormat ( 6 ) ) ; records . add ( retval . createFormat ( 7 ) ) ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . xfpos = records . size ( ) - 1 ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . bspos = records . size ( ) - 1 ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( fontpos - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; ++ fontpos ; ++ bspos ; ++ xfpos ; records . add ( fontpos , rec ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( backuppos ) ; } public void setSheetName ( int sheetnum , String sheetname ) { checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setSheetname ( sheetname ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( ++ bspos , bsr ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( bspos - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; bspos -- ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( tabpos ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( boundsheets . size ( ) ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = xfpos - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; ++ xfpos ; ++ bspos ; records . add ( xfpos , xf ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public byte [ ] serialize ( ) { log . log ( DEBUG , "Serializing Workbook!" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( DEBUG , "Exiting serialize workbook" ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos + offset , data ) ; } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; retval . setCurrentCountry ( ( short ) 1 ) ; return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BookBoolRecord extends Record { public final static short sid = 0xDA ; private short field_1_save_link_values ; public BookBoolRecord ( ) { } public BookBoolRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BookBoolRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOOKBOOL RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_save_link_values = LittleEndian . getShort ( data , 0 + offset ) ; } public void setSaveLinkValues ( short flag ) { field_1_save_link_values = flag ; } public short getSaveLinkValues ( ) { return field_1_save_link_values ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOOKBOOL]\n" ) ; buffer . append ( "    .savelinkvalues  = " ) . append ( Integer . toHexString ( getSaveLinkValues ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOOKBOOL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_save_link_values ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; public class Util { public static boolean equal ( final byte [ ] a , final byte [ ] b ) { if ( a . length != b . length ) return false ; for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] != b [ i ] ) return false ; return true ; } public static void copy ( final byte [ ] src , final int srcOffset , final int length , final byte [ ] dst , final int dstOffset ) { for ( int i = 0 ; i < length ; i ++ ) dst [ dstOffset + i ] = src [ srcOffset + i ] ; } public static byte [ ] cat ( final byte [ ] [ ] byteArrays ) { int capacity = 0 ; for ( int i = 0 ; i < byteArrays . length ; i ++ ) capacity += byteArrays [ i ] . length ; final byte [ ] result = new byte [ capacity ] ; int r = 0 ; for ( int i = 0 ; i < byteArrays . length ; i ++ ) for ( int j = 0 ; j < byteArrays [ i ] . length ; j ++ ) result [ r ++ ] = byteArrays [ i ] [ j ] ; return result ; } public static byte [ ] copy ( final byte [ ] src , final int offset , final int length ) { final byte [ ] result = new byte [ length ] ; copy ( src , offset , length , result , 0 ) ; return result ; } public final static long EPOCH_DIFF = 11644473600000L ; public static Date filetimeToDate ( final int high , final int low ) { final long filetime = ( ( long ) high ) << 32 | ( ( long ) low ) ; final long ms_since_16010101 = filetime / ( 1000 * 10 ) ; final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF ; return new Date ( ms_since_19700101 ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface ListManagedBlock { public byte [ ] getData ( ) throws IOException ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; public class IndexRecord extends Record { public final static short sid = 0x20B ; public final static int DBCELL_CAPACITY = 30 ; public int field_1_zero ; public int field_2_first_row ; public int field_3_last_row_add1 ; public int field_4_zero ; public IntList field_5_dbcells ; public IndexRecord ( ) { } public IndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public IndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Index RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_5_dbcells = new IntList ( DBCELL_CAPACITY ) ; field_1_zero = LittleEndian . getInt ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getInt ( data , 4 + offset ) ; field_3_last_row_add1 = LittleEndian . getInt ( data , 8 + offset ) ; field_4_zero = LittleEndian . getInt ( data , 12 + offset ) ; for ( int k = 16 ; k < size ; k = k + 4 ) { field_5_dbcells . add ( LittleEndian . getInt ( data , k + offset ) ) ; } } public void setFirstRow ( int row ) { field_2_first_row = row ; } public void setLastRowAdd1 ( int row ) { field_3_last_row_add1 = row ; } public void addDbcell ( int cell ) { if ( field_5_dbcells == null ) { field_5_dbcells = new IntList ( ) ; } field_5_dbcells . add ( cell ) ; } public void setDbcell ( int cell , int value ) { field_5_dbcells . set ( cell , value ) ; } public int getFirstRow ( ) { return field_2_first_row ; } public int getLastRowAdd1 ( ) { return field_3_last_row_add1 ; } public int getNumDbcells ( ) { if ( field_5_dbcells == null ) { return 0 ; } return field_5_dbcells . size ( ) ; } public int getDbcellAt ( int cellnum ) { return field_5_dbcells . get ( cellnum ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INDEX]\n" ) ; buffer . append ( "    .firstrow       = " ) . append ( Integer . toHexString ( getFirstRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .lastrowadd1    = " ) . append ( Integer . toHexString ( getLastRowAdd1 ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumDbcells ( ) ; k ++ ) { buffer . append ( "    .dbcell_" + k + "       = " ) . append ( Integer . toHexString ( getDbcellAt ( k ) ) ) . append ( "\n" ) ; } buffer . append ( "[/INDEX]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 16 + ( getNumDbcells ( ) * 4 ) ) ) ; LittleEndian . putInt ( data , 4 + offset , 0 ) ; LittleEndian . putInt ( data , 8 + offset , getFirstRow ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getLastRowAdd1 ( ) ) ; LittleEndian . putInt ( data , 16 + offset , 0 ) ; for ( int k = 0 ; k < getNumDbcells ( ) ; k ++ ) { LittleEndian . putInt ( data , ( k * 4 ) + 20 + offset , getDbcellAt ( k ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 + ( getNumDbcells ( ) * 4 ) ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private short rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , short rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { this . rowNum = rowNum ; cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( short rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public short getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	0
package org . apache . poi . dev ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import java . io . File ; public class RecordGenerator { public static void main ( String [ ] args ) throws Exception { Class . forName ( "org.apache.poi.generator.FieldIterator" ) ; if ( args . length != 4 ) { System . out . println ( "Usage:" ) ; System . out . println ( "  java org.apache.poi.hssf.util.RecordGenerator RECORD_DEFINTIONS RECORD_STYLES DEST_SRC_PATH TEST_SRC_PATH" ) ; } else { generateRecords ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; } } private static void generateRecords ( String defintionsDir , String recordStyleDir , String destSrcPathDir , String testSrcPathDir ) throws Exception { File definitionsFile = new File ( defintionsDir ) ; for ( int i = 0 ; i < definitionsFile . listFiles ( ) . length ; i ++ ) { File file = definitionsFile . listFiles ( ) [ i ] ; if ( file . isFile ( ) && ( file . getName ( ) . endsWith ( "_record.xml" ) || file . getName ( ) . endsWith ( "_type.xml" ) ) ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( file ) ; Element record = document . getDocumentElement ( ) ; String extendstg = record . getElementsByTagName ( "extends" ) . item ( 0 ) . getFirstChild ( ) . getNodeValue ( ) ; String suffix = record . getElementsByTagName ( "suffix" ) . item ( 0 ) . getFirstChild ( ) . getNodeValue ( ) ; String recordName = record . getAttributes ( ) . getNamedItem ( "name" ) . getNodeValue ( ) ; String packageName = record . getAttributes ( ) . getNamedItem ( "package" ) . getNodeValue ( ) ; packageName = packageName . replace ( '.' , '/' ) ; String destinationPath = destSrcPathDir + "/" + packageName ; File destinationPathFile = new File ( destinationPath ) ; destinationPathFile . mkdirs ( ) ; String destinationFilepath = destinationPath + "/" + recordName + suffix + ".java" ; String args [ ] = new String [ ] { "-in" , file . getAbsolutePath ( ) , "-xsl" , recordStyleDir + "/" + extendstg . toLowerCase ( ) + ".xsl" , "-out" , destinationFilepath , "-TEXT" } ; org . apache . xalan . xslt . Process . main ( args ) ; System . out . println ( "Generated " + suffix + ": " + destinationFilepath ) ; destinationPath = testSrcPathDir + "/" + packageName ; destinationPathFile = new File ( destinationPath ) ; destinationPathFile . mkdirs ( ) ; destinationFilepath = destinationPath + "/Test" + recordName + suffix + ".java" ; if ( new File ( destinationFilepath ) . exists ( ) == false ) { String temp = ( recordStyleDir + "/" + extendstg . toLowerCase ( ) + "_test.xsl" ) ; args = new String [ ] { "-in" , file . getAbsolutePath ( ) , "-xsl" , temp , "-out" , destinationFilepath , "-TEXT" } ; org . apache . xalan . xslt . Process . main ( args ) ; System . out . println ( "Generated test: " + destinationFilepath ) ; } else { System . out . println ( "Skipped test generation: " + destinationFilepath ) ; } } } } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . ListManagedBlock ; import org . apache . poi . poifs . storage . DocumentBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; import org . apache . poi . util . HexDump ; public class POIFSDocument implements BATManaged , BlockWritable , POIFSViewable { private DocumentProperty _property ; private int _size ; private SmallBlockStore _small_store ; private BigBlockStore _big_store ; public POIFSDocument ( final String name , final RawDataBlock [ ] blocks , final int length ) throws IOException { _size = length ; _big_store = new BigBlockStore ( blocks ) ; _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final SmallDocumentBlock [ ] blocks , final int length ) { _size = length ; try { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; } catch ( IOException ignored ) { } _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( blocks ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final ListManagedBlock [ ] blocks , final int length ) throws IOException { _size = length ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( Property . isSmall ( _size ) ) { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; _small_store = new SmallBlockStore ( blocks ) ; } else { _big_store = new BigBlockStore ( blocks ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; _size = 0 ; while ( true ) { DocumentBlock block = new DocumentBlock ( stream ) ; int blockSize = block . size ( ) ; if ( blockSize > 0 ) { blocks . add ( block ) ; _size += blockSize ; } if ( block . partiallyRead ( ) ) { break ; } } DocumentBlock [ ] bigBlocks = ( DocumentBlock [ ] ) blocks . toArray ( new DocumentBlock [ 0 ] ) ; _big_store = new BigBlockStore ( bigBlocks ) ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( SmallDocumentBlock . convert ( bigBlocks , _size ) ) ; _big_store = new BigBlockStore ( new DocumentBlock [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final int size , final POIFSDocumentPath path , final POIFSWriterListener writer ) throws IOException { _size = size ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( path , name , size , writer ) ; _big_store = new BigBlockStore ( new Object [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _big_store = new BigBlockStore ( path , name , size , writer ) ; } } public BlockWritable [ ] getSmallBlocks ( ) { return _small_store . getBlocks ( ) ; } public int getSize ( ) { return _size ; } void read ( final byte [ ] buffer , final int offset ) { if ( _property . shouldUseSmallBlocks ( ) ) { SmallDocumentBlock . read ( _small_store . getBlocks ( ) , buffer , offset ) ; } else { DocumentBlock . read ( _big_store . getBlocks ( ) , buffer , offset ) ; } } DocumentProperty getDocumentProperty ( ) { return _property ; } public void writeBlocks ( final OutputStream stream ) throws IOException { _big_store . writeBlocks ( stream ) ; } public int countBlocks ( ) { return _big_store . countBlocks ( ) ; } public void setStartBlock ( final int index ) { _property . setStartBlock ( index ) ; } public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ 1 ] ; String result ; try { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; BlockWritable [ ] blocks = null ; if ( _big_store . isValid ( ) ) { blocks = _big_store . getBlocks ( ) ; } else if ( _small_store . isValid ( ) ) { blocks = _small_store . getBlocks ( ) ; } if ( blocks != null ) { for ( int k = 0 ; k < blocks . length ; k ++ ) { blocks [ k ] . writeBlocks ( output ) ; } byte [ ] data = output . toByteArray ( ) ; if ( data . length > _property . getSize ( ) ) { byte [ ] tmp = new byte [ _property . getSize ( ) ] ; System . arraycopy ( data , 0 , tmp , 0 , tmp . length ) ; data = tmp ; } output = new ByteArrayOutputStream ( ) ; HexDump . dump ( data , 0 , output , 0 ) ; result = output . toString ( ) ; } else { result = "<NO DATA>" ; } } catch ( IOException e ) { result = e . getMessage ( ) ; } results [ 0 ] = result ; return results ; } public Iterator getViewableIterator ( ) { return Collections . EMPTY_LIST . iterator ( ) ; } public boolean preferArray ( ) { return true ; } public String getShortDescription ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Document: \"" ) . append ( _property . getName ( ) ) . append ( "\"" ) ; buffer . append ( " size = " ) . append ( getSize ( ) ) ; return buffer . toString ( ) ; } private class SmallBlockStore { private SmallDocumentBlock [ ] smallBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; SmallBlockStore ( final Object [ ] blocks ) { smallBlocks = new SmallDocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { smallBlocks [ j ] = ( SmallDocumentBlock ) blocks [ j ] ; } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } SmallBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { smallBlocks = new SmallDocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( smallBlocks . length > 0 ) || ( writer != null ) ) ; } BlockWritable [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; smallBlocks = SmallDocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return smallBlocks ; } } private class BigBlockStore { private DocumentBlock [ ] bigBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; BigBlockStore ( final Object [ ] blocks ) throws IOException { bigBlocks = new DocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { if ( blocks [ j ] instanceof DocumentBlock ) { bigBlocks [ j ] = ( DocumentBlock ) blocks [ j ] ; } else { bigBlocks [ j ] = new DocumentBlock ( ( RawDataBlock ) blocks [ j ] ) ; } } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } BigBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { bigBlocks = new DocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( bigBlocks . length > 0 ) || ( writer != null ) ) ; } DocumentBlock [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; bigBlocks = DocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return bigBlocks ; } void writeBlocks ( OutputStream stream ) throws IOException { if ( isValid ( ) ) { if ( writer != null ) { DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; dstream . writeFiller ( countBlocks ( ) * POIFSConstants . BIG_BLOCK_SIZE , DocumentBlock . getFillByte ( ) ) ; } else { for ( int k = 0 ; k < bigBlocks . length ; k ++ ) { bigBlocks [ k ] . writeBlocks ( stream ) ; } } } } int countBlocks ( ) { int rval = 0 ; if ( isValid ( ) ) { if ( writer != null ) { rval = ( size + POIFSConstants . BIG_BLOCK_SIZE - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ; } else { rval = bigBlocks . length ; } } return rval ; } } } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class InterfaceEndRecord extends Record { public final static short sid = 0xe2 ; public InterfaceEndRecord ( ) { } public InterfaceEndRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public InterfaceEndRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A INTERFACEEND RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INTERFACEEND]\n" ) ; buffer . append ( "[/INTERFACEEND]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x00 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; public interface CellValueRecordInterface { public short getRow ( ) ; public short getColumn ( ) ; public void setRow ( short row ) ; public void setColumn ( short col ) ; public void setXFIndex ( short xf ) ; public short getXFIndex ( ) ; public boolean isBefore ( CellValueRecordInterface i ) ; public boolean isAfter ( CellValueRecordInterface i ) ; public boolean isEqual ( CellValueRecordInterface i ) ; } 	1
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import java . util . * ; public class POILogger { private Log log = null ; public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( final Log log ) { this . log = log ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final Log log , final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( log , level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BlankRecord extends Record implements CellValueRecordInterface , Comparable { public final static short sid = 0x201 ; private short field_1_row ; private short field_2_col ; private short field_3_xf ; public BlankRecord ( ) { } public BlankRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BlankRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf = LittleEndian . getShort ( data , 4 + offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BLANKRECORD!" ) ; } } public void setRow ( short row ) { field_1_row = row ; } public short getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_col ; } public void setXFIndex ( short xf ) { field_3_xf = xf ; } public short getXFIndex ( ) { return field_3_xf ; } public void setColumn ( short col ) { field_2_col = col ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public short getSid ( ) { return BlankRecord . sid ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BLANK]\n" ) ; buffer . append ( "row       = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "col       = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "xf        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BLANK]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 6 ) ; LittleEndian . putShort ( data , 4 + offset , getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 10 ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } } 	1
package org . apache . poi . poifs . filesystem ; public interface Entry { public String getName ( ) ; public boolean isDirectoryEntry ( ) ; public boolean isDocumentEntry ( ) ; public DirectoryEntry getParent ( ) ; public boolean delete ( ) ; public boolean renameTo ( final String newName ) ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DeltaRecord extends Record { public final static short sid = 0x10 ; public final static double DEFAULT_VALUE = 0.0010 ; private double field_1_max_change ; public DeltaRecord ( ) { } public DeltaRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DeltaRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A DELTA RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_max_change = LittleEndian . getDouble ( data , 0 + offset ) ; } public void setMaxChange ( double maxChange ) { field_1_max_change = maxChange ; } public double getMaxChange ( ) { return field_1_max_change ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DELTA]\n" ) ; buffer . append ( "    .maxchange      = " ) . append ( getMaxChange ( ) ) . append ( "\n" ) ; buffer . append ( "[/DELTA]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x8 ) ; LittleEndian . putDouble ( data , 4 + offset , getMaxChange ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 12 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . filesystem ; public interface BATManaged { public int countBlocks ( ) ; public void setStartBlock ( final int index ) ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class LinkedDataRecord extends Record { public final static short sid = 0x1051 ; private byte field_1_linkType ; public final static byte LINK_TYPE_TITLE_OR_TEXT = 0 ; public final static byte LINK_TYPE_VALUES = 1 ; public final static byte LINK_TYPE_CATEGORIES = 1 ; private byte field_2_referenceType ; public final static byte REFERENCE_TYPE_DEFAULT_CATEGORIES = 0 ; public final static byte REFERENCE_TYPE_DIRECT = 1 ; public final static byte REFERENCE_TYPE_WORKSHEET = 2 ; public final static byte REFERENCE_TYPE_NOT_USED = 3 ; public final static byte REFERENCE_TYPE_ERROR_REPORTED = 4 ; private short field_3_options ; private BitField customNumberFormat = new BitField ( 0x1 ) ; private short field_4_indexNumberFmtRecord ; private short field_5_formulaOfLink ; public LinkedDataRecord ( ) { } public LinkedDataRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LinkedDataRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a LinkedData record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_linkType = data [ 0x0 + offset ] ; field_2_referenceType = data [ 0x1 + offset ] ; field_3_options = LittleEndian . getShort ( data , 0x2 + offset ) ; field_4_indexNumberFmtRecord = LittleEndian . getShort ( data , 0x4 + offset ) ; field_5_formulaOfLink = LittleEndian . getShort ( data , 0x6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[LinkedData]\n" ) ; buffer . append ( "    .linkType             = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( byte ) getLinkType ( ) ) ) . append ( " (" ) . append ( getLinkType ( ) ) . append ( " )\n" ) ; buffer . append ( "    .referenceType        = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( byte ) getReferenceType ( ) ) ) . append ( " (" ) . append ( getReferenceType ( ) ) . append ( " )\n" ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )\n" ) ; buffer . append ( "         .customNumberFormat       = " ) . append ( isCustomNumberFormat ( ) ) . append ( '\n' ) ; buffer . append ( "    .indexNumberFmtRecord = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getIndexNumberFmtRecord ( ) ) ) . append ( " (" ) . append ( getIndexNumberFmtRecord ( ) ) . append ( " )\n" ) ; buffer . append ( "    .formulaOfLink        = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFormulaOfLink ( ) ) ) . append ( " (" ) . append ( getFormulaOfLink ( ) ) . append ( " )\n" ) ; buffer . append ( "[/LinkedData]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; data [ 4 + offset ] = field_1_linkType ; data [ 5 + offset ] = field_2_referenceType ; LittleEndian . putShort ( data , 6 + offset , field_3_options ) ; LittleEndian . putShort ( data , 8 + offset , field_4_indexNumberFmtRecord ) ; LittleEndian . putShort ( data , 10 + offset , field_5_formulaOfLink ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 1 + 1 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public byte getLinkType ( ) { return field_1_linkType ; } public void setLinkType ( byte field_1_linkType ) { this . field_1_linkType = field_1_linkType ; } public byte getReferenceType ( ) { return field_2_referenceType ; } public void setReferenceType ( byte field_2_referenceType ) { this . field_2_referenceType = field_2_referenceType ; } public short getOptions ( ) { return field_3_options ; } public void setOptions ( short field_3_options ) { this . field_3_options = field_3_options ; } public short getIndexNumberFmtRecord ( ) { return field_4_indexNumberFmtRecord ; } public void setIndexNumberFmtRecord ( short field_4_indexNumberFmtRecord ) { this . field_4_indexNumberFmtRecord = field_4_indexNumberFmtRecord ; } public short getFormulaOfLink ( ) { return field_5_formulaOfLink ; } public void setFormulaOfLink ( short field_5_formulaOfLink ) { this . field_5_formulaOfLink = field_5_formulaOfLink ; } public void setCustomNumberFormat ( boolean value ) { field_3_options = customNumberFormat . setShortBoolean ( field_3_options , value ) ; } public boolean isCustomNumberFormat ( ) { return customNumberFormat . isSet ( field_3_options ) ; } } 	1
package org . apache . poi . hpsf . littleendian ; import java . io . * ; public class ClassID extends LittleEndian { public ClassID ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 16 ; public int length ( ) { return LENGTH ; } public byte [ ] read ( byte [ ] src , int offset ) { LittleEndian [ ] b = new LittleEndian [ 11 ] ; b [ 0 ] = new DWord ( src , offset ) ; b [ 1 ] = new Word ( src , offset += DWord . LENGTH ) ; b [ 2 ] = new Word ( src , offset += Word . LENGTH ) ; b [ 3 ] = new Byte ( src , offset += Word . LENGTH ) ; b [ 4 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 5 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 6 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 7 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 8 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 9 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 10 ] = new Byte ( src , offset += Byte . LENGTH ) ; int capacity = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) capacity += b [ i ] . getBytes ( ) . length ; bytes = new byte [ capacity ] ; int pos = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) { byte [ ] s = b [ i ] . getBytes ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) bytes [ pos ++ ] = s [ j ] ; } return bytes ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class AxisRecord extends Record { public final static short sid = 0x101d ; private short field_1_axisType ; public final static short AXIS_TYPE_CATEGORY_OR_X_AXIS = 0 ; public final static short AXIS_TYPE_VALUE_AXIS = 1 ; public final static short AXIS_TYPE_SERIES_AXIS = 2 ; private int field_2_reserved1 ; private int field_3_reserved2 ; private int field_4_reserved3 ; private int field_5_reserved4 ; public AxisRecord ( ) { } public AxisRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AxisRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Axis record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_axisType = LittleEndian . getShort ( data , 0x0 + offset ) ; field_2_reserved1 = LittleEndian . getInt ( data , 0x2 + offset ) ; field_3_reserved2 = LittleEndian . getInt ( data , 0x6 + offset ) ; field_4_reserved3 = LittleEndian . getInt ( data , 0xa + offset ) ; field_5_reserved4 = LittleEndian . getInt ( data , 0xe + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[Axis]\n" ) ; buffer . append ( "    .axisType             = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getAxisType ( ) ) ) . append ( " (" ) . append ( getAxisType ( ) ) . append ( " )\n" ) ; buffer . append ( "    .reserved1            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getReserved1 ( ) ) ) . append ( " (" ) . append ( getReserved1 ( ) ) . append ( " )\n" ) ; buffer . append ( "    .reserved2            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getReserved2 ( ) ) ) . append ( " (" ) . append ( getReserved2 ( ) ) . append ( " )\n" ) ; buffer . append ( "    .reserved3            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getReserved3 ( ) ) ) . append ( " (" ) . append ( getReserved3 ( ) ) . append ( " )\n" ) ; buffer . append ( "    .reserved4            = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getReserved4 ( ) ) ) . append ( " (" ) . append ( getReserved4 ( ) ) . append ( " )\n" ) ; buffer . append ( "[/Axis]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_axisType ) ; LittleEndian . putInt ( data , 6 + offset , field_2_reserved1 ) ; LittleEndian . putInt ( data , 10 + offset , field_3_reserved2 ) ; LittleEndian . putInt ( data , 14 + offset , field_4_reserved3 ) ; LittleEndian . putInt ( data , 18 + offset , field_5_reserved4 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 4 + 4 + 4 + 4 ; } public short getSid ( ) { return this . sid ; } public short getAxisType ( ) { return field_1_axisType ; } public void setAxisType ( short field_1_axisType ) { this . field_1_axisType = field_1_axisType ; } public int getReserved1 ( ) { return field_2_reserved1 ; } public void setReserved1 ( int field_2_reserved1 ) { this . field_2_reserved1 = field_2_reserved1 ; } public int getReserved2 ( ) { return field_3_reserved2 ; } public void setReserved2 ( int field_3_reserved2 ) { this . field_3_reserved2 = field_3_reserved2 ; } public int getReserved3 ( ) { return field_4_reserved3 ; } public void setReserved3 ( int field_4_reserved3 ) { this . field_4_reserved3 = field_4_reserved3 ; } public int getReserved4 ( ) { return field_5_reserved4 ; } public void setReserved4 ( int field_5_reserved4 ) { this . field_5_reserved4 = field_5_reserved4 ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class MMSRecord extends Record { public final static short sid = 0xC1 ; private byte field_1_addMenuCount ; private byte field_2_delMenuCount ; public MMSRecord ( ) { } public MMSRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MMSRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A MMS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_addMenuCount = data [ 0 + offset ] ; field_2_delMenuCount = data [ 1 + offset ] ; } public void setAddMenuCount ( byte am ) { field_1_addMenuCount = am ; } public void setDelMenuCount ( byte dm ) { field_2_delMenuCount = dm ; } public byte getAddMenuCount ( ) { return field_1_addMenuCount ; } public byte getDelMenuCount ( ) { return field_2_delMenuCount ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MMS]\n" ) ; buffer . append ( "    .addMenu        = " ) . append ( Integer . toHexString ( getAddMenuCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .delMenu        = " ) . append ( Integer . toHexString ( getDelMenuCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/MMS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; data [ 4 + offset ] = getAddMenuCount ( ) ; data [ 5 + offset ] = getDelMenuCount ( ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ExtSSTInfoSubRecord extends Record { public final static short sid = 0xFFF ; private int field_1_stream_pos ; private short field_2_bucket_sst_offset ; private short field_3_zero ; public ExtSSTInfoSubRecord ( ) { } public ExtSSTInfoSubRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtSSTInfoSubRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_stream_pos = LittleEndian . getInt ( data , 0 + offset ) ; field_2_bucket_sst_offset = LittleEndian . getShort ( data , 4 + offset ) ; field_3_zero = LittleEndian . getShort ( data , 6 + offset ) ; } public void setStreamPos ( int pos ) { field_1_stream_pos = pos ; } public void setBucketSSTOffset ( short offset ) { field_2_bucket_sst_offset = offset ; } public int getStreamPos ( ) { return field_1_stream_pos ; } public short getBucketSSTOffset ( ) { return field_2_bucket_sst_offset ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTSST]\n" ) ; buffer . append ( "    .streampos      = " ) . append ( Integer . toHexString ( getStreamPos ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .bucketsstoffset= " ) . append ( Integer . toHexString ( getBucketSSTOffset ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .zero           = " ) . append ( Integer . toHexString ( field_3_zero ) ) . append ( "\n" ) ; buffer . append ( "[/EXTSST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putInt ( data , 0 + offset , getStreamPos ( ) ) ; LittleEndian . putShort ( data , 4 + offset , getBucketSSTOffset ( ) ) ; LittleEndian . putShort ( data , 6 + offset , ( short ) 0 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableReader { private IntList _entries ; public BlockAllocationTableReader ( final int block_count , final int [ ] block_array , final int xbat_count , final int xbat_index , final BlockList raw_block_list ) throws IOException { this ( ) ; if ( block_count <= 0 ) { throw new IOException ( "Illegal block count; minimum count is 1, got " + block_count + " instead" ) ; } RawDataBlock blocks [ ] = new RawDataBlock [ block_count ] ; int limit = Math . min ( block_count , block_array . length ) ; int block_index ; for ( block_index = 0 ; block_index < limit ; block_index ++ ) { blocks [ block_index ] = ( RawDataBlock ) raw_block_list . remove ( block_array [ block_index ] ) ; } if ( block_index < block_count ) { if ( xbat_index < 0 ) { throw new IOException ( "BAT count exceeds limit, yet XBAT index indicates no valid entries" ) ; } int chain_index = xbat_index ; int max_entries_per_block = BATBlock . entriesPerXBATBlock ( ) ; int chain_index_offset = BATBlock . getXBATChainOffset ( ) ; for ( int j = 0 ; j < xbat_count ; j ++ ) { limit = Math . min ( block_count - block_index , max_entries_per_block ) ; byte [ ] data = raw_block_list . remove ( chain_index ) . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { blocks [ block_index ++ ] = ( RawDataBlock ) raw_block_list . remove ( LittleEndian . getInt ( data , offset ) ) ; offset += LittleEndianConsts . INT_SIZE ; } chain_index = LittleEndian . getInt ( data , chain_index_offset ) ; if ( chain_index == POIFSConstants . END_OF_CHAIN ) { break ; } } } if ( block_index != block_count ) { throw new IOException ( "Could not find all blocks" ) ; } setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( final ListManagedBlock [ ] blocks , final BlockList raw_block_list ) throws IOException { this ( ) ; setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( ) { _entries = new IntList ( ) ; } ListManagedBlock [ ] fetchBlocks ( final int startBlock , final BlockList blockList ) throws IOException { List blocks = new ArrayList ( ) ; int currentBlock = startBlock ; while ( currentBlock != POIFSConstants . END_OF_CHAIN ) { blocks . add ( blockList . remove ( currentBlock ) ) ; currentBlock = _entries . get ( currentBlock ) ; } return ( ListManagedBlock [ ] ) blocks . toArray ( new ListManagedBlock [ 0 ] ) ; } boolean isUsed ( final int index ) { boolean rval = false ; try { rval = _entries . get ( index ) != - 1 ; } catch ( IndexOutOfBoundsException ignored ) { } return rval ; } int getNextBlockIndex ( final int index ) throws IOException { if ( isUsed ( index ) ) { return _entries . get ( index ) ; } else { throw new IOException ( "index " + index + " is unused" ) ; } } private void setEntries ( final ListManagedBlock [ ] blocks , final BlockList raw_blocks ) throws IOException { int limit = BATBlock . entriesPerBlock ( ) ; for ( int block_index = 0 ; block_index < blocks . length ; block_index ++ ) { byte [ ] data = blocks [ block_index ] . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { int entry = LittleEndian . getInt ( data , offset ) ; if ( entry == POIFSConstants . UNUSED_BLOCK ) { raw_blocks . zap ( _entries . size ( ) ) ; } _entries . add ( entry ) ; offset += LittleEndianConsts . INT_SIZE ; } blocks [ block_index ] = null ; } raw_blocks . setBAT ( this ) ; } } 	0
package org . apache . poi . hssf . record . formula ; public class SubtractPtg extends Ptg implements OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x04 ; public SubtractPtg ( ) { } public SubtractPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( ) { return "-" ; } public String toFormulaString ( Ptg [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] . toFormulaString ( ) ) ; buffer . append ( "-" ) ; buffer . append ( operands [ 1 ] . toFormulaString ( ) ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class HideObjRecord extends Record { public final static short sid = 0x8d ; public final static short HIDE_ALL = 2 ; public final static short SHOW_PLACEHOLDERS = 1 ; public final static short SHOW_ALL = 0 ; private short field_1_hide_obj ; public HideObjRecord ( ) { } public HideObjRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public HideObjRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A HIDEOBJ RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_hide_obj = LittleEndian . getShort ( data , 0 + offset ) ; } public void setHideObj ( short hide ) { field_1_hide_obj = hide ; } public short getHideObj ( ) { return field_1_hide_obj ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[HIDEOBJ]\n" ) ; buffer . append ( "    .hideobj         = " ) . append ( Integer . toHexString ( getHideObj ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/HIDEOBJ]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getHideObj ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class SeriesLabelsRecord extends Record { public final static short sid = 0x100c ; private short field_1_formatFlags ; private BitField showActual = new BitField ( 0x1 ) ; private BitField showPercent = new BitField ( 0x2 ) ; private BitField labelAsPercentage = new BitField ( 0x4 ) ; private BitField smoothedLine = new BitField ( 0x8 ) ; private BitField showLabel = new BitField ( 0x10 ) ; private BitField showBubbleSizes = new BitField ( 0x20 ) ; public SeriesLabelsRecord ( ) { } public SeriesLabelsRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesLabelsRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesLabels record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_formatFlags = LittleEndian . getShort ( data , 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SeriesLabels]\n" ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )\n" ) ; buffer . append ( "         .showActual               = " ) . append ( isShowActual ( ) ) . append ( '\n' ) ; buffer . append ( "         .showPercent              = " ) . append ( isShowPercent ( ) ) . append ( '\n' ) ; buffer . append ( "         .labelAsPercentage        = " ) . append ( isLabelAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .smoothedLine             = " ) . append ( isSmoothedLine ( ) ) . append ( '\n' ) ; buffer . append ( "         .showLabel                = " ) . append ( isShowLabel ( ) ) . append ( '\n' ) ; buffer . append ( "         .showBubbleSizes          = " ) . append ( isShowBubbleSizes ( ) ) . append ( '\n' ) ; buffer . append ( "[/SeriesLabels]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public short getFormatFlags ( ) { return field_1_formatFlags ; } public void setFormatFlags ( short field_1_formatFlags ) { this . field_1_formatFlags = field_1_formatFlags ; } public void setShowActual ( boolean value ) { field_1_formatFlags = showActual . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowActual ( ) { return showActual . isSet ( field_1_formatFlags ) ; } public void setShowPercent ( boolean value ) { field_1_formatFlags = showPercent . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowPercent ( ) { return showPercent . isSet ( field_1_formatFlags ) ; } public void setLabelAsPercentage ( boolean value ) { field_1_formatFlags = labelAsPercentage . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isLabelAsPercentage ( ) { return labelAsPercentage . isSet ( field_1_formatFlags ) ; } public void setSmoothedLine ( boolean value ) { field_1_formatFlags = smoothedLine . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isSmoothedLine ( ) { return smoothedLine . isSet ( field_1_formatFlags ) ; } public void setShowLabel ( boolean value ) { field_1_formatFlags = showLabel . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowLabel ( ) { return showLabel . isSet ( field_1_formatFlags ) ; } public void setShowBubbleSizes ( boolean value ) { field_1_formatFlags = showBubbleSizes . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowBubbleSizes ( ) { return showBubbleSizes . isSet ( field_1_formatFlags ) ; } } 	1
package org . apache . poi . util ; import java . util . * ; public final class BinaryTree extends AbstractMap { private Node [ ] _root = new Node [ ] { null , null } ; private int _size = 0 ; private int _modifications = 0 ; private Set [ ] _key_set = new Set [ ] { null , null } ; private Set [ ] _entry_set = new Set [ ] { null , null } ; private Collection [ ] _value_collection = new Collection [ ] { null , null } ; private static final int _KEY = 0 ; private static final int _VALUE = 1 ; private static final int _INDEX_SUM = _KEY + _VALUE ; private static final int _MINIMUM_INDEX = 0 ; private static final int _INDEX_COUNT = 2 ; private static final String [ ] _data_name = new String [ ] { "key" , "value" } ; public BinaryTree ( ) { } public BinaryTree ( final Map map ) throws ClassCastException , NullPointerException , IllegalArgumentException { putAll ( map ) ; } public Object getKeyForValue ( final Object value ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) value , _VALUE ) ; } public Object removeValue ( final Object value ) { return doRemove ( ( Comparable ) value , _VALUE ) ; } public Set entrySetByValue ( ) { if ( _entry_set [ _VALUE ] == null ) { _entry_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; return ( node != null ) && node . getData ( _KEY ) . equals ( key ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; if ( ( node != null ) && node . getData ( _KEY ) . equals ( key ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _VALUE ] ; } public Set keySetByValue ( ) { if ( _key_set [ _VALUE ] == null ) { _key_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _VALUE ] ; } public Collection valuesByValue ( ) { if ( _value_collection [ _VALUE ] == null ) { _value_collection [ _VALUE ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _VALUE ] ; } private Object doRemove ( final Comparable o , final int index ) { Node node = lookup ( o , index ) ; Object rval = null ; if ( node != null ) { rval = node . getData ( oppositeIndex ( index ) ) ; doRedBlackDelete ( node ) ; } return rval ; } private Object doGet ( final Comparable o , final int index ) { checkNonNullComparable ( o , index ) ; Node node = lookup ( o , index ) ; return ( ( node == null ) ? null : node . getData ( oppositeIndex ( index ) ) ) ; } private int oppositeIndex ( final int index ) { return _INDEX_SUM - index ; } private Node lookup ( final Comparable data , final int index ) { Node rval = null ; Node node = _root [ index ] ; while ( node != null ) { int cmp = compare ( data , node . getData ( index ) ) ; if ( cmp == 0 ) { rval = node ; break ; } else { node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; } } return rval ; } private static int compare ( final Comparable o1 , final Comparable o2 ) { return ( ( Comparable ) o1 ) . compareTo ( o2 ) ; } private static Node leastNode ( final Node node , final int index ) { Node rval = node ; if ( rval != null ) { while ( rval . getLeft ( index ) != null ) { rval = rval . getLeft ( index ) ; } } return rval ; } private Node nextGreater ( final Node node , final int index ) { Node rval = null ; if ( node == null ) { rval = null ; } else if ( node . getRight ( index ) != null ) { rval = leastNode ( node . getRight ( index ) , index ) ; } else { Node parent = node . getParent ( index ) ; Node child = node ; while ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { child = parent ; parent = parent . getParent ( index ) ; } rval = parent ; } return rval ; } private static void copyColor ( final Node from , final Node to , final int index ) { if ( to != null ) { if ( from == null ) { to . setBlack ( index ) ; } else { to . copyColor ( from , index ) ; } } } private static boolean isRed ( final Node node , final int index ) { return ( ( node == null ) ? false : node . isRed ( index ) ) ; } private static boolean isBlack ( final Node node , final int index ) { return ( ( node == null ) ? true : node . isBlack ( index ) ) ; } private static void makeRed ( final Node node , final int index ) { if ( node != null ) { node . setRed ( index ) ; } } private static void makeBlack ( final Node node , final int index ) { if ( node != null ) { node . setBlack ( index ) ; } } private static Node getGrandParent ( final Node node , final int index ) { return getParent ( getParent ( node , index ) , index ) ; } private static Node getParent ( final Node node , final int index ) { return ( ( node == null ) ? null : node . getParent ( index ) ) ; } private static Node getRightChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getRight ( index ) ; } private static Node getLeftChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getLeft ( index ) ; } private static boolean isLeftChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getLeft ( index ) ) ) ; } private static boolean isRightChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getRight ( index ) ) ) ; } private void rotateLeft ( final Node node , final int index ) { Node right_child = node . getRight ( index ) ; node . setRight ( right_child . getLeft ( index ) , index ) ; if ( right_child . getLeft ( index ) != null ) { right_child . getLeft ( index ) . setParent ( node , index ) ; } right_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = right_child ; } else if ( node . getParent ( index ) . getLeft ( index ) == node ) { node . getParent ( index ) . setLeft ( right_child , index ) ; } else { node . getParent ( index ) . setRight ( right_child , index ) ; } right_child . setLeft ( node , index ) ; node . setParent ( right_child , index ) ; } private void rotateRight ( final Node node , final int index ) { Node left_child = node . getLeft ( index ) ; node . setLeft ( left_child . getRight ( index ) , index ) ; if ( left_child . getRight ( index ) != null ) { left_child . getRight ( index ) . setParent ( node , index ) ; } left_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = left_child ; } else if ( node . getParent ( index ) . getRight ( index ) == node ) { node . getParent ( index ) . setRight ( left_child , index ) ; } else { node . getParent ( index ) . setLeft ( left_child , index ) ; } left_child . setRight ( node , index ) ; node . setParent ( left_child , index ) ; } private void doRedBlackInsert ( final Node inserted_node , final int index ) { Node current_node = inserted_node ; makeRed ( current_node , index ) ; while ( ( current_node != null ) && ( current_node != _root [ index ] ) && ( isRed ( current_node . getParent ( index ) , index ) ) ) { if ( isLeftChild ( getParent ( current_node , index ) , index ) ) { Node y = getRightChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isRightChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateLeft ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateRight ( getGrandParent ( current_node , index ) , index ) ; } } } else { Node y = getLeftChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isLeftChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateRight ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateLeft ( getGrandParent ( current_node , index ) , index ) ; } } } } makeBlack ( _root [ index ] , index ) ; } private void doRedBlackDelete ( final Node deleted_node ) { for ( int index = _MINIMUM_INDEX ; index < _INDEX_COUNT ; index ++ ) { if ( ( deleted_node . getLeft ( index ) != null ) && ( deleted_node . getRight ( index ) != null ) ) { swapPosition ( nextGreater ( deleted_node , index ) , deleted_node , index ) ; } Node replacement = ( ( deleted_node . getLeft ( index ) != null ) ? deleted_node . getLeft ( index ) : deleted_node . getRight ( index ) ) ; if ( replacement != null ) { replacement . setParent ( deleted_node . getParent ( index ) , index ) ; if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = replacement ; } else if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( replacement , index ) ; } else { deleted_node . getParent ( index ) . setRight ( replacement , index ) ; } deleted_node . setLeft ( null , index ) ; deleted_node . setRight ( null , index ) ; deleted_node . setParent ( null , index ) ; if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( replacement , index ) ; } } else { if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = null ; } else { if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( deleted_node , index ) ; } if ( deleted_node . getParent ( index ) != null ) { if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( null , index ) ; } else { deleted_node . getParent ( index ) . setRight ( null , index ) ; } deleted_node . setParent ( null , index ) ; } } } } shrink ( ) ; } private void doRedBlackDeleteFixup ( final Node replacement_node , final int index ) { Node current_node = replacement_node ; while ( ( current_node != _root [ index ] ) && ( isBlack ( current_node , index ) ) ) { if ( isLeftChild ( current_node , index ) ) { Node sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) && isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateRight ( sibling_node , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getRightChild ( sibling_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } else { Node sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getRightChild ( sibling_node , index ) , index ) && isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeBlack ( getRightChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateLeft ( sibling_node , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } } makeBlack ( current_node , index ) ; } private void swapPosition ( final Node x , final Node y , final int index ) { Node x_old_parent = x . getParent ( index ) ; Node x_old_left_child = x . getLeft ( index ) ; Node x_old_right_child = x . getRight ( index ) ; Node y_old_parent = y . getParent ( index ) ; Node y_old_left_child = y . getLeft ( index ) ; Node y_old_right_child = y . getRight ( index ) ; boolean x_was_left_child = ( x . getParent ( index ) != null ) && ( x == x . getParent ( index ) . getLeft ( index ) ) ; boolean y_was_left_child = ( y . getParent ( index ) != null ) && ( y == y . getParent ( index ) . getLeft ( index ) ) ; if ( x == y_old_parent ) { x . setParent ( y , index ) ; if ( y_was_left_child ) { y . setLeft ( x , index ) ; y . setRight ( x_old_right_child , index ) ; } else { y . setRight ( x , index ) ; y . setLeft ( x_old_left_child , index ) ; } } else { x . setParent ( y_old_parent , index ) ; if ( y_old_parent != null ) { if ( y_was_left_child ) { y_old_parent . setLeft ( x , index ) ; } else { y_old_parent . setRight ( x , index ) ; } } y . setLeft ( x_old_left_child , index ) ; y . setRight ( x_old_right_child , index ) ; } if ( y == x_old_parent ) { y . setParent ( x , index ) ; if ( x_was_left_child ) { x . setLeft ( y , index ) ; x . setRight ( y_old_right_child , index ) ; } else { x . setRight ( y , index ) ; x . setLeft ( y_old_left_child , index ) ; } } else { y . setParent ( x_old_parent , index ) ; if ( x_old_parent != null ) { if ( x_was_left_child ) { x_old_parent . setLeft ( y , index ) ; } else { x_old_parent . setRight ( y , index ) ; } } x . setLeft ( y_old_left_child , index ) ; x . setRight ( y_old_right_child , index ) ; } if ( x . getLeft ( index ) != null ) { x . getLeft ( index ) . setParent ( x , index ) ; } if ( x . getRight ( index ) != null ) { x . getRight ( index ) . setParent ( x , index ) ; } if ( y . getLeft ( index ) != null ) { y . getLeft ( index ) . setParent ( y , index ) ; } if ( y . getRight ( index ) != null ) { y . getRight ( index ) . setParent ( y , index ) ; } x . swapColors ( y , index ) ; if ( _root [ index ] == x ) { _root [ index ] = y ; } else if ( _root [ index ] == y ) { _root [ index ] = x ; } } private static void checkNonNullComparable ( final Object o , final int index ) { if ( o == null ) { throw new NullPointerException ( _data_name [ index ] + " cannot be null" ) ; } if ( ! ( o instanceof Comparable ) ) { throw new ClassCastException ( _data_name [ index ] + " must be Comparable" ) ; } } private static void checkKey ( final Object key ) { checkNonNullComparable ( key , _KEY ) ; } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , _VALUE ) ; } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; checkValue ( value ) ; } private void modify ( ) { _modifications ++ ; } private void grow ( ) { modify ( ) ; _size ++ ; } private void shrink ( ) { modify ( ) ; _size -- ; } private void insertValue ( final Node newNode ) throws IllegalArgumentException { Node node = _root [ _VALUE ] ; while ( true ) { int cmp = compare ( newNode . getData ( _VALUE ) , node . getData ( _VALUE ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate value (\"" + newNode . getData ( _VALUE ) + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _VALUE ) != null ) { node = node . getLeft ( _VALUE ) ; } else { node . setLeft ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } else { if ( node . getRight ( _VALUE ) != null ) { node = node . getRight ( _VALUE ) ; } else { node . setRight ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } } } public int size ( ) { return _size ; } public boolean containsKey ( final Object key ) throws ClassCastException , NullPointerException { checkKey ( key ) ; return lookup ( ( Comparable ) key , _KEY ) != null ; } public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookup ( ( Comparable ) value , _VALUE ) != null ; } public Object get ( final Object key ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) key , _KEY ) ; } public Object put ( final Object key , final Object value ) throws ClassCastException , NullPointerException , IllegalArgumentException { checkKeyAndValue ( key , value ) ; Node node = _root [ _KEY ] ; if ( node == null ) { Node root = new Node ( ( Comparable ) key , ( Comparable ) value ) ; _root [ _KEY ] = root ; _root [ _VALUE ] = root ; grow ( ) ; } else { while ( true ) { int cmp = compare ( ( Comparable ) key , node . getData ( _KEY ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate key (\"" + key + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _KEY ) != null ) { node = node . getLeft ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setLeft ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } else { if ( node . getRight ( _KEY ) != null ) { node = node . getRight ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setRight ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } } } return null ; } public Object remove ( final Object key ) { return doRemove ( ( Comparable ) key , _KEY ) ; } public void clear ( ) { modify ( ) ; _size = 0 ; _root [ _KEY ] = null ; _root [ _VALUE ] = null ; } public Set keySet ( ) { if ( _key_set [ _KEY ] == null ) { _key_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _KEY ] ; } public Collection values ( ) { if ( _value_collection [ _KEY ] == null ) { _value_collection [ _KEY ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _KEY ] ; } public Set entrySet ( ) { if ( _entry_set [ _KEY ] == null ) { _entry_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; return ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; if ( ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _KEY ] ; } private abstract class BinaryTreeIterator implements Iterator { private int _expected_modifications ; protected Node _last_returned_node ; private Node _next_node ; private int _type ; BinaryTreeIterator ( final int type ) { _type = type ; _expected_modifications = BinaryTree . this . _modifications ; _last_returned_node = null ; _next_node = leastNode ( _root [ _type ] , _type ) ; } protected abstract Object doGetNext ( ) ; public final boolean hasNext ( ) { return _next_node != null ; } public final Object next ( ) throws NoSuchElementException , ConcurrentModificationException { if ( _next_node == null ) { throw new NoSuchElementException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } _last_returned_node = _next_node ; _next_node = nextGreater ( _next_node , _type ) ; return doGetNext ( ) ; } public final void remove ( ) throws IllegalStateException , ConcurrentModificationException { if ( _last_returned_node == null ) { throw new IllegalStateException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } doRedBlackDelete ( _last_returned_node ) ; _expected_modifications ++ ; _last_returned_node = null ; } } private static final class Node implements Map . Entry { private Comparable [ ] _data ; private Node [ ] _left ; private Node [ ] _right ; private Node [ ] _parent ; private boolean [ ] _black ; private int _hashcode ; private boolean _calculated_hashcode ; Node ( final Comparable key , final Comparable value ) { _data = new Comparable [ ] { key , value } ; _left = new Node [ ] { null , null } ; _right = new Node [ ] { null , null } ; _parent = new Node [ ] { null , null } ; _black = new boolean [ ] { true , true } ; _calculated_hashcode = false ; } private Comparable getData ( final int index ) { return _data [ index ] ; } private void setLeft ( final Node node , final int index ) { _left [ index ] = node ; } private Node getLeft ( final int index ) { return _left [ index ] ; } private void setRight ( final Node node , final int index ) { _right [ index ] = node ; } private Node getRight ( final int index ) { return _right [ index ] ; } private void setParent ( final Node node , final int index ) { _parent [ index ] = node ; } private Node getParent ( final int index ) { return _parent [ index ] ; } private void swapColors ( final Node node , final int index ) { _black [ index ] ^= node . _black [ index ] ; node . _black [ index ] ^= _black [ index ] ; _black [ index ] ^= node . _black [ index ] ; } private boolean isBlack ( final int index ) { return _black [ index ] ; } private boolean isRed ( final int index ) { return ! _black [ index ] ; } private void setBlack ( final int index ) { _black [ index ] = true ; } private void setRed ( final int index ) { _black [ index ] = false ; } private void copyColor ( final Node node , final int index ) { _black [ index ] = node . _black [ index ] ; } public Object getKey ( ) { return _data [ _KEY ] ; } public Object getValue ( ) { return _data [ _VALUE ] ; } public Object setValue ( Object ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( "Map.Entry.setValue is not supported" ) ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry e = ( Map . Entry ) o ; return _data [ _KEY ] . equals ( e . getKey ( ) ) && _data [ _VALUE ] . equals ( e . getValue ( ) ) ; } public int hashCode ( ) { if ( ! _calculated_hashcode ) { _hashcode = _data [ _KEY ] . hashCode ( ) ^ _data [ _VALUE ] . hashCode ( ) ; _calculated_hashcode = true ; } return _hashcode ; } } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class PlotGrowthRecord extends Record { public final static short sid = 0x1064 ; private int field_1_horizontalScale ; private int field_2_verticalScale ; public PlotGrowthRecord ( ) { } public PlotGrowthRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PlotGrowthRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a PlotGrowth record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_horizontalScale = LittleEndian . getInt ( data , 0x0 + offset ) ; field_2_verticalScale = LittleEndian . getInt ( data , 0x4 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PlotGrowth]\n" ) ; buffer . append ( "    .horizontalScale      = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getHorizontalScale ( ) ) ) . append ( " (" ) . append ( getHorizontalScale ( ) ) . append ( " )\n" ) ; buffer . append ( "    .verticalScale        = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( int ) getVerticalScale ( ) ) ) . append ( " (" ) . append ( getVerticalScale ( ) ) . append ( " )\n" ) ; buffer . append ( "[/PlotGrowth]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset , field_1_horizontalScale ) ; LittleEndian . putInt ( data , 8 + offset , field_2_verticalScale ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 ; } public short getSid ( ) { return this . sid ; } public int getHorizontalScale ( ) { return field_1_horizontalScale ; } public void setHorizontalScale ( int field_1_horizontalScale ) { this . field_1_horizontalScale = field_1_horizontalScale ; } public int getVerticalScale ( ) { return field_2_verticalScale ; } public void setVerticalScale ( int field_2_verticalScale ) { this . field_2_verticalScale = field_2_verticalScale ; } } 	1
package org . apache . poi . poifs . eventfilesystem ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentDescriptor ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; class POIFSReaderRegistry { private Set omnivorousListeners ; private Map selectiveListeners ; private Map chosenDocumentDescriptors ; POIFSReaderRegistry ( ) { omnivorousListeners = new HashSet ( ) ; selectiveListeners = new HashMap ( ) ; chosenDocumentDescriptors = new HashMap ( ) ; } void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String documentName ) { if ( ! omnivorousListeners . contains ( listener ) ) { Set descriptors = ( Set ) selectiveListeners . get ( listener ) ; if ( descriptors == null ) { descriptors = new HashSet ( ) ; selectiveListeners . put ( listener , descriptors ) ; } DocumentDescriptor descriptor = new DocumentDescriptor ( path , documentName ) ; if ( descriptors . add ( descriptor ) ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; if ( listeners == null ) { listeners = new HashSet ( ) ; chosenDocumentDescriptors . put ( descriptor , listeners ) ; } listeners . add ( listener ) ; } } } void registerListener ( final POIFSReaderListener listener ) { if ( ! omnivorousListeners . contains ( listener ) ) { removeSelectiveListener ( listener ) ; omnivorousListeners . add ( listener ) ; } } Iterator getListeners ( final POIFSDocumentPath path , final String name ) { Set rval = new HashSet ( omnivorousListeners ) ; Set selectiveListeners = ( Set ) chosenDocumentDescriptors . get ( new DocumentDescriptor ( path , name ) ) ; if ( selectiveListeners != null ) { rval . addAll ( selectiveListeners ) ; } return rval . iterator ( ) ; } private void removeSelectiveListener ( final POIFSReaderListener listener ) { Set selectedDescriptors = ( Set ) selectiveListeners . remove ( listener ) ; if ( selectedDescriptors != null ) { Iterator iter = selectedDescriptors . iterator ( ) ; while ( iter . hasNext ( ) ) { dropDocument ( listener , ( DocumentDescriptor ) iter . next ( ) ) ; } } } private void dropDocument ( final POIFSReaderListener listener , final DocumentDescriptor descriptor ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; listeners . remove ( listener ) ; if ( listeners . size ( ) == 0 ) { chosenDocumentDescriptors . remove ( descriptor ) ; } } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class DataFormatRecord extends Record { public final static short sid = 0x1006 ; private short field_1_pointNumber ; private short field_2_seriesIndex ; private short field_3_seriesNumber ; private short field_4_formatFlags ; private BitField useExcel4Colors = new BitField ( 0x1 ) ; public DataFormatRecord ( ) { } public DataFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DataFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a DataFormat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_pointNumber = LittleEndian . getShort ( data , 0x0 + offset ) ; field_2_seriesIndex = LittleEndian . getShort ( data , 0x2 + offset ) ; field_3_seriesNumber = LittleEndian . getShort ( data , 0x4 + offset ) ; field_4_formatFlags = LittleEndian . getShort ( data , 0x6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DataFormat]\n" ) ; buffer . append ( "    .pointNumber          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getPointNumber ( ) ) ) . append ( " (" ) . append ( getPointNumber ( ) ) . append ( " )\n" ) ; buffer . append ( "    .seriesIndex          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getSeriesIndex ( ) ) ) . append ( " (" ) . append ( getSeriesIndex ( ) ) . append ( " )\n" ) ; buffer . append ( "    .seriesNumber         = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getSeriesNumber ( ) ) ) . append ( " (" ) . append ( getSeriesNumber ( ) ) . append ( " )\n" ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )\n" ) ; buffer . append ( "         .useExcel4Colors          = " ) . append ( isUseExcel4Colors ( ) ) . append ( '\n' ) ; buffer . append ( "[/DataFormat]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_pointNumber ) ; LittleEndian . putShort ( data , 6 + offset , field_2_seriesIndex ) ; LittleEndian . putShort ( data , 8 + offset , field_3_seriesNumber ) ; LittleEndian . putShort ( data , 10 + offset , field_4_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public short getPointNumber ( ) { return field_1_pointNumber ; } public void setPointNumber ( short field_1_pointNumber ) { this . field_1_pointNumber = field_1_pointNumber ; } public short getSeriesIndex ( ) { return field_2_seriesIndex ; } public void setSeriesIndex ( short field_2_seriesIndex ) { this . field_2_seriesIndex = field_2_seriesIndex ; } public short getSeriesNumber ( ) { return field_3_seriesNumber ; } public void setSeriesNumber ( short field_3_seriesNumber ) { this . field_3_seriesNumber = field_3_seriesNumber ; } public short getFormatFlags ( ) { return field_4_formatFlags ; } public void setFormatFlags ( short field_4_formatFlags ) { this . field_4_formatFlags = field_4_formatFlags ; } public void setUseExcel4Colors ( boolean value ) { field_4_formatFlags = useExcel4Colors . setShortBoolean ( field_4_formatFlags , value ) ; } public boolean isUseExcel4Colors ( ) { return useExcel4Colors . isSet ( field_4_formatFlags ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class EndRecord extends Record { public static final short sid = 0x1034 ; public EndRecord ( ) { } public EndRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public EndRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An END RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[END]\n" ) ; buffer . append ( "[/END]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding ; private Workbook book ; private Sheet sheet ; private short row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , short row , short col ) { cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , short row , short col , int type ) { cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : record = new FormulaRecord ( ) ; ( ( FormulaRecord ) record ) . setColumn ( col ) ; ( ( FormulaRecord ) record ) . setRow ( row ) ; ( ( FormulaRecord ) record ) . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , short row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecord . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecord frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecord ( ) ; } else { frec = ( FormulaRecord ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } return HSSFDateUtil . getJavaDate ( cellValue ) ; } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; class BlockListImpl implements BlockList { private ListManagedBlock [ ] _blocks ; private BlockAllocationTableReader _bat ; protected BlockListImpl ( ) { _blocks = new ListManagedBlock [ 0 ] ; _bat = null ; } protected void setBlocks ( final ListManagedBlock [ ] blocks ) { _blocks = blocks ; } public void zap ( final int index ) { if ( ( index >= 0 ) && ( index < _blocks . length ) ) { _blocks [ index ] = null ; } } public ListManagedBlock remove ( final int index ) throws IOException { ListManagedBlock result = null ; try { result = _blocks [ index ] ; if ( result == null ) { throw new IOException ( "block[ " + index + " ] already removed" ) ; } _blocks [ index ] = null ; } catch ( ArrayIndexOutOfBoundsException ignored ) { throw new IOException ( "Cannot remove block[ " + index + " ]; out of range" ) ; } return result ; } public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException { if ( _bat == null ) { throw new IOException ( "Improperly initialized list: no block allocation table provided" ) ; } return _bat . fetchBlocks ( startBlock , this ) ; } public void setBAT ( final BlockAllocationTableReader bat ) throws IOException { if ( _bat != null ) { throw new IOException ( "Attempt to replace existing BlockAllocationTable" ) ; } _bat = bat ; } } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public static final String EOL = System . getProperty ( "line.separator" ) ; private static final StringBuffer _lbuffer = new StringBuffer ( 8 ) ; private static final StringBuffer _cbuffer = new StringBuffer ( 2 ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private static StringBuffer dump ( final long value ) { _lbuffer . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { _lbuffer . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return _lbuffer ; } private static StringBuffer dump ( final byte value ) { _cbuffer . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { _cbuffer . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return _cbuffer ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface BlockList { public void zap ( final int index ) ; public ListManagedBlock remove ( final int index ) throws IOException ; public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException ; public void setBAT ( final BlockAllocationTableReader bat ) throws IOException ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class MulBlankRecord extends Record { public final static short sid = 0xbe ; private short field_1_row ; private short field_2_first_col ; private short [ ] field_3_xfs ; private short field_4_last_col ; public MulBlankRecord ( ) { } public MulBlankRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MulBlankRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public short getRow ( ) { return field_1_row ; } public short getFirstColumn ( ) { return field_2_first_col ; } public short getLastColumn ( ) { return field_4_last_col ; } public int getNumColumns ( ) { return field_4_last_col - field_2_first_col + 1 ; } public short getXFAt ( int coffset ) { return field_3_xfs [ coffset ] ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xfs = parseXFs ( data , 4 , offset , size ) ; field_4_last_col = LittleEndian . getShort ( data , ( field_3_xfs . length * 2 ) + 4 + offset ) ; } private short [ ] parseXFs ( byte [ ] data , int offset , int recoffset , short size ) { short [ ] retval = new short [ ( ( size - offset ) - 2 ) / 2 ] ; int idx = 0 ; for ( ; offset < size - 2 ; ) { short xf = 0 ; xf = LittleEndian . getShort ( data , offset + recoffset ) ; offset += 2 ; retval [ idx ] = xf ; idx ++ ; } return retval ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MULBLANK]\n" ) ; buffer . append ( "firstcol  = " ) . append ( Integer . toHexString ( getFirstColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( " lastcol  = " ) . append ( Integer . toHexString ( getLastColumn ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumColumns ( ) ; k ++ ) { buffer . append ( "xf" ) . append ( k ) . append ( "        = " ) . append ( Integer . toHexString ( getXFAt ( k ) ) ) . append ( "\n" ) ; } buffer . append ( "[/MULBLANK]\n" ) ; return buffer . toString ( ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a MulBlankRecord!" ) ; } } public short getSid ( ) { return this . sid ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "Sorry, you can't serialize a MulBlank in this release" ) ; } } 	1
package org . apache . poi . hssf . eventmodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected void processRecord ( Record rec ) { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { HSSFListener listener = ( HSSFListener ) listeners . get ( k ) ; listener . processRecord ( rec ) ; } } } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private StringUtil ( ) { } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } byte [ ] bstring = new byte [ len ] ; int index = offset + 1 ; for ( int k = 0 ; k < len ; k ++ ) { bstring [ k ] = string [ index ] ; index += 2 ; } return new String ( bstring ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CountryRecord extends Record { public final static short sid = 0x8c ; private short field_1_default_country ; private short field_2_current_country ; public CountryRecord ( ) { } public CountryRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CountryRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Country RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_default_country = LittleEndian . getShort ( data , 0 + offset ) ; field_2_current_country = LittleEndian . getShort ( data , 2 + offset ) ; } public void setDefaultCountry ( short country ) { field_1_default_country = country ; } public void setCurrentCountry ( short country ) { field_2_current_country = country ; } public short getDefaultCountry ( ) { return field_1_default_country ; } public short getCurrentCountry ( ) { return field_2_current_country ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[COUNTRY]\n" ) ; buffer . append ( "    .defaultcountry  = " ) . append ( Integer . toHexString ( getDefaultCountry ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .currentcountry  = " ) . append ( Integer . toHexString ( getCurrentCountry ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/COUNTRY]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x04 ) ) ; LittleEndian . putShort ( data , 4 + offset , getDefaultCountry ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getCurrentCountry ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont implements HSSFColorConstants { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DSFRecord extends Record { public final static short sid = 0x161 ; private short field_1_dsf ; public DSFRecord ( ) { } public DSFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DSFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A DSF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_dsf = LittleEndian . getShort ( data , 0 + offset ) ; } public void setDsf ( short dsfflag ) { field_1_dsf = dsfflag ; } public short getDsf ( ) { return field_1_dsf ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DSF]\n" ) ; buffer . append ( "    .isDSF           = " ) . append ( Integer . toHexString ( getDsf ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/DSF]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getDsf ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PrintGridlinesRecord extends Record { public final static short sid = 0x2b ; private short field_1_print_gridlines ; public PrintGridlinesRecord ( ) { } public PrintGridlinesRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PrintGridlinesRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PrintGridlines RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_print_gridlines = LittleEndian . getShort ( data , 0 + offset ) ; } public void setPrintGridlines ( boolean pg ) { if ( pg == true ) { field_1_print_gridlines = 1 ; } else { field_1_print_gridlines = 0 ; } } public boolean getPrintGridlines ( ) { return ( field_1_print_gridlines == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PRINTGRIDLINES]\n" ) ; buffer . append ( "    .printgridlines = " ) . append ( getPrintGridlines ( ) ) . append ( "\n" ) ; buffer . append ( "[/PRINTGRIDLINES]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_print_gridlines ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PasswordRev4Record extends Record { public final static short sid = 0x1BC ; private short field_1_password ; public PasswordRev4Record ( ) { } public PasswordRev4Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PasswordRev4Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROT4REVPASSWORD RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_password = LittleEndian . getShort ( data , 0 + offset ) ; } public void setPassword ( short pw ) { field_1_password = pw ; } public short getPassword ( ) { return field_1_password ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROT4REVPASSWORD]\n" ) ; buffer . append ( "    .password       = " ) . append ( Integer . toHexString ( getPassword ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/PROT4REVPASSWORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getPassword ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class CategorySeriesAxisRecord extends Record { public final static short sid = 0x1020 ; private short field_1_crossingPoint ; private short field_2_labelFrequency ; private short field_3_tickMarkFrequency ; private short field_4_options ; private BitField valueAxisCrossing = new BitField ( 0x1 ) ; private BitField crossesFarRight = new BitField ( 0x2 ) ; private BitField reversed = new BitField ( 0x4 ) ; public CategorySeriesAxisRecord ( ) { } public CategorySeriesAxisRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CategorySeriesAxisRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a CategorySeriesAxis record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_crossingPoint = LittleEndian . getShort ( data , 0x0 + offset ) ; field_2_labelFrequency = LittleEndian . getShort ( data , 0x2 + offset ) ; field_3_tickMarkFrequency = LittleEndian . getShort ( data , 0x4 + offset ) ; field_4_options = LittleEndian . getShort ( data , 0x6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CategorySeriesAxis]\n" ) ; buffer . append ( "    .crossingPoint        = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getCrossingPoint ( ) ) ) . append ( " (" ) . append ( getCrossingPoint ( ) ) . append ( " )\n" ) ; buffer . append ( "    .labelFrequency       = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getLabelFrequency ( ) ) ) . append ( " (" ) . append ( getLabelFrequency ( ) ) . append ( " )\n" ) ; buffer . append ( "    .tickMarkFrequency    = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getTickMarkFrequency ( ) ) ) . append ( " (" ) . append ( getTickMarkFrequency ( ) ) . append ( " )\n" ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )\n" ) ; buffer . append ( "         .valueAxisCrossing        = " ) . append ( isValueAxisCrossing ( ) ) . append ( '\n' ) ; buffer . append ( "         .crossesFarRight          = " ) . append ( isCrossesFarRight ( ) ) . append ( '\n' ) ; buffer . append ( "         .reversed                 = " ) . append ( isReversed ( ) ) . append ( '\n' ) ; buffer . append ( "[/CategorySeriesAxis]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_crossingPoint ) ; LittleEndian . putShort ( data , 6 + offset , field_2_labelFrequency ) ; LittleEndian . putShort ( data , 8 + offset , field_3_tickMarkFrequency ) ; LittleEndian . putShort ( data , 10 + offset , field_4_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public short getCrossingPoint ( ) { return field_1_crossingPoint ; } public void setCrossingPoint ( short field_1_crossingPoint ) { this . field_1_crossingPoint = field_1_crossingPoint ; } public short getLabelFrequency ( ) { return field_2_labelFrequency ; } public void setLabelFrequency ( short field_2_labelFrequency ) { this . field_2_labelFrequency = field_2_labelFrequency ; } public short getTickMarkFrequency ( ) { return field_3_tickMarkFrequency ; } public void setTickMarkFrequency ( short field_3_tickMarkFrequency ) { this . field_3_tickMarkFrequency = field_3_tickMarkFrequency ; } public short getOptions ( ) { return field_4_options ; } public void setOptions ( short field_4_options ) { this . field_4_options = field_4_options ; } public void setValueAxisCrossing ( boolean value ) { field_4_options = valueAxisCrossing . setShortBoolean ( field_4_options , value ) ; } public boolean isValueAxisCrossing ( ) { return valueAxisCrossing . isSet ( field_4_options ) ; } public void setCrossesFarRight ( boolean value ) { field_4_options = crossesFarRight . setShortBoolean ( field_4_options , value ) ; } public boolean isCrossesFarRight ( ) { return crossesFarRight . isSet ( field_4_options ) ; } public void setReversed ( boolean value ) { field_4_options = reversed . setShortBoolean ( field_4_options , value ) ; } public boolean isReversed ( ) { return reversed . isSet ( field_4_options ) ; } } 	1
package org . apache . poi . poifs . eventfilesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . property . PropertyTable ; import org . apache . poi . poifs . storage . BlockAllocationTableReader ; import org . apache . poi . poifs . storage . BlockList ; import org . apache . poi . poifs . storage . HeaderBlockReader ; import org . apache . poi . poifs . storage . RawDataBlockList ; import org . apache . poi . poifs . storage . SmallBlockTableReader ; public class POIFSReader { private POIFSReaderRegistry registry ; private boolean registryClosed ; public POIFSReader ( ) { registry = new POIFSReaderRegistry ( ) ; registryClosed = false ; } public void read ( final InputStream stream ) throws IOException { registryClosed = true ; HeaderBlockReader header_block_reader = new HeaderBlockReader ( stream ) ; RawDataBlockList data_blocks = new RawDataBlockList ( stream ) ; new BlockAllocationTableReader ( header_block_reader . getBATCount ( ) , header_block_reader . getBATArray ( ) , header_block_reader . getXBATCount ( ) , header_block_reader . getXBATIndex ( ) , data_blocks ) ; PropertyTable properties = new PropertyTable ( header_block_reader . getPropertyStart ( ) , data_blocks ) ; processProperties ( SmallBlockTableReader . getSmallDocumentBlocks ( data_blocks , properties . getRoot ( ) , header_block_reader . getSBATStart ( ) ) , data_blocks , properties . getRoot ( ) . getChildren ( ) , new POIFSDocumentPath ( ) ) ; } public void registerListener ( final POIFSReaderListener listener ) { if ( listener == null ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener ) ; } public void registerListener ( final POIFSReaderListener listener , final String name ) { registerListener ( listener , null , name ) ; } public void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String name ) { if ( ( listener == null ) || ( name == null ) || ( name . length ( ) == 0 ) ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener , ( path == null ) ? new POIFSDocumentPath ( ) : path , name ) ; } public static void main ( String args [ ] ) throws IOException { if ( args . length == 0 ) { System . err . println ( "at least one argument required: input filename(s)" ) ; System . exit ( 1 ) ; } for ( int j = 0 ; j < args . length ; j ++ ) { POIFSReader reader = new POIFSReader ( ) ; POIFSReaderListener listener = new SampleListener ( ) ; reader . registerListener ( listener ) ; System . out . println ( "reading " + args [ j ] ) ; FileInputStream istream = new FileInputStream ( args [ j ] ) ; reader . read ( istream ) ; istream . close ( ) ; } } private void processProperties ( final BlockList small_blocks , final BlockList big_blocks , final Iterator properties , final POIFSDocumentPath path ) throws IOException { while ( properties . hasNext ( ) ) { Property property = ( Property ) properties . next ( ) ; String name = property . getName ( ) ; if ( property . isDirectory ( ) ) { POIFSDocumentPath new_path = new POIFSDocumentPath ( path , new String [ ] { name } ) ; processProperties ( small_blocks , big_blocks , ( ( DirectoryProperty ) property ) . getChildren ( ) , new_path ) ; } else { int startBlock = property . getStartBlock ( ) ; Iterator listeners = registry . getListeners ( path , name ) ; if ( listeners . hasNext ( ) ) { int size = property . getSize ( ) ; POIFSDocument document = null ; if ( property . shouldUseSmallBlocks ( ) ) { document = new POIFSDocument ( name , small_blocks . fetchBlocks ( startBlock ) , size ) ; } else { document = new POIFSDocument ( name , big_blocks . fetchBlocks ( startBlock ) , size ) ; } while ( listeners . hasNext ( ) ) { POIFSReaderListener listener = ( POIFSReaderListener ) listeners . next ( ) ; listener . processPOIFSReaderEvent ( new POIFSReaderEvent ( new DocumentInputStream ( document ) , path , name ) ) ; } } else { if ( property . shouldUseSmallBlocks ( ) ) { small_blocks . fetchBlocks ( startBlock ) ; } else { big_blocks . fetchBlocks ( startBlock ) ; } } } } } private static class SampleListener implements POIFSReaderListener { SampleListener ( ) { } public void processPOIFSReaderEvent ( final POIFSReaderEvent event ) { DocumentInputStream istream = event . getStream ( ) ; POIFSDocumentPath path = event . getPath ( ) ; String name = event . getName ( ) ; try { byte [ ] data = new byte [ istream . available ( ) ] ; istream . read ( data ) ; int pathLength = path . length ( ) ; for ( int k = 0 ; k < pathLength ; k ++ ) { System . out . print ( "/" + path . getComponent ( k ) ) ; } System . out . println ( "/" + name + ": " + data . length + " bytes read" ) ; } catch ( IOException ignored ) { } } } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class FooterRecord extends Record { public final static short sid = 0x15 ; private byte field_1_footer_len ; private String field_2_footer ; public FooterRecord ( ) { } public FooterRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FooterRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FooterRECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { if ( size > 0 ) { field_1_footer_len = data [ 0 + offset ] ; field_2_footer = new String ( data , 3 + offset , LittleEndian . ubyteToInt ( field_1_footer_len ) ) ; } } public void setFooterLength ( byte len ) { field_1_footer_len = len ; } public void setFooter ( String footer ) { field_2_footer = footer ; } public short getFooterLength ( ) { return ( short ) ( 0xFF & field_1_footer_len ) ; } public String getFooter ( ) { return field_2_footer ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FOOTER]\n" ) ; buffer . append ( "    .footerlen      = " ) . append ( Integer . toHexString ( getFooterLength ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .footer         = " ) . append ( getFooter ( ) ) . append ( "\n" ) ; buffer . append ( "[/FOOTER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int len = 4 ; if ( getFooterLength ( ) > 0 ) { len += 3 ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( ( len - 4 ) + getFooterLength ( ) ) ) ; if ( getFooterLength ( ) > 0 ) { data [ 4 + offset ] = ( byte ) getFooterLength ( ) ; StringUtil . putCompressedUnicode ( getFooter ( ) , data , 7 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 4 ; if ( getFooterLength ( ) > 0 ) { retval += 3 ; } return retval + getFooterLength ( ) ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . util ; public class BitField { private final int _mask ; private final int _shift_count ; public BitField ( final int mask ) { _mask = mask ; int count = 0 ; int bit_pattern = mask ; if ( bit_pattern != 0 ) { while ( ( bit_pattern & 1 ) == 0 ) { count ++ ; bit_pattern >>= 1 ; } } _shift_count = count ; } public int getValue ( final int holder ) { return getRawValue ( holder ) > > _shift_count ; } public short getShortValue ( final short holder ) { return ( short ) getValue ( holder ) ; } public int getRawValue ( final int holder ) { return ( holder & _mask ) ; } public short getShortRawValue ( final short holder ) { return ( short ) getRawValue ( holder ) ; } public boolean isSet ( final int holder ) { return ( holder & _mask ) != 0 ; } public boolean isAllSet ( final int holder ) { return ( holder & _mask ) == _mask ; } public int setValue ( final int holder , final int value ) { return ( holder & ~ _mask ) | ( ( value << _shift_count ) & _mask ) ; } public short setShortValue ( final short holder , final short value ) { return ( short ) setValue ( holder , value ) ; } public int clear ( final int holder ) { return holder & ~ _mask ; } public short clearShort ( final short holder ) { return ( short ) clear ( holder ) ; } public byte clearByte ( final byte holder ) { return ( byte ) clear ( holder ) ; } public int set ( final int holder ) { return holder | _mask ; } public short setShort ( final short holder ) { return ( short ) set ( holder ) ; } public byte setByte ( final byte holder ) { return ( byte ) set ( holder ) ; } public int setBoolean ( final int holder , final boolean flag ) { return flag ? set ( holder ) : clear ( holder ) ; } public short setShortBoolean ( final short holder , final boolean flag ) { return flag ? setShort ( holder ) : clearShort ( holder ) ; } public byte setByteBoolean ( final byte holder , final boolean flag ) { return flag ? setByte ( holder ) : clearByte ( holder ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class WriteAccessRecord extends Record { public final static short sid = 0x5c ; private String field_1_username ; public WriteAccessRecord ( ) { } public WriteAccessRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WriteAccessRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WRITEACCESS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_username = new String ( data , 3 + offset , data . length - 4 ) ; } public void setUsername ( String username ) { field_1_username = username ; } public String getUsername ( ) { return field_1_username ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WRITEACCESS]\n" ) ; buffer . append ( "    .name            = " ) . append ( field_1_username . toString ( ) ) . append ( "\n" ) ; buffer . append ( "[/WRITEACCESS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { String username = getUsername ( ) ; StringBuffer temp = new StringBuffer ( 0x70 - ( 0x3 ) ) ; temp . append ( username ) ; while ( temp . length ( ) < 0x70 - 0x3 ) { temp . append ( " " ) ; } username = temp . toString ( ) ; UnicodeString str = new UnicodeString ( ) ; str . setString ( username ) ; str . setOptionFlags ( ( byte ) 0x0 ) ; str . setCharCount ( ( short ) 0x4 ) ; byte [ ] stringbytes = str . serialize ( ) ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( stringbytes . length ) ) ; System . arraycopy ( stringbytes , 0 , data , 4 + offset , stringbytes . length ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 116 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . property ; public interface PropertyConstants { public static final int PROPERTY_TYPE_OFFSET = 0x42 ; public static final byte DIRECTORY_TYPE = 1 ; public static final byte DOCUMENT_TYPE = 2 ; public static final byte ROOT_TYPE = 5 ; } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; public AreaPtg ( ) { } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; System . out . println ( toString ( ) ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstColRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastColRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_3_first_column & 0x3FFF ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstColRowRelative ( ) { return ( ( ( getFirstColumnRaw ( ) ) & 0x8000 ) == 0x8000 ) ; } public boolean isFirstColRelative ( ) { return ( ( ( getFirstColumnRaw ( ) ) & 0x4000 ) == 0x4000 ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_4_last_column & 0x3FFF ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastColRowRelative ( ) { return ( ( ( getLastColumnRaw ( ) ) & 0x8000 ) == 1 ) ; } public boolean isLastColRelative ( ) { return ( ( ( getFirstColumnRaw ( ) ) & 0x4000 ) == 1 ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( ) { String firstrow = "" + ( getFirstRow ( ) + 1 ) ; String lastrow = null ; if ( isLastColRowRelative ( ) ) { lastrow = "" + ( getFirstRow ( ) + getLastRow ( ) ) ; } else { lastrow = "" + ( getLastRow ( ) + 1 ) ; } return colNumToLetter ( getFirstColumn ( ) ) + firstrow + ":" + colNumToLetter ( getLastColumn ( ) ) + lastrow ; } public String colNumToLetter ( int col ) { byte [ ] b = { 0x41 } ; b [ 0 ] += ( byte ) col ; String retval = null ; try { retval = new String ( b , "UTF-8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( "NON JDK 1.3 COMPLIANT JVM -- YOUR JVM MUST SUPPORT UTF-8 encoding as per docs!" ) ; } return retval ; } } 	1
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . Record ; public class NumberRecord extends Record implements CellValueRecordInterface , Comparable { public static final short sid = 0x203 ; private short field_1_row ; private short field_2_col ; private short field_3_xf ; private double field_4_value ; public NumberRecord ( ) { } public NumberRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public NumberRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf = LittleEndian . getShort ( data , 4 + offset ) ; field_4_value = LittleEndian . getDouble ( data , 6 + offset ) ; } public void setRow ( short row ) { field_1_row = row ; } public void setColumn ( short col ) { field_2_col = col ; } public void setXFIndex ( short xf ) { field_3_xf = xf ; } public void setValue ( double value ) { field_4_value = value ; } public short getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_col ; } public short getXFIndex ( ) { return field_3_xf ; } public double getValue ( ) { return field_4_value ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[NUMBER]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .col            = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .value          = " ) . append ( getValue ( ) ) . append ( "\n" ) ; buffer . append ( "[/NUMBER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 14 ) ; LittleEndian . putShort ( data , 4 + offset , getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; LittleEndian . putDouble ( data , 10 + offset , getValue ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 18 ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Number RECORD" ) ; } } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; public class DocumentOutputStream extends OutputStream { private OutputStream stream ; private int limit ; private int written ; DocumentOutputStream ( final OutputStream stream , final int limit ) { this . stream = stream ; this . limit = limit ; this . written = 0 ; } public void write ( final int b ) throws IOException { limitCheck ( 1 ) ; stream . write ( b ) ; } public void write ( final byte b [ ] ) throws IOException { write ( b , 0 , b . length ) ; } public void write ( final byte b [ ] , final int off , final int len ) throws IOException { limitCheck ( len ) ; stream . write ( b , off , len ) ; } public void flush ( ) throws IOException { stream . flush ( ) ; } public void close ( ) throws IOException { } void writeFiller ( final int totalLimit , final byte fill ) throws IOException { if ( totalLimit > written ) { byte [ ] filler = new byte [ totalLimit - written ] ; Arrays . fill ( filler , fill ) ; stream . write ( filler ) ; } } private void limitCheck ( final int toBeWritten ) throws IOException { if ( ( written + toBeWritten ) > limit ) { throw new IOException ( "tried to write too much data" ) ; } written += toBeWritten ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import java . util . Stack ; public class FormulaParser { private String formulaString ; private int pointer = 0 ; private Stack operationsList = new java . util . Stack ( ) ; private Stack operandsList = new java . util . Stack ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char Look ; public FormulaParser ( String formula ) { formulaString = formula ; pointer = 0 ; } private void GetChar ( ) { Look = formulaString . charAt ( pointer ++ ) ; System . out . println ( "Got char: " + Look ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry" ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) ; } private boolean IsDigit ( char c ) { System . out . println ( "Checking digit for" + c ) ; return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private void SkipWhite ( ) { while ( IsWhite ( Look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( Look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { String Token ; Token = "" ; if ( ! IsAlpha ( Look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( Look ) ) { Token = Token + Character . toUpperCase ( Look ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( Look ) ) Expected ( "Integer" ) ; while ( IsDigit ( Look ) ) { Value = Value + Look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String Name ; Name = GetName ( ) ; if ( Look == '(' ) { Match ( '(' ) ; Match ( ')' ) ; } else { boolean cellRef = true ; if ( cellRef ) { operationsList . add ( new ValueReferencePtg ( ) ) ; } else { } } } private void Factor ( ) { if ( Look == '(' ) { Match ( '(' ) ; operationsList . add ( new ParenthesisPtg ( ) ) ; Expression ( ) ; Match ( ')' ) ; operationsList . add ( new ParenthesisPtg ( ) ) ; return ; } else if ( IsAlpha ( Look ) ) { Ident ( ) ; } else { IntPtg p = new IntPtg ( ) ; p . setValue ( Short . parseShort ( GetNum ( ) ) ) ; operandsList . add ( p ) ; } } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; operationsList . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; operationsList . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( Look == '*' || Look == '/' ) { if ( Look == '*' ) Multiply ( ) ; if ( Look == '/' ) Divide ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; operationsList . add ( new AddPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; operationsList . add ( new SubtractPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( Look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( Look ) ) { EmitLn ( "MOVE D0,-(SP)" ) ; if ( Look == '+' ) Add ( ) ; if ( Look == '-' ) Subtract ( ) ; } } private void Init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { Init ( ) ; Expression ( ) ; tokenToRPN ( ) ; } private void tokenToRPN ( ) { OperationPtg op ; Ptg operand ; int numOper = 0 ; int numOnStack = 0 ; result . add ( operandsList . pop ( ) ) ; numOnStack ++ ; while ( ! operationsList . isEmpty ( ) ) { op = ( OperationPtg ) operationsList . pop ( ) ; if ( op instanceof ParenthesisPtg ) { } for ( numOper = op . getNumberOfOperands ( ) ; numOper > 0 ; numOper -- ) { if ( numOnStack == 0 ) { result . add ( operandsList . pop ( ) ) ; } else { numOnStack -- ; } } result . add ( op ) ; numOnStack ++ ; } } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) result . get ( i ) ) . toFormulaString ( ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } public static void main ( String [ ] argv ) { FormulaParser fp = new FormulaParser ( argv [ 0 ] + ";" ) ; fp . parse ( ) ; System . out . println ( fp . toString ( ) ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class ChartFormatRecord extends Record { public static final short sid = 0x1014 ; private int field1_x_position ; private int field2_y_position ; private int field3_width ; private int field4_height ; private short field5_grbit ; private BitField varyDisplayPattern = new BitField ( 0x01 ) ; public ChartFormatRecord ( ) { } public ChartFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ChartFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CHARTFORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field1_x_position = LittleEndian . getInt ( data , 0 + offset ) ; field2_y_position = LittleEndian . getInt ( data , 4 + offset ) ; field3_width = LittleEndian . getInt ( data , 8 + offset ) ; field4_height = LittleEndian . getInt ( data , 12 + offset ) ; field5_grbit = LittleEndian . getShort ( data , 16 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CHARTFORMAT]\n" ) ; buffer . append ( "    .xPosition       = " ) . append ( getXPosition ( ) ) . append ( "\n" ) ; buffer . append ( "    .yPosition       = " ) . append ( getYPosition ( ) ) . append ( "\n" ) ; buffer . append ( "    .width           = " ) . append ( getWidth ( ) ) . append ( "\n" ) ; buffer . append ( "    .height          = " ) . append ( getHeight ( ) ) . append ( "\n" ) ; buffer . append ( "    .grBit           = " ) . append ( Integer . toHexString ( field5_grbit ) ) . append ( "\n" ) ; buffer . append ( "[/CHARTFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 22 ) ) ; LittleEndian . putInt ( data , 4 + offset , getXPosition ( ) ) ; LittleEndian . putInt ( data , 8 + offset , getYPosition ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getWidth ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getHeight ( ) ) ; LittleEndian . putShort ( data , 20 + offset , field5_grbit ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } public int getXPosition ( ) { return field1_x_position ; } public void setXPosition ( int xPosition ) { this . field1_x_position = xPosition ; } public int getYPosition ( ) { return field2_y_position ; } public void setYPosition ( int yPosition ) { this . field2_y_position = yPosition ; } public int getWidth ( ) { return field3_width ; } public void setWidth ( int width ) { this . field3_width = width ; } public int getHeight ( ) { return field4_height ; } public void setHeight ( int height ) { this . field4_height = height ; } public boolean getVaryDisplayPattern ( ) { return varyDisplayPattern . isSet ( field5_grbit ) ; } public void setVaryDisplayPattern ( boolean value ) { field5_grbit = varyDisplayPattern . setShortBoolean ( field5_grbit , value ) ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . hpsf . littleendian . * ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; private ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } private int offset ; public int getOffset ( ) { return offset ; } private int size ; public int getSize ( ) { return size ; } private int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } private Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = new DWord ( src , offset ) . intValue ( ) ; offset = this . offset ; size = new DWord ( src , offset ) . intValue ( ) ; offset += DWord . LENGTH ; propertyCount = new DWord ( src , offset ) . intValue ( ) ; offset += DWord . LENGTH ; properties = new Property [ propertyCount ] ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = new DWord ( src , offset ) . intValue ( ) ; offset += DWord . LENGTH ; final int sOffset = new DWord ( src , offset ) . intValue ( ) ; offset += DWord . LENGTH ; int length ; if ( i == properties . length - 1 ) length = src . length - this . offset - sOffset ; else length = new DWord ( src , offset + DWord . LENGTH ) . intValue ( ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } protected Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Integer i = ( Integer ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . util . * ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; public class DocumentNode extends EntryNode implements DocumentEntry , POIFSViewable { private POIFSDocument _document ; DocumentNode ( final DocumentProperty property , final DirectoryNode parent ) { super ( property , parent ) ; _document = property . getDocument ( ) ; } POIFSDocument getDocument ( ) { return _document ; } public int getSize ( ) { return getProperty ( ) . getSize ( ) ; } public boolean isDocumentEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return true ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; components . add ( _document ) ; return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RowRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; public class RowRecordsAggregate extends Record { int firstrow = - 1 ; int lastrow = - 1 ; HashMap records = null ; int size = 0 ; public RowRecordsAggregate ( ) { records = new HashMap ( ) ; } public void insertRow ( RowRecord row ) { size += row . getRecordSize ( ) ; records . put ( row , row ) ; if ( ( row . getRowNumber ( ) < firstrow ) || ( firstrow == - 1 ) ) { firstrow = row . getRowNumber ( ) ; } if ( ( row . getRowNumber ( ) > lastrow ) || ( lastrow == - 1 ) ) { lastrow = row . getRowNumber ( ) ; } } public void removeRow ( RowRecord row ) { size -= row . getRecordSize ( ) ; records . remove ( row ) ; } public RowRecord getRow ( int rownum ) { RowRecord row = new RowRecord ( ) ; row . setRowNumber ( ( short ) rownum ) ; return ( RowRecord ) records . get ( row ) ; } public int getPhysicalNumberOfRows ( ) { return records . size ( ) ; } public int getFirstRowNum ( ) { return firstrow ; } public int getLastRowNum ( ) { return lastrow ; } public int construct ( int offset , List records ) { int k = 0 ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec . getSid ( ) == RowRecord . sid ) { insertRow ( ( RowRecord ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return - 1000 ; } public int getRecordSize ( ) { return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } } 	1
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableReader { public static BlockList getSmallDocumentBlocks ( final RawDataBlockList blockList , final RootProperty root , final int sbatStart ) throws IOException { BlockList list = new SmallDocumentBlockList ( SmallDocumentBlock . extract ( blockList . fetchBlocks ( root . getStartBlock ( ) ) ) ) ; new BlockAllocationTableReader ( blockList . fetchBlocks ( sbatStart ) , list ) ; return list ; } } 	0
package org . apache . poi . hssf . record ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class SelectionRecord extends Record { public final static short sid = 0x1d ; private byte field_1_pane ; private short field_2_row_active_cell ; private short field_3_col_active_cell ; private short field_4_ref_active_cell ; private short field_5_num_refs ; private ArrayList field_6_refs ; public SelectionRecord ( ) { } public SelectionRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SelectionRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid Selection RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_pane = data [ 0 + offset ] ; field_2_row_active_cell = LittleEndian . getShort ( data , 1 + offset ) ; field_3_col_active_cell = LittleEndian . getShort ( data , 3 + offset ) ; field_4_ref_active_cell = LittleEndian . getShort ( data , 5 + offset ) ; field_5_num_refs = LittleEndian . getShort ( data , 7 + offset ) ; } public void setPane ( byte pane ) { field_1_pane = pane ; } public void setActiveCellRow ( short row ) { field_2_row_active_cell = row ; } public void setActiveCellCol ( short col ) { field_3_col_active_cell = col ; } public void setActiveCellRef ( short ref ) { field_4_ref_active_cell = ref ; } public void setNumRefs ( short refs ) { field_5_num_refs = refs ; } public byte getPane ( ) { return field_1_pane ; } public short getActiveCellRow ( ) { return field_2_row_active_cell ; } public short getActiveCellCol ( ) { return field_3_col_active_cell ; } public short getActiveCellRef ( ) { return field_4_ref_active_cell ; } public short getNumRefs ( ) { return field_5_num_refs ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SELECTION]\n" ) ; buffer . append ( "    .pane            = " ) . append ( Integer . toHexString ( getPane ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .activecellrow   = " ) . append ( Integer . toHexString ( getActiveCellRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .activecellcol   = " ) . append ( Integer . toHexString ( getActiveCellCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .activecellref   = " ) . append ( Integer . toHexString ( getActiveCellRef ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .numrefs         = " ) . append ( Integer . toHexString ( getNumRefs ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/SELECTION]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 15 ) ; data [ 4 + offset ] = getPane ( ) ; LittleEndian . putShort ( data , 5 + offset , getActiveCellRow ( ) ) ; LittleEndian . putShort ( data , 7 + offset , getActiveCellCol ( ) ) ; LittleEndian . putShort ( data , 9 + offset , getActiveCellRef ( ) ) ; LittleEndian . putShort ( data , 11 + offset , ( short ) 1 ) ; LittleEndian . putShort ( data , 13 + offset , ( short ) 0 ) ; LittleEndian . putShort ( data , 15 + offset , ( short ) 0 ) ; data [ 17 + offset ] = 0 ; data [ 18 + offset ] = 0 ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 19 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; class SSTDeserializer { private BinaryTree strings ; private int continuationReadChars ; private String unfinishedString ; private boolean wideChar ; private boolean richText ; private boolean extendedText ; private short runCount ; private int charCount ; private int extensionLength ; private int continueSkipBytes = 0 ; public SSTDeserializer ( BinaryTree strings ) { this . strings = strings ; initVars ( ) ; } private void initVars ( ) { runCount = 0 ; continuationReadChars = 0 ; unfinishedString = "" ; wideChar = false ; richText = false ; extendedText = false ; continueSkipBytes = 0 ; } public void manufactureStrings ( final byte [ ] data , final int initialOffset ) { initVars ( ) ; int offset = initialOffset ; final int dataSize = data . length ; while ( offset < dataSize ) { int remaining = dataSize - offset ; if ( ( remaining > 0 ) && ( remaining < LittleEndianConsts . SHORT_SIZE ) ) { throw new RecordFormatException ( "Cannot get length of the last string in SSTRecord" ) ; } if ( remaining == LittleEndianConsts . SHORT_SIZE ) { setContinuationCharsRead ( 0 ) ; unfinishedString = "" ; break ; } charCount = LittleEndian . getUShort ( data , offset ) ; int charsRead = charCount ; readStringHeader ( data , offset ) ; boolean stringContinuesOverContinuation = remaining < totalStringSize ( ) ; if ( stringContinuesOverContinuation ) { int remainingBytes = dataSize - offset - stringHeaderOverhead ( ) ; charsRead = Math . min ( charsRead , calculateCharCount ( remainingBytes ) ) ; setContinuationCharsRead ( charsRead ) ; if ( charsRead == charCount ) { continueSkipBytes = offsetForContinuedRecord ( 0 ) - ( remainingBytes - calculateByteCount ( charsRead ) ) ; } } processString ( data , offset , charsRead ) ; offset += totalStringSize ( ) ; if ( stringContinuesOverContinuation ) { break ; } } } private void readStringHeader ( final byte [ ] data , final int index ) { byte optionFlag = data [ index + LittleEndianConsts . SHORT_SIZE ] ; wideChar = ( optionFlag & 1 ) == 1 ; extendedText = ( optionFlag & 4 ) == 4 ; richText = ( optionFlag & 8 ) == 8 ; runCount = 0 ; if ( richText ) { runCount = LittleEndian . getShort ( data , index + SSTRecord . STRING_MINIMAL_OVERHEAD ) ; } extensionLength = 0 ; if ( extendedText ) { extensionLength = LittleEndian . getInt ( data , index + SSTRecord . STRING_MINIMAL_OVERHEAD + ( richText ? LittleEndianConsts . SHORT_SIZE : 0 ) ) ; } } private int processString ( final byte [ ] data , final int dataIndex , final int characters ) { int length = SSTRecord . STRING_MINIMAL_OVERHEAD + calculateByteCount ( characters ) ; byte [ ] unicodeStringBuffer = new byte [ length ] ; int offset = 0 ; LittleEndian . putUShort ( unicodeStringBuffer , offset , characters ) ; offset += LittleEndianConsts . SHORT_SIZE ; unicodeStringBuffer [ offset ] = data [ dataIndex + offset ] ; int bytesRead = unicodeStringBuffer . length - SSTRecord . STRING_MINIMAL_OVERHEAD ; arraycopy ( data , dataIndex + stringHeaderOverhead ( ) , unicodeStringBuffer , SSTRecord . STRING_MINIMAL_OVERHEAD , bytesRead ) ; UnicodeString string = new UnicodeString ( UnicodeString . sid , ( short ) unicodeStringBuffer . length , unicodeStringBuffer ) ; setContinuationCharsRead ( calculateCharCount ( bytesRead ) ) ; if ( isStringFinished ( ) ) { Integer integer = new Integer ( strings . size ( ) ) ; addToStringTable ( strings , integer , string ) ; } else { unfinishedString = string . getString ( ) ; } return bytesRead ; } private boolean isStringFinished ( ) { return getContinuationCharsRead ( ) == charCount ; } static public void addToStringTable ( BinaryTree strings , Integer integer , UnicodeString string ) { if ( string . isRichText ( ) ) string . setOptionFlags ( ( byte ) ( string . getOptionFlags ( ) & ( ~ 8 ) ) ) ; if ( string . isExtendedText ( ) ) string . setOptionFlags ( ( byte ) ( string . getOptionFlags ( ) & ( ~ 4 ) ) ) ; boolean added = false ; while ( added == false ) { try { strings . put ( integer , string ) ; added = true ; } catch ( Exception ignore ) { string . setString ( string . getString ( ) + " " ) ; } } } private int calculateCharCount ( final int byte_count ) { return byte_count / ( wideChar ? LittleEndianConsts . SHORT_SIZE : LittleEndianConsts . BYTE_SIZE ) ; } public void processContinueRecord ( final byte [ ] record ) { if ( isStringFinished ( ) ) { final int offset = continueSkipBytes ; initVars ( ) ; manufactureStrings ( record , offset ) ; } else { wideChar = ( record [ 0 ] & 1 ) == 1 ; if ( stringSpansContinuation ( record . length - LittleEndianConsts . BYTE_SIZE ) ) { processEntireContinuation ( record ) ; } else { readStringRemainder ( record ) ; } } } private void readStringRemainder ( final byte [ ] record ) { int stringRemainderSizeInBytes = calculateByteCount ( charCount - getContinuationCharsRead ( ) ) ; byte [ ] unicodeStringData = new byte [ SSTRecord . STRING_MINIMAL_OVERHEAD + stringRemainderSizeInBytes ] ; LittleEndian . putShort ( unicodeStringData , 0 , ( short ) ( charCount - getContinuationCharsRead ( ) ) ) ; unicodeStringData [ LittleEndianConsts . SHORT_SIZE ] = createOptionByte ( wideChar , richText , extendedText ) ; arraycopy ( record , LittleEndianConsts . BYTE_SIZE , unicodeStringData , SSTRecord . STRING_MINIMAL_OVERHEAD , stringRemainderSizeInBytes ) ; UnicodeString string = new UnicodeString ( UnicodeString . sid , ( short ) unicodeStringData . length , unicodeStringData , unfinishedString ) ; Integer integer = new Integer ( strings . size ( ) ) ; addToStringTable ( strings , integer , string ) ; int newOffset = offsetForContinuedRecord ( stringRemainderSizeInBytes ) ; manufactureStrings ( record , newOffset ) ; } private int stringSizeInBytes ( ) { return calculateByteCount ( charCount ) ; } private int totalStringSize ( ) { return stringSizeInBytes ( ) + stringHeaderOverhead ( ) + LittleEndianConsts . INT_SIZE * runCount + extensionLength ; } private int stringHeaderOverhead ( ) { return SSTRecord . STRING_MINIMAL_OVERHEAD + ( richText ? LittleEndianConsts . SHORT_SIZE : 0 ) + ( extendedText ? LittleEndianConsts . INT_SIZE : 0 ) ; } private int offsetForContinuedRecord ( int stringRemainderSizeInBytes ) { int offset = stringRemainderSizeInBytes + runCount * LittleEndianConsts . INT_SIZE + extensionLength ; if ( stringRemainderSizeInBytes != 0 ) offset += + LittleEndianConsts . BYTE_SIZE ; return offset ; } private byte createOptionByte ( boolean wideChar , boolean richText , boolean farEast ) { return ( byte ) ( ( wideChar ? 1 : 0 ) + ( farEast ? 4 : 0 ) + ( richText ? 8 : 0 ) ) ; } private void processEntireContinuation ( final byte [ ] record ) { int dataLengthInBytes = record . length - LittleEndianConsts . BYTE_SIZE ; byte [ ] unicodeStringData = new byte [ record . length + LittleEndianConsts . SHORT_SIZE ] ; int charsRead = calculateCharCount ( dataLengthInBytes ) ; LittleEndian . putShort ( unicodeStringData , ( byte ) 0 , ( short ) charsRead ) ; arraycopy ( record , 0 , unicodeStringData , LittleEndianConsts . SHORT_SIZE , record . length ) ; UnicodeString ucs = new UnicodeString ( UnicodeString . sid , ( short ) unicodeStringData . length , unicodeStringData , unfinishedString ) ; unfinishedString = ucs . getString ( ) ; setContinuationCharsRead ( getContinuationCharsRead ( ) + charsRead ) ; if ( getContinuationCharsRead ( ) == charCount ) { Integer integer = new Integer ( strings . size ( ) ) ; addToStringTable ( strings , integer , ucs ) ; } } private boolean stringSpansContinuation ( int continuationSizeInBytes ) { return calculateByteCount ( charCount - getContinuationCharsRead ( ) ) > continuationSizeInBytes ; } int getContinuationCharsRead ( ) { return continuationReadChars ; } private void setContinuationCharsRead ( final int count ) { continuationReadChars = count ; } private int calculateByteCount ( final int character_count ) { return character_count * ( wideChar ? LittleEndianConsts . SHORT_SIZE : LittleEndianConsts . BYTE_SIZE ) ; } private void arraycopy ( byte [ ] src , int src_position , byte [ ] dst , int dst_position , int length ) { System . arraycopy ( src , src_position , dst , dst_position , length ) ; } String getUnfinishedString ( ) { return unfinishedString ; } boolean isWideChar ( ) { return wideChar ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import org . apache . poi . util . LittleEndian ; public class MergeCellsRecord extends Record { public final static short sid = 0xe5 ; private short field_1_num_areas ; private ArrayList field_2_regions ; public MergeCellsRecord ( ) { } public MergeCellsRecord ( short sid , short size , byte [ ] data ) { super ( sid , size , data ) ; } public MergeCellsRecord ( short sid , short size , byte [ ] data , int offset ) { super ( sid , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_num_areas = LittleEndian . getShort ( data , 0 + offset ) ; field_2_regions = new ArrayList ( field_1_num_areas + 10 ) ; int pos = 2 ; for ( int k = 0 ; k < field_1_num_areas ; k ++ ) { MergedRegion region = new MergedRegion ( LittleEndian . getShort ( data , pos + offset ) , LittleEndian . getShort ( data , pos + 2 + offset ) , LittleEndian . getShort ( data , pos + 4 + offset ) , LittleEndian . getShort ( data , pos + 6 + offset ) ) ; pos += 8 ; field_2_regions . add ( region ) ; } } public short getNumAreas ( ) { return field_1_num_areas ; } public void setNumAreas ( short numareas ) { field_1_num_areas = numareas ; } public int addArea ( int rowfrom , short colfrom , int rowto , short colto ) { if ( field_2_regions == null ) { field_2_regions = new ArrayList ( 10 ) ; } MergedRegion region = new MergedRegion ( rowfrom , rowto , colfrom , colto ) ; field_2_regions . add ( region ) ; field_1_num_areas ++ ; return field_2_regions . size ( ) - 1 ; } public void removeAreaAt ( int area ) { field_2_regions . remove ( area ) ; field_1_num_areas -- ; } public MergedRegion getAreaAt ( int index ) { return ( MergedRegion ) field_2_regions . get ( index ) ; } public int getRecordSize ( ) { int retValue ; retValue = 6 + ( 8 * field_2_regions . size ( ) ) ; return retValue ; } public short getSid ( ) { return sid ; } public int serialize ( int offset , byte [ ] data ) { int recordsize = getRecordSize ( ) ; int pos = 6 ; LittleEndian . putShort ( data , offset + 0 , sid ) ; LittleEndian . putShort ( data , offset + 2 , ( short ) ( recordsize - 4 ) ) ; LittleEndian . putShort ( data , offset + 4 , getNumAreas ( ) ) ; for ( int k = 0 ; k < getNumAreas ( ) ; k ++ ) { MergedRegion region = getAreaAt ( k ) ; LittleEndian . putShort ( data , offset + pos , ( short ) region . row_from ) ; pos += 2 ; LittleEndian . putShort ( data , offset + pos , ( short ) region . row_to ) ; pos += 2 ; LittleEndian . putShort ( data , offset + pos , region . col_from ) ; pos += 2 ; LittleEndian . putShort ( data , offset + pos , region . col_to ) ; pos += 2 ; } return recordsize ; } public String toString ( ) { StringBuffer retval = new StringBuffer ( ) ; retval . append ( "[MERGEDCELLS]" ) . append ( "\n" ) ; retval . append ( "     .sid        =" ) . append ( sid ) . append ( "\n" ) ; retval . append ( "     .numregions =" ) . append ( field_1_num_areas ) . append ( "\n" ) ; for ( int k = 0 ; k < field_1_num_areas ; k ++ ) { MergedRegion region = ( MergedRegion ) field_2_regions . get ( k ) ; retval . append ( "     .rowfrom    =" ) . append ( region . row_from ) . append ( "\n" ) ; retval . append ( "     .colfrom    =" ) . append ( region . col_from ) . append ( "\n" ) ; retval . append ( "     .rowto      =" ) . append ( region . row_to ) . append ( "\n" ) ; retval . append ( "     .colto      =" ) . append ( region . col_to ) . append ( "\n" ) ; } retval . append ( "[MERGEDCELLS]" ) . append ( "\n" ) ; return retval . toString ( ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A MERGEDCELLS RECORD!! " + id ) ; } } public class MergedRegion { public MergedRegion ( int row_from , int row_to , short col_from , short col_to ) { this . row_from = row_from ; this . row_to = row_to ; this . col_from = col_from ; this . col_to = col_to ; } public int row_from ; public int row_to ; public short col_from ; public short col_to ; } public Object clone ( ) { MergeCellsRecord rec = new MergeCellsRecord ( ) ; rec . field_1_num_areas = field_1_num_areas ; rec . field_2_regions = field_2_regions ; return rec ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class WindowProtectRecord extends Record { public final static short sid = 0x19 ; private short field_1_protect ; public WindowProtectRecord ( ) { } public WindowProtectRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowProtectRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WINDOWPROTECT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect == true ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public boolean getProtect ( ) { return ( field_1_protect == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOWPROTECT]\n" ) ; buffer . append ( "    .protect         = " ) . append ( getProtect ( ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOWPROTECT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_protect ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class ConcatPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x08 ; private final static String CONCAT = "&" ; public ConcatPtg ( byte [ ] data , int offset ) { } public ConcatPtg ( ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return CONCAT ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( CONCAT ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new ConcatPtg ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class DataFormatRecord extends Record { public final static short sid = 0x1006 ; private short field_1_pointNumber ; private short field_2_seriesIndex ; private short field_3_seriesNumber ; private short field_4_formatFlags ; private BitField useExcel4Colors = new BitField ( 0x1 ) ; public DataFormatRecord ( ) { } public DataFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DataFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a DataFormat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_pointNumber = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_seriesIndex = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_seriesNumber = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_4_formatFlags = LittleEndian . getShort ( data , pos + 0x6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DATAFORMAT]\n" ) ; buffer . append ( "    .pointNumber          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getPointNumber ( ) ) ) . append ( " (" ) . append ( getPointNumber ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .seriesIndex          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getSeriesIndex ( ) ) ) . append ( " (" ) . append ( getSeriesIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .seriesNumber         = " ) . append ( "0x" ) . append ( HexDump . toHex ( getSeriesNumber ( ) ) ) . append ( " (" ) . append ( getSeriesNumber ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .useExcel4Colors          = " ) . append ( isUseExcel4Colors ( ) ) . append ( '\n' ) ; buffer . append ( "[/DATAFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_pointNumber ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_seriesIndex ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_seriesNumber ) ; LittleEndian . putShort ( data , 10 + offset + pos , field_4_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { DataFormatRecord rec = new DataFormatRecord ( ) ; rec . field_1_pointNumber = field_1_pointNumber ; rec . field_2_seriesIndex = field_2_seriesIndex ; rec . field_3_seriesNumber = field_3_seriesNumber ; rec . field_4_formatFlags = field_4_formatFlags ; return rec ; } public short getPointNumber ( ) { return field_1_pointNumber ; } public void setPointNumber ( short field_1_pointNumber ) { this . field_1_pointNumber = field_1_pointNumber ; } public short getSeriesIndex ( ) { return field_2_seriesIndex ; } public void setSeriesIndex ( short field_2_seriesIndex ) { this . field_2_seriesIndex = field_2_seriesIndex ; } public short getSeriesNumber ( ) { return field_3_seriesNumber ; } public void setSeriesNumber ( short field_3_seriesNumber ) { this . field_3_seriesNumber = field_3_seriesNumber ; } public short getFormatFlags ( ) { return field_4_formatFlags ; } public void setFormatFlags ( short field_4_formatFlags ) { this . field_4_formatFlags = field_4_formatFlags ; } public void setUseExcel4Colors ( boolean value ) { field_4_formatFlags = useExcel4Colors . setShortBoolean ( field_4_formatFlags , value ) ; } public boolean isUseExcel4Colors ( ) { return useExcel4Colors . isSet ( field_4_formatFlags ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import java . util . ArrayList ; public class ExternSheetRecord extends Record { public final static short sid = 0x17 ; private short field_1_number_of_REF_sturcutres ; private ArrayList field_2_REF_structures ; public ExternSheetRecord ( ) { field_2_REF_structures = new ArrayList ( ) ; } public ExternSheetRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExternSheetRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An ExternSheet RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_2_REF_structures = new ArrayList ( ) ; field_1_number_of_REF_sturcutres = LittleEndian . getShort ( data , 0 + offset ) ; int pos = 2 + offset ; for ( int i = 0 ; i < field_1_number_of_REF_sturcutres ; ++ i ) { ExternSheetSubRecord rec = new ExternSheetSubRecord ( ( short ) 0 , ( short ) 6 , data , pos ) ; pos += 6 ; field_2_REF_structures . add ( rec ) ; } } public void setNumOfREFStructures ( short numStruct ) { field_1_number_of_REF_sturcutres = numStruct ; } public short getNumOfREFStructures ( ) { return field_1_number_of_REF_sturcutres ; } public void addREFRecord ( ExternSheetSubRecord rec ) { field_2_REF_structures . add ( rec ) ; } public int getNumOfREFRecords ( ) { return field_2_REF_structures . size ( ) ; } public ExternSheetSubRecord getREFRecordAt ( int elem ) { ExternSheetSubRecord result = ( ExternSheetSubRecord ) field_2_REF_structures . get ( elem ) ; return result ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTERNSHEET]\n" ) ; buffer . append ( "   numOfRefs     = " ) . append ( getNumOfREFStructures ( ) ) . append ( "\n" ) ; for ( int k = 0 ; k < this . getNumOfREFRecords ( ) ; k ++ ) { buffer . append ( "refrec         #" ) . append ( k ) . append ( '\n' ) ; buffer . append ( getREFRecordAt ( k ) . toString ( ) ) ; buffer . append ( "----refrec     #" ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/EXTERNSHEET]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 2 + ( getNumOfREFRecords ( ) * 6 ) ) ) ; LittleEndian . putShort ( data , 4 + offset , getNumOfREFStructures ( ) ) ; int pos = 6 ; for ( int k = 0 ; k < getNumOfREFRecords ( ) ; k ++ ) { ExternSheetSubRecord record = getREFRecordAt ( k ) ; System . arraycopy ( record . serialize ( ) , 0 , data , pos + offset , 6 ) ; pos += 6 ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + getNumOfREFRecords ( ) * 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . hssf . util ; public class RangeAddress { final static int WRONG_POS = - 1 ; final static int MAX_HEIGHT = 66666 ; final static char SO_FORMNAME_ENCLOSURE = '\'' ; String m_sheetName ; String m_cellFrom ; String m_cellTo ; public RangeAddress ( String _url ) { init ( _url ) ; } public RangeAddress ( int _startCol , int _startRow , int _endCol , int _endRow ) { init ( numTo26Sys ( _startCol ) + _startRow + ":" + numTo26Sys ( _endCol ) + _endRow ) ; } public String getAddress ( ) { String result = "" ; if ( m_sheetName != null ) result += m_sheetName + "!" ; if ( m_cellFrom != null ) { result += m_cellFrom ; if ( m_cellTo != null ) result += ":" + m_cellTo ; } return result ; } public String getSheetName ( ) { return m_sheetName ; } public String getRange ( ) { String result = "" ; if ( m_cellFrom != null ) { result += m_cellFrom ; if ( m_cellTo != null ) result += ":" + m_cellTo ; } return result ; } public boolean isCellOk ( String _cell ) { if ( _cell != null ) { if ( ( getYPosition ( _cell ) != WRONG_POS ) && ( getXPosition ( _cell ) != WRONG_POS ) ) return true ; else return false ; } else return false ; } public boolean isSheetNameOk ( ) { return isSheetNameOk ( m_sheetName ) ; } private static boolean intern_isSheetNameOk ( String _sheetName , boolean _canBeWaitSpace ) { for ( int i = 0 ; i < _sheetName . length ( ) ; i ++ ) { char ch = _sheetName . charAt ( i ) ; if ( ! ( Character . isLetterOrDigit ( ch ) || ( ch == '_' ) || _canBeWaitSpace && ( ch == ' ' ) ) ) { return false ; } } return true ; } public static boolean isSheetNameOk ( String _sheetName ) { boolean res = false ; if ( ( _sheetName != null ) && ! _sheetName . equals ( "" ) ) { res = intern_isSheetNameOk ( _sheetName , true ) ; } else res = true ; return res ; } public String getFromCell ( ) { return m_cellFrom ; } public String getToCell ( ) { return m_cellTo ; } public int getWidth ( ) { if ( m_cellFrom != null && m_cellTo != null ) { int toX = getXPosition ( m_cellTo ) ; int fromX = getXPosition ( m_cellFrom ) ; if ( ( toX == WRONG_POS ) || ( fromX == WRONG_POS ) ) { return 0 ; } else return toX - fromX + 1 ; } return 0 ; } public int getHeight ( ) { if ( m_cellFrom != null && m_cellTo != null ) { int toY = getYPosition ( m_cellTo ) ; int fromY = getYPosition ( m_cellFrom ) ; if ( ( toY == WRONG_POS ) || ( fromY == WRONG_POS ) ) { return 0 ; } else return toY - fromY + 1 ; } return 0 ; } public void setSize ( int _width , int _height ) { if ( m_cellFrom == null ) m_cellFrom = "a1" ; int tlX , tlY , rbX , rbY ; tlX = getXPosition ( m_cellFrom ) ; tlY = getYPosition ( m_cellFrom ) ; m_cellTo = numTo26Sys ( tlX + _width - 1 ) ; m_cellTo += String . valueOf ( tlY + _height - 1 ) ; } public boolean hasSheetName ( ) { if ( m_sheetName == null ) return false ; return true ; } public boolean hasRange ( ) { if ( m_cellFrom == null || m_cellTo == null ) return false ; return true ; } public boolean hasCell ( ) { if ( m_cellFrom == null ) return false ; return true ; } private void init ( String _url ) { _url = removeString ( _url , "$" ) ; _url = removeString ( _url , "'" ) ; String [ ] urls = parseURL ( _url ) ; m_sheetName = urls [ 0 ] ; m_cellFrom = urls [ 1 ] ; m_cellTo = urls [ 2 ] ; if ( m_cellTo == null ) { m_cellTo = m_cellFrom ; } m_cellTo = removeString ( m_cellTo , "." ) ; } private String [ ] parseURL ( String _url ) { String [ ] result = new String [ 3 ] ; int index = _url . indexOf ( ':' ) ; if ( index >= 0 ) { String fromStr = _url . substring ( 0 , index ) ; String toStr = _url . substring ( index + 1 ) ; index = fromStr . indexOf ( '!' ) ; if ( index >= 0 ) { result [ 0 ] = fromStr . substring ( 0 , index ) ; result [ 1 ] = fromStr . substring ( index + 1 ) ; } else { result [ 1 ] = fromStr ; } index = toStr . indexOf ( '!' ) ; if ( index >= 0 ) { result [ 2 ] = toStr . substring ( index + 1 ) ; } else { result [ 2 ] = toStr ; } } else { index = _url . indexOf ( '!' ) ; if ( index >= 0 ) { result [ 0 ] = _url . substring ( 0 , index ) ; result [ 1 ] = _url . substring ( index + 1 ) ; } else { result [ 1 ] = _url ; } } return result ; } public int getYPosition ( String _subrange ) { int result = WRONG_POS ; _subrange = _subrange . trim ( ) ; if ( _subrange . length ( ) != 0 ) { String digitstr = getDigitPart ( _subrange ) ; try { result = Integer . parseInt ( digitstr ) ; if ( result > MAX_HEIGHT ) { result = WRONG_POS ; } } catch ( Exception ex ) { result = WRONG_POS ; } } return result ; } private static boolean isLetter ( String _str ) { boolean res = true ; if ( ! _str . equals ( "" ) ) { for ( int i = 0 ; i < _str . length ( ) ; i ++ ) { char ch = _str . charAt ( i ) ; if ( ! Character . isLetter ( ch ) ) { res = false ; break ; } } } else res = false ; return res ; } public int getXPosition ( String _subrange ) { int result = WRONG_POS ; String tmp = filter$ ( _subrange ) ; tmp = this . getCharPart ( _subrange ) ; if ( isLetter ( tmp ) && ( ( tmp . length ( ) == 2 ) || ( tmp . length ( ) == 1 ) ) ) { result = get26Sys ( tmp ) ; } return result ; } public String getDigitPart ( String _value ) { String result = "" ; int digitpos = getFirstDigitPosition ( _value ) ; if ( digitpos >= 0 ) { result = _value . substring ( digitpos ) ; } return result ; } public String getCharPart ( String _value ) { String result = "" ; int digitpos = getFirstDigitPosition ( _value ) ; if ( digitpos >= 0 ) { result = _value . substring ( 0 , digitpos ) ; } return result ; } private String filter$ ( String _range ) { String res = "" ; for ( int i = 0 ; i < _range . length ( ) ; i ++ ) { char ch = _range . charAt ( i ) ; if ( ch != '$' ) { res = res + ch ; } } return res ; } private int getFirstDigitPosition ( String _value ) { int result = WRONG_POS ; if ( _value != null && _value . trim ( ) . length ( ) == 0 ) { return result ; } _value = _value . trim ( ) ; int length = _value . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( Character . isDigit ( _value . charAt ( i ) ) ) { result = i ; break ; } } return result ; } public int get26Sys ( String _s ) { int sum = 0 ; int multiplier = 1 ; if ( _s != "" ) { for ( int i = _s . length ( ) - 1 ; i >= 0 ; i -- ) { char ch = _s . charAt ( i ) ; int val = Character . getNumericValue ( ch ) - Character . getNumericValue ( 'A' ) + 1 ; sum = sum + val * multiplier ; multiplier = multiplier * 26 ; } return sum ; } return WRONG_POS ; } public String numTo26Sys ( int _num ) { int sum = 0 ; int reminder ; String s = "" ; do { _num -- ; reminder = _num % 26 ; int val = 65 + reminder ; _num = _num / 26 ; s = ( char ) val + s ; } while ( _num > 0 ) ; return s ; } public String replaceString ( String _source , String _oldPattern , String _newPattern ) { StringBuffer res = new StringBuffer ( _source ) ; int pos = - 1 ; while ( ( pos = res . toString ( ) . indexOf ( _oldPattern , pos ) ) > - 1 ) { res . replace ( pos , pos + _oldPattern . length ( ) , _newPattern ) ; } return res . toString ( ) ; } public String removeString ( String _source , String _match ) { return replaceString ( _source , _match , "" ) ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class MulBlankRecord extends Record { public final static short sid = 0xbe ; private int field_1_row ; private short field_2_first_col ; private short [ ] field_3_xfs ; private short field_4_last_col ; public MulBlankRecord ( ) { } public MulBlankRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MulBlankRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public int getRow ( ) { return field_1_row ; } public short getFirstColumn ( ) { return field_2_first_col ; } public short getLastColumn ( ) { return field_4_last_col ; } public int getNumColumns ( ) { return field_4_last_col - field_2_first_col + 1 ; } public short getXFAt ( int coffset ) { return field_3_xfs [ coffset ] ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_first_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xfs = parseXFs ( data , 4 , offset , size ) ; field_4_last_col = LittleEndian . getShort ( data , ( field_3_xfs . length * 2 ) + 4 + offset ) ; } private short [ ] parseXFs ( byte [ ] data , int offset , int recoffset , short size ) { short [ ] retval = new short [ ( ( size - offset ) - 2 ) / 2 ] ; int idx = 0 ; for ( ; offset < size - 2 ; ) { short xf = 0 ; xf = LittleEndian . getShort ( data , offset + recoffset ) ; offset += 2 ; retval [ idx ] = xf ; idx ++ ; } return retval ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MULBLANK]\n" ) ; buffer . append ( "row  = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "firstcol  = " ) . append ( Integer . toHexString ( getFirstColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( " lastcol  = " ) . append ( Integer . toHexString ( getLastColumn ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumColumns ( ) ; k ++ ) { buffer . append ( "xf" ) . append ( k ) . append ( "        = " ) . append ( Integer . toHexString ( getXFAt ( k ) ) ) . append ( "\n" ) ; } buffer . append ( "[/MULBLANK]\n" ) ; return buffer . toString ( ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a MulBlankRecord!" ) ; } } public short getSid ( ) { return this . sid ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "Sorry, you can't serialize a MulBlank in this release" ) ; } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PrintGridlinesRecord extends Record { public final static short sid = 0x2b ; private short field_1_print_gridlines ; public PrintGridlinesRecord ( ) { } public PrintGridlinesRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PrintGridlinesRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PrintGridlines RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_print_gridlines = LittleEndian . getShort ( data , 0 + offset ) ; } public void setPrintGridlines ( boolean pg ) { if ( pg == true ) { field_1_print_gridlines = 1 ; } else { field_1_print_gridlines = 0 ; } } public boolean getPrintGridlines ( ) { return ( field_1_print_gridlines == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PRINTGRIDLINES]\n" ) ; buffer . append ( "    .printgridlines = " ) . append ( getPrintGridlines ( ) ) . append ( "\n" ) ; buffer . append ( "[/PRINTGRIDLINES]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_print_gridlines ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { PrintGridlinesRecord rec = new PrintGridlinesRecord ( ) ; rec . field_1_print_gridlines = field_1_print_gridlines ; return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1
package org . apache . poi . poifs . property ; import java . util . Iterator ; import java . io . IOException ; public interface Parent extends Child { public Iterator getChildren ( ) ; public void addChild ( final Property property ) throws IOException ; public void setPreviousChild ( final Child child ) ; public void setNextChild ( final Child child ) ; } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class LabelRecord extends Record implements CellValueRecordInterface { public final static short sid = 0x204 ; private int field_1_row ; private short field_2_column ; private short field_3_xf_index ; private short field_4_string_len ; private byte field_5_unicode_flag ; private String field_6_value ; public LabelRecord ( ) { } public LabelRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LabelRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != this . sid ) { throw new RecordFormatException ( "Not a valid LabelRecord" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_column = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_string_len = LittleEndian . getShort ( data , 6 + offset ) ; field_5_unicode_flag = data [ 8 + offset ] ; if ( field_4_string_len > 0 ) { if ( isUnCompressedUnicode ( ) ) { field_6_value = StringUtil . getFromUnicode ( data , 9 + offset , field_4_string_len ) ; } else { field_6_value = StringUtil . getFromCompressedUnicode ( data , 9 + offset , getStringLength ( ) ) ; } } else field_6_value = null ; } public int getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_column ; } public short getXFIndex ( ) { return field_3_xf_index ; } public short getStringLength ( ) { return field_4_string_len ; } public boolean isUnCompressedUnicode ( ) { return ( field_5_unicode_flag == 1 ) ; } public String getValue ( ) { return field_6_value ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "Label Records are supported READ ONLY...convert to LabelSST" ) ; } public short getSid ( ) { return this . sid ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[LABEL]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .column         = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .string_len       = " ) . append ( Integer . toHexString ( field_4_string_len ) ) . append ( "\n" ) ; buffer . append ( "    .unicode_flag       = " ) . append ( Integer . toHexString ( field_5_unicode_flag ) ) . append ( "\n" ) ; buffer . append ( "    .value       = " ) . append ( getValue ( ) ) . append ( "\n" ) ; buffer . append ( "[/LABEL]\n" ) ; return buffer . toString ( ) ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public void setColumn ( short col ) { } public void setRow ( int row ) { } public void setXFIndex ( short xf ) { } public Object clone ( ) { LabelRecord rec = new LabelRecord ( ) ; rec . field_1_row = field_1_row ; rec . field_2_column = field_2_column ; rec . field_3_xf_index = field_3_xf_index ; rec . field_4_string_len = field_4_string_len ; rec . field_5_unicode_flag = field_5_unicode_flag ; rec . field_6_value = field_6_value ; return rec ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class FooterRecord extends Record { public final static short sid = 0x15 ; private byte field_1_footer_len ; private String field_2_footer ; public FooterRecord ( ) { } public FooterRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FooterRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FooterRECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { if ( size > 0 ) { field_1_footer_len = data [ 0 + offset ] ; field_2_footer = StringUtil . getFromCompressedUnicode ( data , 3 + offset , LittleEndian . ubyteToInt ( field_1_footer_len ) ) ; } } public void setFooterLength ( byte len ) { field_1_footer_len = len ; } public void setFooter ( String footer ) { field_2_footer = footer ; } public short getFooterLength ( ) { return ( short ) ( 0xFF & field_1_footer_len ) ; } public String getFooter ( ) { return field_2_footer ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FOOTER]\n" ) ; buffer . append ( "    .footerlen      = " ) . append ( Integer . toHexString ( getFooterLength ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .footer         = " ) . append ( getFooter ( ) ) . append ( "\n" ) ; buffer . append ( "[/FOOTER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int len = 4 ; if ( getFooterLength ( ) > 0 ) { len += 3 ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( ( len - 4 ) + getFooterLength ( ) ) ) ; if ( getFooterLength ( ) > 0 ) { data [ 4 + offset ] = ( byte ) getFooterLength ( ) ; StringUtil . putCompressedUnicode ( getFooter ( ) , data , 7 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 4 ; if ( getFooterLength ( ) > 0 ) { retval += 3 ; } return retval + getFooterLength ( ) ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { FooterRecord rec = new FooterRecord ( ) ; rec . field_1_footer_len = field_1_footer_len ; rec . field_2_footer = field_2_footer ; return rec ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1
package org . apache . poi . hssf . record ; public interface CustomField extends Cloneable { int getSize ( ) ; int fillField ( byte [ ] data , short size , int offset ) ; void toString ( StringBuffer str ) ; int serializeField ( int offset , byte [ ] data ) ; } 	0
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1
package org . apache . poi . hssf . usermodel ; public interface HSSFErrorConstants { public static final byte ERROR_NULL = 0x00 ; public static final byte ERROR_DIV_0 = 0x07 ; public static final byte ERROR_VALUE = 0x0f ; public static final byte ERROR_REF = 0x17 ; public static final byte ERROR_NAME = 0x1d ; public static final byte ERROR_NUM = 0x24 ; public static final byte ERROR_NA = 0x2a ; } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SCLRecord extends Record { public final static short sid = 0xa0 ; private short field_1_numerator ; private short field_2_denominator ; public SCLRecord ( ) { } public SCLRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SCLRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SCL record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_numerator = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_denominator = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SCL]\n" ) ; buffer . append ( "    .numerator            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getNumerator ( ) ) ) . append ( " (" ) . append ( getNumerator ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .denominator          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getDenominator ( ) ) ) . append ( " (" ) . append ( getDenominator ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SCL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_numerator ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_denominator ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SCLRecord rec = new SCLRecord ( ) ; rec . field_1_numerator = field_1_numerator ; rec . field_2_denominator = field_2_denominator ; return rec ; } public short getNumerator ( ) { return field_1_numerator ; } public void setNumerator ( short field_1_numerator ) { this . field_1_numerator = field_1_numerator ; } public short getDenominator ( ) { return field_2_denominator ; } public void setDenominator ( short field_2_denominator ) { this . field_2_denominator = field_2_denominator ; } } 	0
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . Record ; public class NumberRecord extends Record implements CellValueRecordInterface , Comparable { public static final short sid = 0x203 ; private int field_1_row ; private short field_2_col ; private short field_3_xf ; private double field_4_value ; public NumberRecord ( ) { } public NumberRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public NumberRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf = LittleEndian . getShort ( data , 4 + offset ) ; field_4_value = LittleEndian . getDouble ( data , 6 + offset ) ; } public void setRow ( int row ) { field_1_row = row ; } public void setColumn ( short col ) { field_2_col = col ; } public void setXFIndex ( short xf ) { field_3_xf = xf ; } public void setValue ( double value ) { field_4_value = value ; } public int getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_col ; } public short getXFIndex ( ) { return field_3_xf ; } public double getValue ( ) { return field_4_value ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[NUMBER]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .col            = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .value          = " ) . append ( getValue ( ) ) . append ( "\n" ) ; buffer . append ( "[/NUMBER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 14 ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; LittleEndian . putDouble ( data , 10 + offset , getValue ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 18 ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Number RECORD" ) ; } } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } public Object clone ( ) { NumberRecord rec = new NumberRecord ( ) ; rec . field_1_row = field_1_row ; rec . field_2_col = field_2_col ; rec . field_3_xf = field_3_xf ; rec . field_4_value = field_4_value ; return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . record . Record ; public interface ERFListener { public boolean processRecord ( Record rec ) ; } 	0
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class MultiplyPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x05 ; private final static String MULTIPLY = "*" ; public MultiplyPtg ( ) { } public MultiplyPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public int getStringLength ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "*" ; } public String toFormulaString ( Ptg [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] . toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( "*" ) ; buffer . append ( operands [ 1 ] . toFormulaString ( ( Workbook ) null ) ) ; return buffer . toString ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new MultiplyPtg ( ) ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RKUtil ; public class MulRKRecord extends Record { public final static short sid = 0xbd ; private int field_1_row ; private short field_2_first_col ; private ArrayList field_3_rks ; private short field_4_last_col ; public MulRKRecord ( ) { } public MulRKRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MulRKRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public int getRow ( ) { return field_1_row ; } public short getFirstColumn ( ) { return field_2_first_col ; } public short getLastColumn ( ) { return field_4_last_col ; } public int getNumColumns ( ) { return field_4_last_col - field_2_first_col + 1 ; } public short getXFAt ( int coffset ) { return ( ( RkRec ) field_3_rks . get ( coffset ) ) . xf ; } public double getRKNumberAt ( int coffset ) { return RKUtil . decodeNumber ( ( ( RkRec ) field_3_rks . get ( coffset ) ) . rk ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_first_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_rks = parseRKs ( data , 4 , offset , size ) ; field_4_last_col = LittleEndian . getShort ( data , ( field_3_rks . size ( ) * 6 ) + 4 + offset ) ; } private ArrayList parseRKs ( byte [ ] data , int offset , int recoffset , short size ) { ArrayList retval = new ArrayList ( ) ; for ( ; offset < size - 2 ; ) { RkRec rec = new RkRec ( ) ; rec . xf = LittleEndian . getShort ( data , offset + recoffset ) ; offset += 2 ; rec . rk = LittleEndian . getInt ( data , offset + recoffset ) ; offset += 4 ; retval . add ( rec ) ; } return retval ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MULRK]\n" ) ; buffer . append ( "firstcol  = " ) . append ( Integer . toHexString ( getFirstColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( " lastcol  = " ) . append ( Integer . toHexString ( getLastColumn ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumColumns ( ) ; k ++ ) { buffer . append ( "xf" ) . append ( k ) . append ( "        = " ) . append ( Integer . toHexString ( getXFAt ( k ) ) ) . append ( "\n" ) ; buffer . append ( "rk" ) . append ( k ) . append ( "        = " ) . append ( getRKNumberAt ( k ) ) . append ( "\n" ) ; } buffer . append ( "[/MULRK]\n" ) ; return buffer . toString ( ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a MulRKRecord!" ) ; } } public short getSid ( ) { return this . sid ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "Sorry, you can't serialize a MulRK in this release" ) ; } } class RkRec { public short xf ; public int rk ; } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import java . util . ArrayList ; public class ExtSSTRecord extends Record { public static final int DEFAULT_BUCKET_SIZE = 8 ; public static final int MAX_BUCKETS = 128 ; public final static short sid = 0xff ; private short field_1_strings_per_bucket = DEFAULT_BUCKET_SIZE ; private ArrayList field_2_sst_info ; public ExtSSTRecord ( ) { field_2_sst_info = new ArrayList ( ) ; } public ExtSSTRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtSSTRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An EXTSST RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_2_sst_info = new ArrayList ( ) ; field_1_strings_per_bucket = LittleEndian . getShort ( data , 0 + offset ) ; for ( int k = 2 ; k < ( size - offset ) ; k += 8 ) { byte [ ] tempdata = new byte [ 8 + offset ] ; System . arraycopy ( data , k , tempdata , 0 , 8 ) ; ExtSSTInfoSubRecord rec = new ExtSSTInfoSubRecord ( ( short ) 0 , ( short ) 8 , tempdata ) ; field_2_sst_info . add ( rec ) ; } } public void setNumStringsPerBucket ( short numStrings ) { field_1_strings_per_bucket = numStrings ; } public void addInfoRecord ( ExtSSTInfoSubRecord rec ) { field_2_sst_info . add ( rec ) ; } public short getNumStringsPerBucket ( ) { return field_1_strings_per_bucket ; } public int getNumInfoRecords ( ) { return field_2_sst_info . size ( ) ; } public ExtSSTInfoSubRecord getInfoRecordAt ( int elem ) { return ( ExtSSTInfoSubRecord ) field_2_sst_info . get ( elem ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTSST]\n" ) ; buffer . append ( "    .dsst           = " ) . append ( Integer . toHexString ( getNumStringsPerBucket ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .numInfoRecords = " ) . append ( getNumInfoRecords ( ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumInfoRecords ( ) ; k ++ ) { buffer . append ( "    .inforecord     = " ) . append ( k ) . append ( "\n" ) ; buffer . append ( "    .streampos      = " ) . append ( Integer . toHexString ( getInfoRecordAt ( k ) . getStreamPos ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .sstoffset      = " ) . append ( Integer . toHexString ( getInfoRecordAt ( k ) . getBucketSSTOffset ( ) ) ) . append ( "\n" ) ; } buffer . append ( "[/EXTSST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_strings_per_bucket ) ; int pos = 6 ; for ( int k = 0 ; k < getNumInfoRecords ( ) ; k ++ ) { ExtSSTInfoSubRecord rec = getInfoRecordAt ( k ) ; pos += rec . serialize ( pos + offset , data ) ; } return pos ; } public int getRecordSize ( ) { return 6 + 8 * getNumInfoRecords ( ) ; } public static final int getNumberOfInfoRecsForStrings ( int numStrings ) { int infoRecs = ( numStrings / DEFAULT_BUCKET_SIZE ) ; if ( ( numStrings % DEFAULT_BUCKET_SIZE ) != 0 ) infoRecs ++ ; if ( infoRecs > MAX_BUCKETS ) infoRecs = MAX_BUCKETS ; return infoRecs ; } public static final int getRecordSizeForStrings ( int numStrings ) { return 4 + 2 + ( getNumberOfInfoRecsForStrings ( numStrings ) * 8 ) ; } public short getSid ( ) { return sid ; } public void setBucketOffsets ( int [ ] bucketAbsoluteOffsets , int [ ] bucketRelativeOffsets ) { this . field_2_sst_info = new ArrayList ( bucketAbsoluteOffsets . length ) ; for ( int i = 0 ; i < bucketAbsoluteOffsets . length ; i ++ ) { ExtSSTInfoSubRecord r = new ExtSSTInfoSubRecord ( ) ; r . setBucketRecordOffset ( ( short ) bucketRelativeOffsets [ i ] ) ; r . setStreamPos ( bucketAbsoluteOffsets [ i ] ) ; field_2_sst_info . add ( r ) ; } } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BlankRecord extends Record implements CellValueRecordInterface , Comparable { public final static short sid = 0x201 ; private int field_1_row ; private short field_2_col ; private short field_3_xf ; public BlankRecord ( ) { } public BlankRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BlankRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf = LittleEndian . getShort ( data , 4 + offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BLANKRECORD!" ) ; } } public void setRow ( int row ) { field_1_row = row ; } public int getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_col ; } public void setXFIndex ( short xf ) { field_3_xf = xf ; } public short getXFIndex ( ) { return field_3_xf ; } public void setColumn ( short col ) { field_2_col = col ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public short getSid ( ) { return BlankRecord . sid ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BLANK]\n" ) ; buffer . append ( "row       = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "col       = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "xf        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BLANK]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 6 ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 10 ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } public Object clone ( ) { BlankRecord rec = new BlankRecord ( ) ; rec . field_1_row = field_1_row ; rec . field_2_col = field_2_col ; rec . field_3_xf = field_3_xf ; return rec ; } } 	0
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class AxisRecord extends Record { public final static short sid = 0x101d ; private short field_1_axisType ; public final static short AXIS_TYPE_CATEGORY_OR_X_AXIS = 0 ; public final static short AXIS_TYPE_VALUE_AXIS = 1 ; public final static short AXIS_TYPE_SERIES_AXIS = 2 ; private int field_2_reserved1 ; private int field_3_reserved2 ; private int field_4_reserved3 ; private int field_5_reserved4 ; public AxisRecord ( ) { } public AxisRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AxisRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Axis record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_axisType = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_reserved1 = LittleEndian . getInt ( data , pos + 0x2 + offset ) ; field_3_reserved2 = LittleEndian . getInt ( data , pos + 0x6 + offset ) ; field_4_reserved3 = LittleEndian . getInt ( data , pos + 0xa + offset ) ; field_5_reserved4 = LittleEndian . getInt ( data , pos + 0xe + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AXIS]\n" ) ; buffer . append ( "    .axisType             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getAxisType ( ) ) ) . append ( " (" ) . append ( getAxisType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .reserved1            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getReserved1 ( ) ) ) . append ( " (" ) . append ( getReserved1 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .reserved2            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getReserved2 ( ) ) ) . append ( " (" ) . append ( getReserved2 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .reserved3            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getReserved3 ( ) ) ) . append ( " (" ) . append ( getReserved3 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .reserved4            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getReserved4 ( ) ) ) . append ( " (" ) . append ( getReserved4 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/AXIS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_axisType ) ; LittleEndian . putInt ( data , 6 + offset + pos , field_2_reserved1 ) ; LittleEndian . putInt ( data , 10 + offset + pos , field_3_reserved2 ) ; LittleEndian . putInt ( data , 14 + offset + pos , field_4_reserved3 ) ; LittleEndian . putInt ( data , 18 + offset + pos , field_5_reserved4 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 4 + 4 + 4 + 4 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { AxisRecord rec = new AxisRecord ( ) ; rec . field_1_axisType = field_1_axisType ; rec . field_2_reserved1 = field_2_reserved1 ; rec . field_3_reserved2 = field_3_reserved2 ; rec . field_4_reserved3 = field_4_reserved3 ; rec . field_5_reserved4 = field_5_reserved4 ; return rec ; } public short getAxisType ( ) { return field_1_axisType ; } public void setAxisType ( short field_1_axisType ) { this . field_1_axisType = field_1_axisType ; } public int getReserved1 ( ) { return field_2_reserved1 ; } public void setReserved1 ( int field_2_reserved1 ) { this . field_2_reserved1 = field_2_reserved1 ; } public int getReserved2 ( ) { return field_3_reserved2 ; } public void setReserved2 ( int field_3_reserved2 ) { this . field_3_reserved2 = field_3_reserved2 ; } public int getReserved3 ( ) { return field_4_reserved3 ; } public void setReserved3 ( int field_4_reserved3 ) { this . field_4_reserved3 = field_4_reserved3 ; } public int getReserved4 ( ) { return field_5_reserved4 ; } public void setReserved4 ( int field_5_reserved4 ) { this . field_5_reserved4 = field_5_reserved4 ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ExtSSTInfoSubRecord extends Record { public static final int INFO_SIZE = 8 ; public final static short sid = 0xFFF ; private int field_1_stream_pos ; private short field_2_bucket_sst_offset ; private short field_3_zero ; public ExtSSTInfoSubRecord ( ) { } public ExtSSTInfoSubRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtSSTInfoSubRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_stream_pos = LittleEndian . getInt ( data , 0 + offset ) ; field_2_bucket_sst_offset = LittleEndian . getShort ( data , 4 + offset ) ; field_3_zero = LittleEndian . getShort ( data , 6 + offset ) ; } public void setStreamPos ( int pos ) { field_1_stream_pos = pos ; } public void setBucketRecordOffset ( short offset ) { field_2_bucket_sst_offset = offset ; } public int getStreamPos ( ) { return field_1_stream_pos ; } public short getBucketSSTOffset ( ) { return field_2_bucket_sst_offset ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTSST]\n" ) ; buffer . append ( "    .streampos      = " ) . append ( Integer . toHexString ( getStreamPos ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .bucketsstoffset= " ) . append ( Integer . toHexString ( getBucketSSTOffset ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .zero           = " ) . append ( Integer . toHexString ( field_3_zero ) ) . append ( "\n" ) ; buffer . append ( "[/EXTSST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putInt ( data , 0 + offset , getStreamPos ( ) ) ; LittleEndian . putShort ( data , 4 + offset , getBucketSSTOffset ( ) ) ; LittleEndian . putShort ( data , 6 + offset , ( short ) 0 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 ; } public short getSid ( ) { return sid ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1
package org . apache . poi . poifs . property ; public interface Child { public Child getNextChild ( ) ; public Child getPreviousChild ( ) ; public void setNextChild ( final Child child ) ; public void setPreviousChild ( final Child child ) ; } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1
package org . apache . poi . hssf . record ; public class RecordFormatException extends RuntimeException { public RecordFormatException ( String exception ) { super ( exception ) ; } } 	0
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; public class ExpPtg extends Ptg { private final static int SIZE = 5 ; public final static short sid = 0x1 ; private byte [ ] existing = null ; public ExpPtg ( ) { } public ExpPtg ( byte [ ] array , int offset ) { existing = new byte [ this . getSize ( ) ] ; System . arraycopy ( array , offset , existing , 0 , this . getSize ( ) ) ; } public void writeBytes ( byte [ ] array , int offset ) { if ( existing != null ) { System . arraycopy ( existing , 0 , array , offset , existing . length ) ; } } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return "NO IDEA SHARED FORMULA EXP PTG" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { if ( this . existing == null ) throw new RuntimeException ( "NO IDEA SHARED FORMULA EXP PTG" ) ; return new ExpPtg ( this . existing , 0 ) ; } } 	0
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RowRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import java . util . Map ; import java . util . TreeMap ; import java . util . Iterator ; import java . util . List ; public class RowRecordsAggregate extends Record { int firstrow = - 1 ; int lastrow = - 1 ; Map records = null ; int size = 0 ; public RowRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertRow ( RowRecord row ) { size += row . getRecordSize ( ) ; records . put ( row , row ) ; if ( ( row . getRowNumber ( ) < firstrow ) || ( firstrow == - 1 ) ) { firstrow = row . getRowNumber ( ) ; } if ( ( row . getRowNumber ( ) > lastrow ) || ( lastrow == - 1 ) ) { lastrow = row . getRowNumber ( ) ; } } public void removeRow ( RowRecord row ) { size -= row . getRecordSize ( ) ; records . remove ( row ) ; } public RowRecord getRow ( int rownum ) { RowRecord row = new RowRecord ( ) ; row . setRowNumber ( ( short ) rownum ) ; return ( RowRecord ) records . get ( row ) ; } public int getPhysicalNumberOfRows ( ) { return records . size ( ) ; } public int getFirstRowNum ( ) { return firstrow ; } public int getLastRowNum ( ) { return lastrow ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return - 1000 ; } public int getRecordSize ( ) { return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { RowRecordsAggregate rec = new RowRecordsAggregate ( ) ; for ( Iterator rowIter = getIterator ( ) ; rowIter . hasNext ( ) ; ) { RowRecord row = ( RowRecord ) ( ( RowRecord ) rowIter . next ( ) ) . clone ( ) ; rec . insertRow ( row ) ; } return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . StringUtil ; public class StringPtg extends Ptg { public final static int SIZE = 9 ; public final static byte sid = 0x17 ; byte field_1_length ; byte field_2_options ; BitField fHighByte = new BitField ( 0x01 ) ; private String field_3_string ; private StringPtg ( ) { } public StringPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_length = data [ offset ] ; field_2_options = data [ offset + 1 ] ; if ( fHighByte . isSet ( field_2_options ) ) { field_3_string = StringUtil . getFromUnicode ( data , offset + 2 , field_1_length ) ; } else { field_3_string = StringUtil . getFromCompressedUnicode ( data , offset + 2 , field_1_length ) ; } } public StringPtg ( String value ) { if ( value . length ( ) > 255 ) { throw new IllegalArgumentException ( "String literals in formulas cant be bigger than 255 characters ASCII" ) ; } this . field_2_options = 0 ; this . fHighByte . setBoolean ( field_2_options , false ) ; this . field_3_string = value ; this . field_1_length = ( byte ) value . length ( ) ; } public String getValue ( ) { return field_3_string ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; array [ offset + 1 ] = field_1_length ; array [ offset + 2 ] = field_2_options ; if ( fHighByte . isSet ( field_2_options ) ) { StringUtil . putUncompressedUnicode ( getValue ( ) , array , offset + 3 ) ; } else { StringUtil . putCompressedUnicode ( getValue ( ) , array , offset + 3 ) ; } } public int getSize ( ) { if ( fHighByte . isSet ( field_2_options ) ) { return 2 * field_1_length + 3 ; } else { return field_1_length + 3 ; } } public String toFormulaString ( Workbook book ) { return "\"" + getValue ( ) + "\"" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { StringPtg ptg = new StringPtg ( ) ; ptg . field_1_length = field_1_length ; ptg . field_2_options = field_2_options ; ptg . field_3_string = field_3_string ; return ptg ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1
package org . apache . poi . util ; import java . io . IOException ; import java . io . InputStream ; public class IOUtils { private IOUtils ( ) { } public static int readFully ( InputStream in , byte [ ] b ) throws IOException { return readFully ( in , b , 0 , b . length ) ; } public static int readFully ( InputStream in , byte [ ] b , int off , int len ) throws IOException { int total = 0 ; for ( ; ; ) { int got = in . read ( b , off + total , len - total ) ; if ( got < 0 ) { return ( total == 0 ) ? - 1 : total ; } else { total += got ; if ( total == len ) return total ; } } } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IOUtils ; import java . io . * ; public class RawDataBlock implements ListManagedBlock { private byte [ ] _data ; private boolean _eof ; public RawDataBlock ( final InputStream stream ) throws IOException { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; int count = IOUtils . readFully ( stream , _data ) ; if ( count == - 1 ) { _eof = true ; } else if ( count != POIFSConstants . BIG_BLOCK_SIZE ) { String type = " byte" + ( ( count == 1 ) ? ( "" ) : ( "s" ) ) ; throw new IOException ( "Unable to read entire block; " + count + type + " read; expected " + POIFSConstants . BIG_BLOCK_SIZE + " bytes" ) ; } else { _eof = false ; } } public boolean eof ( ) throws IOException { return _eof ; } public byte [ ] getData ( ) throws IOException { if ( eof ( ) ) { throw new IOException ( "Cannot return empty data" ) ; } return _data ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class IterationRecord extends Record { public final static short sid = 0x11 ; private short field_1_iteration ; public IterationRecord ( ) { } public IterationRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public IterationRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An ITERATION RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_iteration = LittleEndian . getShort ( data , 0 + offset ) ; } public void setIteration ( boolean iterate ) { if ( iterate ) { field_1_iteration = 1 ; } else { field_1_iteration = 0 ; } } public boolean getIteration ( ) { return ( field_1_iteration == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[ITERATION]\n" ) ; buffer . append ( "    .iteration      = " ) . append ( getIteration ( ) ) . append ( "\n" ) ; buffer . append ( "[/ITERATION]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_iteration ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { IterationRecord rec = new IterationRecord ( ) ; rec . field_1_iteration = field_1_iteration ; return rec ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class PropertyBlock extends BigBlock { private static final int _properties_per_block = POIFSConstants . BIG_BLOCK_SIZE / POIFSConstants . PROPERTY_SIZE ; private Property [ ] _properties ; private PropertyBlock ( final Property [ ] properties , final int offset ) { _properties = new Property [ _properties_per_block ] ; for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] = properties [ j + offset ] ; } } public static BlockWritable [ ] createPropertyBlockArray ( final List properties ) { int block_count = ( properties . size ( ) + _properties_per_block - 1 ) / _properties_per_block ; Property [ ] to_be_written = new Property [ block_count * _properties_per_block ] ; System . arraycopy ( properties . toArray ( new Property [ 0 ] ) , 0 , to_be_written , 0 , properties . size ( ) ) ; for ( int j = properties . size ( ) ; j < to_be_written . length ; j ++ ) { to_be_written [ j ] = new Property ( ) { protected void preWrite ( ) { } public boolean isDirectory ( ) { return false ; } } ; } BlockWritable [ ] rvalue = new BlockWritable [ block_count ] ; for ( int j = 0 ; j < block_count ; j ++ ) { rvalue [ j ] = new PropertyBlock ( to_be_written , j * _properties_per_block ) ; } return rvalue ; } void writeData ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] . writeData ( stream ) ; } } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; public interface BlockWritable { public void writeBlocks ( final OutputStream stream ) throws IOException ; } 	0
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class WSBoolRecord extends Record { public final static short sid = 0x81 ; private byte field_1_wsbool ; private byte field_2_wsbool ; static final private BitField autobreaks = new BitField ( 0x01 ) ; static final private BitField dialog = new BitField ( 0x10 ) ; static final private BitField applystyles = new BitField ( 0x20 ) ; static final private BitField rowsumsbelow = new BitField ( 0x40 ) ; static final private BitField rowsumsright = new BitField ( 0x80 ) ; static final private BitField fittopage = new BitField ( 0x01 ) ; static final private BitField displayguts = new BitField ( 0x06 ) ; static final private BitField alternateexpression = new BitField ( 0x40 ) ; static final private BitField alternateformula = new BitField ( 0x80 ) ; public WSBoolRecord ( ) { } public WSBoolRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WSBoolRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WSBoolRECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_wsbool = data [ 1 + offset ] ; field_2_wsbool = data [ 0 + offset ] ; } public void setWSBool1 ( byte bool1 ) { field_1_wsbool = bool1 ; } public void setAutobreaks ( boolean ab ) { field_1_wsbool = autobreaks . setByteBoolean ( field_1_wsbool , ab ) ; } public void setDialog ( boolean isDialog ) { field_1_wsbool = dialog . setByteBoolean ( field_1_wsbool , isDialog ) ; } public void setRowSumsBelow ( boolean below ) { field_1_wsbool = rowsumsbelow . setByteBoolean ( field_1_wsbool , below ) ; } public void setRowSumsRight ( boolean right ) { field_1_wsbool = rowsumsright . setByteBoolean ( field_1_wsbool , right ) ; } public void setWSBool2 ( byte bool2 ) { field_2_wsbool = field_2_wsbool = bool2 ; } public void setFitToPage ( boolean fit2page ) { field_2_wsbool = fittopage . setByteBoolean ( field_2_wsbool , fit2page ) ; } public void setDisplayGuts ( boolean guts ) { field_2_wsbool = displayguts . setByteBoolean ( field_2_wsbool , guts ) ; } public void setAlternateExpression ( boolean altexp ) { field_2_wsbool = alternateexpression . setByteBoolean ( field_2_wsbool , altexp ) ; } public void setAlternateFormula ( boolean formula ) { field_2_wsbool = alternateformula . setByteBoolean ( field_2_wsbool , formula ) ; } public byte getWSBool1 ( ) { return field_1_wsbool ; } public boolean getAutobreaks ( ) { return autobreaks . isSet ( field_1_wsbool ) ; } public boolean getDialog ( ) { return dialog . isSet ( field_1_wsbool ) ; } public boolean getRowSumsBelow ( ) { return rowsumsbelow . isSet ( field_1_wsbool ) ; } public boolean getRowSumsRight ( ) { return rowsumsright . isSet ( field_1_wsbool ) ; } public byte getWSBool2 ( ) { return field_2_wsbool ; } public boolean getFitToPage ( ) { return fittopage . isSet ( field_2_wsbool ) ; } public boolean getDisplayGuts ( ) { return displayguts . isSet ( field_2_wsbool ) ; } public boolean getAlternateExpression ( ) { return alternateexpression . isSet ( field_2_wsbool ) ; } public boolean getAlternateFormula ( ) { return alternateformula . isSet ( field_2_wsbool ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WSBOOL]\n" ) ; buffer . append ( "    .wsbool1        = " ) . append ( Integer . toHexString ( getWSBool1 ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .autobreaks = " ) . append ( getAutobreaks ( ) ) . append ( "\n" ) ; buffer . append ( "        .dialog     = " ) . append ( getDialog ( ) ) . append ( "\n" ) ; buffer . append ( "        .rowsumsbelw= " ) . append ( getRowSumsBelow ( ) ) . append ( "\n" ) ; buffer . append ( "        .rowsumsrigt= " ) . append ( getRowSumsRight ( ) ) . append ( "\n" ) ; buffer . append ( "    .wsbool2        = " ) . append ( Integer . toHexString ( getWSBool2 ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .fittopage  = " ) . append ( getFitToPage ( ) ) . append ( "\n" ) ; buffer . append ( "        .displayguts= " ) . append ( getDisplayGuts ( ) ) . append ( "\n" ) ; buffer . append ( "        .alternateex= " ) . append ( getAlternateExpression ( ) ) . append ( "\n" ) ; buffer . append ( "        .alternatefo= " ) . append ( getAlternateFormula ( ) ) . append ( "\n" ) ; buffer . append ( "[/WSBOOL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; data [ 5 + offset ] = getWSBool1 ( ) ; data [ 4 + offset ] = getWSBool2 ( ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { WSBoolRecord rec = new WSBoolRecord ( ) ; rec . field_1_wsbool = field_1_wsbool ; rec . field_2_wsbool = field_2_wsbool ; return rec ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class LegendRecord extends Record { public final static short sid = 0x1015 ; private int field_1_xAxisUpperLeft ; private int field_2_yAxisUpperLeft ; private int field_3_xSize ; private int field_4_ySize ; private byte field_5_type ; public final static byte TYPE_BOTTOM = 0 ; public final static byte TYPE_CORNER = 1 ; public final static byte TYPE_TOP = 2 ; public final static byte TYPE_RIGHT = 3 ; public final static byte TYPE_LEFT = 4 ; public final static byte TYPE_UNDOCKED = 7 ; private byte field_6_spacing ; public final static byte SPACING_CLOSE = 0 ; public final static byte SPACING_MEDIUM = 1 ; public final static byte SPACING_OPEN = 2 ; private short field_7_options ; private BitField autoPosition = new BitField ( 0x1 ) ; private BitField autoSeries = new BitField ( 0x2 ) ; private BitField autoXPositioning = new BitField ( 0x4 ) ; private BitField autoYPositioning = new BitField ( 0x8 ) ; private BitField vertical = new BitField ( 0x10 ) ; private BitField dataTable = new BitField ( 0x20 ) ; public LegendRecord ( ) { } public LegendRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LegendRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Legend record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_xAxisUpperLeft = LittleEndian . getInt ( data , pos + 0x0 + offset ) ; field_2_yAxisUpperLeft = LittleEndian . getInt ( data , pos + 0x4 + offset ) ; field_3_xSize = LittleEndian . getInt ( data , pos + 0x8 + offset ) ; field_4_ySize = LittleEndian . getInt ( data , pos + 0xc + offset ) ; field_5_type = data [ pos + 0x10 + offset ] ; field_6_spacing = data [ pos + 0x11 + offset ] ; field_7_options = LittleEndian . getShort ( data , pos + 0x12 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[LEGEND]\n" ) ; buffer . append ( "    .xAxisUpperLeft       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getXAxisUpperLeft ( ) ) ) . append ( " (" ) . append ( getXAxisUpperLeft ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .yAxisUpperLeft       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getYAxisUpperLeft ( ) ) ) . append ( " (" ) . append ( getYAxisUpperLeft ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .xSize                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getXSize ( ) ) ) . append ( " (" ) . append ( getXSize ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .ySize                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getYSize ( ) ) ) . append ( " (" ) . append ( getYSize ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .type                 = " ) . append ( "0x" ) . append ( HexDump . toHex ( getType ( ) ) ) . append ( " (" ) . append ( getType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .spacing              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getSpacing ( ) ) ) . append ( " (" ) . append ( getSpacing ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .autoPosition             = " ) . append ( isAutoPosition ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoSeries               = " ) . append ( isAutoSeries ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoXPositioning         = " ) . append ( isAutoXPositioning ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoYPositioning         = " ) . append ( isAutoYPositioning ( ) ) . append ( '\n' ) ; buffer . append ( "         .vertical                 = " ) . append ( isVertical ( ) ) . append ( '\n' ) ; buffer . append ( "         .dataTable                = " ) . append ( isDataTable ( ) ) . append ( '\n' ) ; buffer . append ( "[/LEGEND]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset + pos , field_1_xAxisUpperLeft ) ; LittleEndian . putInt ( data , 8 + offset + pos , field_2_yAxisUpperLeft ) ; LittleEndian . putInt ( data , 12 + offset + pos , field_3_xSize ) ; LittleEndian . putInt ( data , 16 + offset + pos , field_4_ySize ) ; data [ 20 + offset + pos ] = field_5_type ; data [ 21 + offset + pos ] = field_6_spacing ; LittleEndian . putShort ( data , 22 + offset + pos , field_7_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 + 4 + 4 + 1 + 1 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { LegendRecord rec = new LegendRecord ( ) ; rec . field_1_xAxisUpperLeft = field_1_xAxisUpperLeft ; rec . field_2_yAxisUpperLeft = field_2_yAxisUpperLeft ; rec . field_3_xSize = field_3_xSize ; rec . field_4_ySize = field_4_ySize ; rec . field_5_type = field_5_type ; rec . field_6_spacing = field_6_spacing ; rec . field_7_options = field_7_options ; return rec ; } public int getXAxisUpperLeft ( ) { return field_1_xAxisUpperLeft ; } public void setXAxisUpperLeft ( int field_1_xAxisUpperLeft ) { this . field_1_xAxisUpperLeft = field_1_xAxisUpperLeft ; } public int getYAxisUpperLeft ( ) { return field_2_yAxisUpperLeft ; } public void setYAxisUpperLeft ( int field_2_yAxisUpperLeft ) { this . field_2_yAxisUpperLeft = field_2_yAxisUpperLeft ; } public int getXSize ( ) { return field_3_xSize ; } public void setXSize ( int field_3_xSize ) { this . field_3_xSize = field_3_xSize ; } public int getYSize ( ) { return field_4_ySize ; } public void setYSize ( int field_4_ySize ) { this . field_4_ySize = field_4_ySize ; } public byte getType ( ) { return field_5_type ; } public void setType ( byte field_5_type ) { this . field_5_type = field_5_type ; } public byte getSpacing ( ) { return field_6_spacing ; } public void setSpacing ( byte field_6_spacing ) { this . field_6_spacing = field_6_spacing ; } public short getOptions ( ) { return field_7_options ; } public void setOptions ( short field_7_options ) { this . field_7_options = field_7_options ; } public void setAutoPosition ( boolean value ) { field_7_options = autoPosition . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoPosition ( ) { return autoPosition . isSet ( field_7_options ) ; } public void setAutoSeries ( boolean value ) { field_7_options = autoSeries . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoSeries ( ) { return autoSeries . isSet ( field_7_options ) ; } public void setAutoXPositioning ( boolean value ) { field_7_options = autoXPositioning . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoXPositioning ( ) { return autoXPositioning . isSet ( field_7_options ) ; } public void setAutoYPositioning ( boolean value ) { field_7_options = autoYPositioning . setShortBoolean ( field_7_options , value ) ; } public boolean isAutoYPositioning ( ) { return autoYPositioning . isSet ( field_7_options ) ; } public void setVertical ( boolean value ) { field_7_options = vertical . setShortBoolean ( field_7_options , value ) ; } public boolean isVertical ( ) { return vertical . isSet ( field_7_options ) ; } public void setDataTable ( boolean value ) { field_7_options = dataTable . setShortBoolean ( field_7_options , value ) ; } public boolean isDataTable ( ) { return dataTable . isSet ( field_7_options ) ; } } 	0
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class IntegerField implements FixedField { private int _value ; private final int _offset ; public IntegerField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "negative offset" ) ; } _offset = offset ; } public IntegerField ( final int offset , final int value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public IntegerField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public IntegerField ( final int offset , final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public int get ( ) { return _value ; } public void set ( final int value ) { _value = value ; } public void set ( final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getInt ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readInt ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putInt ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CountryRecord extends Record { public final static short sid = 0x8c ; private short field_1_default_country ; private short field_2_current_country ; public CountryRecord ( ) { } public CountryRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CountryRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Country RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_default_country = LittleEndian . getShort ( data , 0 + offset ) ; field_2_current_country = LittleEndian . getShort ( data , 2 + offset ) ; } public void setDefaultCountry ( short country ) { field_1_default_country = country ; } public void setCurrentCountry ( short country ) { field_2_current_country = country ; } public short getDefaultCountry ( ) { return field_1_default_country ; } public short getCurrentCountry ( ) { return field_2_current_country ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[COUNTRY]\n" ) ; buffer . append ( "    .defaultcountry  = " ) . append ( Integer . toHexString ( getDefaultCountry ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .currentcountry  = " ) . append ( Integer . toHexString ( getCurrentCountry ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/COUNTRY]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x04 ) ) ; LittleEndian . putShort ( data , 4 + offset , getDefaultCountry ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getCurrentCountry ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . property . PropertyTable ; import org . apache . poi . poifs . storage . BATBlock ; import org . apache . poi . poifs . storage . BlockAllocationTableReader ; import org . apache . poi . poifs . storage . BlockAllocationTableWriter ; import org . apache . poi . poifs . storage . BlockList ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . HeaderBlockReader ; import org . apache . poi . poifs . storage . HeaderBlockWriter ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . RawDataBlockList ; import org . apache . poi . poifs . storage . SmallBlockTableReader ; import org . apache . poi . poifs . storage . SmallBlockTableWriter ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class POIFSFileSystem implements POIFSViewable { private PropertyTable _property_table ; private List _documents ; private DirectoryNode _root ; public POIFSFileSystem ( ) { _property_table = new PropertyTable ( ) ; _documents = new ArrayList ( ) ; _root = null ; } public POIFSFileSystem ( final InputStream stream ) throws IOException { this ( ) ; HeaderBlockReader header_block_reader = new HeaderBlockReader ( stream ) ; RawDataBlockList data_blocks = new RawDataBlockList ( stream ) ; new BlockAllocationTableReader ( header_block_reader . getBATCount ( ) , header_block_reader . getBATArray ( ) , header_block_reader . getXBATCount ( ) , header_block_reader . getXBATIndex ( ) , data_blocks ) ; PropertyTable properties = new PropertyTable ( header_block_reader . getPropertyStart ( ) , data_blocks ) ; processProperties ( SmallBlockTableReader . getSmallDocumentBlocks ( data_blocks , properties . getRoot ( ) , header_block_reader . getSBATStart ( ) ) , data_blocks , properties . getRoot ( ) . getChildren ( ) , null ) ; } public DocumentEntry createDocument ( final InputStream stream , final String name ) throws IOException { return getRoot ( ) . createDocument ( name , stream ) ; } public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException { return getRoot ( ) . createDocument ( name , size , writer ) ; } public DirectoryEntry createDirectory ( final String name ) throws IOException { return getRoot ( ) . createDirectory ( name ) ; } public void writeFilesystem ( final OutputStream stream ) throws IOException { _property_table . preWrite ( ) ; SmallBlockTableWriter sbtw = new SmallBlockTableWriter ( _documents , _property_table . getRoot ( ) ) ; BlockAllocationTableWriter bat = new BlockAllocationTableWriter ( ) ; List bm_objects = new ArrayList ( ) ; bm_objects . addAll ( _documents ) ; bm_objects . add ( _property_table ) ; bm_objects . add ( sbtw ) ; bm_objects . add ( sbtw . getSBAT ( ) ) ; Iterator iter = bm_objects . iterator ( ) ; while ( iter . hasNext ( ) ) { BATManaged bmo = ( BATManaged ) iter . next ( ) ; int block_count = bmo . countBlocks ( ) ; if ( block_count != 0 ) { bmo . setStartBlock ( bat . allocateSpace ( block_count ) ) ; } else { } } int batStartBlock = bat . createBlocks ( ) ; HeaderBlockWriter header_block_writer = new HeaderBlockWriter ( ) ; BATBlock [ ] xbat_blocks = header_block_writer . setBATBlocks ( bat . countBlocks ( ) , batStartBlock ) ; header_block_writer . setPropertyStart ( _property_table . getStartBlock ( ) ) ; header_block_writer . setSBATStart ( sbtw . getSBAT ( ) . getStartBlock ( ) ) ; header_block_writer . setSBATBlockCount ( sbtw . getSBATBlockCount ( ) ) ; List writers = new ArrayList ( ) ; writers . add ( header_block_writer ) ; writers . addAll ( _documents ) ; writers . add ( _property_table ) ; writers . add ( sbtw ) ; writers . add ( sbtw . getSBAT ( ) ) ; writers . add ( bat ) ; for ( int j = 0 ; j < xbat_blocks . length ; j ++ ) { writers . add ( xbat_blocks [ j ] ) ; } iter = writers . iterator ( ) ; while ( iter . hasNext ( ) ) { BlockWritable writer = ( BlockWritable ) iter . next ( ) ; writer . writeBlocks ( stream ) ; } } public static void main ( String args [ ] ) throws IOException { if ( args . length != 2 ) { System . err . println ( "two arguments required: input filename and output filename" ) ; System . exit ( 1 ) ; } FileInputStream istream = new FileInputStream ( args [ 0 ] ) ; FileOutputStream ostream = new FileOutputStream ( args [ 1 ] ) ; new POIFSFileSystem ( istream ) . writeFilesystem ( ostream ) ; istream . close ( ) ; ostream . close ( ) ; } public DirectoryEntry getRoot ( ) { if ( _root == null ) { _root = new DirectoryNode ( _property_table . getRoot ( ) , this , null ) ; } return _root ; } public DocumentInputStream createDocumentInputStream ( final String documentName ) throws IOException { Entry document = getRoot ( ) . getEntry ( documentName ) ; if ( ! document . isDocumentEntry ( ) ) { throw new IOException ( "Entry '" + documentName + "' is not a DocumentEntry" ) ; } return new DocumentInputStream ( ( DocumentEntry ) document ) ; } void addDocument ( final POIFSDocument document ) { _documents . add ( document ) ; _property_table . addProperty ( document . getDocumentProperty ( ) ) ; } void addDirectory ( final DirectoryProperty directory ) { _property_table . addProperty ( directory ) ; } void remove ( EntryNode entry ) { _property_table . removeProperty ( entry . getProperty ( ) ) ; if ( entry . isDocumentEntry ( ) ) { _documents . remove ( ( ( DocumentNode ) entry ) . getDocument ( ) ) ; } } private void processProperties ( final BlockList small_blocks , final BlockList big_blocks , final Iterator properties , final DirectoryNode dir ) throws IOException { while ( properties . hasNext ( ) ) { Property property = ( Property ) properties . next ( ) ; String name = property . getName ( ) ; DirectoryNode parent = ( dir == null ) ? ( ( DirectoryNode ) getRoot ( ) ) : dir ; if ( property . isDirectory ( ) ) { DirectoryNode new_dir = ( DirectoryNode ) parent . createDirectory ( name ) ; new_dir . setStorageClsid ( property . getStorageClsid ( ) ) ; processProperties ( small_blocks , big_blocks , ( ( DirectoryProperty ) property ) . getChildren ( ) , new_dir ) ; } else { int startBlock = property . getStartBlock ( ) ; int size = property . getSize ( ) ; POIFSDocument document = null ; if ( property . shouldUseSmallBlocks ( ) ) { document = new POIFSDocument ( name , small_blocks . fetchBlocks ( startBlock ) , size ) ; } else { document = new POIFSDocument ( name , big_blocks . fetchBlocks ( startBlock ) , size ) ; } parent . createDocument ( document ) ; } } } public Object [ ] getViewableArray ( ) { if ( preferArray ( ) ) { return ( ( POIFSViewable ) getRoot ( ) ) . getViewableArray ( ) ; } else { return new Object [ 0 ] ; } } public Iterator getViewableIterator ( ) { if ( ! preferArray ( ) ) { return ( ( POIFSViewable ) getRoot ( ) ) . getViewableIterator ( ) ; } else { return Collections . EMPTY_LIST . iterator ( ) ; } } public boolean preferArray ( ) { return ( ( POIFSViewable ) getRoot ( ) ) . preferArray ( ) ; } public String getShortDescription ( ) { return "POIFS FileSystem" ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . hssf . record ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . record . formula . Ref3DPtg ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class NameRecord extends Record { public final static short sid = 0x18 ; public final static byte BUILTIN_CONSOLIDATE_AREA = ( byte ) 1 ; public final static byte BUILTIN_AUTO_OPEN = ( byte ) 2 ; public final static byte BUILTIN_AUTO_CLOSE = ( byte ) 3 ; public final static byte BUILTIN_DATABASE = ( byte ) 4 ; public final static byte BUILTIN_CRITERIA = ( byte ) 5 ; public final static byte BUILTIN_PRINT_AREA = ( byte ) 6 ; public final static byte BUILTIN_PRINT_TITLE = ( byte ) 7 ; public final static byte BUILTIN_RECORDER = ( byte ) 8 ; public final static byte BUILTIN_DATA_FORM = ( byte ) 9 ; public final static byte BUILTIN_AUTO_ACTIVATE = ( byte ) 10 ; public final static byte BUILTIN_AUTO_DEACTIVATE = ( byte ) 11 ; public final static byte BUILTIN_SHEET_TITLE = ( byte ) 12 ; public static final short OPT_HIDDEN_NAME = ( short ) 0x0001 ; public static final short OPT_FUNCTION_NAME = ( short ) 0x0002 ; public static final short OPT_COMMAND_NAME = ( short ) 0x0004 ; public static final short OPT_MACRO = ( short ) 0x0008 ; public static final short OPT_COMPLEX = ( short ) 0x0010 ; public static final short OPT_BUILTIN = ( short ) 0x0020 ; public static final short OPT_BINDATA = ( short ) 0x1000 ; private short field_1_option_flag ; private byte field_2_keyboard_shortcut ; private byte field_3_length_name_text ; private short field_4_length_name_definition ; private short field_5_index_to_sheet ; private short field_6_equals_to_index_to_sheet ; private byte field_7_length_custom_menu ; private byte field_8_length_description_text ; private byte field_9_length_help_topic_text ; private byte field_10_length_status_bar_text ; private byte field_11_compressed_unicode_flag ; private byte field_12_builtIn_name ; private String field_12_name_text ; private Stack field_13_name_definition ; private byte [ ] field_13_raw_name_definition ; private String field_14_custom_menu_text ; private String field_15_description_text ; private String field_16_help_topic_text ; private String field_17_status_bar_text ; public NameRecord ( ) { field_13_name_definition = new Stack ( ) ; field_12_name_text = new String ( ) ; field_14_custom_menu_text = new String ( ) ; field_15_description_text = new String ( ) ; field_16_help_topic_text = new String ( ) ; field_17_status_bar_text = new String ( ) ; } public NameRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public NameRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public NameRecord ( byte builtin , short index ) { this ( ) ; this . field_12_builtIn_name = builtin ; this . setOptionFlag ( ( short ) ( this . getOptionFlag ( ) | OPT_BUILTIN ) ) ; this . setNameTextLength ( ( byte ) 1 ) ; this . setEqualsToIndexToSheet ( index ) ; this . setCustomMenuLength ( ( byte ) 0 ) ; this . setDescriptionTextLength ( ( byte ) 0 ) ; this . setHelpTopicLength ( ( byte ) 0 ) ; this . setStatusBarLength ( ( byte ) 0 ) ; } public void setOptionFlag ( short flag ) { field_1_option_flag = flag ; } public void setKeyboardShortcut ( byte shortcut ) { field_2_keyboard_shortcut = shortcut ; } public void setNameTextLength ( byte length ) { field_3_length_name_text = length ; } public void setDefinitionTextLength ( short length ) { field_4_length_name_definition = length ; } public void setUnused ( short index ) { field_5_index_to_sheet = index ; } public short getEqualsToIndexToSheet ( ) { return field_6_equals_to_index_to_sheet ; } public short getIndexToSheet ( ) { return getEqualsToIndexToSheet ( ) ; } public byte getFnGroup ( ) { int masked = field_1_option_flag & 0x0fc0 ; return ( byte ) ( masked > > 4 ) ; } public void setEqualsToIndexToSheet ( short value ) { field_6_equals_to_index_to_sheet = value ; } public void setCustomMenuLength ( byte length ) { field_7_length_custom_menu = length ; } public void setDescriptionTextLength ( byte length ) { field_8_length_description_text = length ; } public void setHelpTopicLength ( byte length ) { field_9_length_help_topic_text = length ; } public void setStatusBarLength ( byte length ) { field_10_length_status_bar_text = length ; } public void setCompressedUnicodeFlag ( byte flag ) { field_11_compressed_unicode_flag = flag ; } public void setNameText ( String name ) { field_12_name_text = name ; } public void setCustomMenuText ( String text ) { field_14_custom_menu_text = text ; } public void setDescriptionText ( String text ) { field_15_description_text = text ; } public void setHelpTopicText ( String text ) { field_16_help_topic_text = text ; } public void setStatusBarText ( String text ) { field_17_status_bar_text = text ; } public short getOptionFlag ( ) { return field_1_option_flag ; } public byte getKeyboardShortcut ( ) { return field_2_keyboard_shortcut ; } public byte getNameTextLength ( ) { return field_3_length_name_text ; } public short getDefinitionTextLength ( ) { return field_4_length_name_definition ; } public short getUnused ( ) { return field_5_index_to_sheet ; } public byte getCustomMenuLength ( ) { return field_7_length_custom_menu ; } public byte getDescriptionTextLength ( ) { return field_8_length_description_text ; } public byte getHelpTopicLength ( ) { return field_9_length_help_topic_text ; } public byte getStatusBarLength ( ) { return field_10_length_status_bar_text ; } public byte getCompressedUnicodeFlag ( ) { return field_11_compressed_unicode_flag ; } public boolean isHiddenName ( ) { return ( field_1_option_flag & OPT_HIDDEN_NAME ) != 0 ; } public boolean isFunctionName ( ) { return ( field_1_option_flag & OPT_FUNCTION_NAME ) != 0 ; } public boolean isCommandName ( ) { return ( field_1_option_flag & OPT_COMMAND_NAME ) != 0 ; } public boolean isMacro ( ) { return ( field_1_option_flag & OPT_MACRO ) != 0 ; } public boolean isComplexFunction ( ) { return ( field_1_option_flag & OPT_COMPLEX ) != 0 ; } public boolean isBuiltInName ( ) { return ( ( this . getOptionFlag ( ) & OPT_BUILTIN ) != 0 ) ; } public String getNameText ( ) { return this . isBuiltInName ( ) ? this . translateBuiltInName ( this . getBuiltInName ( ) ) : field_12_name_text ; } public byte getBuiltInName ( ) { return this . field_12_builtIn_name ; } public List getNameDefinition ( ) { return field_13_name_definition ; } public void setNameDefinition ( Stack nameDefinition ) { field_13_name_definition = nameDefinition ; } public String getCustomMenuText ( ) { return field_14_custom_menu_text ; } public String getDescriptionText ( ) { return field_15_description_text ; } public String getHelpTopicText ( ) { return field_16_help_topic_text ; } public String getStatusBarText ( ) { return field_17_status_bar_text ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid Name RECORD" ) ; } } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 4 + offset , getOptionFlag ( ) ) ; data [ 6 + offset ] = getKeyboardShortcut ( ) ; data [ 7 + offset ] = getNameTextLength ( ) ; LittleEndian . putShort ( data , 8 + offset , getDefinitionTextLength ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getUnused ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getEqualsToIndexToSheet ( ) ) ; data [ 14 + offset ] = getCustomMenuLength ( ) ; data [ 15 + offset ] = getDescriptionTextLength ( ) ; data [ 16 + offset ] = getHelpTopicLength ( ) ; data [ 17 + offset ] = getStatusBarLength ( ) ; data [ 18 + offset ] = getCompressedUnicodeFlag ( ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 15 + getTextsLength ( ) ) ) ; int start_of_name_definition = 19 + field_3_length_name_text ; if ( this . isBuiltInName ( ) ) { data [ 19 + offset ] = this . getBuiltInName ( ) ; } else { StringUtil . putCompressedUnicode ( getNameText ( ) , data , 19 + offset ) ; } if ( this . field_13_name_definition != null ) { serializePtgs ( data , start_of_name_definition + offset ) ; } else { System . arraycopy ( field_13_raw_name_definition , 0 , data , start_of_name_definition + offset , field_13_raw_name_definition . length ) ; } int start_of_custom_menu_text = start_of_name_definition + field_4_length_name_definition ; StringUtil . putCompressedUnicode ( getCustomMenuText ( ) , data , start_of_custom_menu_text + offset ) ; int start_of_description_text = start_of_custom_menu_text + field_7_length_custom_menu ; StringUtil . putCompressedUnicode ( getDescriptionText ( ) , data , start_of_description_text + offset ) ; int start_of_help_topic_text = start_of_description_text + field_8_length_description_text ; StringUtil . putCompressedUnicode ( getHelpTopicText ( ) , data , start_of_help_topic_text + offset ) ; int start_of_status_bar_text = start_of_help_topic_text + field_9_length_help_topic_text ; StringUtil . putCompressedUnicode ( getStatusBarText ( ) , data , start_of_status_bar_text + offset ) ; return getRecordSize ( ) ; } private void serializePtgs ( byte [ ] data , int offset ) { int pos = offset ; for ( int k = 0 ; k < field_13_name_definition . size ( ) ; k ++ ) { Ptg ptg = ( Ptg ) field_13_name_definition . get ( k ) ; ptg . writeBytes ( data , pos ) ; pos += ptg . getSize ( ) ; } } public int getTextsLength ( ) { int result ; result = getNameTextLength ( ) + getDefinitionTextLength ( ) + getDescriptionTextLength ( ) + getHelpTopicLength ( ) + getStatusBarLength ( ) ; return result ; } public int getRecordSize ( ) { int result ; result = 19 + getTextsLength ( ) ; return result ; } public short getExternSheetNumber ( ) { if ( field_13_name_definition == null ) return 0 ; Ptg ptg = ( Ptg ) field_13_name_definition . peek ( ) ; short result = 0 ; if ( ptg . getClass ( ) == Area3DPtg . class ) { result = ( ( Area3DPtg ) ptg ) . getExternSheetIndex ( ) ; } else if ( ptg . getClass ( ) == Ref3DPtg . class ) { result = ( ( Ref3DPtg ) ptg ) . getExternSheetIndex ( ) ; } return result ; } public void setExternSheetNumber ( short externSheetNumber ) { Ptg ptg ; if ( field_13_name_definition == null || field_13_name_definition . isEmpty ( ) ) { field_13_name_definition = new Stack ( ) ; ptg = createNewPtg ( ) ; } else { ptg = ( Ptg ) field_13_name_definition . peek ( ) ; } if ( ptg . getClass ( ) == Area3DPtg . class ) { ( ( Area3DPtg ) ptg ) . setExternSheetIndex ( externSheetNumber ) ; } else if ( ptg . getClass ( ) == Ref3DPtg . class ) { ( ( Ref3DPtg ) ptg ) . setExternSheetIndex ( externSheetNumber ) ; } } private Ptg createNewPtg ( ) { Ptg ptg = new Area3DPtg ( ) ; field_13_name_definition . push ( ptg ) ; return ptg ; } public String getAreaReference ( Workbook book ) { if ( field_13_name_definition == null ) return "#REF!" ; Ptg ptg = ( Ptg ) field_13_name_definition . peek ( ) ; String result = "" ; if ( ptg . getClass ( ) == Area3DPtg . class ) { result = ptg . toFormulaString ( book ) ; } else if ( ptg . getClass ( ) == Ref3DPtg . class ) { result = ptg . toFormulaString ( book ) ; } return result ; } public void setAreaReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; Ptg oldPtg ; Ptg ptg ; if ( field_13_name_definition == null || field_13_name_definition . isEmpty ( ) ) { field_13_name_definition = new Stack ( ) ; oldPtg = createNewPtg ( ) ; } else { oldPtg = ( Ptg ) field_13_name_definition . pop ( ) ; } short externSheetIndex = 0 ; if ( oldPtg . getClass ( ) == Area3DPtg . class ) { externSheetIndex = ( ( Area3DPtg ) oldPtg ) . getExternSheetIndex ( ) ; } else if ( oldPtg . getClass ( ) == Ref3DPtg . class ) { externSheetIndex = ( ( Ref3DPtg ) oldPtg ) . getExternSheetIndex ( ) ; } if ( ra . hasRange ( ) ) { ptg = new Area3DPtg ( ) ; ( ( Area3DPtg ) ptg ) . setExternSheetIndex ( externSheetIndex ) ; ( ( Area3DPtg ) ptg ) . setArea ( ref ) ; this . setDefinitionTextLength ( ( short ) ptg . getSize ( ) ) ; } else { ptg = new Ref3DPtg ( ) ; ( ( Ref3DPtg ) ptg ) . setExternSheetIndex ( externSheetIndex ) ; ( ( Ref3DPtg ) ptg ) . setArea ( ref ) ; this . setDefinitionTextLength ( ( short ) ptg . getSize ( ) ) ; } field_13_name_definition . push ( ptg ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_option_flag = LittleEndian . getShort ( data , 0 + offset ) ; field_2_keyboard_shortcut = data [ 2 + offset ] ; field_3_length_name_text = data [ 3 + offset ] ; field_4_length_name_definition = LittleEndian . getShort ( data , 4 + offset ) ; field_5_index_to_sheet = LittleEndian . getShort ( data , 6 + offset ) ; field_6_equals_to_index_to_sheet = LittleEndian . getShort ( data , 8 + offset ) ; field_7_length_custom_menu = data [ 10 + offset ] ; field_8_length_description_text = data [ 11 + offset ] ; field_9_length_help_topic_text = data [ 12 + offset ] ; field_10_length_status_bar_text = data [ 13 + offset ] ; field_11_compressed_unicode_flag = data [ 14 + offset ] ; if ( this . isBuiltInName ( ) ) { field_12_builtIn_name = data [ 15 + offset ] ; } field_12_name_text = StringUtil . getFromCompressedUnicode ( data , 15 + offset , LittleEndian . ubyteToInt ( field_3_length_name_text ) ) ; int start_of_name_definition = 15 + field_3_length_name_text ; field_13_name_definition = getParsedExpressionTokens ( data , field_4_length_name_definition , offset , start_of_name_definition ) ; int start_of_custom_menu_text = start_of_name_definition + field_4_length_name_definition ; field_14_custom_menu_text = StringUtil . getFromCompressedUnicode ( data , start_of_custom_menu_text + offset , LittleEndian . ubyteToInt ( field_7_length_custom_menu ) ) ; int start_of_description_text = start_of_custom_menu_text + field_7_length_custom_menu ; ; field_15_description_text = StringUtil . getFromCompressedUnicode ( data , start_of_description_text + offset , LittleEndian . ubyteToInt ( field_8_length_description_text ) ) ; int start_of_help_topic_text = start_of_description_text + field_8_length_description_text ; field_16_help_topic_text = StringUtil . getFromCompressedUnicode ( data , start_of_help_topic_text + offset , LittleEndian . ubyteToInt ( field_9_length_help_topic_text ) ) ; int start_of_status_bar_text = start_of_help_topic_text + field_9_length_help_topic_text ; field_17_status_bar_text = StringUtil . getFromCompressedUnicode ( data , start_of_status_bar_text + offset , LittleEndian . ubyteToInt ( field_10_length_status_bar_text ) ) ; } private Stack getParsedExpressionTokens ( byte [ ] data , short size , int offset , int start_of_expression ) { Stack stack = new Stack ( ) ; int pos = start_of_expression + offset ; int sizeCounter = 0 ; try { while ( sizeCounter < size ) { Ptg ptg = Ptg . createPtg ( data , pos ) ; pos += ptg . getSize ( ) ; sizeCounter += ptg . getSize ( ) ; stack . push ( ptg ) ; field_13_raw_name_definition = new byte [ size ] ; System . arraycopy ( data , offset , field_13_raw_name_definition , 0 , size ) ; } } catch ( java . lang . UnsupportedOperationException uoe ) { System . err . println ( "[WARNING] Unknown Ptg " + uoe . getMessage ( ) ) ; field_13_raw_name_definition = new byte [ size ] ; System . arraycopy ( data , offset , field_13_raw_name_definition , 0 , size ) ; return null ; } return stack ; } public short getSid ( ) { return this . sid ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[NAME]\n" ) ; buffer . append ( "    .option flags         = " ) . append ( HexDump . toHex ( field_1_option_flag ) ) . append ( "\n" ) ; buffer . append ( "    .keyboard shortcut    = " ) . append ( HexDump . toHex ( field_2_keyboard_shortcut ) ) . append ( "\n" ) ; buffer . append ( "    .length of the name   = " ) . append ( field_3_length_name_text ) . append ( "\n" ) ; buffer . append ( "    .size of the formula data = " ) . append ( field_4_length_name_definition ) . append ( "\n" ) ; buffer . append ( "    .unused                   = " ) . append ( field_5_index_to_sheet ) . append ( "\n" ) ; buffer . append ( "    .index to sheet (1-based, 0=Global)           = " ) . append ( field_6_equals_to_index_to_sheet ) . append ( "\n" ) ; buffer . append ( "    .Length of menu text (character count)        = " ) . append ( field_7_length_custom_menu ) . append ( "\n" ) ; buffer . append ( "    .Length of description text (character count) = " ) . append ( field_8_length_description_text ) . append ( "\n" ) ; buffer . append ( "    .Length of help topic text (character count)  = " ) . append ( field_9_length_help_topic_text ) . append ( "\n" ) ; buffer . append ( "    .Length of status bar text (character count)  = " ) . append ( field_10_length_status_bar_text ) . append ( "\n" ) ; buffer . append ( "    .Name (Unicode flag)  = " ) . append ( field_11_compressed_unicode_flag ) . append ( "\n" ) ; buffer . append ( "    .Name (Unicode text)  = " ) . append ( getNameText ( ) ) . append ( "\n" ) ; buffer . append ( "    .Formula data (RPN token array without size field)      = " ) . append ( HexDump . toHex ( ( ( field_13_raw_name_definition != null ) ? field_13_raw_name_definition : new byte [ 0 ] ) ) ) . append ( "\n" ) ; buffer . append ( "    .Menu text (Unicode string without length field)        = " ) . append ( field_14_custom_menu_text ) . append ( "\n" ) ; buffer . append ( "    .Description text (Unicode string without length field) = " ) . append ( field_15_description_text ) . append ( "\n" ) ; buffer . append ( "    .Help topic text (Unicode string without length field)  = " ) . append ( field_16_help_topic_text ) . append ( "\n" ) ; buffer . append ( "    .Status bar text (Unicode string without length field)  = " ) . append ( field_17_status_bar_text ) . append ( "\n" ) ; buffer . append ( org . apache . poi . util . HexDump . dump ( this . field_13_raw_name_definition , 0 , 0 ) ) ; buffer . append ( "[/NAME]\n" ) ; return buffer . toString ( ) ; } protected String translateBuiltInName ( byte name ) { switch ( name ) { case NameRecord . BUILTIN_AUTO_ACTIVATE : return "Auto_Activate" ; case NameRecord . BUILTIN_AUTO_CLOSE : return "Auto_Close" ; case NameRecord . BUILTIN_AUTO_DEACTIVATE : return "Auto_Deactivate" ; case NameRecord . BUILTIN_AUTO_OPEN : return "Auto_Open" ; case NameRecord . BUILTIN_CONSOLIDATE_AREA : return "Consolidate_Area" ; case NameRecord . BUILTIN_CRITERIA : return "Criteria" ; case NameRecord . BUILTIN_DATABASE : return "Database" ; case NameRecord . BUILTIN_DATA_FORM : return "Data_Form" ; case NameRecord . BUILTIN_PRINT_AREA : return "Print_Area" ; case NameRecord . BUILTIN_PRINT_TITLE : return "Print_Titles" ; case NameRecord . BUILTIN_RECORDER : return "Recorder" ; case NameRecord . BUILTIN_SHEET_TITLE : return "Sheet_Title" ; } return "Unknown" ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class ChartFormatRecord extends Record { public static final short sid = 0x1014 ; private int field1_x_position ; private int field2_y_position ; private int field3_width ; private int field4_height ; private short field5_grbit ; private BitField varyDisplayPattern = new BitField ( 0x01 ) ; public ChartFormatRecord ( ) { } public ChartFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ChartFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CHARTFORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field1_x_position = LittleEndian . getInt ( data , 0 + offset ) ; field2_y_position = LittleEndian . getInt ( data , 4 + offset ) ; field3_width = LittleEndian . getInt ( data , 8 + offset ) ; field4_height = LittleEndian . getInt ( data , 12 + offset ) ; field5_grbit = LittleEndian . getShort ( data , 16 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CHARTFORMAT]\n" ) ; buffer . append ( "    .xPosition       = " ) . append ( getXPosition ( ) ) . append ( "\n" ) ; buffer . append ( "    .yPosition       = " ) . append ( getYPosition ( ) ) . append ( "\n" ) ; buffer . append ( "    .width           = " ) . append ( getWidth ( ) ) . append ( "\n" ) ; buffer . append ( "    .height          = " ) . append ( getHeight ( ) ) . append ( "\n" ) ; buffer . append ( "    .grBit           = " ) . append ( Integer . toHexString ( field5_grbit ) ) . append ( "\n" ) ; buffer . append ( "[/CHARTFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 22 ) ) ; LittleEndian . putInt ( data , 4 + offset , getXPosition ( ) ) ; LittleEndian . putInt ( data , 8 + offset , getYPosition ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getWidth ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getHeight ( ) ) ; LittleEndian . putShort ( data , 20 + offset , field5_grbit ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } public int getXPosition ( ) { return field1_x_position ; } public void setXPosition ( int xPosition ) { this . field1_x_position = xPosition ; } public int getYPosition ( ) { return field2_y_position ; } public void setYPosition ( int yPosition ) { this . field2_y_position = yPosition ; } public int getWidth ( ) { return field3_width ; } public void setWidth ( int width ) { this . field3_width = width ; } public int getHeight ( ) { return field4_height ; } public void setHeight ( int height ) { this . field4_height = height ; } public boolean getVaryDisplayPattern ( ) { return varyDisplayPattern . isSet ( field5_grbit ) ; } public void setVaryDisplayPattern ( boolean value ) { field5_grbit = varyDisplayPattern . setShortBoolean ( field5_grbit , value ) ; } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . util . * ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; public class DocumentNode extends EntryNode implements DocumentEntry , POIFSViewable { private POIFSDocument _document ; DocumentNode ( final DocumentProperty property , final DirectoryNode parent ) { super ( property , parent ) ; _document = property . getDocument ( ) ; } POIFSDocument getDocument ( ) { return _document ; } public int getSize ( ) { return getProperty ( ) . getSize ( ) ; } public boolean isDocumentEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return true ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; components . add ( _document ) ; return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class AxisParentRecord extends Record { public final static short sid = 0x1041 ; private short field_1_axisType ; public final static short AXIS_TYPE_MAIN = 0 ; public final static short AXIS_TYPE_SECONDARY = 1 ; private int field_2_x ; private int field_3_y ; private int field_4_width ; private int field_5_height ; public AxisParentRecord ( ) { } public AxisParentRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AxisParentRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a AxisParent record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_axisType = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_x = LittleEndian . getInt ( data , pos + 0x2 + offset ) ; field_3_y = LittleEndian . getInt ( data , pos + 0x6 + offset ) ; field_4_width = LittleEndian . getInt ( data , pos + 0xa + offset ) ; field_5_height = LittleEndian . getInt ( data , pos + 0xe + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AXISPARENT]\n" ) ; buffer . append ( "    .axisType             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getAxisType ( ) ) ) . append ( " (" ) . append ( getAxisType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .x                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getX ( ) ) ) . append ( " (" ) . append ( getX ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .y                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getY ( ) ) ) . append ( " (" ) . append ( getY ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .width                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getWidth ( ) ) ) . append ( " (" ) . append ( getWidth ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .height               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getHeight ( ) ) ) . append ( " (" ) . append ( getHeight ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/AXISPARENT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_axisType ) ; LittleEndian . putInt ( data , 6 + offset + pos , field_2_x ) ; LittleEndian . putInt ( data , 10 + offset + pos , field_3_y ) ; LittleEndian . putInt ( data , 14 + offset + pos , field_4_width ) ; LittleEndian . putInt ( data , 18 + offset + pos , field_5_height ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 4 + 4 + 4 + 4 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { AxisParentRecord rec = new AxisParentRecord ( ) ; rec . field_1_axisType = field_1_axisType ; rec . field_2_x = field_2_x ; rec . field_3_y = field_3_y ; rec . field_4_width = field_4_width ; rec . field_5_height = field_5_height ; return rec ; } public short getAxisType ( ) { return field_1_axisType ; } public void setAxisType ( short field_1_axisType ) { this . field_1_axisType = field_1_axisType ; } public int getX ( ) { return field_2_x ; } public void setX ( int field_2_x ) { this . field_2_x = field_2_x ; } public int getY ( ) { return field_3_y ; } public void setY ( int field_3_y ) { this . field_3_y = field_3_y ; } public int getWidth ( ) { return field_4_width ; } public void setWidth ( int field_4_width ) { this . field_4_width = field_4_width ; } public int getHeight ( ) { return field_5_height ; } public void setHeight ( int field_5_height ) { this . field_5_height = field_5_height ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; public class UnionPtg extends OperationPtg { public final static byte sid = 0x10 ; public UnionPtg ( ) { } public UnionPtg ( byte [ ] data , int offset ) { } public int getSize ( ) { return 1 ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public Object clone ( ) { return new UnionPtg ( ) ; } public int getType ( ) { return TYPE_BINARY ; } public String toFormulaString ( Workbook book ) { return "," ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( "," ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public int getNumberOfOperands ( ) { return 2 ; } } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import java . util . List ; public class AttrPtg extends OperationPtg { public final static byte sid = 0x19 ; private final static int SIZE = 4 ; private byte field_1_options ; private short field_2_data ; private BitField semiVolatile = new BitField ( 0x01 ) ; private BitField optiIf = new BitField ( 0x02 ) ; private BitField optiChoose = new BitField ( 0x04 ) ; private BitField optGoto = new BitField ( 0x08 ) ; private BitField sum = new BitField ( 0x10 ) ; private BitField baxcel = new BitField ( 0x20 ) ; private BitField space = new BitField ( 0x40 ) ; public AttrPtg ( ) { } public AttrPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_options = data [ offset + 0 ] ; field_2_data = LittleEndian . getShort ( data , offset + 1 ) ; } public void setOptions ( byte options ) { field_1_options = options ; } public byte getOptions ( ) { return field_1_options ; } public boolean isSemiVolatile ( ) { return semiVolatile . isSet ( getOptions ( ) ) ; } public boolean isOptimizedIf ( ) { return optiIf . isSet ( getOptions ( ) ) ; } public boolean isOptimizedChoose ( ) { return optiChoose . isSet ( getOptions ( ) ) ; } public boolean isGoto ( ) { return optGoto . isSet ( getOptions ( ) ) ; } public boolean isSum ( ) { return sum . isSet ( getOptions ( ) ) ; } public void setSum ( boolean bsum ) { field_1_options = sum . setByteBoolean ( field_1_options , bsum ) ; } public void setOptimizedIf ( boolean bif ) { field_1_options = optiIf . setByteBoolean ( field_1_options , bif ) ; } public void setGoto ( boolean isGoto ) { field_1_options = optGoto . setByteBoolean ( field_1_options , isGoto ) ; } public boolean isBaxcel ( ) { return baxcel . isSet ( getOptions ( ) ) ; } public boolean isSpace ( ) { return space . isSet ( getOptions ( ) ) ; } public void setData ( short data ) { field_2_data = data ; } public short getData ( ) { return field_2_data ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AttrPtg\n" ) ; buffer . append ( "options=" ) . append ( field_1_options ) . append ( "\n" ) ; buffer . append ( "data   =" ) . append ( field_2_data ) . append ( "\n" ) ; buffer . append ( "semi   =" ) . append ( isSemiVolatile ( ) ) . append ( "\n" ) ; buffer . append ( "optimif=" ) . append ( isOptimizedIf ( ) ) . append ( "\n" ) ; buffer . append ( "optchos=" ) . append ( isOptimizedChoose ( ) ) . append ( "\n" ) ; buffer . append ( "isGoto =" ) . append ( isGoto ( ) ) . append ( "\n" ) ; buffer . append ( "isSum  =" ) . append ( isSum ( ) ) . append ( "\n" ) ; buffer . append ( "isBaxce=" ) . append ( isBaxcel ( ) ) . append ( "\n" ) ; buffer . append ( "isSpace=" ) . append ( isSpace ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = sid ; array [ offset + 1 ] = field_1_options ; LittleEndian . putShort ( array , offset + 2 , field_2_data ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( String [ ] operands ) { if ( space . isSet ( field_1_options ) ) { return operands [ 0 ] ; } else if ( optiIf . isSet ( field_1_options ) ) { return toFormulaString ( ( Workbook ) null ) + "(" + operands [ 0 ] + ")" ; } else if ( optGoto . isSet ( field_1_options ) ) { return toFormulaString ( ( Workbook ) null ) + operands [ 0 ] ; } else { return toFormulaString ( ( Workbook ) null ) + "(" + operands [ 0 ] + ")" ; } } public int getNumberOfOperands ( ) { return 1 ; } public int getType ( ) { return - 1 ; } public String toFormulaString ( Workbook book ) { if ( semiVolatile . isSet ( field_1_options ) ) { return "ATTR(semiVolatile)" ; } if ( optiIf . isSet ( field_1_options ) ) { return "IF" ; } if ( optiChoose . isSet ( field_1_options ) ) { return "CHOOSE" ; } if ( optGoto . isSet ( field_1_options ) ) { return "" ; } if ( sum . isSet ( field_1_options ) ) { return "SUM" ; } if ( baxcel . isSet ( field_1_options ) ) { return "ATTR(baxcel)" ; } if ( space . isSet ( field_1_options ) ) { return "" ; } return "UNKNOWN ATTRIBUTE" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { AttrPtg ptg = new AttrPtg ( ) ; ptg . field_1_options = field_1_options ; ptg . field_2_data = field_2_data ; return ptg ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . hpsf ; import org . apache . poi . util . LittleEndian ; public class Thumbnail { public static int OFFSET_CFTAG = 4 ; public static int OFFSET_CF = 8 ; public static int OFFSET_WMFDATA = 20 ; public static int CFTAG_WINDOWS = - 1 ; public static int CFTAG_MACINTOSH = - 2 ; public static int CFTAG_FMTID = - 3 ; public static int CFTAG_NODATA = 0 ; public static int CF_METAFILEPICT = 3 ; public static int CF_DIB = 8 ; public static int CF_ENHMETAFILE = 14 ; public static int CF_BITMAP = 2 ; private byte [ ] thumbnailData = null ; public Thumbnail ( ) { super ( ) ; } public Thumbnail ( byte [ ] thumbnailData ) { this . thumbnailData = thumbnailData ; } public byte [ ] getThumbnail ( ) { return thumbnailData ; } public void setThumbnail ( byte [ ] thumbnail ) { this . thumbnailData = thumbnail ; } public long getClipboardFormatTag ( ) { long clipboardFormatTag = LittleEndian . getUInt ( getThumbnail ( ) , OFFSET_CFTAG ) ; return clipboardFormatTag ; } public long getClipboardFormat ( ) throws HPSFException { if ( ! ( getClipboardFormatTag ( ) == CFTAG_WINDOWS ) ) throw new HPSFException ( "Clipboard Format Tag of Thumbnail must " + "be CFTAG_WINDOWS." ) ; return LittleEndian . getUInt ( getThumbnail ( ) , OFFSET_CF ) ; } public byte [ ] getThumbnailAsWMF ( ) throws HPSFException { if ( ! ( getClipboardFormatTag ( ) == CFTAG_WINDOWS ) ) throw new HPSFException ( "Clipboard Format Tag of Thumbnail must " + "be CFTAG_WINDOWS." ) ; if ( ! ( getClipboardFormat ( ) == CF_METAFILEPICT ) ) throw new HPSFException ( "Clipboard Format of Thumbnail must " + "be CF_METAFILEPICT." ) ; else { byte [ ] thumbnail = getThumbnail ( ) ; int wmfImageLength = thumbnail . length - OFFSET_WMFDATA ; byte [ ] wmfImage = new byte [ wmfImageLength ] ; System . arraycopy ( thumbnail , OFFSET_WMFDATA , wmfImage , 0 , wmfImageLength ) ; return wmfImage ; } } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1
package org . apache . poi . hssf . record ; import java . io . UnsupportedEncodingException ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class UnicodeString extends Record implements Comparable { public final static short sid = 0xFFF ; private short field_1_charCount ; private byte field_2_optionflags ; private String field_3_string ; private final int RICH_TEXT_BIT = 8 ; private final int EXT_BIT = 4 ; public UnicodeString ( ) { } public int hashCode ( ) { int stringHash = 0 ; if ( field_3_string != null ) stringHash = field_3_string . hashCode ( ) ; return field_1_charCount + stringHash ; } public boolean equals ( Object o ) { if ( ( o == null ) || ( o . getClass ( ) != this . getClass ( ) ) ) { return false ; } UnicodeString other = ( UnicodeString ) o ; return ( ( field_1_charCount == other . field_1_charCount ) && ( field_2_optionflags == other . field_2_optionflags ) && field_3_string . equals ( other . field_3_string ) ) ; } public UnicodeString ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public UnicodeString ( short id , short size , byte [ ] data , String prefix ) { this ( id , size , data ) ; field_3_string = prefix + field_3_string ; setCharCount ( ) ; } protected void validateSid ( short id ) { } protected void fillFields ( byte [ ] data , short size ) { field_1_charCount = LittleEndian . getShort ( data , 0 ) ; field_2_optionflags = data [ 2 ] ; if ( ( field_2_optionflags & 1 ) == 0 ) { try { field_3_string = new String ( data , 3 , getCharCount ( ) , StringUtil . getPreferredEncoding ( ) ) ; } catch ( UnsupportedEncodingException e ) { String errorMessage = e . getMessage ( ) ; if ( errorMessage == null ) { errorMessage = e . toString ( ) ; } throw new RuntimeException ( errorMessage ) ; } } else { char [ ] array = new char [ getCharCount ( ) ] ; for ( int j = 0 ; j < array . length ; j ++ ) { array [ j ] = ( char ) LittleEndian . getShort ( data , 3 + ( j * 2 ) ) ; } field_3_string = new String ( array ) ; } } public short getCharCount ( ) { return field_1_charCount ; } public void setCharCount ( short cc ) { field_1_charCount = cc ; } public void setCharCount ( ) { field_1_charCount = ( short ) field_3_string . length ( ) ; } public byte getOptionFlags ( ) { return field_2_optionflags ; } public void setOptionFlags ( byte of ) { field_2_optionflags = of ; } public String getString ( ) { return field_3_string ; } public void setString ( String string ) { field_3_string = string ; if ( getCharCount ( ) < field_3_string . length ( ) ) { setCharCount ( ) ; } } public String toString ( ) { return getString ( ) ; } public String getDebugInfo ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[UNICODESTRING]\n" ) ; buffer . append ( "    .charcount       = " ) . append ( Integer . toHexString ( getCharCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .optionflags     = " ) . append ( Integer . toHexString ( getOptionFlags ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .string          = " ) . append ( getString ( ) ) . append ( "\n" ) ; buffer . append ( "[/UNICODESTRING]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int charsize = 1 ; if ( getOptionFlags ( ) == 1 ) { charsize = 2 ; } LittleEndian . putShort ( data , 0 + offset , getCharCount ( ) ) ; data [ 2 + offset ] = getOptionFlags ( ) ; try { String unicodeString = new String ( getString ( ) . getBytes ( "Unicode" ) , "Unicode" ) ; if ( getOptionFlags ( ) == 0 ) { StringUtil . putCompressedUnicode ( unicodeString , data , 0x3 + offset ) ; } else { StringUtil . putUncompressedUnicode ( unicodeString , data , 0x3 + offset ) ; } } catch ( Exception e ) { if ( getOptionFlags ( ) == 0 ) { StringUtil . putCompressedUnicode ( getString ( ) , data , 0x3 + offset ) ; } else { StringUtil . putUncompressedUnicode ( getString ( ) , data , 0x3 + offset ) ; } } return getRecordSize ( ) ; } private boolean isUncompressedUnicode ( ) { return ( getOptionFlags ( ) & 0x01 ) == 1 ; } public int getRecordSize ( ) { int charsize = isUncompressedUnicode ( ) ? 2 : 1 ; return 3 + ( getString ( ) . length ( ) * charsize ) ; } public short getSid ( ) { return this . sid ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } public int compareTo ( Object obj ) { UnicodeString str = ( UnicodeString ) obj ; return this . getString ( ) . compareTo ( str . getString ( ) ) ; } public boolean isRichText ( ) { return ( getOptionFlags ( ) & RICH_TEXT_BIT ) != 0 ; } int maxBrokenLength ( final int proposedBrokenLength ) { int rval = proposedBrokenLength ; if ( isUncompressedUnicode ( ) ) { int proposedStringLength = proposedBrokenLength - 3 ; if ( ( proposedStringLength % 2 ) == 1 ) { proposedStringLength -- ; } rval = proposedStringLength + 3 ; } return rval ; } public boolean isExtendedText ( ) { return ( getOptionFlags ( ) & EXT_BIT ) != 0 ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class LinkedDataRecord extends Record { public final static short sid = 0x1051 ; private byte field_1_linkType ; public final static byte LINK_TYPE_TITLE_OR_TEXT = 0 ; public final static byte LINK_TYPE_VALUES = 1 ; public final static byte LINK_TYPE_CATEGORIES = 2 ; private byte field_2_referenceType ; public final static byte REFERENCE_TYPE_DEFAULT_CATEGORIES = 0 ; public final static byte REFERENCE_TYPE_DIRECT = 1 ; public final static byte REFERENCE_TYPE_WORKSHEET = 2 ; public final static byte REFERENCE_TYPE_NOT_USED = 3 ; public final static byte REFERENCE_TYPE_ERROR_REPORTED = 4 ; private short field_3_options ; private BitField customNumberFormat = new BitField ( 0x1 ) ; private short field_4_indexNumberFmtRecord ; private LinkedDataFormulaField field_5_formulaOfLink ; public LinkedDataRecord ( ) { } public LinkedDataRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LinkedDataRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a LinkedData record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_linkType = data [ pos + 0x0 + offset ] ; field_2_referenceType = data [ pos + 0x1 + offset ] ; field_3_options = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_4_indexNumberFmtRecord = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_5_formulaOfLink = new org . apache . poi . hssf . record . LinkedDataFormulaField ( ) ; pos += field_5_formulaOfLink . fillField ( data , size , pos + offset + 6 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AI]\n" ) ; buffer . append ( "    .linkType             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLinkType ( ) ) ) . append ( " (" ) . append ( getLinkType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .referenceType        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getReferenceType ( ) ) ) . append ( " (" ) . append ( getReferenceType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .customNumberFormat       = " ) . append ( isCustomNumberFormat ( ) ) . append ( '\n' ) ; buffer . append ( "    .indexNumberFmtRecord = " ) . append ( "0x" ) . append ( HexDump . toHex ( getIndexNumberFmtRecord ( ) ) ) . append ( " (" ) . append ( getIndexNumberFmtRecord ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .formulaOfLink        = " ) . append ( " (" ) . append ( getFormulaOfLink ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/AI]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; data [ 4 + offset + pos ] = field_1_linkType ; data [ 5 + offset + pos ] = field_2_referenceType ; LittleEndian . putShort ( data , 6 + offset + pos , field_3_options ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_4_indexNumberFmtRecord ) ; pos += field_5_formulaOfLink . serializeField ( pos + 10 + offset , data ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 1 + 1 + 2 + 2 + field_5_formulaOfLink . getSize ( ) ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { LinkedDataRecord rec = new LinkedDataRecord ( ) ; rec . field_1_linkType = field_1_linkType ; rec . field_2_referenceType = field_2_referenceType ; rec . field_3_options = field_3_options ; rec . field_4_indexNumberFmtRecord = field_4_indexNumberFmtRecord ; rec . field_5_formulaOfLink = ( ( org . apache . poi . hssf . record . LinkedDataFormulaField ) field_5_formulaOfLink . clone ( ) ) ; ; return rec ; } public byte getLinkType ( ) { return field_1_linkType ; } public void setLinkType ( byte field_1_linkType ) { this . field_1_linkType = field_1_linkType ; } public byte getReferenceType ( ) { return field_2_referenceType ; } public void setReferenceType ( byte field_2_referenceType ) { this . field_2_referenceType = field_2_referenceType ; } public short getOptions ( ) { return field_3_options ; } public void setOptions ( short field_3_options ) { this . field_3_options = field_3_options ; } public short getIndexNumberFmtRecord ( ) { return field_4_indexNumberFmtRecord ; } public void setIndexNumberFmtRecord ( short field_4_indexNumberFmtRecord ) { this . field_4_indexNumberFmtRecord = field_4_indexNumberFmtRecord ; } public LinkedDataFormulaField getFormulaOfLink ( ) { return field_5_formulaOfLink ; } public void setFormulaOfLink ( LinkedDataFormulaField field_5_formulaOfLink ) { this . field_5_formulaOfLink = field_5_formulaOfLink ; } public void setCustomNumberFormat ( boolean value ) { field_3_options = customNumberFormat . setShortBoolean ( field_3_options , value ) ; } public boolean isCustomNumberFormat ( ) { return customNumberFormat . isSet ( field_3_options ) ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ShortField implements FixedField { private short _value ; private final int _offset ; public ShortField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public ShortField ( final int offset , final short value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public ShortField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ShortField ( final int offset , final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public short get ( ) { return _value ; } public void set ( final short value ) { _value = value ; } public void set ( final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getShort ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readShort ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putShort ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1
package org . apache . poi . poifs . common ; public interface POIFSConstants { public static final int BIG_BLOCK_SIZE = 0x0200 ; public static final int END_OF_CHAIN = - 2 ; public static final int PROPERTY_SIZE = 0x0080 ; public static final int UNUSED_BLOCK = - 1 ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class DocumentSummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005DocumentSummaryInformation" ; public DocumentSummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isDocumentSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getCategory ( ) { return ( String ) getProperty ( PropertyIDMap . PID_CATEGORY ) ; } public String getPresentationFormat ( ) { return ( String ) getProperty ( PropertyIDMap . PID_PRESFORMAT ) ; } public int getByteCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_BYTECOUNT ) ; } public int getLineCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_LINECOUNT ) ; } public int getParCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PARCOUNT ) ; } public int getSlideCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SLIDECOUNT ) ; } public int getNoteCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_NOTECOUNT ) ; } public int getHiddenCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_HIDDENCOUNT ) ; } public int getMMClipCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_MMCLIPCOUNT ) ; } public boolean getScale ( ) { return getPropertyBooleanValue ( PropertyIDMap . PID_SCALE ) ; } public byte [ ] getHeadingPair ( ) { if ( true ) throw new UnsupportedOperationException ( "FIXME" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_HEADINGPAIR ) ; } public byte [ ] getDocparts ( ) { if ( true ) throw new UnsupportedOperationException ( "FIXME" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_DOCPARTS ) ; } public String getManager ( ) { return ( String ) getProperty ( PropertyIDMap . PID_MANAGER ) ; } public String getCompany ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMPANY ) ; } public boolean getLinksDirty ( ) { return getPropertyBooleanValue ( PropertyIDMap . PID_LINKSDIRTY ) ; } } 	0
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1
package org . apache . poi . hssf . model ; public interface Model { } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ExternSheetSubRecord extends Record { public final static short sid = 0xFFF ; private short field_1_index_to_supbook ; private short field_2_index_to_first_supbook_sheet ; private short field_3_index_to_last_supbook_sheet ; public ExternSheetSubRecord ( ) { } public ExternSheetSubRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExternSheetSubRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public void setIndexToSupBook ( short index ) { field_1_index_to_supbook = index ; } public short getIndexToSupBook ( ) { return field_1_index_to_supbook ; } public void setIndexToFirstSupBook ( short index ) { field_2_index_to_first_supbook_sheet = index ; } public short getIndexToFirstSupBook ( ) { return field_2_index_to_first_supbook_sheet ; } public void setIndexToLastSupBook ( short index ) { field_3_index_to_last_supbook_sheet = index ; } public short getIndexToLastSupBook ( ) { return field_3_index_to_last_supbook_sheet ; } protected void validateSid ( short id ) { } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_index_to_supbook = LittleEndian . getShort ( data , 0 + offset ) ; field_2_index_to_first_supbook_sheet = LittleEndian . getShort ( data , 2 + offset ) ; field_3_index_to_last_supbook_sheet = LittleEndian . getShort ( data , 4 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "   supbookindex =" ) . append ( getIndexToSupBook ( ) ) . append ( '\n' ) ; buffer . append ( "   1stsbindex   =" ) . append ( getIndexToFirstSupBook ( ) ) . append ( '\n' ) ; buffer . append ( "   lastsbindex  =" ) . append ( getIndexToLastSupBook ( ) ) . append ( '\n' ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , getIndexToSupBook ( ) ) ; LittleEndian . putShort ( data , 2 + offset , getIndexToFirstSupBook ( ) ) ; LittleEndian . putShort ( data , 4 + offset , getIndexToLastSupBook ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1
package org . apache . poi . poifs . filesystem ; public class POIFSWriterEvent { private DocumentOutputStream stream ; private POIFSDocumentPath path ; private String documentName ; private int limit ; POIFSWriterEvent ( final DocumentOutputStream stream , final POIFSDocumentPath path , final String documentName , final int limit ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; this . limit = limit ; } public DocumentOutputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } public int getLimit ( ) { return limit ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class AxisLineFormatRecord extends Record { public final static short sid = 0x1021 ; private short field_1_axisType ; public final static short AXIS_TYPE_AXIS_LINE = 0 ; public final static short AXIS_TYPE_MAJOR_GRID_LINE = 1 ; public final static short AXIS_TYPE_MINOR_GRID_LINE = 2 ; public final static short AXIS_TYPE_WALLS_OR_FLOOR = 3 ; public AxisLineFormatRecord ( ) { } public AxisLineFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AxisLineFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a AxisLineFormat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_axisType = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AXISLINEFORMAT]\n" ) ; buffer . append ( "    .axisType             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getAxisType ( ) ) ) . append ( " (" ) . append ( getAxisType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/AXISLINEFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_axisType ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { AxisLineFormatRecord rec = new AxisLineFormatRecord ( ) ; rec . field_1_axisType = field_1_axisType ; return rec ; } public short getAxisType ( ) { return field_1_axisType ; } public void setAxisType ( short field_1_axisType ) { this . field_1_axisType = field_1_axisType ; } } 	0
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IOUtils ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class DocumentBlock extends BigBlock { private static final byte _default_value = ( byte ) 0xFF ; private byte [ ] _data ; private int _bytes_read ; public DocumentBlock ( final RawDataBlock block ) throws IOException { _data = block . getData ( ) ; _bytes_read = _data . length ; } public DocumentBlock ( final InputStream stream ) throws IOException { this ( ) ; int count = IOUtils . readFully ( stream , _data ) ; _bytes_read = ( count == - 1 ) ? 0 : count ; } private DocumentBlock ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; } public int size ( ) { return _bytes_read ; } public boolean partiallyRead ( ) { return _bytes_read != POIFSConstants . BIG_BLOCK_SIZE ; } public static byte getFillByte ( ) { return _default_value ; } public static DocumentBlock [ ] convert ( final byte [ ] array , final int size ) { DocumentBlock [ ] rval = new DocumentBlock [ ( size + POIFSConstants . BIG_BLOCK_SIZE - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ] ; int offset = 0 ; for ( int k = 0 ; k < rval . length ; k ++ ) { rval [ k ] = new DocumentBlock ( ) ; if ( offset < array . length ) { int length = Math . min ( POIFSConstants . BIG_BLOCK_SIZE , array . length - offset ) ; System . arraycopy ( array , offset , rval [ k ] . _data , 0 , length ) ; if ( length != POIFSConstants . BIG_BLOCK_SIZE ) { Arrays . fill ( rval [ k ] . _data , length , POIFSConstants . BIG_BLOCK_SIZE , _default_value ) ; } } else { Arrays . fill ( rval [ k ] . _data , _default_value ) ; } offset += POIFSConstants . BIG_BLOCK_SIZE ; } return rval ; } public static void read ( final DocumentBlock [ ] blocks , final byte [ ] buffer , final int offset ) { int firstBlockIndex = offset / POIFSConstants . BIG_BLOCK_SIZE ; int firstBlockOffset = offset % POIFSConstants . BIG_BLOCK_SIZE ; int lastBlockIndex = ( offset + buffer . length - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ; if ( firstBlockIndex == lastBlockIndex ) { System . arraycopy ( blocks [ firstBlockIndex ] . _data , firstBlockOffset , buffer , 0 , buffer . length ) ; } else { int buffer_offset = 0 ; System . arraycopy ( blocks [ firstBlockIndex ] . _data , firstBlockOffset , buffer , buffer_offset , POIFSConstants . BIG_BLOCK_SIZE - firstBlockOffset ) ; buffer_offset += POIFSConstants . BIG_BLOCK_SIZE - firstBlockOffset ; for ( int j = firstBlockIndex + 1 ; j < lastBlockIndex ; j ++ ) { System . arraycopy ( blocks [ j ] . _data , 0 , buffer , buffer_offset , POIFSConstants . BIG_BLOCK_SIZE ) ; buffer_offset += POIFSConstants . BIG_BLOCK_SIZE ; } System . arraycopy ( blocks [ lastBlockIndex ] . _data , 0 , buffer , buffer_offset , buffer . length - buffer_offset ) ; } } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1
package org . apache . poi . poifs . eventfilesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . property . PropertyTable ; import org . apache . poi . poifs . storage . BlockAllocationTableReader ; import org . apache . poi . poifs . storage . BlockList ; import org . apache . poi . poifs . storage . HeaderBlockReader ; import org . apache . poi . poifs . storage . RawDataBlockList ; import org . apache . poi . poifs . storage . SmallBlockTableReader ; public class POIFSReader { private POIFSReaderRegistry registry ; private boolean registryClosed ; public POIFSReader ( ) { registry = new POIFSReaderRegistry ( ) ; registryClosed = false ; } public void read ( final InputStream stream ) throws IOException { registryClosed = true ; HeaderBlockReader header_block_reader = new HeaderBlockReader ( stream ) ; RawDataBlockList data_blocks = new RawDataBlockList ( stream ) ; new BlockAllocationTableReader ( header_block_reader . getBATCount ( ) , header_block_reader . getBATArray ( ) , header_block_reader . getXBATCount ( ) , header_block_reader . getXBATIndex ( ) , data_blocks ) ; PropertyTable properties = new PropertyTable ( header_block_reader . getPropertyStart ( ) , data_blocks ) ; processProperties ( SmallBlockTableReader . getSmallDocumentBlocks ( data_blocks , properties . getRoot ( ) , header_block_reader . getSBATStart ( ) ) , data_blocks , properties . getRoot ( ) . getChildren ( ) , new POIFSDocumentPath ( ) ) ; } public void registerListener ( final POIFSReaderListener listener ) { if ( listener == null ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener ) ; } public void registerListener ( final POIFSReaderListener listener , final String name ) { registerListener ( listener , null , name ) ; } public void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String name ) { if ( ( listener == null ) || ( name == null ) || ( name . length ( ) == 0 ) ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener , ( path == null ) ? new POIFSDocumentPath ( ) : path , name ) ; } public static void main ( String args [ ] ) throws IOException { if ( args . length == 0 ) { System . err . println ( "at least one argument required: input filename(s)" ) ; System . exit ( 1 ) ; } for ( int j = 0 ; j < args . length ; j ++ ) { POIFSReader reader = new POIFSReader ( ) ; POIFSReaderListener listener = new SampleListener ( ) ; reader . registerListener ( listener ) ; System . out . println ( "reading " + args [ j ] ) ; FileInputStream istream = new FileInputStream ( args [ j ] ) ; reader . read ( istream ) ; istream . close ( ) ; } } private void processProperties ( final BlockList small_blocks , final BlockList big_blocks , final Iterator properties , final POIFSDocumentPath path ) throws IOException { while ( properties . hasNext ( ) ) { Property property = ( Property ) properties . next ( ) ; String name = property . getName ( ) ; if ( property . isDirectory ( ) ) { POIFSDocumentPath new_path = new POIFSDocumentPath ( path , new String [ ] { name } ) ; processProperties ( small_blocks , big_blocks , ( ( DirectoryProperty ) property ) . getChildren ( ) , new_path ) ; } else { int startBlock = property . getStartBlock ( ) ; Iterator listeners = registry . getListeners ( path , name ) ; if ( listeners . hasNext ( ) ) { int size = property . getSize ( ) ; POIFSDocument document = null ; if ( property . shouldUseSmallBlocks ( ) ) { document = new POIFSDocument ( name , small_blocks . fetchBlocks ( startBlock ) , size ) ; } else { document = new POIFSDocument ( name , big_blocks . fetchBlocks ( startBlock ) , size ) ; } while ( listeners . hasNext ( ) ) { POIFSReaderListener listener = ( POIFSReaderListener ) listeners . next ( ) ; listener . processPOIFSReaderEvent ( new POIFSReaderEvent ( new DocumentInputStream ( document ) , path , name ) ) ; } } else { if ( property . shouldUseSmallBlocks ( ) ) { small_blocks . fetchBlocks ( startBlock ) ; } else { big_blocks . fetchBlocks ( startBlock ) ; } } } } } private static class SampleListener implements POIFSReaderListener { SampleListener ( ) { } public void processPOIFSReaderEvent ( final POIFSReaderEvent event ) { DocumentInputStream istream = event . getStream ( ) ; POIFSDocumentPath path = event . getPath ( ) ; String name = event . getName ( ) ; try { byte [ ] data = new byte [ istream . available ( ) ] ; istream . read ( data ) ; int pathLength = path . length ( ) ; for ( int k = 0 ; k < pathLength ; k ++ ) { System . out . print ( "/" + path . getComponent ( k ) ) ; } System . out . println ( "/" + name + ": " + data . length + " bytes read" ) ; } catch ( IOException ignored ) { } } } } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class PowerPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x07 ; public PowerPtg ( ) { } public PowerPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "^" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new PowerPtg ( ) ; } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; public class POIFSViewEngine { private static final String _EOL = System . getProperty ( "line.separator" ) ; public static List inspectViewable ( final Object viewable , final boolean drilldown , final int indentLevel , final String indentString ) { List objects = new ArrayList ( ) ; if ( viewable instanceof POIFSViewable ) { POIFSViewable inspected = ( POIFSViewable ) viewable ; objects . add ( indent ( indentLevel , indentString , inspected . getShortDescription ( ) ) ) ; if ( drilldown ) { if ( inspected . preferArray ( ) ) { Object [ ] data = inspected . getViewableArray ( ) ; for ( int j = 0 ; j < data . length ; j ++ ) { objects . addAll ( inspectViewable ( data [ j ] , drilldown , indentLevel + 1 , indentString ) ) ; } } else { Iterator iter = inspected . getViewableIterator ( ) ; while ( iter . hasNext ( ) ) { objects . addAll ( inspectViewable ( iter . next ( ) , drilldown , indentLevel + 1 , indentString ) ) ; } } } } else { objects . add ( indent ( indentLevel , indentString , viewable . toString ( ) ) ) ; } return objects ; } private static String indent ( final int indentLevel , final String indentString , final String data ) { StringBuffer finalBuffer = new StringBuffer ( ) ; StringBuffer indentPrefix = new StringBuffer ( ) ; for ( int j = 0 ; j < indentLevel ; j ++ ) { indentPrefix . append ( indentString ) ; } LineNumberReader reader = new LineNumberReader ( new StringReader ( data ) ) ; try { String line = reader . readLine ( ) ; while ( line != null ) { finalBuffer . append ( indentPrefix ) . append ( line ) . append ( _EOL ) ; line = reader . readLine ( ) ; } } catch ( IOException e ) { finalBuffer . append ( indentPrefix ) . append ( e . getMessage ( ) ) . append ( _EOL ) ; } return finalBuffer . toString ( ) ; } } 	0
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; import java . util . Iterator ; import java . util . List ; public class SSTRecord extends Record { static final int MAX_RECORD_SIZE = 8228 ; static final int STD_RECORD_OVERHEAD = 2 * LittleEndianConsts . SHORT_SIZE ; static final int SST_RECORD_OVERHEAD = ( STD_RECORD_OVERHEAD + ( 2 * LittleEndianConsts . INT_SIZE ) ) ; static final int MAX_DATA_SPACE = MAX_RECORD_SIZE - SST_RECORD_OVERHEAD ; static final int STRING_MINIMAL_OVERHEAD = LittleEndianConsts . SHORT_SIZE + LittleEndianConsts . BYTE_SIZE ; public static final short sid = 0xfc ; private int field_1_num_strings ; private int field_2_num_unique_strings ; private BinaryTree field_3_strings ; private List _record_lengths = null ; private SSTDeserializer deserializer ; int [ ] bucketAbsoluteOffsets ; int [ ] bucketRelativeOffsets ; public SSTRecord ( ) { field_1_num_strings = 0 ; field_2_num_unique_strings = 0 ; field_3_strings = new BinaryTree ( ) ; deserializer = new SSTDeserializer ( field_3_strings ) ; } public SSTRecord ( final short id , final short size , final byte [ ] data ) { super ( id , size , data ) ; } public SSTRecord ( final short id , final short size , final byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public int addString ( final String string ) { int rval ; if ( string == null ) { rval = addString ( "" , false ) ; } else { boolean useUTF16 = false ; int strlen = string . length ( ) ; for ( int j = 0 ; j < strlen ; j ++ ) { if ( string . charAt ( j ) > 255 ) { useUTF16 = true ; break ; } } rval = addString ( string , useUTF16 ) ; } return rval ; } public int addString ( final String string , final boolean useUTF16 ) { field_1_num_strings ++ ; String str = ( string == null ) ? "" : string ; int rval ; UnicodeString ucs = new UnicodeString ( ) ; ucs . setString ( str ) ; ucs . setCharCount ( ( short ) str . length ( ) ) ; ucs . setOptionFlags ( ( byte ) ( useUTF16 ? 1 : 0 ) ) ; Integer integer = ( Integer ) field_3_strings . getKeyForValue ( ucs ) ; if ( integer != null ) { rval = integer . intValue ( ) ; } else { rval = field_3_strings . size ( ) ; field_2_num_unique_strings ++ ; integer = new Integer ( rval ) ; SSTDeserializer . addToStringTable ( field_3_strings , integer , ucs ) ; } return rval ; } public int getNumStrings ( ) { return field_1_num_strings ; } public int getNumUniqueStrings ( ) { return field_2_num_unique_strings ; } public void setNumStrings ( final int count ) { field_1_num_strings = count ; } public void setNumUniqueStrings ( final int count ) { field_2_num_unique_strings = count ; } public String getString ( final int id ) { return ( ( UnicodeString ) field_3_strings . get ( new Integer ( id ) ) ) . getString ( ) ; } public boolean isString16bit ( final int id ) { UnicodeString unicodeString = ( ( UnicodeString ) field_3_strings . get ( new Integer ( id ) ) ) ; return ( ( unicodeString . getOptionFlags ( ) & 0x01 ) == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SST]\n" ) ; buffer . append ( "    .numstrings     = " ) . append ( Integer . toHexString ( getNumStrings ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .uniquestrings  = " ) . append ( Integer . toHexString ( getNumUniqueStrings ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < field_3_strings . size ( ) ; k ++ ) { buffer . append ( "    .string_" + k + "      = " ) . append ( ( field_3_strings . get ( new Integer ( k ) ) ) . toString ( ) ) . append ( "\n" ) ; } buffer . append ( "[/SST]\n" ) ; return buffer . toString ( ) ; } public short getSid ( ) { return sid ; } public int hashCode ( ) { return field_2_num_unique_strings ; } public boolean equals ( Object o ) { if ( ( o == null ) || ( o . getClass ( ) != this . getClass ( ) ) ) { return false ; } SSTRecord other = ( SSTRecord ) o ; return ( ( field_1_num_strings == other . field_1_num_strings ) && ( field_2_num_unique_strings == other . field_2_num_unique_strings ) && field_3_strings . equals ( other . field_3_strings ) ) ; } protected void validateSid ( final short id ) throws RecordFormatException { if ( id != sid ) { throw new RecordFormatException ( "NOT An SST RECORD" ) ; } } protected void fillFields ( final byte [ ] data , final short size , int offset ) { field_1_num_strings = LittleEndian . getInt ( data , 0 + offset ) ; field_2_num_unique_strings = LittleEndian . getInt ( data , 4 + offset ) ; field_3_strings = new BinaryTree ( ) ; deserializer = new SSTDeserializer ( field_3_strings ) ; deserializer . manufactureStrings ( data , 8 + offset ) ; } Iterator getStrings ( ) { return field_3_strings . values ( ) . iterator ( ) ; } int countStrings ( ) { return field_3_strings . size ( ) ; } public int serialize ( int offset , byte [ ] data ) { SSTSerializer serializer = new SSTSerializer ( _record_lengths , field_3_strings , getNumStrings ( ) , getNumUniqueStrings ( ) ) ; int bytes = serializer . serialize ( getRecordSize ( ) , offset , data ) ; bucketAbsoluteOffsets = serializer . getBucketAbsoluteOffsets ( ) ; bucketRelativeOffsets = serializer . getBucketRelativeOffsets ( ) ; return bytes ; } public int getRecordSize ( ) { SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator ( field_3_strings ) ; int recordSize = calculator . getRecordSize ( ) ; _record_lengths = calculator . getRecordLengths ( ) ; return recordSize ; } SSTDeserializer getDeserializer ( ) { return deserializer ; } public void processContinueRecord ( byte [ ] record ) { deserializer . processContinueRecord ( record ) ; } public ExtSSTRecord createExtSSTRecord ( int sstOffset ) { if ( bucketAbsoluteOffsets == null || bucketAbsoluteOffsets == null ) throw new IllegalStateException ( "SST record has not yet been serialized." ) ; ExtSSTRecord extSST = new ExtSSTRecord ( ) ; extSST . setNumStringsPerBucket ( ( short ) 8 ) ; int [ ] absoluteOffsets = ( int [ ] ) bucketAbsoluteOffsets . clone ( ) ; int [ ] relativeOffsets = ( int [ ] ) bucketRelativeOffsets . clone ( ) ; for ( int i = 0 ; i < absoluteOffsets . length ; i ++ ) absoluteOffsets [ i ] += sstOffset ; extSST . setBucketOffsets ( absoluteOffsets , relativeOffsets ) ; return extSST ; } public int calcExtSSTRecordSize ( ) { return ExtSSTRecord . getRecordSizeForStrings ( field_3_strings . size ( ) ) ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1
package org . apache . poi . poifs . property ; import org . apache . poi . poifs . filesystem . POIFSDocument ; public class DocumentProperty extends Property { private POIFSDocument _document ; public DocumentProperty ( final String name , final int size ) { super ( ) ; _document = null ; setName ( name ) ; setSize ( size ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . DOCUMENT_TYPE ) ; } protected DocumentProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _document = null ; } public void setDocument ( POIFSDocument doc ) { _document = doc ; } public POIFSDocument getDocument ( ) { return _document ; } public boolean shouldUseSmallBlocks ( ) { return super . shouldUseSmallBlocks ( ) ; } public boolean isDirectory ( ) { return false ; } protected void preWrite ( ) { } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import java . util . * ; public class SystemOutLogger extends POILogger { private String cat ; public void initialize ( final String cat ) { this . cat = cat ; } public void log ( final int level , final Object obj1 ) { if ( check ( level ) ) System . out . println ( "[" + cat + "] " + obj1 ) ; } public boolean check ( final int level ) { int currentLevel = Integer . parseInt ( System . getProperty ( "poi.log.level" , WARN + "" ) ) ; if ( level >= currentLevel ) return true ; else return false ; } } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BATBlock extends BigBlock { private static final int _entries_per_block = POIFSConstants . BIG_BLOCK_SIZE / LittleEndianConsts . INT_SIZE ; private static final int _entries_per_xbat_block = _entries_per_block - 1 ; private static final int _xbat_chain_offset = _entries_per_xbat_block * LittleEndianConsts . INT_SIZE ; private static final byte _default_value = ( byte ) 0xFF ; private IntegerField [ ] _fields ; private byte [ ] _data ; private BATBlock ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; _fields = new IntegerField [ _entries_per_block ] ; int offset = 0 ; for ( int j = 0 ; j < _entries_per_block ; j ++ ) { _fields [ j ] = new IntegerField ( offset ) ; offset += LittleEndianConsts . INT_SIZE ; } } public static BATBlock [ ] createBATBlocks ( final int [ ] entries ) { int block_count = calculateStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; for ( int j = 0 ; j < entries . length ; j += _entries_per_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_block ) ? j + _entries_per_block : entries . length ) ; remaining -= _entries_per_block ; } return blocks ; } public static BATBlock [ ] createXBATBlocks ( final int [ ] entries , final int startBlock ) { int block_count = calculateXBATStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; if ( block_count != 0 ) { for ( int j = 0 ; j < entries . length ; j += _entries_per_xbat_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_xbat_block ) ? j + _entries_per_xbat_block : entries . length ) ; remaining -= _entries_per_xbat_block ; } for ( index = 0 ; index < blocks . length - 1 ; index ++ ) { blocks [ index ] . setXBATChain ( startBlock + index + 1 ) ; } blocks [ index ] . setXBATChain ( POIFSConstants . END_OF_CHAIN ) ; } return blocks ; } public static int calculateStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_block - 1 ) / _entries_per_block ; } public static int calculateXBATStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_xbat_block - 1 ) / _entries_per_xbat_block ; } public static final int entriesPerBlock ( ) { return _entries_per_block ; } public static final int entriesPerXBATBlock ( ) { return _entries_per_xbat_block ; } public static final int getXBATChainOffset ( ) { return _xbat_chain_offset ; } private void setXBATChain ( int chainIndex ) { _fields [ _entries_per_xbat_block ] . set ( chainIndex , _data ) ; } private BATBlock ( final int [ ] entries , final int start_index , final int end_index ) { this ( ) ; for ( int k = start_index ; k < end_index ; k ++ ) { _fields [ k - start_index ] . set ( entries [ k ] , _data ) ; } } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1
package org . apache . poi . util ; public interface LittleEndianConsts { public static final int BYTE_SIZE = 1 ; public static final int SHORT_SIZE = 2 ; public static final int INT_SIZE = 4 ; public static final int LONG_SIZE = 8 ; public static final int DOUBLE_SIZE = 8 ; } 	0
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class WindowTwoRecord extends Record { public final static short sid = 0x23e ; private short field_1_options ; private BitField displayFormulas = new BitField ( 0x01 ) ; private BitField displayGridlines = new BitField ( 0x02 ) ; private BitField displayRowColHeadings = new BitField ( 0x04 ) ; private BitField freezePanes = new BitField ( 0x08 ) ; private BitField displayZeros = new BitField ( 0x10 ) ; private BitField defaultHeader = new BitField ( 0x20 ) ; private BitField arabic = new BitField ( 0x40 ) ; private BitField displayGuts = new BitField ( 0x80 ) ; private BitField freezePanesNoSplit = new BitField ( 0x100 ) ; private BitField selected = new BitField ( 0x200 ) ; private BitField paged = new BitField ( 0x400 ) ; private BitField savedInPageBreakPreview = new BitField ( 0x800 ) ; private short field_2_top_row ; private short field_3_left_col ; private int field_4_header_color ; private short field_5_page_break_zoom ; private short field_6_normal_zoom ; private int field_7_reserved ; public WindowTwoRecord ( ) { } public WindowTwoRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowTwoRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid WindowTwo RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_options = LittleEndian . getShort ( data , 0 + offset ) ; field_2_top_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_left_col = LittleEndian . getShort ( data , 4 + offset ) ; field_4_header_color = LittleEndian . getInt ( data , 6 + offset ) ; if ( size > 10 ) { field_5_page_break_zoom = LittleEndian . getShort ( data , 10 + offset ) ; field_6_normal_zoom = LittleEndian . getShort ( data , 12 + offset ) ; } if ( size > 14 ) { field_7_reserved = LittleEndian . getInt ( data , 14 + offset ) ; } } public void setOptions ( short options ) { field_1_options = options ; } public void setDisplayFormulas ( boolean formulas ) { field_1_options = displayFormulas . setShortBoolean ( field_1_options , formulas ) ; } public void setDisplayGridlines ( boolean gridlines ) { field_1_options = displayGridlines . setShortBoolean ( field_1_options , gridlines ) ; } public void setDisplayRowColHeadings ( boolean headings ) { field_1_options = displayRowColHeadings . setShortBoolean ( field_1_options , headings ) ; } public void setFreezePanes ( boolean freezepanes ) { field_1_options = freezePanes . setShortBoolean ( field_1_options , freezepanes ) ; } public void setDisplayZeros ( boolean zeros ) { field_1_options = displayZeros . setShortBoolean ( field_1_options , zeros ) ; } public void setDefaultHeader ( boolean header ) { field_1_options = defaultHeader . setShortBoolean ( field_1_options , header ) ; } public void setArabic ( boolean isarabic ) { field_1_options = arabic . setShortBoolean ( field_1_options , isarabic ) ; } public void setDisplayGuts ( boolean guts ) { field_1_options = displayGuts . setShortBoolean ( field_1_options , guts ) ; } public void setFreezePanesNoSplit ( boolean freeze ) { field_1_options = freezePanesNoSplit . setShortBoolean ( field_1_options , freeze ) ; } public void setSelected ( boolean sel ) { field_1_options = selected . setShortBoolean ( field_1_options , sel ) ; } public void setPaged ( boolean p ) { field_1_options = paged . setShortBoolean ( field_1_options , p ) ; } public void setSavedInPageBreakPreview ( boolean p ) { field_1_options = savedInPageBreakPreview . setShortBoolean ( field_1_options , p ) ; } public void setTopRow ( short topRow ) { field_2_top_row = topRow ; } public void setLeftCol ( short leftCol ) { field_3_left_col = leftCol ; } public void setHeaderColor ( int color ) { field_4_header_color = color ; } public void setPageBreakZoom ( short zoom ) { field_5_page_break_zoom = zoom ; } public void setNormalZoom ( short zoom ) { field_6_normal_zoom = zoom ; } public void setReserved ( int reserved ) { field_7_reserved = reserved ; } public short getOptions ( ) { return field_1_options ; } public boolean getDisplayFormulas ( ) { return displayFormulas . isSet ( field_1_options ) ; } public boolean getDisplayGridlines ( ) { return displayGridlines . isSet ( field_1_options ) ; } public boolean getDisplayRowColHeadings ( ) { return displayRowColHeadings . isSet ( field_1_options ) ; } public boolean getFreezePanes ( ) { return freezePanes . isSet ( field_1_options ) ; } public boolean getDisplayZeros ( ) { return displayZeros . isSet ( field_1_options ) ; } public boolean getDefaultHeader ( ) { return defaultHeader . isSet ( field_1_options ) ; } public boolean getArabic ( ) { return arabic . isSet ( field_1_options ) ; } public boolean getDisplayGuts ( ) { return displayGuts . isSet ( field_1_options ) ; } public boolean getFreezePanesNoSplit ( ) { return freezePanesNoSplit . isSet ( field_1_options ) ; } public boolean getSelected ( ) { return selected . isSet ( field_1_options ) ; } public boolean getPaged ( ) { return paged . isSet ( field_1_options ) ; } public boolean getSavedInPageBreakPreview ( ) { return savedInPageBreakPreview . isSet ( field_1_options ) ; } public short getTopRow ( ) { return field_2_top_row ; } public short getLeftCol ( ) { return field_3_left_col ; } public int getHeaderColor ( ) { return field_4_header_color ; } public short getPageBreakZoom ( ) { return field_5_page_break_zoom ; } public short getNormalZoom ( ) { return field_6_normal_zoom ; } public int getReserved ( ) { return field_7_reserved ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOW2]\n" ) ; buffer . append ( "    .options        = " ) . append ( Integer . toHexString ( getOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "       .dispformulas= " ) . append ( getDisplayFormulas ( ) ) . append ( "\n" ) ; buffer . append ( "       .dispgridlins= " ) . append ( getDisplayGridlines ( ) ) . append ( "\n" ) ; buffer . append ( "       .disprcheadin= " ) . append ( getDisplayRowColHeadings ( ) ) . append ( "\n" ) ; buffer . append ( "       .freezepanes = " ) . append ( getFreezePanes ( ) ) . append ( "\n" ) ; buffer . append ( "       .displayzeros= " ) . append ( getDisplayZeros ( ) ) . append ( "\n" ) ; buffer . append ( "       .defaultheadr= " ) . append ( getDefaultHeader ( ) ) . append ( "\n" ) ; buffer . append ( "       .arabic      = " ) . append ( getArabic ( ) ) . append ( "\n" ) ; buffer . append ( "       .displayguts = " ) . append ( getDisplayGuts ( ) ) . append ( "\n" ) ; buffer . append ( "       .frzpnsnosplt= " ) . append ( getFreezePanesNoSplit ( ) ) . append ( "\n" ) ; buffer . append ( "       .selected    = " ) . append ( getSelected ( ) ) . append ( "\n" ) ; buffer . append ( "       .paged       = " ) . append ( getPaged ( ) ) . append ( "\n" ) ; buffer . append ( "       .svdinpgbrkpv= " ) . append ( getSavedInPageBreakPreview ( ) ) . append ( "\n" ) ; buffer . append ( "    .toprow         = " ) . append ( Integer . toHexString ( getTopRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .leftcol        = " ) . append ( Integer . toHexString ( getLeftCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .headercolor    = " ) . append ( Integer . toHexString ( getHeaderColor ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .pagebreakzoom  = " ) . append ( Integer . toHexString ( getPageBreakZoom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .normalzoom     = " ) . append ( Integer . toHexString ( getNormalZoom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .reserved       = " ) . append ( Integer . toHexString ( getReserved ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOW2]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 18 ) ; LittleEndian . putShort ( data , 4 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getTopRow ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getLeftCol ( ) ) ; LittleEndian . putInt ( data , 10 + offset , getHeaderColor ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getPageBreakZoom ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getNormalZoom ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getReserved ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { WindowTwoRecord rec = new WindowTwoRecord ( ) ; rec . field_1_options = field_1_options ; rec . field_2_top_row = field_2_top_row ; rec . field_3_left_col = field_3_left_col ; rec . field_4_header_color = field_4_header_color ; rec . field_5_page_break_zoom = field_5_page_break_zoom ; rec . field_6_normal_zoom = field_6_normal_zoom ; rec . field_7_reserved = field_7_reserved ; return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class HeaderRecord extends Record { public final static short sid = 0x14 ; private byte field_1_header_len ; private String field_2_header ; public HeaderRecord ( ) { } public HeaderRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public HeaderRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A HEADERRECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { if ( size > 0 ) { field_1_header_len = data [ 0 + offset ] ; field_2_header = StringUtil . getFromCompressedUnicode ( data , 3 + offset , LittleEndian . ubyteToInt ( field_1_header_len ) ) ; } } public void setHeaderLength ( byte len ) { field_1_header_len = len ; } public void setHeader ( String header ) { field_2_header = header ; } public short getHeaderLength ( ) { return ( short ) ( 0xFF & field_1_header_len ) ; } public String getHeader ( ) { return field_2_header ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[HEADER]\n" ) ; buffer . append ( "    .length         = " ) . append ( getHeaderLength ( ) ) . append ( "\n" ) ; buffer . append ( "    .header         = " ) . append ( getHeader ( ) ) . append ( "\n" ) ; buffer . append ( "[/HEADER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int len = 4 ; if ( getHeaderLength ( ) != 0 ) { len += 3 ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( ( len - 4 ) + getHeaderLength ( ) ) ) ; if ( getHeaderLength ( ) > 0 ) { data [ 4 + offset ] = ( byte ) getHeaderLength ( ) ; StringUtil . putCompressedUnicode ( getHeader ( ) , data , 7 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 4 ; if ( getHeaderLength ( ) != 0 ) { retval += 3 ; } retval += getHeaderLength ( ) ; return retval ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { HeaderRecord rec = new HeaderRecord ( ) ; rec . field_1_header_len = field_1_header_len ; rec . field_2_header = field_2_header ; return rec ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; import java . io . IOException ; public class StringRecord extends Record { public final static short sid = 0x207 ; private int field_1_string_length ; private byte field_2_unicode_flag ; private String field_3_string ; public StringRecord ( ) { } public StringRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public StringRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != this . sid ) { throw new RecordFormatException ( "Not a valid StringRecord" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_string_length = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_unicode_flag = data [ 2 + offset ] ; if ( isUnCompressedUnicode ( ) ) { field_3_string = StringUtil . getFromUnicode ( data , 3 + offset , field_1_string_length ) ; } else { field_3_string = StringUtil . getFromCompressedUnicode ( data , 3 + offset , field_1_string_length ) ; } } public boolean isInValueSection ( ) { return true ; } private int getStringLength ( ) { return field_1_string_length ; } private int getStringByteLength ( ) { return isUnCompressedUnicode ( ) ? field_1_string_length * 2 : field_1_string_length ; } public int getRecordSize ( ) { return 4 + 2 + 1 + getStringByteLength ( ) ; } public boolean isUnCompressedUnicode ( ) { return ( field_2_unicode_flag == 1 ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 3 + getStringByteLength ( ) ) ) ; LittleEndian . putUShort ( data , 4 + offset , field_1_string_length ) ; data [ 6 + offset ] = field_2_unicode_flag ; if ( isUnCompressedUnicode ( ) ) { StringUtil . putUncompressedUnicode ( field_3_string , data , 7 + offset ) ; } else { StringUtil . putCompressedUnicode ( field_3_string , data , 7 + offset ) ; } return getRecordSize ( ) ; } public short getSid ( ) { return sid ; } public String getString ( ) { return field_3_string ; } public void setCompressedFlag ( byte unicode_flag ) { this . field_2_unicode_flag = unicode_flag ; } public void setString ( String string ) { this . field_1_string_length = string . length ( ) ; this . field_3_string = string ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[STRING]\n" ) ; buffer . append ( "    .string            = " ) . append ( field_3_string ) . append ( "\n" ) ; buffer . append ( "[/STRING]\n" ) ; return buffer . toString ( ) ; } public Object clone ( ) { StringRecord rec = new StringRecord ( ) ; rec . field_1_string_length = this . field_1_string_length ; rec . field_2_unicode_flag = this . field_2_unicode_flag ; rec . field_3_string = this . field_3_string ; return rec ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; public abstract class OperationPtg extends Ptg { public final static int TYPE_UNARY = 0 ; public final static int TYPE_BINARY = 1 ; public final static int TYPE_FUNCTION = 2 ; public abstract int getType ( ) ; public abstract String toFormulaString ( String [ ] operands ) ; public abstract int getNumberOfOperands ( ) ; public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class LongField implements FixedField { private long _value ; private final int _offset ; public LongField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public LongField ( final int offset , final long value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public LongField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public LongField ( final int offset , final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public long get ( ) { return _value ; } public void set ( final long value ) { _value = value ; } public void set ( final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getLong ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readLong ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putLong ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class FontBasisRecord extends Record { public final static short sid = 0x1060 ; private short field_1_xBasis ; private short field_2_yBasis ; private short field_3_heightBasis ; private short field_4_scale ; private short field_5_indexToFontTable ; public FontBasisRecord ( ) { } public FontBasisRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FontBasisRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a FontBasis record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_xBasis = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_yBasis = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_heightBasis = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_4_scale = LittleEndian . getShort ( data , pos + 0x6 + offset ) ; field_5_indexToFontTable = LittleEndian . getShort ( data , pos + 0x8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FBI]\n" ) ; buffer . append ( "    .xBasis               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getXBasis ( ) ) ) . append ( " (" ) . append ( getXBasis ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .yBasis               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getYBasis ( ) ) ) . append ( " (" ) . append ( getYBasis ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .heightBasis          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getHeightBasis ( ) ) ) . append ( " (" ) . append ( getHeightBasis ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .scale                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getScale ( ) ) ) . append ( " (" ) . append ( getScale ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .indexToFontTable     = " ) . append ( "0x" ) . append ( HexDump . toHex ( getIndexToFontTable ( ) ) ) . append ( " (" ) . append ( getIndexToFontTable ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/FBI]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_xBasis ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_yBasis ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_heightBasis ) ; LittleEndian . putShort ( data , 10 + offset + pos , field_4_scale ) ; LittleEndian . putShort ( data , 12 + offset + pos , field_5_indexToFontTable ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { FontBasisRecord rec = new FontBasisRecord ( ) ; rec . field_1_xBasis = field_1_xBasis ; rec . field_2_yBasis = field_2_yBasis ; rec . field_3_heightBasis = field_3_heightBasis ; rec . field_4_scale = field_4_scale ; rec . field_5_indexToFontTable = field_5_indexToFontTable ; return rec ; } public short getXBasis ( ) { return field_1_xBasis ; } public void setXBasis ( short field_1_xBasis ) { this . field_1_xBasis = field_1_xBasis ; } public short getYBasis ( ) { return field_2_yBasis ; } public void setYBasis ( short field_2_yBasis ) { this . field_2_yBasis = field_2_yBasis ; } public short getHeightBasis ( ) { return field_3_heightBasis ; } public void setHeightBasis ( short field_3_heightBasis ) { this . field_3_heightBasis = field_3_heightBasis ; } public short getScale ( ) { return field_4_scale ; } public void setScale ( short field_4_scale ) { this . field_4_scale = field_4_scale ; } public short getIndexToFontTable ( ) { return field_5_indexToFontTable ; } public void setIndexToFontTable ( short field_5_indexToFontTable ) { this . field_5_indexToFontTable = field_5_indexToFontTable ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SheetPropertiesRecord extends Record { public final static short sid = 0x1044 ; private short field_1_flags ; private BitField chartTypeManuallyFormatted = new BitField ( 0x1 ) ; private BitField plotVisibleOnly = new BitField ( 0x2 ) ; private BitField doNotSizeWithWindow = new BitField ( 0x4 ) ; private BitField defaultPlotDimensions = new BitField ( 0x8 ) ; private BitField autoPlotArea = new BitField ( 0x10 ) ; private byte field_2_empty ; public final static byte EMPTY_NOT_PLOTTED = 0 ; public final static byte EMPTY_ZERO = 1 ; public final static byte EMPTY_INTERPOLATED = 2 ; public SheetPropertiesRecord ( ) { } public SheetPropertiesRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SheetPropertiesRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SheetProperties record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_flags = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_empty = data [ pos + 0x2 + offset ] ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SHTPROPS]\n" ) ; buffer . append ( "    .flags                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFlags ( ) ) ) . append ( " (" ) . append ( getFlags ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .chartTypeManuallyFormatted     = " ) . append ( isChartTypeManuallyFormatted ( ) ) . append ( '\n' ) ; buffer . append ( "         .plotVisibleOnly          = " ) . append ( isPlotVisibleOnly ( ) ) . append ( '\n' ) ; buffer . append ( "         .doNotSizeWithWindow      = " ) . append ( isDoNotSizeWithWindow ( ) ) . append ( '\n' ) ; buffer . append ( "         .defaultPlotDimensions     = " ) . append ( isDefaultPlotDimensions ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoPlotArea             = " ) . append ( isAutoPlotArea ( ) ) . append ( '\n' ) ; buffer . append ( "    .empty                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getEmpty ( ) ) ) . append ( " (" ) . append ( getEmpty ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SHTPROPS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_flags ) ; data [ 6 + offset + pos ] = field_2_empty ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 1 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SheetPropertiesRecord rec = new SheetPropertiesRecord ( ) ; rec . field_1_flags = field_1_flags ; rec . field_2_empty = field_2_empty ; return rec ; } public short getFlags ( ) { return field_1_flags ; } public void setFlags ( short field_1_flags ) { this . field_1_flags = field_1_flags ; } public byte getEmpty ( ) { return field_2_empty ; } public void setEmpty ( byte field_2_empty ) { this . field_2_empty = field_2_empty ; } public void setChartTypeManuallyFormatted ( boolean value ) { field_1_flags = chartTypeManuallyFormatted . setShortBoolean ( field_1_flags , value ) ; } public boolean isChartTypeManuallyFormatted ( ) { return chartTypeManuallyFormatted . isSet ( field_1_flags ) ; } public void setPlotVisibleOnly ( boolean value ) { field_1_flags = plotVisibleOnly . setShortBoolean ( field_1_flags , value ) ; } public boolean isPlotVisibleOnly ( ) { return plotVisibleOnly . isSet ( field_1_flags ) ; } public void setDoNotSizeWithWindow ( boolean value ) { field_1_flags = doNotSizeWithWindow . setShortBoolean ( field_1_flags , value ) ; } public boolean isDoNotSizeWithWindow ( ) { return doNotSizeWithWindow . isSet ( field_1_flags ) ; } public void setDefaultPlotDimensions ( boolean value ) { field_1_flags = defaultPlotDimensions . setShortBoolean ( field_1_flags , value ) ; } public boolean isDefaultPlotDimensions ( ) { return defaultPlotDimensions . isSet ( field_1_flags ) ; } public void setAutoPlotArea ( boolean value ) { field_1_flags = autoPlotArea . setShortBoolean ( field_1_flags , value ) ; } public boolean isAutoPlotArea ( ) { return autoPlotArea . isSet ( field_1_flags ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LittleEndian ; class RecordProcessor { private byte [ ] data ; private int recordOffset ; private int available ; private SSTRecordHeader sstRecordHeader ; public RecordProcessor ( byte [ ] data , int available , int numStrings , int numUniqueStrings ) { this . data = data ; this . available = available ; this . sstRecordHeader = new SSTRecordHeader ( numStrings , numUniqueStrings ) ; } public int getAvailable ( ) { return available ; } public void writeRecordHeader ( int offset , int totalWritten , int recordLength , boolean first_record ) { if ( first_record ) { available -= 8 ; recordOffset = sstRecordHeader . writeSSTHeader ( data , recordOffset + offset + totalWritten , recordLength ) ; } else { recordOffset = writeContinueHeader ( data , recordOffset + offset + totalWritten , recordLength ) ; } } public byte [ ] writeStringRemainder ( boolean lastStringCompleted , byte [ ] stringreminant , int offset , int totalWritten ) { if ( ! lastStringCompleted ) { System . arraycopy ( stringreminant , 0 , data , recordOffset + offset + totalWritten , stringreminant . length ) ; adjustPointers ( stringreminant . length ) ; } else { System . arraycopy ( stringreminant , 0 , data , recordOffset + offset + totalWritten , available ) ; byte [ ] leftover = new byte [ ( stringreminant . length - available ) + LittleEndianConsts . BYTE_SIZE ] ; System . arraycopy ( stringreminant , available , leftover , LittleEndianConsts . BYTE_SIZE , stringreminant . length - available ) ; leftover [ 0 ] = stringreminant [ 0 ] ; stringreminant = leftover ; adjustPointers ( available ) ; } return stringreminant ; } public void writeWholeString ( UnicodeString unistr , int offset , int totalWritten ) { unistr . serialize ( recordOffset + offset + totalWritten , data ) ; int rsize = unistr . getRecordSize ( ) ; adjustPointers ( rsize ) ; } public byte [ ] writePartString ( UnicodeString unistr , int offset , int totalWritten ) { byte [ ] stringReminant ; byte [ ] ucs = unistr . serialize ( ) ; System . arraycopy ( ucs , 0 , data , recordOffset + offset + totalWritten , available ) ; stringReminant = new byte [ ( ucs . length - available ) + LittleEndianConsts . BYTE_SIZE ] ; System . arraycopy ( ucs , available , stringReminant , LittleEndianConsts . BYTE_SIZE , ucs . length - available ) ; stringReminant [ 0 ] = ucs [ LittleEndianConsts . SHORT_SIZE ] ; available = 0 ; return stringReminant ; } private int writeContinueHeader ( final byte [ ] data , final int pos , final int recsize ) { int offset = pos ; LittleEndian . putShort ( data , offset , ContinueRecord . sid ) ; offset += LittleEndianConsts . SHORT_SIZE ; LittleEndian . putShort ( data , offset , ( short ) ( recsize ) ) ; offset += LittleEndianConsts . SHORT_SIZE ; return offset - pos ; } private void adjustPointers ( int amount ) { recordOffset += amount ; available -= amount ; } public int getRecordOffset ( ) { return recordOffset ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class TickRecord extends Record { public final static short sid = 0x101e ; private byte field_1_majorTickType ; private byte field_2_minorTickType ; private byte field_3_labelPosition ; private byte field_4_background ; private int field_5_labelColorRgb ; private short field_6_zero1 ; private short field_7_zero2 ; private short field_8_options ; private BitField autoTextColor = new BitField ( 0x1 ) ; private BitField autoTextBackground = new BitField ( 0x2 ) ; private BitField rotation = new BitField ( 0x1c ) ; private BitField autorotate = new BitField ( 0x20 ) ; private short field_9_tickColor ; private short field_10_zero3 ; public TickRecord ( ) { } public TickRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public TickRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Tick record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_majorTickType = data [ pos + 0x0 + offset ] ; field_2_minorTickType = data [ pos + 0x1 + offset ] ; field_3_labelPosition = data [ pos + 0x2 + offset ] ; field_4_background = data [ pos + 0x3 + offset ] ; field_5_labelColorRgb = LittleEndian . getInt ( data , pos + 0x4 + offset ) ; field_6_zero1 = LittleEndian . getShort ( data , pos + 0x8 + offset ) ; field_7_zero2 = LittleEndian . getShort ( data , pos + 0x10 + offset ) ; field_8_options = LittleEndian . getShort ( data , pos + 0x18 + offset ) ; field_9_tickColor = LittleEndian . getShort ( data , pos + 0x1a + offset ) ; field_10_zero3 = LittleEndian . getShort ( data , pos + 0x1c + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[TICK]\n" ) ; buffer . append ( "    .majorTickType        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMajorTickType ( ) ) ) . append ( " (" ) . append ( getMajorTickType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .minorTickType        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMinorTickType ( ) ) ) . append ( " (" ) . append ( getMinorTickType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .labelPosition        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLabelPosition ( ) ) ) . append ( " (" ) . append ( getLabelPosition ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .background           = " ) . append ( "0x" ) . append ( HexDump . toHex ( getBackground ( ) ) ) . append ( " (" ) . append ( getBackground ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .labelColorRgb        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLabelColorRgb ( ) ) ) . append ( " (" ) . append ( getLabelColorRgb ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .zero1                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getZero1 ( ) ) ) . append ( " (" ) . append ( getZero1 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .zero2                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getZero2 ( ) ) ) . append ( " (" ) . append ( getZero2 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .autoTextColor            = " ) . append ( isAutoTextColor ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoTextBackground       = " ) . append ( isAutoTextBackground ( ) ) . append ( '\n' ) ; buffer . append ( "         .rotation                 = " ) . append ( getRotation ( ) ) . append ( '\n' ) ; buffer . append ( "         .autorotate               = " ) . append ( isAutorotate ( ) ) . append ( '\n' ) ; buffer . append ( "    .tickColor            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getTickColor ( ) ) ) . append ( " (" ) . append ( getTickColor ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .zero3                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getZero3 ( ) ) ) . append ( " (" ) . append ( getZero3 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/TICK]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; data [ 4 + offset + pos ] = field_1_majorTickType ; data [ 5 + offset + pos ] = field_2_minorTickType ; data [ 6 + offset + pos ] = field_3_labelPosition ; data [ 7 + offset + pos ] = field_4_background ; LittleEndian . putInt ( data , 8 + offset + pos , field_5_labelColorRgb ) ; LittleEndian . putShort ( data , 12 + offset + pos , field_6_zero1 ) ; LittleEndian . putShort ( data , 20 + offset + pos , field_7_zero2 ) ; LittleEndian . putShort ( data , 28 + offset + pos , field_8_options ) ; LittleEndian . putShort ( data , 30 + offset + pos , field_9_tickColor ) ; LittleEndian . putShort ( data , 32 + offset + pos , field_10_zero3 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 1 + 1 + 1 + 1 + 4 + 8 + 8 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { TickRecord rec = new TickRecord ( ) ; rec . field_1_majorTickType = field_1_majorTickType ; rec . field_2_minorTickType = field_2_minorTickType ; rec . field_3_labelPosition = field_3_labelPosition ; rec . field_4_background = field_4_background ; rec . field_5_labelColorRgb = field_5_labelColorRgb ; rec . field_6_zero1 = field_6_zero1 ; rec . field_7_zero2 = field_7_zero2 ; rec . field_8_options = field_8_options ; rec . field_9_tickColor = field_9_tickColor ; rec . field_10_zero3 = field_10_zero3 ; return rec ; } public byte getMajorTickType ( ) { return field_1_majorTickType ; } public void setMajorTickType ( byte field_1_majorTickType ) { this . field_1_majorTickType = field_1_majorTickType ; } public byte getMinorTickType ( ) { return field_2_minorTickType ; } public void setMinorTickType ( byte field_2_minorTickType ) { this . field_2_minorTickType = field_2_minorTickType ; } public byte getLabelPosition ( ) { return field_3_labelPosition ; } public void setLabelPosition ( byte field_3_labelPosition ) { this . field_3_labelPosition = field_3_labelPosition ; } public byte getBackground ( ) { return field_4_background ; } public void setBackground ( byte field_4_background ) { this . field_4_background = field_4_background ; } public int getLabelColorRgb ( ) { return field_5_labelColorRgb ; } public void setLabelColorRgb ( int field_5_labelColorRgb ) { this . field_5_labelColorRgb = field_5_labelColorRgb ; } public short getZero1 ( ) { return field_6_zero1 ; } public void setZero1 ( short field_6_zero1 ) { this . field_6_zero1 = field_6_zero1 ; } public short getZero2 ( ) { return field_7_zero2 ; } public void setZero2 ( short field_7_zero2 ) { this . field_7_zero2 = field_7_zero2 ; } public short getOptions ( ) { return field_8_options ; } public void setOptions ( short field_8_options ) { this . field_8_options = field_8_options ; } public short getTickColor ( ) { return field_9_tickColor ; } public void setTickColor ( short field_9_tickColor ) { this . field_9_tickColor = field_9_tickColor ; } public short getZero3 ( ) { return field_10_zero3 ; } public void setZero3 ( short field_10_zero3 ) { this . field_10_zero3 = field_10_zero3 ; } public void setAutoTextColor ( boolean value ) { field_8_options = autoTextColor . setShortBoolean ( field_8_options , value ) ; } public boolean isAutoTextColor ( ) { return autoTextColor . isSet ( field_8_options ) ; } public void setAutoTextBackground ( boolean value ) { field_8_options = autoTextBackground . setShortBoolean ( field_8_options , value ) ; } public boolean isAutoTextBackground ( ) { return autoTextBackground . isSet ( field_8_options ) ; } public void setRotation ( short value ) { field_8_options = rotation . setShortValue ( field_8_options , value ) ; } public short getRotation ( ) { return rotation . getShortValue ( field_8_options ) ; } public void setAutorotate ( boolean value ) { field_8_options = autorotate . setShortBoolean ( field_8_options , value ) ; } public boolean isAutorotate ( ) { return autorotate . isSet ( field_8_options ) ; } } 	0
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; abstract class BigBlock implements BlockWritable { protected void doWriteData ( final OutputStream stream , final byte [ ] data ) throws IOException { stream . write ( data ) ; } abstract void writeData ( final OutputStream stream ) throws IOException ; public void writeBlocks ( final OutputStream stream ) throws IOException { writeData ( stream ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class WriteAccessRecord extends Record { public final static short sid = 0x5c ; private String field_1_username ; public WriteAccessRecord ( ) { } public WriteAccessRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WriteAccessRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WRITEACCESS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_username = StringUtil . getFromCompressedUnicode ( data , 3 + offset , data . length - 4 ) ; } public void setUsername ( String username ) { field_1_username = username ; } public String getUsername ( ) { return field_1_username ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WRITEACCESS]\n" ) ; buffer . append ( "    .name            = " ) . append ( field_1_username . toString ( ) ) . append ( "\n" ) ; buffer . append ( "[/WRITEACCESS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { String username = getUsername ( ) ; StringBuffer temp = new StringBuffer ( 0x70 - ( 0x3 ) ) ; temp . append ( username ) ; while ( temp . length ( ) < 0x70 - 0x3 ) { temp . append ( " " ) ; } username = temp . toString ( ) ; UnicodeString str = new UnicodeString ( ) ; str . setString ( username ) ; str . setOptionFlags ( ( byte ) 0x0 ) ; str . setCharCount ( ( short ) 0x4 ) ; byte [ ] stringbytes = str . serialize ( ) ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( stringbytes . length ) ) ; System . arraycopy ( stringbytes , 0 , data , 4 + offset , stringbytes . length ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 116 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PrecisionRecord extends Record { public final static short sid = 0xE ; public short field_1_precision ; public PrecisionRecord ( ) { } public PrecisionRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PrecisionRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PRECISION RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_precision = LittleEndian . getShort ( data , 0 + offset ) ; } public void setFullPrecision ( boolean fullprecision ) { if ( fullprecision == true ) { field_1_precision = 1 ; } else { field_1_precision = 0 ; } } public boolean getFullPrecision ( ) { return ( field_1_precision == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PRECISION]\n" ) ; buffer . append ( "    .precision       = " ) . append ( getFullPrecision ( ) ) . append ( "\n" ) ; buffer . append ( "[/PRECISION]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_precision ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . model . Model ; public interface ModelFactoryListener { public boolean process ( Model model ) ; } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface ListManagedBlock { public byte [ ] getData ( ) throws IOException ; } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class UnknownRecord extends Record { private short sid = 0 ; private byte [ ] thedata = null ; public UnknownRecord ( ) { } public UnknownRecord ( short id , short size , byte [ ] data ) { sid = id ; thedata = data ; } public int serialize ( int offset , byte [ ] data ) { if ( thedata == null ) { thedata = new byte [ 0 ] ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( thedata . length ) ) ; if ( thedata . length > 0 ) { System . arraycopy ( thedata , 0 , data , 4 + offset , thedata . length ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 4 ; if ( thedata != null ) { retval += thedata . length ; } return retval ; } protected void fillFields ( byte [ ] data , short sid ) { this . sid = sid ; thedata = data ; } protected void validateSid ( short id ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[UNKNOWN RECORD:" + Integer . toHexString ( sid ) + "]\n" ) ; buffer . append ( "    .id        = " ) . append ( Integer . toHexString ( sid ) ) . append ( "\n" ) ; buffer . append ( "[/UNKNOWN RECORD]\n" ) ; return buffer . toString ( ) ; } public short getSid ( ) { return this . sid ; } protected void fillFields ( byte [ ] data , short size , int offset ) { throw new RecordFormatException ( "Unknown record cannot be constructed via offset -- we need a copy of the data" ) ; } public Object clone ( ) { UnknownRecord rec = new UnknownRecord ( ) ; rec . sid = sid ; rec . thedata = thedata ; return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; public class NamePtg extends Ptg { public final static short sid = 0x23 ; private final static int SIZE = 5 ; private short field_1_label_index ; private short field_2_zero ; boolean xtra = false ; private NamePtg ( ) { } public NamePtg ( String name , Workbook book ) { final short n = ( short ) ( book . getNumNames ( ) + 1 ) ; NameRecord rec ; for ( short i = 1 ; i < n ; i ++ ) { rec = book . getNameRecord ( i - 1 ) ; if ( name . equals ( rec . getNameText ( ) ) ) { field_1_label_index = i ; return ; } } rec = new NameRecord ( ) ; rec . setNameText ( name ) ; rec . setNameTextLength ( ( byte ) name . length ( ) ) ; book . addName ( rec ) ; field_1_label_index = n ; } public NamePtg ( byte [ ] data , int offset ) { offset ++ ; field_1_label_index = LittleEndian . getShort ( data , offset ) ; field_2_zero = LittleEndian . getShort ( data , offset + 2 ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_label_index ) ; LittleEndian . putShort ( array , offset + 3 , field_2_zero ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { NameRecord rec = book . getNameRecord ( field_1_label_index - 1 ) ; return rec . getNameText ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { NamePtg ptg = new NamePtg ( ) ; ptg . field_1_label_index = field_1_label_index ; ptg . field_2_zero = field_2_zero ; return ptg ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . poifs . eventfilesystem ; public interface POIFSReaderListener { public void processPOIFSReaderEvent ( POIFSReaderEvent event ) ; } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class VCenterRecord extends Record { public final static short sid = 0x84 ; private short field_1_vcenter ; public VCenterRecord ( ) { } public VCenterRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public VCenterRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A VCenter RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_vcenter = LittleEndian . getShort ( data , 0 + offset ) ; } public void setVCenter ( boolean hc ) { if ( hc == true ) { field_1_vcenter = 1 ; } else { field_1_vcenter = 0 ; } } public boolean getVCenter ( ) { return ( field_1_vcenter == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[VCENTER]\n" ) ; buffer . append ( "    .vcenter        = " ) . append ( getVCenter ( ) ) . append ( "\n" ) ; buffer . append ( "[/VCENTER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) field_1_vcenter ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { VCenterRecord rec = new VCenterRecord ( ) ; rec . field_1_vcenter = field_1_vcenter ; return rec ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . poifs . property ; import java . util . * ; import java . io . IOException ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class DirectoryProperty extends Property implements Parent { private List _children ; private Set _children_names ; public DirectoryProperty ( String name ) { super ( ) ; _children = new ArrayList ( ) ; _children_names = new HashSet ( ) ; setName ( name ) ; setSize ( 0 ) ; setPropertyType ( PropertyConstants . DIRECTORY_TYPE ) ; setStartBlock ( 0 ) ; setNodeColor ( _NODE_BLACK ) ; } protected DirectoryProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _children = new ArrayList ( ) ; _children_names = new HashSet ( ) ; } public boolean changeName ( final Property property , final String newName ) { boolean result ; String oldName = property . getName ( ) ; property . setName ( newName ) ; String cleanNewName = property . getName ( ) ; if ( _children_names . contains ( cleanNewName ) ) { property . setName ( oldName ) ; result = false ; } else { _children_names . add ( cleanNewName ) ; _children_names . remove ( oldName ) ; result = true ; } return result ; } public boolean deleteChild ( final Property property ) { boolean result = _children . remove ( property ) ; if ( result ) { _children_names . remove ( property . getName ( ) ) ; } return result ; } private class PropertyComparator implements Comparator { public boolean equals ( Object o ) { return this == o ; } public int compare ( Object o1 , Object o2 ) { String name1 = ( ( Property ) o1 ) . getName ( ) ; String name2 = ( ( Property ) o2 ) . getName ( ) ; int result = name1 . length ( ) - name2 . length ( ) ; if ( result == 0 ) { result = name1 . compareTo ( name2 ) ; } return result ; } } public boolean isDirectory ( ) { return true ; } protected void preWrite ( ) { if ( _children . size ( ) > 0 ) { Property [ ] children = ( Property [ ] ) _children . toArray ( new Property [ 0 ] ) ; Arrays . sort ( children , new PropertyComparator ( ) ) ; int midpoint = children . length / 2 ; setChildProperty ( children [ midpoint ] . getIndex ( ) ) ; children [ 0 ] . setPreviousChild ( null ) ; children [ 0 ] . setNextChild ( null ) ; for ( int j = 1 ; j < midpoint ; j ++ ) { children [ j ] . setPreviousChild ( children [ j - 1 ] ) ; children [ j ] . setNextChild ( null ) ; } if ( midpoint != 0 ) { children [ midpoint ] . setPreviousChild ( children [ midpoint - 1 ] ) ; } if ( midpoint != ( children . length - 1 ) ) { children [ midpoint ] . setNextChild ( children [ midpoint + 1 ] ) ; for ( int j = midpoint + 1 ; j < children . length - 1 ; j ++ ) { children [ j ] . setPreviousChild ( null ) ; children [ j ] . setNextChild ( children [ j + 1 ] ) ; } children [ children . length - 1 ] . setPreviousChild ( null ) ; children [ children . length - 1 ] . setNextChild ( null ) ; } else { children [ midpoint ] . setNextChild ( null ) ; } } } public Iterator getChildren ( ) { return _children . iterator ( ) ; } public void addChild ( final Property property ) throws IOException { String name = property . getName ( ) ; if ( _children_names . contains ( name ) ) { throw new IOException ( "Duplicate name \"" + name + "\"" ) ; } _children_names . add ( name ) ; _children . add ( property ) ; } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . model . Workbook ; public class Ref3DPtg extends Ptg { public final static byte sid = 0x3a ; private final static int SIZE = 7 ; private short field_1_index_extern_sheet ; private short field_2_row ; private short field_3_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Ref3DPtg ( ) { } public Ref3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_column = LittleEndian . getShort ( data , 4 + offset ) ; } public Ref3DPtg ( String cellref , short externIdx ) { CellReference c = new CellReference ( cellref ) ; setRow ( ( short ) c . getRow ( ) ) ; setColumn ( ( short ) c . getCol ( ) ) ; setColRelative ( ! c . isColAbsolute ( ) ) ; setRowRelative ( ! c . isRowAbsolute ( ) ) ; setExternSheetIndex ( externIdx ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Ref3dPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "Row = " + getRow ( ) ) . append ( "\n" ) ; buffer . append ( "Col  = " + getColumn ( ) ) . append ( "\n" ) ; buffer . append ( "ColRowRel= " + isRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "ColRel   = " + isColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getRow ( ) { return field_2_row ; } public void setRow ( short row ) { field_2_row = row ; } public short getColumn ( ) { return ( short ) ( field_3_column & 0xFF ) ; } public short getColumnRaw ( ) { return field_3_column ; } public boolean isRowRelative ( ) { return rowRelative . isSet ( field_3_column ) ; } public void setRowRelative ( boolean rel ) { field_3_column = rowRelative . setShortBoolean ( field_3_column , rel ) ; } public boolean isColRelative ( ) { return colRelative . isSet ( field_3_column ) ; } public void setColRelative ( boolean rel ) { field_3_column = colRelative . setShortBoolean ( field_3_column , rel ) ; } public void setColumn ( short column ) { field_3_column &= 0xFF00 ; field_3_column |= column & 0xFF ; } public void setColumnRaw ( short column ) { field_3_column = column ; } public void setArea ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String from = ra . getFromCell ( ) ; setColumn ( ( short ) ( ra . getXPosition ( from ) - 1 ) ) ; setRow ( ( short ) ( ra . getYPosition ( from ) - 1 ) ) ; } public String toFormulaString ( Workbook book ) { StringBuffer retval = new StringBuffer ( ) ; SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( ( int ) this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getRow ( ) , getColumn ( ) , ! isRowRelative ( ) , ! isColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Ref3DPtg ptg = new Ref3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_row = field_2_row ; ptg . field_3_column = field_3_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SeriesIndexRecord extends Record { public final static short sid = 0x1065 ; private short field_1_index ; public SeriesIndexRecord ( ) { } public SeriesIndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesIndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesIndex record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_index = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SINDEX]\n" ) ; buffer . append ( "    .index                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getIndex ( ) ) ) . append ( " (" ) . append ( getIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SINDEX]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_index ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SeriesIndexRecord rec = new SeriesIndexRecord ( ) ; rec . field_1_index = field_1_index ; return rec ; } public short getIndex ( ) { return field_1_index ; } public void setIndex ( short field_1_index ) { this . field_1_index = field_1_index ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . util ; public class BitField { private final int _mask ; private final int _shift_count ; public BitField ( final int mask ) { _mask = mask ; int count = 0 ; int bit_pattern = mask ; if ( bit_pattern != 0 ) { while ( ( bit_pattern & 1 ) == 0 ) { count ++ ; bit_pattern >>= 1 ; } } _shift_count = count ; } public int getValue ( final int holder ) { return getRawValue ( holder ) > > _shift_count ; } public short getShortValue ( final short holder ) { return ( short ) getValue ( holder ) ; } public int getRawValue ( final int holder ) { return ( holder & _mask ) ; } public short getShortRawValue ( final short holder ) { return ( short ) getRawValue ( holder ) ; } public boolean isSet ( final int holder ) { return ( holder & _mask ) != 0 ; } public boolean isAllSet ( final int holder ) { return ( holder & _mask ) == _mask ; } public int setValue ( final int holder , final int value ) { return ( holder & ~ _mask ) | ( ( value << _shift_count ) & _mask ) ; } public short setShortValue ( final short holder , final short value ) { return ( short ) setValue ( holder , value ) ; } public int clear ( final int holder ) { return holder & ~ _mask ; } public short clearShort ( final short holder ) { return ( short ) clear ( holder ) ; } public byte clearByte ( final byte holder ) { return ( byte ) clear ( holder ) ; } public int set ( final int holder ) { return holder | _mask ; } public short setShort ( final short holder ) { return ( short ) set ( holder ) ; } public byte setByte ( final byte holder ) { return ( byte ) set ( holder ) ; } public int setBoolean ( final int holder , final boolean flag ) { return flag ? set ( holder ) : clear ( holder ) ; } public short setShortBoolean ( final short holder , final boolean flag ) { return flag ? setShort ( holder ) : clearShort ( holder ) ; } public byte setByteBoolean ( final byte holder , final boolean flag ) { return flag ? setByte ( holder ) : clearByte ( holder ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1
package org . apache . poi . util ; import java . io . InputStream ; import java . io . IOException ; public class BlockingInputStream extends InputStream { protected InputStream is ; public BlockingInputStream ( InputStream is ) { this . is = is ; } public int available ( ) throws IOException { return is . available ( ) ; } public void close ( ) throws IOException { is . close ( ) ; } public void mark ( int readLimit ) { is . mark ( readLimit ) ; } public boolean markSupported ( ) { return is . markSupported ( ) ; } public int read ( ) throws IOException { return is . read ( ) ; } public int read ( byte [ ] bf ) throws IOException { int i = 0 ; int b = 4611 ; while ( i < bf . length ) { b = is . read ( ) ; if ( b == - 1 ) break ; bf [ i ++ ] = ( byte ) b ; } if ( i == 0 && b == - 1 ) return - 1 ; return i ; } public int read ( byte [ ] bf , int s , int l ) throws IOException { return is . read ( bf , s , l ) ; } public void reset ( ) throws IOException { is . reset ( ) ; } public long skip ( long n ) throws IOException { return is . skip ( n ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class AreaFormatRecord extends Record { public final static short sid = 0x100a ; private int field_1_foregroundColor ; private int field_2_backgroundColor ; private short field_3_pattern ; private short field_4_formatFlags ; private BitField automatic = new BitField ( 0x1 ) ; private BitField invert = new BitField ( 0x2 ) ; private short field_5_forecolorIndex ; private short field_6_backcolorIndex ; public AreaFormatRecord ( ) { } public AreaFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AreaFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a AreaFormat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_foregroundColor = LittleEndian . getInt ( data , pos + 0x0 + offset ) ; field_2_backgroundColor = LittleEndian . getInt ( data , pos + 0x4 + offset ) ; field_3_pattern = LittleEndian . getShort ( data , pos + 0x8 + offset ) ; field_4_formatFlags = LittleEndian . getShort ( data , pos + 0xa + offset ) ; field_5_forecolorIndex = LittleEndian . getShort ( data , pos + 0xc + offset ) ; field_6_backcolorIndex = LittleEndian . getShort ( data , pos + 0xe + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AREAFORMAT]\n" ) ; buffer . append ( "    .foregroundColor      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getForegroundColor ( ) ) ) . append ( " (" ) . append ( getForegroundColor ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .backgroundColor      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getBackgroundColor ( ) ) ) . append ( " (" ) . append ( getBackgroundColor ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .pattern              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getPattern ( ) ) ) . append ( " (" ) . append ( getPattern ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .automatic                = " ) . append ( isAutomatic ( ) ) . append ( '\n' ) ; buffer . append ( "         .invert                   = " ) . append ( isInvert ( ) ) . append ( '\n' ) ; buffer . append ( "    .forecolorIndex       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getForecolorIndex ( ) ) ) . append ( " (" ) . append ( getForecolorIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .backcolorIndex       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getBackcolorIndex ( ) ) ) . append ( " (" ) . append ( getBackcolorIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/AREAFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset + pos , field_1_foregroundColor ) ; LittleEndian . putInt ( data , 8 + offset + pos , field_2_backgroundColor ) ; LittleEndian . putShort ( data , 12 + offset + pos , field_3_pattern ) ; LittleEndian . putShort ( data , 14 + offset + pos , field_4_formatFlags ) ; LittleEndian . putShort ( data , 16 + offset + pos , field_5_forecolorIndex ) ; LittleEndian . putShort ( data , 18 + offset + pos , field_6_backcolorIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { AreaFormatRecord rec = new AreaFormatRecord ( ) ; rec . field_1_foregroundColor = field_1_foregroundColor ; rec . field_2_backgroundColor = field_2_backgroundColor ; rec . field_3_pattern = field_3_pattern ; rec . field_4_formatFlags = field_4_formatFlags ; rec . field_5_forecolorIndex = field_5_forecolorIndex ; rec . field_6_backcolorIndex = field_6_backcolorIndex ; return rec ; } public int getForegroundColor ( ) { return field_1_foregroundColor ; } public void setForegroundColor ( int field_1_foregroundColor ) { this . field_1_foregroundColor = field_1_foregroundColor ; } public int getBackgroundColor ( ) { return field_2_backgroundColor ; } public void setBackgroundColor ( int field_2_backgroundColor ) { this . field_2_backgroundColor = field_2_backgroundColor ; } public short getPattern ( ) { return field_3_pattern ; } public void setPattern ( short field_3_pattern ) { this . field_3_pattern = field_3_pattern ; } public short getFormatFlags ( ) { return field_4_formatFlags ; } public void setFormatFlags ( short field_4_formatFlags ) { this . field_4_formatFlags = field_4_formatFlags ; } public short getForecolorIndex ( ) { return field_5_forecolorIndex ; } public void setForecolorIndex ( short field_5_forecolorIndex ) { this . field_5_forecolorIndex = field_5_forecolorIndex ; } public short getBackcolorIndex ( ) { return field_6_backcolorIndex ; } public void setBackcolorIndex ( short field_6_backcolorIndex ) { this . field_6_backcolorIndex = field_6_backcolorIndex ; } public void setAutomatic ( boolean value ) { field_4_formatFlags = automatic . setShortBoolean ( field_4_formatFlags , value ) ; } public boolean isAutomatic ( ) { return automatic . isSet ( field_4_formatFlags ) ; } public void setInvert ( boolean value ) { field_4_formatFlags = invert . setShortBoolean ( field_4_formatFlags , value ) ; } public boolean isInvert ( ) { return invert . isSet ( field_4_formatFlags ) ; } } 	0
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class UseSelFSRecord extends Record { public final static short sid = 0x160 ; public final static short TRUE = 1 ; public final static short FALSE = 0 ; private short field_1_flag ; public UseSelFSRecord ( ) { } public UseSelFSRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public UseSelFSRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A UseSelFS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_flag = LittleEndian . getShort ( data , 0 + offset ) ; } public void setFlag ( short flag ) { field_1_flag = flag ; } public short getFlag ( ) { return field_1_flag ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[USESELFS]\n" ) ; buffer . append ( "    .flag            = " ) . append ( Integer . toHexString ( getFlag ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/USESELFS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFlag ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . hpsf ; import java . util . * ; public class Util { public static boolean equal ( final byte [ ] a , final byte [ ] b ) { if ( a . length != b . length ) return false ; for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] != b [ i ] ) return false ; return true ; } public static void copy ( final byte [ ] src , final int srcOffset , final int length , final byte [ ] dst , final int dstOffset ) { for ( int i = 0 ; i < length ; i ++ ) dst [ dstOffset + i ] = src [ srcOffset + i ] ; } public static byte [ ] cat ( final byte [ ] [ ] byteArrays ) { int capacity = 0 ; for ( int i = 0 ; i < byteArrays . length ; i ++ ) capacity += byteArrays [ i ] . length ; final byte [ ] result = new byte [ capacity ] ; int r = 0 ; for ( int i = 0 ; i < byteArrays . length ; i ++ ) for ( int j = 0 ; j < byteArrays [ i ] . length ; j ++ ) result [ r ++ ] = byteArrays [ i ] [ j ] ; return result ; } public static byte [ ] copy ( final byte [ ] src , final int offset , final int length ) { final byte [ ] result = new byte [ length ] ; copy ( src , offset , length , result , 0 ) ; return result ; } public final static long EPOCH_DIFF = 11644473600000L ; public static Date filetimeToDate ( final int high , final int low ) { final long filetime = ( ( long ) high ) << 32 | ( low & 0xffffffffL ) ; final long ms_since_16010101 = filetime / ( 1000 * 10 ) ; final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF ; return new Date ( ms_since_19700101 ) ; } } 	0
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1
package org . apache . poi . hpsf ; public class NoPropertySetStreamException extends HPSFException { public NoPropertySetStreamException ( ) { super ( ) ; } public NoPropertySetStreamException ( final String msg ) { super ( msg ) ; } public NoPropertySetStreamException ( final Throwable reason ) { super ( reason ) ; } public NoPropertySetStreamException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class HideObjRecord extends Record { public final static short sid = 0x8d ; public final static short HIDE_ALL = 2 ; public final static short SHOW_PLACEHOLDERS = 1 ; public final static short SHOW_ALL = 0 ; private short field_1_hide_obj ; public HideObjRecord ( ) { } public HideObjRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public HideObjRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A HIDEOBJ RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_hide_obj = LittleEndian . getShort ( data , 0 + offset ) ; } public void setHideObj ( short hide ) { field_1_hide_obj = hide ; } public short getHideObj ( ) { return field_1_hide_obj ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[HIDEOBJ]\n" ) ; buffer . append ( "    .hideobj         = " ) . append ( Integer . toHexString ( getHideObj ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/HIDEOBJ]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getHideObj ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DefaultRowHeightRecord extends Record { public final static short sid = 0x225 ; private short field_1_option_flags ; private short field_2_row_height ; public DefaultRowHeightRecord ( ) { } public DefaultRowHeightRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DefaultRowHeightRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A DefaultRowHeight RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_option_flags = LittleEndian . getShort ( data , 0 + offset ) ; field_2_row_height = LittleEndian . getShort ( data , 2 + offset ) ; } public void setOptionFlags ( short flags ) { field_1_option_flags = flags ; } public void setRowHeight ( short height ) { field_2_row_height = height ; } public short getOptionFlags ( ) { return field_1_option_flags ; } public short getRowHeight ( ) { return field_2_row_height ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DEFAULTROWHEIGHT]\n" ) ; buffer . append ( "    .optionflags    = " ) . append ( Integer . toHexString ( getOptionFlags ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .rowheight      = " ) . append ( Integer . toHexString ( getRowHeight ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/DEFAULTROWHEIGHT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x4 ) ; LittleEndian . putShort ( data , 4 + offset , getOptionFlags ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getRowHeight ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { DefaultRowHeightRecord rec = new DefaultRowHeightRecord ( ) ; rec . field_1_option_flags = field_1_option_flags ; rec . field_2_row_height = field_2_row_height ; return rec ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . property . Property ; public abstract class EntryNode implements Entry { private Property _property ; private DirectoryNode _parent ; protected EntryNode ( final Property property , final DirectoryNode parent ) { _property = property ; _parent = parent ; } protected Property getProperty ( ) { return _property ; } protected boolean isRoot ( ) { return ( _parent == null ) ; } protected abstract boolean isDeleteOK ( ) ; public String getName ( ) { return _property . getName ( ) ; } public boolean isDirectoryEntry ( ) { return false ; } public boolean isDocumentEntry ( ) { return false ; } public DirectoryEntry getParent ( ) { return _parent ; } public boolean delete ( ) { boolean rval = false ; if ( ( ! isRoot ( ) ) && isDeleteOK ( ) ) { rval = _parent . deleteEntry ( this ) ; } return rval ; } public boolean renameTo ( final String newName ) { boolean rval = false ; if ( ! isRoot ( ) ) { rval = _parent . changeName ( getName ( ) , newName ) ; } return rval ; } } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; public class IntPtg extends Ptg { public final static int SIZE = 3 ; public final static byte sid = 0x1e ; private short field_1_value ; private String val ; private int strlen = 0 ; private IntPtg ( ) { } public IntPtg ( byte [ ] data , int offset ) { setValue ( LittleEndian . getShort ( data , offset + 1 ) ) ; } public IntPtg ( String formulaToken ) { setValue ( Short . parseShort ( formulaToken ) ) ; } public void setValue ( short value ) { field_1_value = value ; } public short getValue ( ) { return field_1_value ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; LittleEndian . putShort ( array , offset + 1 , getValue ( ) ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return "" + getValue ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { IntPtg ptg = new IntPtg ( ) ; ptg . field_1_value = field_1_value ; return ptg ; } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . hpsf ; public class Variant { public static final int VT_EMPTY = 0 ; public static final int VT_NULL = 1 ; public static final int VT_I2 = 2 ; public static final int VT_I4 = 3 ; public static final int VT_R4 = 4 ; public static final int VT_R8 = 5 ; public static final int VT_CY = 6 ; public static final int VT_DATE = 7 ; public static final int VT_BSTR = 8 ; public static final int VT_DISPATCH = 9 ; public static final int VT_ERROR = 10 ; public static final int VT_BOOL = 11 ; public static final int VT_VARIANT = 12 ; public static final int VT_UNKNOWN = 13 ; public static final int VT_DECIMAL = 14 ; public static final int VT_I1 = 16 ; public static final int VT_UI1 = 17 ; public static final int VT_UI2 = 18 ; public static final int VT_UI4 = 19 ; public static final int VT_I8 = 20 ; public static final int VT_UI8 = 21 ; public static final int VT_INT = 22 ; public static final int VT_UINT = 23 ; public static final int VT_VOID = 24 ; public static final int VT_HRESULT = 25 ; public static final int VT_PTR = 26 ; public static final int VT_SAFEARRAY = 27 ; public static final int VT_CARRAY = 28 ; public static final int VT_USERDEFINED = 29 ; public static final int VT_LPSTR = 30 ; public static final int VT_LPWSTR = 31 ; public static final int VT_FILETIME = 64 ; public static final int VT_BLOB = 65 ; public static final int VT_STREAM = 66 ; public static final int VT_STORAGE = 67 ; public static final int VT_STREAMED_OBJECT = 68 ; public static final int VT_STORED_OBJECT = 69 ; public static final int VT_BLOB_OBJECT = 70 ; public static final int VT_CF = 71 ; public static final int VT_CLSID = 72 ; public static final int VT_VECTOR = 0x1000 ; public static final int VT_ARRAY = 0x2000 ; public static final int VT_BYREF = 0x4000 ; public static final int VT_RESERVED = 0x8000 ; public static final int VT_ILLEGAL = 0xFFFF ; public static final int VT_ILLEGALMASKED = 0xFFF ; public static final int VT_TYPEMASK = 0xFFF ; } 	0
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class RowRecord extends Record implements Comparable { public final static short sid = 0x208 ; private int field_1_row_number ; private short field_2_first_col ; private short field_3_last_col ; private short field_4_height ; private short field_5_optimize ; private short field_6_reserved ; private short field_7_option_flags ; private BitField outlineLevel = new BitField ( 0x07 ) ; private BitField colapsed = new BitField ( 0x10 ) ; private BitField zeroHeight = new BitField ( 0x20 ) ; private BitField badFontHeight = new BitField ( 0x40 ) ; private BitField formatted = new BitField ( 0x80 ) ; private short field_8_xf_index ; public RowRecord ( ) { } public RowRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RowRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid ROW RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row_number = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_first_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_col = LittleEndian . getShort ( data , 4 + offset ) ; field_4_height = LittleEndian . getShort ( data , 6 + offset ) ; field_5_optimize = LittleEndian . getShort ( data , 8 + offset ) ; field_6_reserved = LittleEndian . getShort ( data , 10 + offset ) ; field_7_option_flags = LittleEndian . getShort ( data , 12 + offset ) ; field_8_xf_index = LittleEndian . getShort ( data , 14 + offset ) ; } public void setRowNumber ( int row ) { field_1_row_number = row ; } public void setFirstCol ( short col ) { field_2_first_col = col ; } public void setLastCol ( short col ) { field_3_last_col = col ; } public void setHeight ( short height ) { field_4_height = height ; } public void setOptimize ( short optimize ) { field_5_optimize = optimize ; } public void setOptionFlags ( short options ) { field_7_option_flags = options ; } public void setOutlineLevel ( short ol ) { field_7_option_flags = outlineLevel . setShortValue ( field_7_option_flags , ol ) ; } public void setColapsed ( boolean c ) { field_7_option_flags = colapsed . setShortBoolean ( field_7_option_flags , c ) ; } public void setZeroHeight ( boolean z ) { field_7_option_flags = zeroHeight . setShortBoolean ( field_7_option_flags , z ) ; } public void setBadFontHeight ( boolean f ) { field_7_option_flags = badFontHeight . setShortBoolean ( field_7_option_flags , f ) ; } public void setFormatted ( boolean f ) { field_7_option_flags = formatted . setShortBoolean ( field_7_option_flags , f ) ; } public void setXFIndex ( short index ) { field_8_xf_index = index ; } public int getRowNumber ( ) { return field_1_row_number ; } public short getFirstCol ( ) { return field_2_first_col ; } public short getLastCol ( ) { return field_3_last_col ; } public short getHeight ( ) { return field_4_height ; } public short getOptimize ( ) { return field_5_optimize ; } public short getOptionFlags ( ) { return field_7_option_flags ; } public short getOutlineLevel ( ) { return outlineLevel . getShortValue ( field_7_option_flags ) ; } public boolean getColapsed ( ) { return ( colapsed . isSet ( field_7_option_flags ) ) ; } public boolean getZeroHeight ( ) { return zeroHeight . isSet ( field_7_option_flags ) ; } public boolean getBadFontHeight ( ) { return badFontHeight . isSet ( field_7_option_flags ) ; } public boolean getFormatted ( ) { return formatted . isSet ( field_7_option_flags ) ; } public short getXFIndex ( ) { return field_8_xf_index ; } public boolean isInValueSection ( ) { return true ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[ROW]\n" ) ; buffer . append ( "    .rownumber      = " ) . append ( Integer . toHexString ( getRowNumber ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .firstcol       = " ) . append ( Integer . toHexString ( getFirstCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .lastcol        = " ) . append ( Integer . toHexString ( getLastCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .height         = " ) . append ( Integer . toHexString ( getHeight ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .optimize       = " ) . append ( Integer . toHexString ( getOptimize ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .reserved       = " ) . append ( Integer . toHexString ( field_6_reserved ) ) . append ( "\n" ) ; buffer . append ( "    .optionflags    = " ) . append ( Integer . toHexString ( getOptionFlags ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .outlinelvl = " ) . append ( Integer . toHexString ( getOutlineLevel ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .colapsed   = " ) . append ( getColapsed ( ) ) . append ( "\n" ) ; buffer . append ( "        .zeroheight = " ) . append ( getZeroHeight ( ) ) . append ( "\n" ) ; buffer . append ( "        .badfontheig= " ) . append ( getBadFontHeight ( ) ) . append ( "\n" ) ; buffer . append ( "        .formatted  = " ) . append ( getFormatted ( ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/ROW]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 16 ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) getRowNumber ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFirstCol ( ) == - 1 ? ( short ) 0 : getFirstCol ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getLastCol ( ) == - 1 ? ( short ) 0 : getLastCol ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getHeight ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getOptimize ( ) ) ; LittleEndian . putShort ( data , 14 + offset , field_6_reserved ) ; LittleEndian . putShort ( data , 16 + offset , getOptionFlags ( ) ) ; LittleEndian . putShort ( data , 18 + offset , getXFIndex ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public int compareTo ( Object obj ) { RowRecord loc = ( RowRecord ) obj ; if ( this . getRowNumber ( ) == loc . getRowNumber ( ) ) { return 0 ; } if ( this . getRowNumber ( ) < loc . getRowNumber ( ) ) { return - 1 ; } if ( this . getRowNumber ( ) > loc . getRowNumber ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof RowRecord ) ) { return false ; } RowRecord loc = ( RowRecord ) obj ; if ( this . getRowNumber ( ) == loc . getRowNumber ( ) ) { return true ; } return false ; } public Object clone ( ) { RowRecord rec = new RowRecord ( ) ; rec . field_1_row_number = field_1_row_number ; rec . field_2_first_col = field_2_first_col ; rec . field_3_last_col = field_3_last_col ; rec . field_4_height = field_4_height ; rec . field_5_optimize = field_5_optimize ; rec . field_6_reserved = field_6_reserved ; rec . field_7_option_flags = field_7_option_flags ; rec . field_8_xf_index = field_8_xf_index ; return rec ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CalcCountRecord extends Record { public final static short sid = 0xC ; private short field_1_iterations ; public CalcCountRecord ( ) { } public CalcCountRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CalcCountRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Calc Count RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_iterations = LittleEndian . getShort ( data , 0 + offset ) ; } public void setIterations ( short iterations ) { field_1_iterations = iterations ; } public short getIterations ( ) { return field_1_iterations ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CALCCOUNT]\n" ) ; buffer . append ( "    .iterations     = " ) . append ( Integer . toHexString ( getIterations ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CALCCOUNT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , getIterations ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { CalcCountRecord rec = new CalcCountRecord ( ) ; rec . field_1_iterations = field_1_iterations ; return rec ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SeriesChartGroupIndexRecord extends Record { public final static short sid = 0x1045 ; private short field_1_chartGroupIndex ; public SeriesChartGroupIndexRecord ( ) { } public SeriesChartGroupIndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesChartGroupIndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesChartGroupIndex record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_chartGroupIndex = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SERTOCRT]\n" ) ; buffer . append ( "    .chartGroupIndex      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getChartGroupIndex ( ) ) ) . append ( " (" ) . append ( getChartGroupIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SERTOCRT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_chartGroupIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SeriesChartGroupIndexRecord rec = new SeriesChartGroupIndexRecord ( ) ; rec . field_1_chartGroupIndex = field_1_chartGroupIndex ; return rec ; } public short getChartGroupIndex ( ) { return field_1_chartGroupIndex ; } public void setChartGroupIndex ( short field_1_chartGroupIndex ) { this . field_1_chartGroupIndex = field_1_chartGroupIndex ; } } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class PaneRecord extends Record { public final static short sid = 0x41 ; private short field_1_x ; private short field_2_y ; private short field_3_topRow ; private short field_4_leftColumn ; private short field_5_activePane ; public final static short ACTIVE_PANE_LOWER_RIGHT = 0 ; public final static short ACTIVE_PANE_UPPER_RIGHT = 1 ; public final static short ACTIVE_PANE_LOWER_LEFT = 2 ; public final static short ACTIVE_PANE_UPER_LEFT = 3 ; public PaneRecord ( ) { } public PaneRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaneRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Pane record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_x = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_y = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_topRow = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_4_leftColumn = LittleEndian . getShort ( data , pos + 0x6 + offset ) ; field_5_activePane = LittleEndian . getShort ( data , pos + 0x8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PANE]\n" ) ; buffer . append ( "    .x                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getX ( ) ) ) . append ( " (" ) . append ( getX ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .y                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getY ( ) ) ) . append ( " (" ) . append ( getY ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .topRow               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getTopRow ( ) ) ) . append ( " (" ) . append ( getTopRow ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .leftColumn           = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLeftColumn ( ) ) ) . append ( " (" ) . append ( getLeftColumn ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .activePane           = " ) . append ( "0x" ) . append ( HexDump . toHex ( getActivePane ( ) ) ) . append ( " (" ) . append ( getActivePane ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/PANE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_x ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_y ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_topRow ) ; LittleEndian . putShort ( data , 10 + offset + pos , field_4_leftColumn ) ; LittleEndian . putShort ( data , 12 + offset + pos , field_5_activePane ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { PaneRecord rec = new PaneRecord ( ) ; rec . field_1_x = field_1_x ; rec . field_2_y = field_2_y ; rec . field_3_topRow = field_3_topRow ; rec . field_4_leftColumn = field_4_leftColumn ; rec . field_5_activePane = field_5_activePane ; return rec ; } public short getX ( ) { return field_1_x ; } public void setX ( short field_1_x ) { this . field_1_x = field_1_x ; } public short getY ( ) { return field_2_y ; } public void setY ( short field_2_y ) { this . field_2_y = field_2_y ; } public short getTopRow ( ) { return field_3_topRow ; } public void setTopRow ( short field_3_topRow ) { this . field_3_topRow = field_3_topRow ; } public short getLeftColumn ( ) { return field_4_leftColumn ; } public void setLeftColumn ( short field_4_leftColumn ) { this . field_4_leftColumn = field_4_leftColumn ; } public short getActivePane ( ) { return field_5_activePane ; } public void setActivePane ( short field_5_activePane ) { this . field_5_activePane = field_5_activePane ; } } 	0
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1
package org . apache . poi . poifs . filesystem ; public interface BATManaged { public int countBlocks ( ) ; public void setStartBlock ( final int index ) ; } 	0
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . FormatRecord ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Vector ; public class HSSFDataFormat { private static Vector builtinFormats ; private Vector formats = new Vector ( ) ; private Workbook workbook ; private boolean movedBuiltins = false ; public HSSFDataFormat ( Workbook workbook ) { this . workbook = workbook ; if ( builtinFormats == null ) populateBuiltinFormats ( ) ; Iterator i = workbook . getFormats ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { FormatRecord r = ( FormatRecord ) i . next ( ) ; if ( formats . size ( ) < r . getIndexCode ( ) + 1 ) { formats . setSize ( r . getIndexCode ( ) + 1 ) ; } formats . set ( r . getIndexCode ( ) , r . getFormatString ( ) ) ; } } private static synchronized void populateBuiltinFormats ( ) { builtinFormats = new Vector ( ) ; builtinFormats . add ( 0 , "General" ) ; builtinFormats . add ( 1 , "0" ) ; builtinFormats . add ( 2 , "0.00" ) ; builtinFormats . add ( 3 , "#,##0" ) ; builtinFormats . add ( 4 , "#,##0.00" ) ; builtinFormats . add ( 5 , "($#,##0_);($#,##0)" ) ; builtinFormats . add ( 6 , "($#,##0_);[Red]($#,##0)" ) ; builtinFormats . add ( 7 , "($#,##0.00);($#,##0.00)" ) ; builtinFormats . add ( 8 , "($#,##0.00_);[Red]($#,##0.00)" ) ; builtinFormats . add ( 9 , "0%" ) ; builtinFormats . add ( 0xa , "0.00%" ) ; builtinFormats . add ( 0xb , "0.00E+00" ) ; builtinFormats . add ( 0xc , "# ?/?" ) ; builtinFormats . add ( 0xd , "# ??/??" ) ; builtinFormats . add ( 0xe , "m/d/yy" ) ; builtinFormats . add ( 0xf , "d-mmm-yy" ) ; builtinFormats . add ( 0x10 , "d-mmm" ) ; builtinFormats . add ( 0x11 , "mmm-yy" ) ; builtinFormats . add ( 0x12 , "h:mm AM/PM" ) ; builtinFormats . add ( 0x13 , "h:mm:ss AM/PM" ) ; builtinFormats . add ( 0x14 , "h:mm" ) ; builtinFormats . add ( 0x15 , "h:mm:ss" ) ; builtinFormats . add ( 0x16 , "m/d/yy h:mm" ) ; builtinFormats . add ( 0x17 , "0x17" ) ; builtinFormats . add ( 0x18 , "0x18" ) ; builtinFormats . add ( 0x19 , "0x19" ) ; builtinFormats . add ( 0x1a , "0x1a" ) ; builtinFormats . add ( 0x1b , "0x1b" ) ; builtinFormats . add ( 0x1c , "0x1c" ) ; builtinFormats . add ( 0x1d , "0x1d" ) ; builtinFormats . add ( 0x1e , "0x1e" ) ; builtinFormats . add ( 0x1f , "0x1f" ) ; builtinFormats . add ( 0x20 , "0x20" ) ; builtinFormats . add ( 0x21 , "0x21" ) ; builtinFormats . add ( 0x22 , "0x22" ) ; builtinFormats . add ( 0x23 , "0x23" ) ; builtinFormats . add ( 0x24 , "0x24" ) ; builtinFormats . add ( 0x25 , "(#,##0_);(#,##0)" ) ; builtinFormats . add ( 0x26 , "(#,##0_);[Red](#,##0)" ) ; builtinFormats . add ( 0x27 , "(#,##0.00_);(#,##0.00)" ) ; builtinFormats . add ( 0x28 , "(#,##0.00_);[Red](#,##0.00)" ) ; builtinFormats . add ( 0x29 , "_(*#,##0_);_(*(#,##0);_(* \"-\"_);_(@_)" ) ; builtinFormats . add ( 0x2a , "_($*#,##0_);_($*(#,##0);_($* \"-\"_);_(@_)" ) ; builtinFormats . add ( 0x2b , "_(*#,##0.00_);_(*(#,##0.00);_(*\"-\"??_);_(@_)" ) ; builtinFormats . add ( 0x2c , "_($*#,##0.00_);_($*(#,##0.00);_($*\"-\"??_);_(@_)" ) ; builtinFormats . add ( 0x2d , "mm:ss" ) ; builtinFormats . add ( 0x2e , "[h]:mm:ss" ) ; builtinFormats . add ( 0x2f , "mm:ss.0" ) ; builtinFormats . add ( 0x30 , "##0.0E+0" ) ; builtinFormats . add ( 0x31 , "@" ) ; } public static List getBuiltinFormats ( ) { if ( builtinFormats == null ) { populateBuiltinFormats ( ) ; } return builtinFormats ; } public static short getBuiltinFormat ( String format ) { if ( format . toUpperCase ( ) . equals ( "TEXT" ) ) format = "@" ; if ( builtinFormats == null ) { populateBuiltinFormats ( ) ; } short retval = - 1 ; for ( short k = 0 ; k <= 0x31 ; k ++ ) { String nformat = ( String ) builtinFormats . get ( k ) ; if ( ( nformat != null ) && nformat . equals ( format ) ) { retval = k ; break ; } } return retval ; } public short getFormat ( String format ) { ListIterator i ; int ind ; if ( format . toUpperCase ( ) . equals ( "TEXT" ) ) format = "@" ; if ( ! movedBuiltins ) { i = builtinFormats . listIterator ( ) ; while ( i . hasNext ( ) ) { ind = i . nextIndex ( ) ; formats . add ( ind , i . next ( ) ) ; } movedBuiltins = true ; } i = formats . listIterator ( ) ; while ( i . hasNext ( ) ) { ind = i . nextIndex ( ) ; if ( format . equals ( i . next ( ) ) ) return ( short ) ind ; } ind = workbook . getFormat ( format , true ) ; if ( formats . size ( ) <= ind ) formats . setSize ( ind + 1 ) ; formats . add ( ind , format ) ; return ( short ) ind ; } public String getFormat ( short index ) { if ( movedBuiltins ) return ( String ) formats . get ( index ) ; else return ( String ) ( builtinFormats . size ( ) > index && builtinFormats . get ( index ) != null ? builtinFormats . get ( index ) : formats . get ( index ) ) ; } public static String getBuiltinFormat ( short index ) { if ( builtinFormats == null ) { populateBuiltinFormats ( ) ; } return ( String ) builtinFormats . get ( index ) ; } public static int getNumberOfBuiltinBuiltinFormats ( ) { if ( builtinFormats == null ) { populateBuiltinFormats ( ) ; } return builtinFormats . size ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1
package org . apache . poi . util ; import java . io . IOException ; import java . io . InputStream ; import java . util . Arrays ; public class LittleEndian implements LittleEndianConsts { private LittleEndian ( ) { } public static short getShort ( final byte [ ] data , final int offset ) { return ( short ) getNumber ( data , offset , SHORT_SIZE ) ; } public static int getUShort ( final byte [ ] data , final int offset ) { short num = ( short ) getNumber ( data , offset , SHORT_SIZE ) ; int retNum ; if ( num < 0 ) { retNum = ( ( int ) Short . MAX_VALUE + 1 ) * 2 + ( int ) num ; } else { retNum = ( int ) num ; } return retNum ; } public static short [ ] getSimpleShortArray ( final byte [ ] data , final int offset , final int size ) { short [ ] results = new short [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { results [ i ] = getShort ( data , offset + 2 + ( i * 2 ) ) ; } return results ; } public static short [ ] getShortArray ( final byte [ ] data , final int offset ) { int size = ( short ) getNumber ( data , offset , SHORT_SIZE ) ; short [ ] results = getSimpleShortArray ( data , offset , size ) ; return results ; } public static short getShort ( final byte [ ] data ) { return getShort ( data , 0 ) ; } public static int getUShort ( final byte [ ] data ) { return getUShort ( data , 0 ) ; } public static int getInt ( final byte [ ] data , final int offset ) { return ( int ) getNumber ( data , offset , INT_SIZE ) ; } public static int getInt ( final byte [ ] data ) { return getInt ( data , 0 ) ; } public static long getUInt ( final byte [ ] data , final int offset ) { int num = ( int ) getNumber ( data , offset , INT_SIZE ) ; long retNum ; if ( num < 0 ) { retNum = ( ( long ) Integer . MAX_VALUE + 1 ) * 2 + ( long ) num ; } else { retNum = ( int ) num ; } return retNum ; } public static long getUInt ( final byte [ ] data ) { return getUInt ( data , 0 ) ; } public static long getLong ( final byte [ ] data , final int offset ) { return getNumber ( data , offset , LONG_SIZE ) ; } public static long getLong ( final byte [ ] data ) { return getLong ( data , 0 ) ; } public static double getDouble ( final byte [ ] data , final int offset ) { return Double . longBitsToDouble ( getNumber ( data , offset , DOUBLE_SIZE ) ) ; } public static double getDouble ( final byte [ ] data ) { return getDouble ( data , 0 ) ; } public static void putShort ( final byte [ ] data , final int offset , final short value ) { putNumber ( data , offset , value , SHORT_SIZE ) ; } public static void putShortArray ( final byte [ ] data , final int offset , final short [ ] value ) { putNumber ( data , offset , value . length , SHORT_SIZE ) ; for ( int i = 0 ; i < value . length ; i ++ ) { putNumber ( data , offset + 2 + ( i * 2 ) , value [ i ] , SHORT_SIZE ) ; } } public static void putUShort ( final byte [ ] data , final int offset , final int value ) { putNumber ( data , offset , value , SHORT_SIZE ) ; } public static void putShort ( final byte [ ] data , final short value ) { putShort ( data , 0 , value ) ; } public static void putInt ( final byte [ ] data , final int offset , final int value ) { putNumber ( data , offset , value , INT_SIZE ) ; } public static void putInt ( final byte [ ] data , final int value ) { putInt ( data , 0 , value ) ; } public static void putLong ( final byte [ ] data , final int offset , final long value ) { putNumber ( data , offset , value , LONG_SIZE ) ; } public static void putLong ( final byte [ ] data , final long value ) { putLong ( data , 0 , value ) ; } public static void putDouble ( final byte [ ] data , final int offset , final double value ) { if ( Double . isNaN ( value ) ) putNumber ( data , offset , - 276939487313920L , DOUBLE_SIZE ) ; else putNumber ( data , offset , Double . doubleToLongBits ( value ) , DOUBLE_SIZE ) ; } public static void putDouble ( final byte [ ] data , final double value ) { putDouble ( data , 0 , value ) ; } public static class BufferUnderrunException extends IOException { BufferUnderrunException ( ) { super ( "buffer underrun" ) ; } } public static short readShort ( final InputStream stream ) throws IOException , BufferUnderrunException { return getShort ( readFromStream ( stream , SHORT_SIZE ) ) ; } public static int readInt ( final InputStream stream ) throws IOException , BufferUnderrunException { return getInt ( readFromStream ( stream , INT_SIZE ) ) ; } public static long readLong ( final InputStream stream ) throws IOException , BufferUnderrunException { return getLong ( readFromStream ( stream , LONG_SIZE ) ) ; } public static byte [ ] readFromStream ( final InputStream stream , final int size ) throws IOException , BufferUnderrunException { byte [ ] buffer = new byte [ size ] ; int count = stream . read ( buffer ) ; if ( count == - 1 ) { Arrays . fill ( buffer , ( byte ) 0 ) ; } else if ( count != size ) { throw new BufferUnderrunException ( ) ; } return buffer ; } private static long getNumber ( final byte [ ] data , final int offset , final int size ) { long result = 0 ; for ( int j = offset + size - 1 ; j >= offset ; j -- ) { result <<= 8 ; result |= 0xff & data [ j ] ; } return result ; } private static void putNumber ( final byte [ ] data , final int offset , final long value , final int size ) { int limit = size + offset ; long v = value ; for ( int j = offset ; j < limit ; j ++ ) { data [ j ] = ( byte ) ( v & 0xFF ) ; v >>= 8 ; } } public static int ubyteToInt ( byte b ) { return ( ( b & 0x80 ) == 0 ? ( int ) b : ( int ) ( b & ( byte ) 0x7f ) + 0x80 ) ; } public static int getUnsignedByte ( final byte [ ] data , final int offset ) { return ( int ) getNumber ( data , offset , BYTE_SIZE ) ; } public static int getUnsignedByte ( final byte [ ] data ) { return getUnsignedByte ( data , 0 ) ; } public static byte [ ] getByteArray ( final byte [ ] data , int offset , int size ) { byte [ ] copy = new byte [ size ] ; System . arraycopy ( data , offset , copy , 0 , size ) ; return copy ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; public class UnknownPtg extends Ptg { private short size ; public UnknownPtg ( ) { } public UnknownPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return size ; } public String toFormulaString ( Workbook book ) { return "UNKNOWN" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new UnknownPtg ( ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class FnGroupCountRecord extends Record { public final static short sid = 0x9c ; public final static short COUNT = 14 ; private short field_1_count ; public FnGroupCountRecord ( ) { } public FnGroupCountRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FnGroupCountRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FNGROUPCOUNT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_count = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCount ( short count ) { field_1_count = count ; } public short getCount ( ) { return field_1_count ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FNGROUPCOUNT]\n" ) ; buffer . append ( "    .count            = " ) . append ( getCount ( ) ) . append ( "\n" ) ; buffer . append ( "[/FNGROUPCOUNT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCount ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1
package org . apache . poi . hpsf ; import org . apache . poi . util . LittleEndian ; public class TypeReader { public static Object read ( final byte [ ] src , int offset , int length , final int type ) { Object value ; length = length - LittleEndian . INT_SIZE ; switch ( type ) { case Variant . VT_EMPTY : { value = null ; break ; } case Variant . VT_I2 : { value = new Integer ( LittleEndian . getUShort ( src , offset ) ) ; break ; } case Variant . VT_I4 : { value = new Long ( LittleEndian . getUInt ( src , offset ) ) ; break ; } case Variant . VT_FILETIME : { final long low = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final long high = LittleEndian . getUInt ( src , offset ) ; value = Util . filetimeToDate ( ( int ) high , ( int ) low ) ; break ; } case Variant . VT_LPSTR : { final int first = offset + LittleEndian . INT_SIZE ; long last = first + LittleEndian . getUInt ( src , offset ) - 1 ; offset += LittleEndian . INT_SIZE ; while ( src [ ( int ) last ] == 0 && first <= last ) last -- ; value = new String ( src , ( int ) first , ( int ) ( last - first + 1 ) ) ; break ; } case Variant . VT_LPWSTR : { final int first = offset + LittleEndian . INT_SIZE ; long last = first + LittleEndian . getUInt ( src , offset ) - 1 ; long l = last - first ; offset += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) ( last - first ) ) ; for ( int i = 0 ; i <= l ; i ++ ) { final int i1 = offset + ( i * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; value = b . toString ( ) ; break ; } case Variant . VT_CF : { final byte [ ] v = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) v [ i ] = src [ ( int ) ( offset + i ) ] ; value = v ; break ; } case Variant . VT_BOOL : { long bool = LittleEndian . getUInt ( src , offset ) ; if ( bool != 0 ) value = new Boolean ( true ) ; else value = new Boolean ( false ) ; break ; } default : { final byte [ ] v = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) v [ i ] = src [ ( int ) ( offset + i ) ] ; value = v ; break ; } } return value ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . util ; public class AreaReference { private CellReference [ ] cells ; private int dim ; public AreaReference ( String reference ) { String [ ] refs = seperateAreaRefs ( reference ) ; dim = refs . length ; cells = new CellReference [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { cells [ i ] = new CellReference ( refs [ i ] ) ; } } public int getDim ( ) { return dim ; } public CellReference [ ] getCells ( ) { return cells ; } public String toString ( ) { StringBuffer retval = new StringBuffer ( ) ; for ( int i = 0 ; i < dim ; i ++ ) { retval . append ( ':' ) ; retval . append ( cells [ i ] . toString ( ) ) ; } retval . deleteCharAt ( 0 ) ; return retval . toString ( ) ; } private String [ ] seperateAreaRefs ( String reference ) { String [ ] retval = null ; int length = reference . length ( ) ; int loc = reference . indexOf ( ':' , 0 ) ; if ( loc == - 1 ) { retval = new String [ 1 ] ; retval [ 0 ] = reference ; } else { retval = new String [ 2 ] ; int sheetStart = reference . indexOf ( "!" ) ; retval [ 0 ] = reference . substring ( 0 , sheetStart + 1 ) + reference . substring ( sheetStart + 1 , loc ) ; retval [ 1 ] = reference . substring ( 0 , sheetStart + 1 ) + reference . substring ( loc + 1 ) ; } return retval ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class BarRecord extends Record { public final static short sid = 0x1017 ; private short field_1_barSpace ; private short field_2_categorySpace ; private short field_3_formatFlags ; private BitField horizontal = new BitField ( 0x1 ) ; private BitField stacked = new BitField ( 0x2 ) ; private BitField displayAsPercentage = new BitField ( 0x4 ) ; private BitField shadow = new BitField ( 0x8 ) ; public BarRecord ( ) { } public BarRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BarRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Bar record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_barSpace = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_categorySpace = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_formatFlags = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BAR]\n" ) ; buffer . append ( "    .barSpace             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getBarSpace ( ) ) ) . append ( " (" ) . append ( getBarSpace ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .categorySpace        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getCategorySpace ( ) ) ) . append ( " (" ) . append ( getCategorySpace ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .horizontal               = " ) . append ( isHorizontal ( ) ) . append ( '\n' ) ; buffer . append ( "         .stacked                  = " ) . append ( isStacked ( ) ) . append ( '\n' ) ; buffer . append ( "         .displayAsPercentage      = " ) . append ( isDisplayAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .shadow                   = " ) . append ( isShadow ( ) ) . append ( '\n' ) ; buffer . append ( "[/BAR]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_barSpace ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_categorySpace ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BarRecord rec = new BarRecord ( ) ; rec . field_1_barSpace = field_1_barSpace ; rec . field_2_categorySpace = field_2_categorySpace ; rec . field_3_formatFlags = field_3_formatFlags ; return rec ; } public short getBarSpace ( ) { return field_1_barSpace ; } public void setBarSpace ( short field_1_barSpace ) { this . field_1_barSpace = field_1_barSpace ; } public short getCategorySpace ( ) { return field_2_categorySpace ; } public void setCategorySpace ( short field_2_categorySpace ) { this . field_2_categorySpace = field_2_categorySpace ; } public short getFormatFlags ( ) { return field_3_formatFlags ; } public void setFormatFlags ( short field_3_formatFlags ) { this . field_3_formatFlags = field_3_formatFlags ; } public void setHorizontal ( boolean value ) { field_3_formatFlags = horizontal . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isHorizontal ( ) { return horizontal . isSet ( field_3_formatFlags ) ; } public void setStacked ( boolean value ) { field_3_formatFlags = stacked . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isStacked ( ) { return stacked . isSet ( field_3_formatFlags ) ; } public void setDisplayAsPercentage ( boolean value ) { field_3_formatFlags = displayAsPercentage . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isDisplayAsPercentage ( ) { return displayAsPercentage . isSet ( field_3_formatFlags ) ; } public void setShadow ( boolean value ) { field_3_formatFlags = shadow . setShortBoolean ( field_3_formatFlags , value ) ; } public boolean isShadow ( ) { return shadow . isSet ( field_3_formatFlags ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BackupRecord extends Record { public final static short sid = 0x40 ; private short field_1_backup ; public BackupRecord ( ) { } public BackupRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BackupRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BACKUP RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_backup = LittleEndian . getShort ( data , 0 + offset ) ; } public void setBackup ( short backup ) { field_1_backup = backup ; } public short getBackup ( ) { return field_1_backup ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BACKUP]\n" ) ; buffer . append ( "    .backup          = " ) . append ( Integer . toHexString ( getBackup ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BACKUP]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getBackup ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . eventmodel ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . apache . poi . hssf . record . BOFRecord ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BookBoolRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . BottomMarginRecord ; import org . apache . poi . hssf . record . BoundSheetRecord ; import org . apache . poi . hssf . record . CalcCountRecord ; import org . apache . poi . hssf . record . CalcModeRecord ; import org . apache . poi . hssf . record . CodepageRecord ; import org . apache . poi . hssf . record . ColumnInfoRecord ; import org . apache . poi . hssf . record . ContinueRecord ; import org . apache . poi . hssf . record . CountryRecord ; import org . apache . poi . hssf . record . DBCellRecord ; import org . apache . poi . hssf . record . DSFRecord ; import org . apache . poi . hssf . record . DateWindow1904Record ; import org . apache . poi . hssf . record . DefaultColWidthRecord ; import org . apache . poi . hssf . record . DefaultRowHeightRecord ; import org . apache . poi . hssf . record . DeltaRecord ; import org . apache . poi . hssf . record . DimensionsRecord ; import org . apache . poi . hssf . record . EOFRecord ; import org . apache . poi . hssf . record . ExtSSTRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . ExternSheetRecord ; import org . apache . poi . hssf . record . FnGroupCountRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . FooterRecord ; import org . apache . poi . hssf . record . FormatRecord ; import org . apache . poi . hssf . record . GridsetRecord ; import org . apache . poi . hssf . record . GutsRecord ; import org . apache . poi . hssf . record . HCenterRecord ; import org . apache . poi . hssf . record . HeaderRecord ; import org . apache . poi . hssf . record . HideObjRecord ; import org . apache . poi . hssf . record . IndexRecord ; import org . apache . poi . hssf . record . InterfaceEndRecord ; import org . apache . poi . hssf . record . InterfaceHdrRecord ; import org . apache . poi . hssf . record . IterationRecord ; import org . apache . poi . hssf . record . LabelRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . LeftMarginRecord ; import org . apache . poi . hssf . record . MMSRecord ; import org . apache . poi . hssf . record . MergeCellsRecord ; import org . apache . poi . hssf . record . MulBlankRecord ; import org . apache . poi . hssf . record . MulRKRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . PaletteRecord ; import org . apache . poi . hssf . record . PasswordRecord ; import org . apache . poi . hssf . record . PasswordRev4Record ; import org . apache . poi . hssf . record . PrecisionRecord ; import org . apache . poi . hssf . record . PrintGridlinesRecord ; import org . apache . poi . hssf . record . PrintHeadersRecord ; import org . apache . poi . hssf . record . PrintSetupRecord ; import org . apache . poi . hssf . record . ProtectRecord ; import org . apache . poi . hssf . record . ProtectionRev4Record ; import org . apache . poi . hssf . record . RKRecord ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFormatException ; import org . apache . poi . hssf . record . RefModeRecord ; import org . apache . poi . hssf . record . RefreshAllRecord ; import org . apache . poi . hssf . record . RightMarginRecord ; import org . apache . poi . hssf . record . RowRecord ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . SaveRecalcRecord ; import org . apache . poi . hssf . record . SelectionRecord ; import org . apache . poi . hssf . record . SharedFormulaRecord ; import org . apache . poi . hssf . record . StringRecord ; import org . apache . poi . hssf . record . StyleRecord ; import org . apache . poi . hssf . record . TabIdRecord ; import org . apache . poi . hssf . record . TopMarginRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . UseSelFSRecord ; import org . apache . poi . hssf . record . VCenterRecord ; import org . apache . poi . hssf . record . WSBoolRecord ; import org . apache . poi . hssf . record . WindowOneRecord ; import org . apache . poi . hssf . record . WindowProtectRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . WriteAccessRecord ; import org . apache . poi . util . LittleEndian ; public class EventRecordFactory { private static final Class [ ] records ; static { records = new Class [ ] { BOFRecord . class , InterfaceHdrRecord . class , MMSRecord . class , InterfaceEndRecord . class , WriteAccessRecord . class , CodepageRecord . class , DSFRecord . class , TabIdRecord . class , FnGroupCountRecord . class , WindowProtectRecord . class , ProtectRecord . class , PasswordRecord . class , ProtectionRev4Record . class , PasswordRev4Record . class , WindowOneRecord . class , BackupRecord . class , HideObjRecord . class , DateWindow1904Record . class , PrecisionRecord . class , RefreshAllRecord . class , BookBoolRecord . class , FontRecord . class , FormatRecord . class , ExtendedFormatRecord . class , StyleRecord . class , UseSelFSRecord . class , BoundSheetRecord . class , CountryRecord . class , SSTRecord . class , ExtSSTRecord . class , EOFRecord . class , IndexRecord . class , CalcModeRecord . class , CalcCountRecord . class , RefModeRecord . class , IterationRecord . class , DeltaRecord . class , SaveRecalcRecord . class , PrintHeadersRecord . class , PrintGridlinesRecord . class , GridsetRecord . class , GutsRecord . class , DefaultRowHeightRecord . class , WSBoolRecord . class , HeaderRecord . class , FooterRecord . class , HCenterRecord . class , VCenterRecord . class , PrintSetupRecord . class , DefaultColWidthRecord . class , DimensionsRecord . class , RowRecord . class , LabelSSTRecord . class , RKRecord . class , NumberRecord . class , DBCellRecord . class , WindowTwoRecord . class , SelectionRecord . class , ContinueRecord . class , LabelRecord . class , BlankRecord . class , ColumnInfoRecord . class , MulRKRecord . class , MulBlankRecord . class , MergeCellsRecord . class , BoolErrRecord . class , ExternSheetRecord . class , NameRecord . class , LeftMarginRecord . class , RightMarginRecord . class , TopMarginRecord . class , BottomMarginRecord . class , PaletteRecord . class , StringRecord . class , SharedFormulaRecord . class } ; } private static Map recordsMap = recordsToMap ( records ) ; private static short [ ] sidscache ; private List listeners ; private boolean abortable ; public EventRecordFactory ( ) { this ( true ) ; } public EventRecordFactory ( boolean abortable ) { this . abortable = abortable ; listeners = new ArrayList ( recordsMap . size ( ) ) ; if ( sidscache == null ) { sidscache = getAllKnownRecordSIDs ( ) ; } } public void registerListener ( ERFListener listener , short [ ] sids ) { if ( sids == null ) sids = sidscache ; ERFListener wrapped = new ListenerWrapper ( listener , sids , abortable ) ; listeners . add ( wrapped ) ; } protected Iterator listeners ( ) { return listeners . iterator ( ) ; } private boolean throwRecordEvent ( Record record ) { boolean result = true ; Iterator i = listeners . iterator ( ) ; while ( i . hasNext ( ) ) { result = ( ( ERFListener ) i . next ( ) ) . processRecord ( record ) ; if ( abortable == true && result == false ) { break ; } } return result ; } public void processRecords ( InputStream in ) throws RecordFormatException { Record last_record = null ; try { short rectype = 0 ; do { rectype = LittleEndian . readShort ( in ) ; if ( rectype != 0 ) { short recsize = LittleEndian . readShort ( in ) ; byte [ ] data = new byte [ ( int ) recsize ] ; in . read ( data ) ; Record [ ] recs = createRecord ( rectype , recsize , data ) ; if ( recs . length > 1 ) { for ( int k = 0 ; k < recs . length ; k ++ ) { if ( last_record != null ) { if ( throwRecordEvent ( last_record ) == false && abortable == true ) { last_record = null ; break ; } } last_record = recs [ k ] ; } } else { Record record = recs [ 0 ] ; if ( record != null ) { if ( rectype == ContinueRecord . sid && ! ( last_record instanceof ContinueRecord ) && ! ( last_record instanceof UnknownRecord ) ) { if ( last_record == null ) { throw new RecordFormatException ( "First record is a ContinueRecord??" ) ; } last_record . processContinueRecord ( data ) ; } else { if ( last_record != null ) { if ( throwRecordEvent ( last_record ) == false && abortable == true ) { last_record = null ; break ; } } last_record = record ; } } } } } while ( rectype != 0 ) ; if ( last_record != null ) { throwRecordEvent ( last_record ) ; } } catch ( IOException e ) { throw new RecordFormatException ( "Error reading bytes" ) ; } } public static Record [ ] createRecord ( short rectype , short size , byte [ ] data ) { Record retval = null ; Record [ ] realretval = null ; try { Constructor constructor = ( Constructor ) recordsMap . get ( new Short ( rectype ) ) ; if ( constructor != null ) { retval = ( Record ) constructor . newInstance ( new Object [ ] { new Short ( rectype ) , new Short ( size ) , data } ) ; } else { retval = new UnknownRecord ( rectype , size , data ) ; } } catch ( Exception introspectionException ) { introspectionException . printStackTrace ( ) ; throw new RecordFormatException ( "Unable to construct record instance, the following exception occured: " + introspectionException . getMessage ( ) ) ; } if ( retval instanceof RKRecord ) { RKRecord rk = ( RKRecord ) retval ; NumberRecord num = new NumberRecord ( ) ; num . setColumn ( rk . getColumn ( ) ) ; num . setRow ( rk . getRow ( ) ) ; num . setXFIndex ( rk . getXFIndex ( ) ) ; num . setValue ( rk . getRKNumber ( ) ) ; retval = num ; } else if ( retval instanceof DBCellRecord ) { retval = null ; } else if ( retval instanceof MulRKRecord ) { MulRKRecord mrk = ( MulRKRecord ) retval ; realretval = new Record [ mrk . getNumColumns ( ) ] ; for ( int k = 0 ; k < mrk . getNumColumns ( ) ; k ++ ) { NumberRecord nr = new NumberRecord ( ) ; nr . setColumn ( ( short ) ( k + mrk . getFirstColumn ( ) ) ) ; nr . setRow ( mrk . getRow ( ) ) ; nr . setXFIndex ( mrk . getXFAt ( k ) ) ; nr . setValue ( mrk . getRKNumberAt ( k ) ) ; realretval [ k ] = nr ; } } else if ( retval instanceof MulBlankRecord ) { MulBlankRecord mb = ( MulBlankRecord ) retval ; realretval = new Record [ mb . getNumColumns ( ) ] ; for ( int k = 0 ; k < mb . getNumColumns ( ) ; k ++ ) { BlankRecord br = new BlankRecord ( ) ; br . setColumn ( ( short ) ( k + mb . getFirstColumn ( ) ) ) ; br . setRow ( mb . getRow ( ) ) ; br . setXFIndex ( mb . getXFAt ( k ) ) ; realretval [ k ] = br ; } } if ( realretval == null ) { realretval = new Record [ 1 ] ; realretval [ 0 ] = retval ; } return realretval ; } public static short [ ] getAllKnownRecordSIDs ( ) { short [ ] results = new short [ recordsMap . size ( ) ] ; int i = 0 ; for ( Iterator iterator = recordsMap . keySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Short sid = ( Short ) iterator . next ( ) ; results [ i ++ ] = sid . shortValue ( ) ; } return results ; } private static Map recordsToMap ( Class [ ] records ) { Map result = new HashMap ( ) ; Constructor constructor ; for ( int i = 0 ; i < records . length ; i ++ ) { Class record = null ; short sid = 0 ; record = records [ i ] ; try { sid = record . getField ( "sid" ) . getShort ( null ) ; constructor = record . getConstructor ( new Class [ ] { short . class , short . class , byte [ ] . class } ) ; } catch ( Exception illegalArgumentException ) { throw new RecordFormatException ( "Unable to determine record types" ) ; } result . put ( new Short ( sid ) , constructor ) ; } return result ; } } class ListenerWrapper implements ERFListener { private ERFListener listener ; private short [ ] sids ; private boolean abortable ; ListenerWrapper ( ERFListener listener , short [ ] sids , boolean abortable ) { this . listener = listener ; this . sids = sids ; this . abortable = abortable ; } public boolean processRecord ( Record rec ) { boolean result = true ; for ( int k = 0 ; k < sids . length ; k ++ ) { if ( sids [ k ] == rec . getSid ( ) ) { result = listener . processRecord ( rec ) ; if ( abortable == true && result == false ) { break ; } } } return result ; } } 	0
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1
package org . apache . poi . hpsf ; import java . io . * ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; public class ClassID { protected byte [ ] bytes ; public ClassID ( final byte [ ] src , final int offset ) { read ( src , offset ) ; } public ClassID ( ) { bytes = new byte [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) bytes [ i ] = 0x00 ; } public static final int LENGTH = 16 ; public int length ( ) { return LENGTH ; } public byte [ ] getBytes ( ) { return bytes ; } public byte [ ] read ( final byte [ ] src , final int offset ) { bytes = new byte [ 16 ] ; bytes [ 0 ] = src [ 3 + offset ] ; bytes [ 1 ] = src [ 2 + offset ] ; bytes [ 2 ] = src [ 1 + offset ] ; bytes [ 3 ] = src [ 0 + offset ] ; bytes [ 4 ] = src [ 5 + offset ] ; bytes [ 5 ] = src [ 4 + offset ] ; bytes [ 6 ] = src [ 7 + offset ] ; bytes [ 7 ] = src [ 6 + offset ] ; for ( int i = 8 ; i < 16 ; i ++ ) bytes [ i ] = src [ i + offset ] ; return bytes ; } public void write ( final byte [ ] dst , final int offset ) throws ArrayStoreException { if ( dst . length < 16 ) throw new ArrayStoreException ( "Destination byte[] must have room for at least 16 bytes, " + "but has a length of only " + dst . length + "." ) ; dst [ 0 + offset ] = bytes [ 3 ] ; dst [ 1 + offset ] = bytes [ 2 ] ; dst [ 2 + offset ] = bytes [ 1 ] ; dst [ 3 + offset ] = bytes [ 0 ] ; dst [ 4 + offset ] = bytes [ 5 ] ; dst [ 5 + offset ] = bytes [ 4 ] ; dst [ 6 + offset ] = bytes [ 7 ] ; dst [ 7 + offset ] = bytes [ 6 ] ; for ( int i = 8 ; i < 16 ; i ++ ) dst [ i + offset ] = bytes [ i ] ; } public boolean equals ( final Object o ) { if ( o == null || ! ( o instanceof ClassID ) ) return false ; final ClassID cid = ( ClassID ) o ; if ( bytes . length != cid . bytes . length ) return false ; for ( int i = 0 ; i < bytes . length ; i ++ ) if ( bytes [ i ] != cid . bytes [ i ] ) return false ; return true ; } public String toString ( ) { StringBuffer sbClassId = new StringBuffer ( 38 ) ; sbClassId . append ( '{' ) ; for ( int i = 0 ; i < 16 ; i ++ ) { sbClassId . append ( HexDump . toHex ( bytes [ i ] ) ) ; if ( i == 3 || i == 5 || i == 7 || i == 9 ) { sbClassId . append ( '-' ) ; } } sbClassId . append ( '}' ) ; return sbClassId . toString ( ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class CategorySeriesAxisRecord extends Record { public final static short sid = 0x1020 ; private short field_1_crossingPoint ; private short field_2_labelFrequency ; private short field_3_tickMarkFrequency ; private short field_4_options ; private BitField valueAxisCrossing = new BitField ( 0x1 ) ; private BitField crossesFarRight = new BitField ( 0x2 ) ; private BitField reversed = new BitField ( 0x4 ) ; public CategorySeriesAxisRecord ( ) { } public CategorySeriesAxisRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CategorySeriesAxisRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a CategorySeriesAxis record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_crossingPoint = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_labelFrequency = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_tickMarkFrequency = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_4_options = LittleEndian . getShort ( data , pos + 0x6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CATSERRANGE]\n" ) ; buffer . append ( "    .crossingPoint        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getCrossingPoint ( ) ) ) . append ( " (" ) . append ( getCrossingPoint ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .labelFrequency       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLabelFrequency ( ) ) ) . append ( " (" ) . append ( getLabelFrequency ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .tickMarkFrequency    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getTickMarkFrequency ( ) ) ) . append ( " (" ) . append ( getTickMarkFrequency ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .valueAxisCrossing        = " ) . append ( isValueAxisCrossing ( ) ) . append ( '\n' ) ; buffer . append ( "         .crossesFarRight          = " ) . append ( isCrossesFarRight ( ) ) . append ( '\n' ) ; buffer . append ( "         .reversed                 = " ) . append ( isReversed ( ) ) . append ( '\n' ) ; buffer . append ( "[/CATSERRANGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_crossingPoint ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_labelFrequency ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_tickMarkFrequency ) ; LittleEndian . putShort ( data , 10 + offset + pos , field_4_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { CategorySeriesAxisRecord rec = new CategorySeriesAxisRecord ( ) ; rec . field_1_crossingPoint = field_1_crossingPoint ; rec . field_2_labelFrequency = field_2_labelFrequency ; rec . field_3_tickMarkFrequency = field_3_tickMarkFrequency ; rec . field_4_options = field_4_options ; return rec ; } public short getCrossingPoint ( ) { return field_1_crossingPoint ; } public void setCrossingPoint ( short field_1_crossingPoint ) { this . field_1_crossingPoint = field_1_crossingPoint ; } public short getLabelFrequency ( ) { return field_2_labelFrequency ; } public void setLabelFrequency ( short field_2_labelFrequency ) { this . field_2_labelFrequency = field_2_labelFrequency ; } public short getTickMarkFrequency ( ) { return field_3_tickMarkFrequency ; } public void setTickMarkFrequency ( short field_3_tickMarkFrequency ) { this . field_3_tickMarkFrequency = field_3_tickMarkFrequency ; } public short getOptions ( ) { return field_4_options ; } public void setOptions ( short field_4_options ) { this . field_4_options = field_4_options ; } public void setValueAxisCrossing ( boolean value ) { field_4_options = valueAxisCrossing . setShortBoolean ( field_4_options , value ) ; } public boolean isValueAxisCrossing ( ) { return valueAxisCrossing . isSet ( field_4_options ) ; } public void setCrossesFarRight ( boolean value ) { field_4_options = crossesFarRight . setShortBoolean ( field_4_options , value ) ; } public boolean isCrossesFarRight ( ) { return crossesFarRight . isSet ( field_4_options ) ; } public void setReversed ( boolean value ) { field_4_options = reversed . setShortBoolean ( field_4_options , value ) ; } public boolean isReversed ( ) { return reversed . isSet ( field_4_options ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1
package org . apache . poi . hssf . util ; import java . util . HashMap ; import java . util . Map ; public class SheetReferences { Map map ; public SheetReferences ( ) { map = new HashMap ( 5 ) ; } public void addSheetReference ( String sheetName , int number ) { map . put ( new Integer ( number ) , sheetName ) ; } public String getSheetName ( int number ) { return ( String ) map . get ( new Integer ( number ) ) ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . hssf . record ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . LittleEndian ; public class FormulaRecord extends Record implements CellValueRecordInterface , Comparable { public static final boolean EXPERIMENTAL_FORMULA_SUPPORT_ENABLED = true ; public static final short sid = 0x06 ; private int field_1_row ; private short field_2_column ; private short field_3_xf ; private double field_4_value ; private short field_5_options ; private int field_6_zero ; private short field_7_expression_len ; private Stack field_8_parsed_expr ; private byte [ ] value_data ; private byte [ ] all_data ; public FormulaRecord ( ) { field_8_parsed_expr = new Stack ( ) ; } public FormulaRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FormulaRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { try { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_column = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf = LittleEndian . getShort ( data , 4 + offset ) ; field_4_value = LittleEndian . getDouble ( data , 6 + offset ) ; field_5_options = LittleEndian . getShort ( data , 14 + offset ) ; if ( Double . isNaN ( field_4_value ) ) { value_data = new byte [ 8 ] ; System . arraycopy ( data , offset + 6 , value_data , 0 , 8 ) ; } field_6_zero = LittleEndian . getInt ( data , 16 + offset ) ; field_7_expression_len = LittleEndian . getShort ( data , 20 + offset ) ; field_8_parsed_expr = getParsedExpressionTokens ( data , size , 22 + offset ) ; } catch ( java . lang . UnsupportedOperationException uoe ) { field_8_parsed_expr = null ; all_data = new byte [ size + 4 ] ; LittleEndian . putShort ( all_data , 0 , sid ) ; LittleEndian . putShort ( all_data , 2 , size ) ; System . arraycopy ( data , offset , all_data , 4 , size ) ; System . err . println ( "[WARNING] Unknown Ptg " + uoe . getMessage ( ) + " at cell (" + field_1_row + "," + field_2_column + ")" ) ; } } private Stack getParsedExpressionTokens ( byte [ ] data , short size , int offset ) { Stack stack = new Stack ( ) ; int pos = offset ; while ( pos < size ) { Ptg ptg = Ptg . createPtg ( data , pos ) ; pos += ptg . getSize ( ) ; stack . push ( ptg ) ; } return stack ; } public void setRow ( int row ) { field_1_row = row ; } public void setColumn ( short column ) { field_2_column = column ; } public void setXFIndex ( short xf ) { field_3_xf = xf ; } public void setValue ( double value ) { field_4_value = value ; } public void setOptions ( short options ) { field_5_options = options ; } public void setExpressionLength ( short len ) { field_7_expression_len = len ; } public int getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_column ; } public short getXFIndex ( ) { return field_3_xf ; } public double getValue ( ) { return field_4_value ; } public short getOptions ( ) { return field_5_options ; } public short getExpressionLength ( ) { return field_7_expression_len ; } public void pushExpressionToken ( Ptg ptg ) { field_8_parsed_expr . push ( ptg ) ; } public Ptg popExpressionToken ( ) { return ( Ptg ) field_8_parsed_expr . pop ( ) ; } public Ptg peekExpressionToken ( ) { return ( Ptg ) field_8_parsed_expr . peek ( ) ; } public int getNumberOfExpressionTokens ( ) { if ( this . field_8_parsed_expr == null ) { return 0 ; } else { return field_8_parsed_expr . size ( ) ; } } public List getParsedExpression ( ) { return field_8_parsed_expr ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FORMULA RECORD" ) ; } } public short getSid ( ) { return sid ; } public int serialize ( int offset , byte [ ] data ) { if ( this . field_8_parsed_expr != null ) { int ptgSize = getTotalPtgSize ( ) ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 22 + ptgSize ) ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; if ( Double . isNaN ( this . getValue ( ) ) && value_data != null ) { System . arraycopy ( value_data , 0 , data , 10 + offset , value_data . length ) ; } else { LittleEndian . putDouble ( data , 10 + offset , field_4_value ) ; } LittleEndian . putShort ( data , 18 + offset , getOptions ( ) ) ; LittleEndian . putInt ( data , 20 + offset , 0 ) ; LittleEndian . putShort ( data , 24 + offset , getExpressionLength ( ) ) ; serializePtgs ( data , 26 + offset ) ; } else { System . arraycopy ( all_data , 0 , data , offset , all_data . length ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 0 ; if ( this . field_8_parsed_expr != null ) { retval = getTotalPtgSize ( ) + 26 ; } else { retval = all_data . length ; } return retval ; } private int getTotalPtgSize ( ) { List list = getParsedExpression ( ) ; int retval = 0 ; for ( int k = 0 ; k < list . size ( ) ; k ++ ) { Ptg ptg = ( Ptg ) list . get ( k ) ; retval += ptg . getSize ( ) ; } return retval ; } private void serializePtgs ( byte [ ] data , int offset ) { int pos = offset ; for ( int k = 0 ; k < field_8_parsed_expr . size ( ) ; k ++ ) { Ptg ptg = ( Ptg ) field_8_parsed_expr . get ( k ) ; ptg . writeBytes ( data , pos ) ; pos += ptg . getSize ( ) ; } } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; if ( EXPERIMENTAL_FORMULA_SUPPORT_ENABLED ) { buffer . append ( "[FORMULA]\n" ) ; buffer . append ( "    .row       = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .column    = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xf              = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; if ( Double . isNaN ( this . getValue ( ) ) && value_data != null ) buffer . append ( "    .value (NaN)     = " ) . append ( org . apache . poi . util . HexDump . dump ( value_data , 0 , 0 ) ) . append ( "\n" ) ; else buffer . append ( "    .value           = " ) . append ( getValue ( ) ) . append ( "\n" ) ; buffer . append ( "    .options         = " ) . append ( getOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .zero            = " ) . append ( field_6_zero ) . append ( "\n" ) ; buffer . append ( "    .expressionlength= " ) . append ( getExpressionLength ( ) ) . append ( "\n" ) ; if ( field_8_parsed_expr != null ) { buffer . append ( "    .numptgsinarray  = " ) . append ( field_8_parsed_expr . size ( ) ) . append ( "\n" ) ; for ( int k = 0 ; k < field_8_parsed_expr . size ( ) ; k ++ ) { buffer . append ( "Formula " ) . append ( k ) . append ( "=" ) . append ( field_8_parsed_expr . get ( k ) . toString ( ) ) . append ( "\n" ) . append ( ( ( Ptg ) field_8_parsed_expr . get ( k ) ) . toDebugString ( ) ) . append ( "\n" ) ; } } else { buffer . append ( "Formula full data \n" ) . append ( org . apache . poi . util . HexDump . dump ( this . all_data , 0 , 0 ) ) ; } buffer . append ( "[/FORMULA]\n" ) ; } else { buffer . append ( super . toString ( ) ) ; } return buffer . toString ( ) ; } public Object clone ( ) { FormulaRecord rec = new FormulaRecord ( ) ; rec . field_1_row = field_1_row ; rec . field_2_column = field_2_column ; rec . field_3_xf = field_3_xf ; rec . field_4_value = field_4_value ; rec . field_5_options = field_5_options ; rec . field_6_zero = field_6_zero ; rec . field_7_expression_len = field_7_expression_len ; rec . field_8_parsed_expr = new Stack ( ) ; int size = 0 ; if ( field_8_parsed_expr != null ) size = field_8_parsed_expr . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Ptg ptg = ( Ptg ) ( ( Ptg ) field_8_parsed_expr . get ( i ) ) . clone ( ) ; rec . field_8_parsed_expr . add ( i , ptg ) ; } rec . value_data = value_data ; rec . all_data = all_data ; return rec ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class AxisOptionsRecord extends Record { public final static short sid = 0x1062 ; private short field_1_minimumCategory ; private short field_2_maximumCategory ; private short field_3_majorUnitValue ; private short field_4_majorUnit ; private short field_5_minorUnitValue ; private short field_6_minorUnit ; private short field_7_baseUnit ; private short field_8_crossingPoint ; private short field_9_options ; private BitField defaultMinimum = new BitField ( 0x1 ) ; private BitField defaultMaximum = new BitField ( 0x2 ) ; private BitField defaultMajor = new BitField ( 0x4 ) ; private BitField defaultMinorUnit = new BitField ( 0x8 ) ; private BitField isDate = new BitField ( 0x10 ) ; private BitField defaultBase = new BitField ( 0x20 ) ; private BitField defaultCross = new BitField ( 0x40 ) ; private BitField defaultDateSettings = new BitField ( 0x80 ) ; public AxisOptionsRecord ( ) { } public AxisOptionsRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AxisOptionsRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a AxisOptions record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_minimumCategory = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_maximumCategory = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_majorUnitValue = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_4_majorUnit = LittleEndian . getShort ( data , pos + 0x6 + offset ) ; field_5_minorUnitValue = LittleEndian . getShort ( data , pos + 0x8 + offset ) ; field_6_minorUnit = LittleEndian . getShort ( data , pos + 0xa + offset ) ; field_7_baseUnit = LittleEndian . getShort ( data , pos + 0xc + offset ) ; field_8_crossingPoint = LittleEndian . getShort ( data , pos + 0xe + offset ) ; field_9_options = LittleEndian . getShort ( data , pos + 0x10 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AXCEXT]\n" ) ; buffer . append ( "    .minimumCategory      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMinimumCategory ( ) ) ) . append ( " (" ) . append ( getMinimumCategory ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .maximumCategory      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMaximumCategory ( ) ) ) . append ( " (" ) . append ( getMaximumCategory ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .majorUnitValue       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMajorUnitValue ( ) ) ) . append ( " (" ) . append ( getMajorUnitValue ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .majorUnit            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMajorUnit ( ) ) ) . append ( " (" ) . append ( getMajorUnit ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .minorUnitValue       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMinorUnitValue ( ) ) ) . append ( " (" ) . append ( getMinorUnitValue ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .minorUnit            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getMinorUnit ( ) ) ) . append ( " (" ) . append ( getMinorUnit ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .baseUnit             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getBaseUnit ( ) ) ) . append ( " (" ) . append ( getBaseUnit ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .crossingPoint        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getCrossingPoint ( ) ) ) . append ( " (" ) . append ( getCrossingPoint ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .defaultMinimum           = " ) . append ( isDefaultMinimum ( ) ) . append ( '\n' ) ; buffer . append ( "         .defaultMaximum           = " ) . append ( isDefaultMaximum ( ) ) . append ( '\n' ) ; buffer . append ( "         .defaultMajor             = " ) . append ( isDefaultMajor ( ) ) . append ( '\n' ) ; buffer . append ( "         .defaultMinorUnit         = " ) . append ( isDefaultMinorUnit ( ) ) . append ( '\n' ) ; buffer . append ( "         .isDate                   = " ) . append ( isIsDate ( ) ) . append ( '\n' ) ; buffer . append ( "         .defaultBase              = " ) . append ( isDefaultBase ( ) ) . append ( '\n' ) ; buffer . append ( "         .defaultCross             = " ) . append ( isDefaultCross ( ) ) . append ( '\n' ) ; buffer . append ( "         .defaultDateSettings      = " ) . append ( isDefaultDateSettings ( ) ) . append ( '\n' ) ; buffer . append ( "[/AXCEXT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_minimumCategory ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_maximumCategory ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_majorUnitValue ) ; LittleEndian . putShort ( data , 10 + offset + pos , field_4_majorUnit ) ; LittleEndian . putShort ( data , 12 + offset + pos , field_5_minorUnitValue ) ; LittleEndian . putShort ( data , 14 + offset + pos , field_6_minorUnit ) ; LittleEndian . putShort ( data , 16 + offset + pos , field_7_baseUnit ) ; LittleEndian . putShort ( data , 18 + offset + pos , field_8_crossingPoint ) ; LittleEndian . putShort ( data , 20 + offset + pos , field_9_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { AxisOptionsRecord rec = new AxisOptionsRecord ( ) ; rec . field_1_minimumCategory = field_1_minimumCategory ; rec . field_2_maximumCategory = field_2_maximumCategory ; rec . field_3_majorUnitValue = field_3_majorUnitValue ; rec . field_4_majorUnit = field_4_majorUnit ; rec . field_5_minorUnitValue = field_5_minorUnitValue ; rec . field_6_minorUnit = field_6_minorUnit ; rec . field_7_baseUnit = field_7_baseUnit ; rec . field_8_crossingPoint = field_8_crossingPoint ; rec . field_9_options = field_9_options ; return rec ; } public short getMinimumCategory ( ) { return field_1_minimumCategory ; } public void setMinimumCategory ( short field_1_minimumCategory ) { this . field_1_minimumCategory = field_1_minimumCategory ; } public short getMaximumCategory ( ) { return field_2_maximumCategory ; } public void setMaximumCategory ( short field_2_maximumCategory ) { this . field_2_maximumCategory = field_2_maximumCategory ; } public short getMajorUnitValue ( ) { return field_3_majorUnitValue ; } public void setMajorUnitValue ( short field_3_majorUnitValue ) { this . field_3_majorUnitValue = field_3_majorUnitValue ; } public short getMajorUnit ( ) { return field_4_majorUnit ; } public void setMajorUnit ( short field_4_majorUnit ) { this . field_4_majorUnit = field_4_majorUnit ; } public short getMinorUnitValue ( ) { return field_5_minorUnitValue ; } public void setMinorUnitValue ( short field_5_minorUnitValue ) { this . field_5_minorUnitValue = field_5_minorUnitValue ; } public short getMinorUnit ( ) { return field_6_minorUnit ; } public void setMinorUnit ( short field_6_minorUnit ) { this . field_6_minorUnit = field_6_minorUnit ; } public short getBaseUnit ( ) { return field_7_baseUnit ; } public void setBaseUnit ( short field_7_baseUnit ) { this . field_7_baseUnit = field_7_baseUnit ; } public short getCrossingPoint ( ) { return field_8_crossingPoint ; } public void setCrossingPoint ( short field_8_crossingPoint ) { this . field_8_crossingPoint = field_8_crossingPoint ; } public short getOptions ( ) { return field_9_options ; } public void setOptions ( short field_9_options ) { this . field_9_options = field_9_options ; } public void setDefaultMinimum ( boolean value ) { field_9_options = defaultMinimum . setShortBoolean ( field_9_options , value ) ; } public boolean isDefaultMinimum ( ) { return defaultMinimum . isSet ( field_9_options ) ; } public void setDefaultMaximum ( boolean value ) { field_9_options = defaultMaximum . setShortBoolean ( field_9_options , value ) ; } public boolean isDefaultMaximum ( ) { return defaultMaximum . isSet ( field_9_options ) ; } public void setDefaultMajor ( boolean value ) { field_9_options = defaultMajor . setShortBoolean ( field_9_options , value ) ; } public boolean isDefaultMajor ( ) { return defaultMajor . isSet ( field_9_options ) ; } public void setDefaultMinorUnit ( boolean value ) { field_9_options = defaultMinorUnit . setShortBoolean ( field_9_options , value ) ; } public boolean isDefaultMinorUnit ( ) { return defaultMinorUnit . isSet ( field_9_options ) ; } public void setIsDate ( boolean value ) { field_9_options = isDate . setShortBoolean ( field_9_options , value ) ; } public boolean isIsDate ( ) { return isDate . isSet ( field_9_options ) ; } public void setDefaultBase ( boolean value ) { field_9_options = defaultBase . setShortBoolean ( field_9_options , value ) ; } public boolean isDefaultBase ( ) { return defaultBase . isSet ( field_9_options ) ; } public void setDefaultCross ( boolean value ) { field_9_options = defaultCross . setShortBoolean ( field_9_options , value ) ; } public boolean isDefaultCross ( ) { return defaultCross . isSet ( field_9_options ) ; } public void setDefaultDateSettings ( boolean value ) { field_9_options = defaultDateSettings . setShortBoolean ( field_9_options , value ) ; } public boolean isDefaultDateSettings ( ) { return defaultDateSettings . isSet ( field_9_options ) ; } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . hpsf . wellknown ; import java . util . * ; public class PropertyIDMap extends HashMap { public final static int PID_TITLE = 2 ; public final static int PID_SUBJECT = 3 ; public final static int PID_AUTHOR = 4 ; public final static int PID_KEYWORDS = 5 ; public final static int PID_COMMENTS = 6 ; public final static int PID_TEMPLATE = 7 ; public final static int PID_LASTAUTHOR = 8 ; public final static int PID_REVNUMBER = 9 ; public final static int PID_EDITTIME = 10 ; public final static int PID_LASTPRINTED = 11 ; public final static int PID_CREATE_DTM = 12 ; public final static int PID_LASTSAVE_DTM = 13 ; public final static int PID_PAGECOUNT = 14 ; public final static int PID_WORDCOUNT = 15 ; public final static int PID_CHARCOUNT = 16 ; public final static int PID_THUMBNAIL = 17 ; public final static int PID_APPNAME = 18 ; public final static int PID_SECURITY = 19 ; public final static int PID_DICTIONARY = 0 ; public final static int PID_CODEPAGE = 1 ; public final static int PID_CATEGORY = 2 ; public final static int PID_PRESFORMAT = 3 ; public final static int PID_BYTECOUNT = 4 ; public final static int PID_LINECOUNT = 5 ; public final static int PID_PARCOUNT = 6 ; public final static int PID_SLIDECOUNT = 7 ; public final static int PID_NOTECOUNT = 8 ; public final static int PID_HIDDENCOUNT = 9 ; public final static int PID_MMCLIPCOUNT = 10 ; public final static int PID_SCALE = 11 ; public final static int PID_HEADINGPAIR = 12 ; public final static int PID_DOCPARTS = 13 ; public final static int PID_MANAGER = 14 ; public final static int PID_COMPANY = 15 ; public final static int PID_LINKSDIRTY = 16 ; private static PropertyIDMap summaryInformationProperties ; private static PropertyIDMap documentSummaryInformationProperties ; public PropertyIDMap ( int initialCapacity , float loadFactor ) { super ( initialCapacity , loadFactor ) ; } public Object put ( int id , String idString ) { return put ( new Integer ( id ) , idString ) ; } public Object get ( int id ) { return get ( new Integer ( id ) ) ; } public static PropertyIDMap getSummaryInformationProperties ( ) { if ( summaryInformationProperties == null ) { PropertyIDMap m = new PropertyIDMap ( 18 , ( float ) 1.0 ) ; m . put ( PID_TITLE , "PID_TITLE" ) ; m . put ( PID_SUBJECT , "PID_SUBJECT" ) ; m . put ( PID_AUTHOR , "PID_AUTHOR" ) ; m . put ( PID_KEYWORDS , "PID_KEYWORDS" ) ; m . put ( PID_COMMENTS , "PID_COMMENTS" ) ; m . put ( PID_TEMPLATE , "PID_TEMPLATE" ) ; m . put ( PID_LASTAUTHOR , "PID_LASTAUTHOR" ) ; m . put ( PID_REVNUMBER , "PID_REVNUMBER" ) ; m . put ( PID_EDITTIME , "PID_EDITTIME" ) ; m . put ( PID_LASTPRINTED , "PID_LASTPRINTED" ) ; m . put ( PID_CREATE_DTM , "PID_CREATE_DTM" ) ; m . put ( PID_LASTSAVE_DTM , "PID_LASTSAVE_DTM" ) ; m . put ( PID_PAGECOUNT , "PID_PAGECOUNT" ) ; m . put ( PID_WORDCOUNT , "PID_WORDCOUNT" ) ; m . put ( PID_CHARCOUNT , "PID_CHARCOUNT" ) ; m . put ( PID_THUMBNAIL , "PID_THUMBNAIL" ) ; m . put ( PID_APPNAME , "PID_APPNAME" ) ; m . put ( PID_SECURITY , "PID_SECURITY" ) ; summaryInformationProperties = m ; } return summaryInformationProperties ; } public static PropertyIDMap getDocumentSummaryInformationProperties ( ) { if ( documentSummaryInformationProperties == null ) { PropertyIDMap m = new PropertyIDMap ( 17 , ( float ) 1.0 ) ; m . put ( PID_DICTIONARY , "PID_DICTIONARY" ) ; m . put ( PID_CODEPAGE , "PID_CODEPAGE" ) ; m . put ( PID_CATEGORY , "PID_CATEGORY" ) ; m . put ( PID_PRESFORMAT , "PID_PRESFORMAT" ) ; m . put ( PID_BYTECOUNT , "PID_BYTECOUNT" ) ; m . put ( PID_LINECOUNT , "PID_LINECOUNT" ) ; m . put ( PID_PARCOUNT , "PID_PARCOUNT" ) ; m . put ( PID_SLIDECOUNT , "PID_SLIDECOUNT" ) ; m . put ( PID_NOTECOUNT , "PID_NOTECOUNT" ) ; m . put ( PID_HIDDENCOUNT , "PID_HIDDENCOUNT" ) ; m . put ( PID_MMCLIPCOUNT , "PID_MMCLIPCOUNT" ) ; m . put ( PID_SCALE , "PID_SCALE" ) ; m . put ( PID_HEADINGPAIR , "PID_HEADINGPAIR" ) ; m . put ( PID_DOCPARTS , "PID_DOCPARTS" ) ; m . put ( PID_MANAGER , "PID_MANAGER" ) ; m . put ( PID_COMPANY , "PID_COMPANY" ) ; m . put ( PID_LINKSDIRTY , "PID_LINKSDIRTY" ) ; documentSummaryInformationProperties = m ; } return documentSummaryInformationProperties ; } public static void main ( String args [ ] ) { PropertyIDMap s1 = getSummaryInformationProperties ( ) ; PropertyIDMap s2 = getDocumentSummaryInformationProperties ( ) ; System . out . println ( "s1: " + s1 ) ; System . out . println ( "s2: " + s2 ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class NumberFormatIndexRecord extends Record { public final static short sid = 0x104e ; private short field_1_formatIndex ; public NumberFormatIndexRecord ( ) { } public NumberFormatIndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public NumberFormatIndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a NumberFormatIndex record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_formatIndex = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[IFMT]\n" ) ; buffer . append ( "    .formatIndex          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFormatIndex ( ) ) ) . append ( " (" ) . append ( getFormatIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/IFMT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_formatIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { NumberFormatIndexRecord rec = new NumberFormatIndexRecord ( ) ; rec . field_1_formatIndex = field_1_formatIndex ; return rec ; } public short getFormatIndex ( ) { return field_1_formatIndex ; } public void setFormatIndex ( short field_1_formatIndex ) { this . field_1_formatIndex = field_1_formatIndex ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; class SSTRecordHeader { int numStrings ; int numUniqueStrings ; public SSTRecordHeader ( int numStrings , int numUniqueStrings ) { this . numStrings = numStrings ; this . numUniqueStrings = numUniqueStrings ; } public int writeSSTHeader ( byte [ ] data , int bufferIndex , int recSize ) { int offset = bufferIndex ; LittleEndian . putShort ( data , offset , SSTRecord . sid ) ; offset += LittleEndianConsts . SHORT_SIZE ; LittleEndian . putShort ( data , offset , ( short ) ( recSize ) ) ; offset += LittleEndianConsts . SHORT_SIZE ; LittleEndian . putInt ( data , offset , numStrings ) ; offset += LittleEndianConsts . INT_SIZE ; LittleEndian . putInt ( data , offset , numUniqueStrings ) ; offset += LittleEndianConsts . INT_SIZE ; return offset - bufferIndex ; } } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface BlockList { public void zap ( final int index ) ; public ListManagedBlock remove ( final int index ) throws IOException ; public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException ; public void setBAT ( final BlockAllocationTableReader bat ) throws IOException ; } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SeriesRecord extends Record { public final static short sid = 0x1003 ; private short field_1_categoryDataType ; public final static short CATEGORY_DATA_TYPE_DATES = 0 ; public final static short CATEGORY_DATA_TYPE_NUMERIC = 1 ; public final static short CATEGORY_DATA_TYPE_SEQUENCE = 2 ; public final static short CATEGORY_DATA_TYPE_TEXT = 3 ; private short field_2_valuesDataType ; public final static short VALUES_DATA_TYPE_DATES = 0 ; public final static short VALUES_DATA_TYPE_NUMERIC = 1 ; public final static short VALUES_DATA_TYPE_SEQUENCE = 2 ; public final static short VALUES_DATA_TYPE_TEXT = 3 ; private short field_3_numCategories ; private short field_4_numValues ; private short field_5_bubbleSeriesType ; public final static short BUBBLE_SERIES_TYPE_DATES = 0 ; public final static short BUBBLE_SERIES_TYPE_NUMERIC = 1 ; public final static short BUBBLE_SERIES_TYPE_SEQUENCE = 2 ; public final static short BUBBLE_SERIES_TYPE_TEXT = 3 ; private short field_6_numBubbleValues ; public SeriesRecord ( ) { } public SeriesRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Series record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_categoryDataType = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_valuesDataType = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_numCategories = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_4_numValues = LittleEndian . getShort ( data , pos + 0x6 + offset ) ; field_5_bubbleSeriesType = LittleEndian . getShort ( data , pos + 0x8 + offset ) ; field_6_numBubbleValues = LittleEndian . getShort ( data , pos + 0xa + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SERIES]\n" ) ; buffer . append ( "    .categoryDataType     = " ) . append ( "0x" ) . append ( HexDump . toHex ( getCategoryDataType ( ) ) ) . append ( " (" ) . append ( getCategoryDataType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .valuesDataType       = " ) . append ( "0x" ) . append ( HexDump . toHex ( getValuesDataType ( ) ) ) . append ( " (" ) . append ( getValuesDataType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .numCategories        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getNumCategories ( ) ) ) . append ( " (" ) . append ( getNumCategories ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .numValues            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getNumValues ( ) ) ) . append ( " (" ) . append ( getNumValues ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .bubbleSeriesType     = " ) . append ( "0x" ) . append ( HexDump . toHex ( getBubbleSeriesType ( ) ) ) . append ( " (" ) . append ( getBubbleSeriesType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .numBubbleValues      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getNumBubbleValues ( ) ) ) . append ( " (" ) . append ( getNumBubbleValues ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SERIES]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_categoryDataType ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_valuesDataType ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_numCategories ) ; LittleEndian . putShort ( data , 10 + offset + pos , field_4_numValues ) ; LittleEndian . putShort ( data , 12 + offset + pos , field_5_bubbleSeriesType ) ; LittleEndian . putShort ( data , 14 + offset + pos , field_6_numBubbleValues ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SeriesRecord rec = new SeriesRecord ( ) ; rec . field_1_categoryDataType = field_1_categoryDataType ; rec . field_2_valuesDataType = field_2_valuesDataType ; rec . field_3_numCategories = field_3_numCategories ; rec . field_4_numValues = field_4_numValues ; rec . field_5_bubbleSeriesType = field_5_bubbleSeriesType ; rec . field_6_numBubbleValues = field_6_numBubbleValues ; return rec ; } public short getCategoryDataType ( ) { return field_1_categoryDataType ; } public void setCategoryDataType ( short field_1_categoryDataType ) { this . field_1_categoryDataType = field_1_categoryDataType ; } public short getValuesDataType ( ) { return field_2_valuesDataType ; } public void setValuesDataType ( short field_2_valuesDataType ) { this . field_2_valuesDataType = field_2_valuesDataType ; } public short getNumCategories ( ) { return field_3_numCategories ; } public void setNumCategories ( short field_3_numCategories ) { this . field_3_numCategories = field_3_numCategories ; } public short getNumValues ( ) { return field_4_numValues ; } public void setNumValues ( short field_4_numValues ) { this . field_4_numValues = field_4_numValues ; } public short getBubbleSeriesType ( ) { return field_5_bubbleSeriesType ; } public void setBubbleSeriesType ( short field_5_bubbleSeriesType ) { this . field_5_bubbleSeriesType = field_5_bubbleSeriesType ; } public short getNumBubbleValues ( ) { return field_6_numBubbleValues ; } public void setNumBubbleValues ( short field_6_numBubbleValues ) { this . field_6_numBubbleValues = field_6_numBubbleValues ; } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . ListManagedBlock ; class PropertyFactory { private PropertyFactory ( ) { } static List convertToProperties ( ListManagedBlock [ ] blocks ) throws IOException { List properties = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; int property_count = data . length / POIFSConstants . PROPERTY_SIZE ; int offset = 0 ; for ( int k = 0 ; k < property_count ; k ++ ) { switch ( data [ offset + PropertyConstants . PROPERTY_TYPE_OFFSET ] ) { case PropertyConstants . DIRECTORY_TYPE : properties . add ( new DirectoryProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . DOCUMENT_TYPE : properties . add ( new DocumentProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . ROOT_TYPE : properties . add ( new RootProperty ( properties . size ( ) , data , offset ) ) ; break ; default : properties . add ( null ) ; break ; } offset += POIFSConstants . PROPERTY_SIZE ; } } return properties ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; public class NameXPtg extends Ptg { public final static short sid = 0x39 ; private final static int SIZE = 7 ; private short field_1_ixals ; private short field_2_ilbl ; private short field_3_reserved ; private NameXPtg ( ) { } public NameXPtg ( String name ) { } public NameXPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_ixals = LittleEndian . getShort ( data , offset ) ; field_2_ilbl = LittleEndian . getShort ( data , offset + 2 ) ; field_3_reserved = LittleEndian . getShort ( data , offset + 4 ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_ixals ) ; LittleEndian . putShort ( array , offset + 3 , field_2_ilbl ) ; LittleEndian . putShort ( array , offset + 5 , field_3_reserved ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return "NO IDEA - NAME" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { NameXPtg ptg = new NameXPtg ( ) ; ptg . field_1_ixals = field_1_ixals ; ptg . field_3_reserved = field_3_reserved ; ptg . field_2_ilbl = field_2_ilbl ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; public class FuncVarPtg extends AbstractFunctionPtg { public final static byte sid = 0x22 ; private final static int SIZE = 4 ; private FuncVarPtg ( ) { } public FuncVarPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_num_args = data [ offset + 0 ] ; field_2_fnc_index = LittleEndian . getShort ( data , offset + 1 ) ; } public FuncVarPtg ( String pName , byte pNumOperands ) { field_1_num_args = pNumOperands ; field_2_fnc_index = lookupIndex ( pName ) ; try { returnClass = ( ( Byte ) functionData [ field_2_fnc_index ] [ 0 ] ) . byteValue ( ) ; paramClass = ( byte [ ] ) functionData [ field_2_fnc_index ] [ 1 ] ; } catch ( NullPointerException npe ) { returnClass = Ptg . CLASS_VALUE ; paramClass = new byte [ ] { Ptg . CLASS_VALUE } ; } } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; array [ offset + 1 ] = field_1_num_args ; LittleEndian . putShort ( array , offset + 2 , field_2_fnc_index ) ; } public int getNumberOfOperands ( ) { return field_1_num_args ; } public Object clone ( ) { FuncVarPtg ptg = new FuncVarPtg ( ) ; ptg . field_1_num_args = field_1_num_args ; ptg . field_2_fnc_index = field_2_fnc_index ; ptg . setClass ( ptgClass ) ; return ptg ; } public int getSize ( ) { return SIZE ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionVarPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class ParenthesisPtg extends OperationPtg { private final static int SIZE = 1 ; public final static byte sid = 0x15 ; public ParenthesisPtg ( ) { } public ParenthesisPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "()" ; } public String toFormulaString ( String [ ] operands ) { return "(" + operands [ 0 ] + ")" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new ParenthesisPtg ( ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableReader { public static BlockList getSmallDocumentBlocks ( final RawDataBlockList blockList , final RootProperty root , final int sbatStart ) throws IOException { BlockList list = new SmallDocumentBlockList ( SmallDocumentBlock . extract ( blockList . fetchBlocks ( root . getStartBlock ( ) ) ) ) ; new BlockAllocationTableReader ( blockList . fetchBlocks ( sbatStart ) , list ) ; return list ; } } 	0
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class GutsRecord extends Record { public final static short sid = 0x80 ; private short field_1_left_row_gutter ; private short field_2_top_col_gutter ; private short field_3_row_level_max ; private short field_4_col_level_max ; public GutsRecord ( ) { } public GutsRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public GutsRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Guts RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_left_row_gutter = LittleEndian . getShort ( data , 0 + offset ) ; field_2_top_col_gutter = LittleEndian . getShort ( data , 2 + offset ) ; field_3_row_level_max = LittleEndian . getShort ( data , 4 + offset ) ; field_4_col_level_max = LittleEndian . getShort ( data , 6 + offset ) ; } public void setLeftRowGutter ( short gut ) { field_1_left_row_gutter = gut ; } public void setTopColGutter ( short gut ) { field_2_top_col_gutter = gut ; } public void setRowLevelMax ( short max ) { field_3_row_level_max = max ; } public void setColLevelMax ( short max ) { field_4_col_level_max = max ; } public short getLeftRowGutter ( ) { return field_1_left_row_gutter ; } public short getTopColGutter ( ) { return field_2_top_col_gutter ; } public short getRowLevelMax ( ) { return field_3_row_level_max ; } public short getColLevelMax ( ) { return field_4_col_level_max ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[GUTS]\n" ) ; buffer . append ( "    .leftgutter     = " ) . append ( Integer . toHexString ( getLeftRowGutter ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .topgutter      = " ) . append ( Integer . toHexString ( getTopColGutter ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .rowlevelmax    = " ) . append ( Integer . toHexString ( getRowLevelMax ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .collevelmax    = " ) . append ( Integer . toHexString ( getColLevelMax ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/GUTS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x8 ) ; LittleEndian . putShort ( data , 4 + offset , getLeftRowGutter ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getTopColGutter ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getRowLevelMax ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getColLevelMax ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 12 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { GutsRecord rec = new GutsRecord ( ) ; rec . field_1_left_row_gutter = field_1_left_row_gutter ; rec . field_2_top_col_gutter = field_2_top_col_gutter ; rec . field_3_row_level_max = field_3_row_level_max ; rec . field_4_col_level_max = field_4_col_level_max ; return rec ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . hssf . util ; import org . apache . poi . hssf . record . MergeCellsRecord . MergedRegion ; public class Region implements Comparable { private int rowFrom ; private short colFrom ; private int rowTo ; private short colTo ; public Region ( ) { } public Region ( int rowFrom , short colFrom , int rowTo , short colTo ) { this . rowFrom = rowFrom ; this . rowTo = rowTo ; this . colFrom = colFrom ; this . colTo = colTo ; } public Region ( MergedRegion region ) { this ( region . row_from , region . col_from , region . row_to , region . col_to ) ; } public short getColumnFrom ( ) { return colFrom ; } public int getRowFrom ( ) { return rowFrom ; } public short getColumnTo ( ) { return colTo ; } public int getRowTo ( ) { return rowTo ; } public void setColumnFrom ( short colFrom ) { this . colFrom = colFrom ; } public void setRowFrom ( int rowFrom ) { this . rowFrom = rowFrom ; } public void setColumnTo ( short colTo ) { this . colTo = colTo ; } public void setRowTo ( int rowTo ) { this . rowTo = rowTo ; } public boolean contains ( int row , short col ) { if ( ( this . rowFrom <= row ) && ( this . rowTo >= row ) && ( this . colFrom <= col ) && ( this . colTo >= col ) ) { return true ; } return false ; } public boolean equals ( Region r ) { return ( compareTo ( r ) == 0 ) ; } public int compareTo ( Region r ) { if ( ( this . getRowFrom ( ) == r . getRowFrom ( ) ) && ( this . getColumnFrom ( ) == r . getColumnFrom ( ) ) && ( this . getRowTo ( ) == r . getRowTo ( ) ) && ( this . getColumnTo ( ) == r . getColumnTo ( ) ) ) { return 0 ; } if ( ( this . getRowFrom ( ) < r . getRowFrom ( ) ) || ( this . getColumnFrom ( ) < r . getColumnFrom ( ) ) || ( this . getRowTo ( ) < r . getRowTo ( ) ) || ( this . getColumnTo ( ) < r . getColumnTo ( ) ) ) { return 1 ; } return - 1 ; } public int compareTo ( Object o ) { return compareTo ( ( Region ) o ) ; } public int getArea ( ) { return ( ( 1 + ( getRowTo ( ) - getRowFrom ( ) ) ) * ( 1 + ( getColumnTo ( ) - getColumnFrom ( ) ) ) ) ; } } 	0
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1
package org . apache . poi . poifs . filesystem ; public interface Entry { public String getName ( ) ; public boolean isDirectoryEntry ( ) ; public boolean isDocumentEntry ( ) ; public DirectoryEntry getParent ( ) ; public boolean delete ( ) ; public boolean renameTo ( final String newName ) ; } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1
package org . apache . poi . hpsf ; public class HPSFRuntimeException extends RuntimeException { private Throwable reason ; public HPSFRuntimeException ( ) { super ( ) ; } public HPSFRuntimeException ( final String msg ) { super ( msg ) ; } public HPSFRuntimeException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HPSFRuntimeException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } } 	0
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1
package org . apache . poi . hpsf . wellknown ; import java . util . * ; public class SectionIDMap extends HashMap { public final static byte [ ] SUMMARY_INFORMATION_ID = new byte [ ] { ( byte ) 0xF2 , ( byte ) 0x9F , ( byte ) 0x85 , ( byte ) 0xE0 , ( byte ) 0x4F , ( byte ) 0xF9 , ( byte ) 0x10 , ( byte ) 0x68 , ( byte ) 0xAB , ( byte ) 0x91 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x2B , ( byte ) 0x27 , ( byte ) 0xB3 , ( byte ) 0xD9 } ; public final static byte [ ] DOCUMENT_SUMMARY_INFORMATION_ID = new byte [ ] { ( byte ) 0xD5 , ( byte ) 0xCD , ( byte ) 0xD5 , ( byte ) 0x02 , ( byte ) 0x2E , ( byte ) 0x9C , ( byte ) 0x10 , ( byte ) 0x1B , ( byte ) 0x93 , ( byte ) 0x97 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x2B , ( byte ) 0x2C , ( byte ) 0xF9 , ( byte ) 0xAE } ; public final static String UNDEFINED = "[undefined]" ; private static SectionIDMap defaultMap ; public static SectionIDMap getInstance ( ) { if ( defaultMap == null ) { final SectionIDMap m = new SectionIDMap ( ) ; m . put ( SUMMARY_INFORMATION_ID , PropertyIDMap . getSummaryInformationProperties ( ) ) ; m . put ( DOCUMENT_SUMMARY_INFORMATION_ID , PropertyIDMap . getDocumentSummaryInformationProperties ( ) ) ; defaultMap = m ; } return defaultMap ; } public static String getPIDString ( final byte [ ] sectionFormatID , final int pid ) { final PropertyIDMap m = ( PropertyIDMap ) getInstance ( ) . get ( sectionFormatID ) ; if ( m == null ) return UNDEFINED ; else { final String s = ( String ) m . get ( pid ) ; if ( s == null ) return UNDEFINED ; return s ; } } public PropertyIDMap get ( final byte [ ] sectionFormatID ) { return ( PropertyIDMap ) super . get ( new String ( sectionFormatID ) ) ; } public Object get ( final Object sectionFormatID ) { return get ( ( byte [ ] ) sectionFormatID ) ; } public Object put ( final byte [ ] sectionFormatID , final PropertyIDMap propertyIDMap ) { return super . put ( new String ( sectionFormatID ) , propertyIDMap ) ; } public Object put ( final Object key , final Object value ) { return put ( ( byte [ ] ) key , ( PropertyIDMap ) value ) ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SeriesLabelsRecord extends Record { public final static short sid = 0x100c ; private short field_1_formatFlags ; private BitField showActual = new BitField ( 0x1 ) ; private BitField showPercent = new BitField ( 0x2 ) ; private BitField labelAsPercentage = new BitField ( 0x4 ) ; private BitField smoothedLine = new BitField ( 0x8 ) ; private BitField showLabel = new BitField ( 0x10 ) ; private BitField showBubbleSizes = new BitField ( 0x20 ) ; public SeriesLabelsRecord ( ) { } public SeriesLabelsRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesLabelsRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesLabels record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_formatFlags = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[ATTACHEDLABEL]\n" ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .showActual               = " ) . append ( isShowActual ( ) ) . append ( '\n' ) ; buffer . append ( "         .showPercent              = " ) . append ( isShowPercent ( ) ) . append ( '\n' ) ; buffer . append ( "         .labelAsPercentage        = " ) . append ( isLabelAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .smoothedLine             = " ) . append ( isSmoothedLine ( ) ) . append ( '\n' ) ; buffer . append ( "         .showLabel                = " ) . append ( isShowLabel ( ) ) . append ( '\n' ) ; buffer . append ( "         .showBubbleSizes          = " ) . append ( isShowBubbleSizes ( ) ) . append ( '\n' ) ; buffer . append ( "[/ATTACHEDLABEL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SeriesLabelsRecord rec = new SeriesLabelsRecord ( ) ; rec . field_1_formatFlags = field_1_formatFlags ; return rec ; } public short getFormatFlags ( ) { return field_1_formatFlags ; } public void setFormatFlags ( short field_1_formatFlags ) { this . field_1_formatFlags = field_1_formatFlags ; } public void setShowActual ( boolean value ) { field_1_formatFlags = showActual . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowActual ( ) { return showActual . isSet ( field_1_formatFlags ) ; } public void setShowPercent ( boolean value ) { field_1_formatFlags = showPercent . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowPercent ( ) { return showPercent . isSet ( field_1_formatFlags ) ; } public void setLabelAsPercentage ( boolean value ) { field_1_formatFlags = labelAsPercentage . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isLabelAsPercentage ( ) { return labelAsPercentage . isSet ( field_1_formatFlags ) ; } public void setSmoothedLine ( boolean value ) { field_1_formatFlags = smoothedLine . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isSmoothedLine ( ) { return smoothedLine . isSet ( field_1_formatFlags ) ; } public void setShowLabel ( boolean value ) { field_1_formatFlags = showLabel . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowLabel ( ) { return showLabel . isSet ( field_1_formatFlags ) ; } public void setShowBubbleSizes ( boolean value ) { field_1_formatFlags = showBubbleSizes . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShowBubbleSizes ( ) { return showBubbleSizes . isSet ( field_1_formatFlags ) ; } } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1
package org . apache . poi . hssf . eventusermodel ; public class HSSFUserException extends Exception { private Throwable reason ; public HSSFUserException ( ) { super ( ) ; } public HSSFUserException ( final String msg ) { super ( msg ) ; } public HSSFUserException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HSSFUserException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . hssf . dev ; import org . apache . poi . hssf . record . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; public class BiffViewer { String filename ; private boolean dump ; public BiffViewer ( String [ ] args ) { if ( args . length > 0 ) { filename = args [ 0 ] ; } else { System . out . println ( "BIFFVIEWER REQUIRES A FILENAME***" ) ; } } public void run ( ) { try { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; Record [ ] records = createRecords ( stream , dump ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static Record [ ] createRecords ( InputStream in , boolean dump ) throws RecordFormatException { ArrayList records = new ArrayList ( ) ; Record last_record = null ; int loc = 0 ; try { short rectype = 0 ; do { rectype = LittleEndian . readShort ( in ) ; System . out . println ( "============================================" ) ; System . out . println ( "Offset 0x" + Integer . toHexString ( loc ) + " (" + loc + ")" ) ; loc += 2 ; if ( rectype != 0 ) { short recsize = LittleEndian . readShort ( in ) ; loc += 2 ; byte [ ] data = new byte [ ( int ) recsize ] ; in . read ( data ) ; if ( ( rectype == WSBoolRecord . sid ) && ( recsize == 0 ) ) { System . out . println ( loc ) ; } loc += recsize ; if ( dump ) { dump ( rectype , recsize , data ) ; } Record [ ] recs = createRecord ( rectype , recsize , data ) ; Record record = recs [ 0 ] ; if ( ( record instanceof UnknownRecord ) && ! dump ) { dumpUnknownRecord ( data ) ; } if ( record != null ) { if ( rectype == ContinueRecord . sid ) { dumpContinueRecord ( last_record , dump , data ) ; } else { last_record = record ; records . add ( record ) ; } } } } while ( rectype != 0 ) ; } catch ( IOException e ) { throw new RecordFormatException ( "Error reading bytes" ) ; } Record [ ] retval = new Record [ records . size ( ) ] ; retval = ( Record [ ] ) records . toArray ( retval ) ; return retval ; } private static void dumpContinueRecord ( Record last_record , boolean dump , byte [ ] data ) throws IOException { if ( last_record == null ) { throw new RecordFormatException ( "First record is a ContinueRecord??" ) ; } if ( dump ) { System . out . println ( "-----PRECONTINUED LAST RECORD WOULD SERIALIZE LIKE:" ) ; byte [ ] lr = last_record . serialize ( ) ; if ( lr != null ) { HexDump . dump ( last_record . serialize ( ) , 0 , System . out , 0 ) ; } System . out . println ( ) ; System . out . println ( "-----PRECONTINUED----------------------------------" ) ; } last_record . processContinueRecord ( data ) ; if ( dump ) { System . out . println ( "-----CONTINUED LAST RECORD WOULD SERIALIZE LIKE:" ) ; HexDump . dump ( last_record . serialize ( ) , 0 , System . out , 0 ) ; System . out . println ( ) ; System . out . println ( "-----CONTINUED----------------------------------" ) ; } } private static void dumpUnknownRecord ( byte [ ] data ) throws IOException { System . out . println ( "-----UNKNOWN----------------------------------" ) ; if ( data . length > 0 ) { HexDump . dump ( data , 0 , System . out , 0 ) ; } else { System . out . print ( "**NO RECORD DATA**" ) ; } System . out . println ( ) ; System . out . println ( "-----UNKNOWN----------------------------------" ) ; } private static void dump ( short rectype , short recsize , byte [ ] data ) throws IOException { System . out . print ( "rectype = 0x" + Integer . toHexString ( rectype ) ) ; System . out . println ( ", recsize = 0x" + Integer . toHexString ( recsize ) ) ; System . out . println ( "-BEGIN DUMP---------------------------------" ) ; if ( data . length > 0 ) { HexDump . dump ( data , 0 , System . out , 0 ) ; } else { System . out . println ( "**NO RECORD DATA**" ) ; } System . out . println ( "-END DUMP-----------------------------------" ) ; } private static Record [ ] createRecord ( short rectype , short size , byte [ ] data ) { Record retval = null ; Record [ ] realretval = null ; switch ( rectype ) { case ChartRecord . sid : retval = new ChartRecord ( rectype , size , data ) ; break ; case ChartFormatRecord . sid : retval = new ChartFormatRecord ( rectype , size , data ) ; break ; case SeriesRecord . sid : retval = new SeriesRecord ( rectype , size , data ) ; break ; case BeginRecord . sid : retval = new BeginRecord ( rectype , size , data ) ; break ; case EndRecord . sid : retval = new EndRecord ( rectype , size , data ) ; break ; case BOFRecord . sid : retval = new BOFRecord ( rectype , size , data ) ; break ; case InterfaceHdrRecord . sid : retval = new InterfaceHdrRecord ( rectype , size , data ) ; break ; case MMSRecord . sid : retval = new MMSRecord ( rectype , size , data ) ; break ; case InterfaceEndRecord . sid : retval = new InterfaceEndRecord ( rectype , size , data ) ; break ; case WriteAccessRecord . sid : retval = new WriteAccessRecord ( rectype , size , data ) ; break ; case CodepageRecord . sid : retval = new CodepageRecord ( rectype , size , data ) ; break ; case DSFRecord . sid : retval = new DSFRecord ( rectype , size , data ) ; break ; case TabIdRecord . sid : retval = new TabIdRecord ( rectype , size , data ) ; break ; case FnGroupCountRecord . sid : retval = new FnGroupCountRecord ( rectype , size , data ) ; break ; case WindowProtectRecord . sid : retval = new WindowProtectRecord ( rectype , size , data ) ; break ; case ProtectRecord . sid : retval = new ProtectRecord ( rectype , size , data ) ; break ; case PasswordRecord . sid : retval = new PasswordRecord ( rectype , size , data ) ; break ; case ProtectionRev4Record . sid : retval = new ProtectionRev4Record ( rectype , size , data ) ; break ; case PasswordRev4Record . sid : retval = new PasswordRev4Record ( rectype , size , data ) ; break ; case WindowOneRecord . sid : retval = new WindowOneRecord ( rectype , size , data ) ; break ; case BackupRecord . sid : retval = new BackupRecord ( rectype , size , data ) ; break ; case HideObjRecord . sid : retval = new HideObjRecord ( rectype , size , data ) ; break ; case DateWindow1904Record . sid : retval = new DateWindow1904Record ( rectype , size , data ) ; break ; case PrecisionRecord . sid : retval = new PrecisionRecord ( rectype , size , data ) ; break ; case RefreshAllRecord . sid : retval = new RefreshAllRecord ( rectype , size , data ) ; break ; case BookBoolRecord . sid : retval = new BookBoolRecord ( rectype , size , data ) ; break ; case FontRecord . sid : retval = new FontRecord ( rectype , size , data ) ; break ; case FormatRecord . sid : retval = new FormatRecord ( rectype , size , data ) ; break ; case ExtendedFormatRecord . sid : retval = new ExtendedFormatRecord ( rectype , size , data ) ; break ; case StyleRecord . sid : retval = new StyleRecord ( rectype , size , data ) ; break ; case UseSelFSRecord . sid : retval = new UseSelFSRecord ( rectype , size , data ) ; break ; case BoundSheetRecord . sid : retval = new BoundSheetRecord ( rectype , size , data ) ; break ; case CountryRecord . sid : retval = new CountryRecord ( rectype , size , data ) ; break ; case SSTRecord . sid : retval = new SSTRecord ( rectype , size , data ) ; break ; case ExtSSTRecord . sid : retval = new ExtSSTRecord ( rectype , size , data ) ; break ; case EOFRecord . sid : retval = new EOFRecord ( rectype , size , data ) ; break ; case IndexRecord . sid : retval = new IndexRecord ( rectype , size , data ) ; break ; case CalcModeRecord . sid : retval = new CalcModeRecord ( rectype , size , data ) ; break ; case CalcCountRecord . sid : retval = new CalcCountRecord ( rectype , size , data ) ; break ; case RefModeRecord . sid : retval = new RefModeRecord ( rectype , size , data ) ; break ; case IterationRecord . sid : retval = new IterationRecord ( rectype , size , data ) ; break ; case DeltaRecord . sid : retval = new DeltaRecord ( rectype , size , data ) ; break ; case SaveRecalcRecord . sid : retval = new SaveRecalcRecord ( rectype , size , data ) ; break ; case PrintHeadersRecord . sid : retval = new PrintHeadersRecord ( rectype , size , data ) ; break ; case PrintGridlinesRecord . sid : retval = new PrintGridlinesRecord ( rectype , size , data ) ; break ; case GridsetRecord . sid : retval = new GridsetRecord ( rectype , size , data ) ; break ; case GutsRecord . sid : retval = new GutsRecord ( rectype , size , data ) ; break ; case DefaultRowHeightRecord . sid : retval = new DefaultRowHeightRecord ( rectype , size , data ) ; break ; case WSBoolRecord . sid : retval = new WSBoolRecord ( rectype , size , data ) ; break ; case HeaderRecord . sid : retval = new HeaderRecord ( rectype , size , data ) ; break ; case FooterRecord . sid : retval = new FooterRecord ( rectype , size , data ) ; break ; case HCenterRecord . sid : retval = new HCenterRecord ( rectype , size , data ) ; break ; case VCenterRecord . sid : retval = new VCenterRecord ( rectype , size , data ) ; break ; case PrintSetupRecord . sid : retval = new PrintSetupRecord ( rectype , size , data ) ; break ; case DefaultColWidthRecord . sid : retval = new DefaultColWidthRecord ( rectype , size , data ) ; break ; case DimensionsRecord . sid : retval = new DimensionsRecord ( rectype , size , data ) ; break ; case RowRecord . sid : retval = new RowRecord ( rectype , size , data ) ; break ; case LabelSSTRecord . sid : retval = new LabelSSTRecord ( rectype , size , data ) ; break ; case RKRecord . sid : retval = new RKRecord ( rectype , size , data ) ; break ; case NumberRecord . sid : retval = new NumberRecord ( rectype , size , data ) ; break ; case DBCellRecord . sid : retval = new DBCellRecord ( rectype , size , data ) ; break ; case WindowTwoRecord . sid : retval = new WindowTwoRecord ( rectype , size , data ) ; break ; case SelectionRecord . sid : retval = new SelectionRecord ( rectype , size , data ) ; break ; case ContinueRecord . sid : retval = new ContinueRecord ( rectype , size , data ) ; break ; case LabelRecord . sid : retval = new LabelRecord ( rectype , size , data ) ; break ; case MulRKRecord . sid : retval = new MulRKRecord ( rectype , size , data ) ; break ; case MulBlankRecord . sid : retval = new MulBlankRecord ( rectype , size , data ) ; break ; case BlankRecord . sid : retval = new BlankRecord ( rectype , size , data ) ; break ; case BoolErrRecord . sid : retval = new BoolErrRecord ( rectype , size , data ) ; break ; case ColumnInfoRecord . sid : retval = new ColumnInfoRecord ( rectype , size , data ) ; break ; case MergeCellsRecord . sid : retval = new MergeCellsRecord ( rectype , size , data ) ; break ; case AreaRecord . sid : retval = new AreaRecord ( rectype , size , data ) ; break ; case DataFormatRecord . sid : retval = new DataFormatRecord ( rectype , size , data ) ; break ; case BarRecord . sid : retval = new BarRecord ( rectype , size , data ) ; break ; case DatRecord . sid : retval = new DatRecord ( rectype , size , data ) ; break ; case PlotGrowthRecord . sid : retval = new PlotGrowthRecord ( rectype , size , data ) ; break ; case UnitsRecord . sid : retval = new UnitsRecord ( rectype , size , data ) ; break ; case FrameRecord . sid : retval = new FrameRecord ( rectype , size , data ) ; break ; case ValueRangeRecord . sid : retval = new ValueRangeRecord ( rectype , size , data ) ; break ; case SeriesListRecord . sid : retval = new SeriesListRecord ( rectype , size , data ) ; break ; case FontBasisRecord . sid : retval = new FontBasisRecord ( rectype , size , data ) ; break ; case FontIndexRecord . sid : retval = new FontIndexRecord ( rectype , size , data ) ; break ; case LineFormatRecord . sid : retval = new LineFormatRecord ( rectype , size , data ) ; break ; case AreaFormatRecord . sid : retval = new AreaFormatRecord ( rectype , size , data ) ; break ; case LinkedDataRecord . sid : retval = new LinkedDataRecord ( rectype , size , data ) ; break ; case FormulaRecord . sid : retval = new FormulaRecord ( rectype , size , data ) ; break ; case SheetPropertiesRecord . sid : retval = new SheetPropertiesRecord ( rectype , size , data ) ; break ; case DefaultDataLabelTextPropertiesRecord . sid : retval = new DefaultDataLabelTextPropertiesRecord ( rectype , size , data ) ; break ; case TextRecord . sid : retval = new TextRecord ( rectype , size , data ) ; break ; case AxisParentRecord . sid : retval = new AxisParentRecord ( rectype , size , data ) ; break ; case AxisLineFormatRecord . sid : retval = new AxisLineFormatRecord ( rectype , size , data ) ; break ; case SupBookRecord . sid : retval = new SupBookRecord ( rectype , size , data ) ; break ; case ExternSheetRecord . sid : retval = new ExternSheetRecord ( rectype , size , data ) ; break ; case SCLRecord . sid : retval = new SCLRecord ( rectype , size , data ) ; break ; case SeriesToChartGroupRecord . sid : retval = new SeriesToChartGroupRecord ( rectype , size , data ) ; break ; case AxisUsedRecord . sid : retval = new AxisUsedRecord ( rectype , size , data ) ; break ; case AxisRecord . sid : retval = new AxisRecord ( rectype , size , data ) ; break ; case CategorySeriesAxisRecord . sid : retval = new CategorySeriesAxisRecord ( rectype , size , data ) ; break ; case AxisOptionsRecord . sid : retval = new AxisOptionsRecord ( rectype , size , data ) ; break ; case TickRecord . sid : retval = new TickRecord ( rectype , size , data ) ; break ; case SeriesTextRecord . sid : retval = new SeriesTextRecord ( rectype , size , data ) ; break ; case ObjectLinkRecord . sid : retval = new ObjectLinkRecord ( rectype , size , data ) ; break ; case PlotAreaRecord . sid : retval = new PlotAreaRecord ( rectype , size , data ) ; break ; case SeriesIndexRecord . sid : retval = new SeriesIndexRecord ( rectype , size , data ) ; break ; case LegendRecord . sid : retval = new LegendRecord ( rectype , size , data ) ; break ; case LeftMarginRecord . sid : retval = new LeftMarginRecord ( rectype , size , data ) ; break ; case RightMarginRecord . sid : retval = new RightMarginRecord ( rectype , size , data ) ; break ; case TopMarginRecord . sid : retval = new TopMarginRecord ( rectype , size , data ) ; break ; case BottomMarginRecord . sid : retval = new BottomMarginRecord ( rectype , size , data ) ; break ; case PaletteRecord . sid : retval = new PaletteRecord ( rectype , size , data ) ; break ; case StringRecord . sid : retval = new StringRecord ( rectype , size , data ) ; break ; case NameRecord . sid : retval = new NameRecord ( rectype , size , data ) ; break ; case PaneRecord . sid : retval = new PaneRecord ( rectype , size , data ) ; break ; case SharedFormulaRecord . sid : retval = new SharedFormulaRecord ( rectype , size , data ) ; break ; default : retval = new UnknownRecord ( rectype , size , data ) ; } if ( realretval == null ) { realretval = new Record [ 1 ] ; realretval [ 0 ] = retval ; System . out . println ( "recordid = 0x" + Integer . toHexString ( rectype ) + ", size =" + size ) ; System . out . println ( realretval [ 0 ] . toString ( ) ) ; } return realretval ; } public void setDump ( boolean dump ) { this . dump = dump ; } public static void main ( String [ ] args ) { try { BiffViewer viewer = new BiffViewer ( args ) ; if ( ( args . length > 1 ) && args [ 1 ] . equals ( "on" ) ) { viewer . setDump ( true ) ; } if ( ( args . length > 1 ) && args [ 1 ] . equals ( "bfd" ) ) { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( args [ 0 ] ) ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; int size = stream . available ( ) ; byte [ ] data = new byte [ size ] ; stream . read ( data ) ; HexDump . dump ( data , 0 , System . out , 0 ) ; } else { viewer . run ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	0
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; public class SmallDocumentBlock implements BlockWritable , ListManagedBlock { private byte [ ] _data ; private static final byte _default_fill = ( byte ) 0xff ; private static final int _block_size = 64 ; private static final int _blocks_per_big_block = POIFSConstants . BIG_BLOCK_SIZE / _block_size ; private SmallDocumentBlock ( final byte [ ] data , final int index ) { this ( ) ; System . arraycopy ( data , index * _block_size , _data , 0 , _block_size ) ; } private SmallDocumentBlock ( ) { _data = new byte [ _block_size ] ; } public static SmallDocumentBlock [ ] convert ( final byte [ ] array , final int size ) { SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ ( size + _block_size - 1 ) / _block_size ] ; int offset = 0 ; for ( int k = 0 ; k < rval . length ; k ++ ) { rval [ k ] = new SmallDocumentBlock ( ) ; if ( offset < array . length ) { int length = Math . min ( _block_size , array . length - offset ) ; System . arraycopy ( array , offset , rval [ k ] . _data , 0 , length ) ; if ( length != _block_size ) { Arrays . fill ( rval [ k ] . _data , length , _block_size , _default_fill ) ; } } else { Arrays . fill ( rval [ k ] . _data , _default_fill ) ; } offset += _block_size ; } return rval ; } public static int fill ( final List blocks ) { int count = blocks . size ( ) ; int big_block_count = ( count + _blocks_per_big_block - 1 ) / _blocks_per_big_block ; int full_count = big_block_count * _blocks_per_big_block ; for ( ; count < full_count ; count ++ ) { blocks . add ( makeEmptySmallDocumentBlock ( ) ) ; } return big_block_count ; } public static SmallDocumentBlock [ ] convert ( final BlockWritable [ ] store , final int size ) throws IOException , ArrayIndexOutOfBoundsException { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; for ( int j = 0 ; j < store . length ; j ++ ) { store [ j ] . writeBlocks ( stream ) ; } byte [ ] data = stream . toByteArray ( ) ; SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ convertToBlockCount ( size ) ] ; for ( int index = 0 ; index < rval . length ; index ++ ) { rval [ index ] = new SmallDocumentBlock ( data , index ) ; } return rval ; } public static List extract ( ListManagedBlock [ ] blocks ) throws IOException { List sdbs = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; for ( int k = 0 ; k < _blocks_per_big_block ; k ++ ) { sdbs . add ( new SmallDocumentBlock ( data , k ) ) ; } } return sdbs ; } public static void read ( final BlockWritable [ ] blocks , final byte [ ] buffer , final int offset ) { int firstBlockIndex = offset / _block_size ; int firstBlockOffset = offset % _block_size ; int lastBlockIndex = ( offset + buffer . length - 1 ) / _block_size ; if ( firstBlockIndex == lastBlockIndex ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , 0 , buffer . length ) ; } else { int buffer_offset = 0 ; System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , buffer_offset , _block_size - firstBlockOffset ) ; buffer_offset += _block_size - firstBlockOffset ; for ( int j = firstBlockIndex + 1 ; j < lastBlockIndex ; j ++ ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ j ] ) . _data , 0 , buffer , buffer_offset , _block_size ) ; buffer_offset += _block_size ; } System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ lastBlockIndex ] ) . _data , 0 , buffer , buffer_offset , buffer . length - buffer_offset ) ; } } public static int calcSize ( int size ) { return size * _block_size ; } private static SmallDocumentBlock makeEmptySmallDocumentBlock ( ) { SmallDocumentBlock block = new SmallDocumentBlock ( ) ; Arrays . fill ( block . _data , _default_fill ) ; return block ; } private static int convertToBlockCount ( final int size ) { return ( size + _block_size - 1 ) / _block_size ; } public void writeBlocks ( final OutputStream stream ) throws IOException { stream . write ( _data ) ; } public byte [ ] getData ( ) throws IOException { return _data ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; public class RawDataBlockList extends BlockListImpl { public RawDataBlockList ( final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; while ( true ) { RawDataBlock block = new RawDataBlock ( stream ) ; if ( block . eof ( ) ) { break ; } blocks . add ( block ) ; } setBlocks ( ( RawDataBlock [ ] ) blocks . toArray ( new RawDataBlock [ 0 ] ) ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1
package org . apache . poi . hssf . eventmodel ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . poi . hssf . model . Model ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BOFRecord ; import org . apache . poi . hssf . record . EOFRecord ; import org . apache . poi . hssf . record . Record ; public class ModelFactory implements ERFListener { List listeners ; Model currentmodel ; boolean lastEOF ; public ModelFactory ( ) { super ( ) ; listeners = new ArrayList ( 1 ) ; } public void registerListener ( ModelFactoryListener listener ) { listeners . add ( listener ) ; } public void run ( InputStream stream ) { EventRecordFactory factory = new EventRecordFactory ( true ) ; factory . registerListener ( this , null ) ; lastEOF = true ; factory . processRecords ( stream ) ; } public boolean processRecord ( Record rec ) { if ( rec . getSid ( ) == BOFRecord . sid ) { if ( lastEOF != true ) { throw new RuntimeException ( "Not yet handled embedded models" ) ; } else { BOFRecord bof = ( BOFRecord ) rec ; switch ( bof . getType ( ) ) { case BOFRecord . TYPE_WORKBOOK : currentmodel = new Workbook ( ) ; break ; case BOFRecord . TYPE_WORKSHEET : currentmodel = new Sheet ( ) ; break ; default : throw new RuntimeException ( "Unsupported model type " + bof . getType ( ) ) ; } } } if ( rec . getSid ( ) == EOFRecord . sid ) { lastEOF = true ; throwEvent ( currentmodel ) ; } else { lastEOF = false ; } return true ; } private void throwEvent ( Model model ) { Iterator i = listeners . iterator ( ) ; while ( i . hasNext ( ) ) { ModelFactoryListener mfl = ( ModelFactoryListener ) i . next ( ) ; mfl . process ( model ) ; } } } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; public class POIFSViewer { public static void main ( final String args [ ] ) { if ( args . length < 0 ) { System . err . println ( "Must specify at least one file to view" ) ; System . exit ( 1 ) ; } boolean printNames = ( args . length > 1 ) ; for ( int j = 0 ; j < args . length ; j ++ ) { viewFile ( args [ j ] , printNames ) ; } } private static void viewFile ( final String filename , final boolean printName ) { if ( printName ) { StringBuffer flowerbox = new StringBuffer ( ) ; flowerbox . append ( "." ) ; for ( int j = 0 ; j < filename . length ( ) ; j ++ ) { flowerbox . append ( "-" ) ; } flowerbox . append ( "." ) ; System . out . println ( flowerbox ) ; System . out . println ( "|" + filename + "|" ) ; System . out . println ( flowerbox ) ; } try { POIFSViewable fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; List strings = POIFSViewEngine . inspectViewable ( fs , true , 0 , "  " ) ; Iterator iter = strings . iterator ( ) ; while ( iter . hasNext ( ) ) { System . out . print ( iter . next ( ) ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } } 	0
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CalcModeRecord extends Record { public final static short sid = 0xD ; public final static short MANUAL = 0 ; public final static short AUTOMATIC = 1 ; public final static short AUTOMATIC_EXCEPT_TABLES = - 1 ; private short field_1_calcmode ; public CalcModeRecord ( ) { } public CalcModeRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CalcModeRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Calc Mode RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_calcmode = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCalcMode ( short calcmode ) { field_1_calcmode = calcmode ; } public short getCalcMode ( ) { return field_1_calcmode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CALCMODE]\n" ) ; buffer . append ( "    .calcmode       = " ) . append ( Integer . toHexString ( getCalcMode ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CALCMODE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , getCalcMode ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { CalcModeRecord rec = new CalcModeRecord ( ) ; rec . field_1_calcmode = field_1_calcmode ; return rec ; } } 	0
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BeginRecord extends Record { public static final short sid = 0x1033 ; public BeginRecord ( ) { } public BeginRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BeginRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BEGIN RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BEGIN]\n" ) ; buffer . append ( "[/BEGIN]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1
package org . apache . poi . poifs . eventfilesystem ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; public class POIFSReaderEvent { private DocumentInputStream stream ; private POIFSDocumentPath path ; private String documentName ; POIFSReaderEvent ( final DocumentInputStream stream , final POIFSDocumentPath path , final String documentName ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; } public DocumentInputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SeriesTextRecord extends Record { public final static short sid = 0x100d ; private short field_1_id ; private byte field_2_textLength ; private byte field_3_undocumented ; private String field_4_text ; public SeriesTextRecord ( ) { } public SeriesTextRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesTextRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesText record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_id = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_textLength = data [ pos + 0x2 + offset ] ; field_3_undocumented = data [ pos + 0x3 + offset ] ; field_4_text = StringUtil . getFromUnicodeHigh ( data , pos + 0x4 + offset , ( ( field_2_textLength * 2 ) / 2 ) ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SERIESTEXT]\n" ) ; buffer . append ( "    .id                   = " ) . append ( "0x" ) . append ( HexDump . toHex ( getId ( ) ) ) . append ( " (" ) . append ( getId ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .textLength           = " ) . append ( "0x" ) . append ( HexDump . toHex ( getTextLength ( ) ) ) . append ( " (" ) . append ( getTextLength ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .undocumented         = " ) . append ( "0x" ) . append ( HexDump . toHex ( getUndocumented ( ) ) ) . append ( " (" ) . append ( getUndocumented ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .text                 = " ) . append ( " (" ) . append ( getText ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SERIESTEXT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_id ) ; data [ 6 + offset + pos ] = field_2_textLength ; data [ 7 + offset + pos ] = field_3_undocumented ; StringUtil . putUncompressedUnicodeHigh ( field_4_text , data , 8 + offset + pos ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 1 + 1 + ( field_2_textLength * 2 ) ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SeriesTextRecord rec = new SeriesTextRecord ( ) ; rec . field_1_id = field_1_id ; rec . field_2_textLength = field_2_textLength ; rec . field_3_undocumented = field_3_undocumented ; rec . field_4_text = field_4_text ; return rec ; } public short getId ( ) { return field_1_id ; } public void setId ( short field_1_id ) { this . field_1_id = field_1_id ; } public byte getTextLength ( ) { return field_2_textLength ; } public void setTextLength ( byte field_2_textLength ) { this . field_2_textLength = field_2_textLength ; } public byte getUndocumented ( ) { return field_3_undocumented ; } public void setUndocumented ( byte field_3_undocumented ) { this . field_3_undocumented = field_3_undocumented ; } public String getText ( ) { return field_4_text ; } public void setText ( String field_4_text ) { this . field_4_text = field_4_text ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; public class MemFuncPtg extends ControlPtg { public final static byte sid = 0x29 ; private short field_1_len_ref_subexpression = 0 ; public MemFuncPtg ( ) { } public MemFuncPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_len_ref_subexpression = LittleEndian . getShort ( data , offset + 0 ) ; } public int getSize ( ) { return 3 ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; LittleEndian . putShort ( array , offset + 1 , ( short ) field_1_len_ref_subexpression ) ; } public String toFormulaString ( Workbook book ) { return "" ; } public byte getDefaultOperandClass ( ) { return 0 ; } public int getNumberOfOperands ( ) { return field_1_len_ref_subexpression ; } public Object clone ( ) { MemFuncPtg ptg = new MemFuncPtg ( ) ; ptg . field_1_len_ref_subexpression = this . field_1_len_ref_subexpression ; return ptg ; } public int getLenRefSubexpression ( ) { return field_1_len_ref_subexpression ; } public void setLenRefSubexpression ( int len ) { field_1_len_ref_subexpression = ( short ) len ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . PaletteRecord ; import org . apache . poi . hssf . util . HSSFColor ; public class HSSFPalette { private PaletteRecord palette ; protected HSSFPalette ( PaletteRecord palette ) { this . palette = palette ; } public HSSFColor getColor ( short index ) { byte [ ] b = palette . getColor ( index ) ; if ( b != null ) { return new CustomColor ( index , b ) ; } return null ; } public HSSFColor findColor ( byte red , byte green , byte blue ) { byte [ ] b = palette . getColor ( PaletteRecord . FIRST_COLOR_INDEX ) ; for ( short i = ( short ) PaletteRecord . FIRST_COLOR_INDEX ; b != null ; b = palette . getColor ( ++ i ) ) { if ( b [ 0 ] == red && b [ 1 ] == green && b [ 2 ] == blue ) { return new CustomColor ( i , b ) ; } } return null ; } public void setColorAtIndex ( short index , byte red , byte green , byte blue ) { palette . setColor ( index , red , green , blue ) ; } private static class CustomColor extends HSSFColor { private short byteOffset ; private byte red ; private byte green ; private byte blue ; private CustomColor ( short byteOffset , byte [ ] colors ) { this ( byteOffset , colors [ 0 ] , colors [ 1 ] , colors [ 2 ] ) ; } private CustomColor ( short byteOffset , byte red , byte green , byte blue ) { this . byteOffset = byteOffset ; this . red = red ; this . green = green ; this . blue = blue ; } public short getIndex ( ) { return byteOffset ; } public short [ ] getTriplet ( ) { return new short [ ] { ( short ) ( red & 0xff ) , ( short ) ( green & 0xff ) , ( short ) ( blue & 0xff ) } ; } public String getHexString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( getGnumericPart ( red ) ) ; sb . append ( ':' ) ; sb . append ( getGnumericPart ( green ) ) ; sb . append ( ':' ) ; sb . append ( getGnumericPart ( blue ) ) ; return sb . toString ( ) ; } private String getGnumericPart ( byte color ) { String s ; if ( color == 0 ) { s = "0" ; } else { int c = color & 0xff ; c = ( c << 8 ) | c ; s = Integer . toHexString ( c ) . toUpperCase ( ) ; while ( s . length ( ) < 4 ) { s = "0" + s ; } } return s ; } } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . PropertyBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . RawDataBlockList ; public class PropertyTable implements BATManaged , BlockWritable { private int _start_block ; private List _properties ; private BlockWritable [ ] _blocks ; public PropertyTable ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _properties = new ArrayList ( ) ; addProperty ( new RootProperty ( ) ) ; _blocks = null ; } public PropertyTable ( final int startBlock , final RawDataBlockList blockList ) throws IOException { _start_block = POIFSConstants . END_OF_CHAIN ; _blocks = null ; _properties = PropertyFactory . convertToProperties ( blockList . fetchBlocks ( startBlock ) ) ; populatePropertyTree ( ( DirectoryProperty ) _properties . get ( 0 ) ) ; } public void addProperty ( final Property property ) { _properties . add ( property ) ; } public void removeProperty ( final Property property ) { _properties . remove ( property ) ; } public RootProperty getRoot ( ) { return ( RootProperty ) _properties . get ( 0 ) ; } public void preWrite ( ) { Property [ ] properties = ( Property [ ] ) _properties . toArray ( new Property [ 0 ] ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . setIndex ( k ) ; } _blocks = PropertyBlock . createPropertyBlockArray ( _properties ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . preWrite ( ) ; } } public int getStartBlock ( ) { return _start_block ; } private void populatePropertyTree ( DirectoryProperty root ) throws IOException { int index = root . getChildIndex ( ) ; if ( ! Property . isValidIndex ( index ) ) { return ; } Stack children = new Stack ( ) ; children . push ( _properties . get ( index ) ) ; while ( ! children . empty ( ) ) { Property property = ( Property ) children . pop ( ) ; root . addChild ( property ) ; if ( property . isDirectory ( ) ) { populatePropertyTree ( ( DirectoryProperty ) property ) ; } index = property . getPreviousChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } index = property . getNextChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } } } public int countBlocks ( ) { return ( _blocks == null ) ? 0 : _blocks . length ; } public void setStartBlock ( final int index ) { _start_block = index ; } public void writeBlocks ( final OutputStream stream ) throws IOException { if ( _blocks != null ) { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BookBoolRecord extends Record { public final static short sid = 0xDA ; private short field_1_save_link_values ; public BookBoolRecord ( ) { } public BookBoolRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BookBoolRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOOKBOOL RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_save_link_values = LittleEndian . getShort ( data , 0 + offset ) ; } public void setSaveLinkValues ( short flag ) { field_1_save_link_values = flag ; } public short getSaveLinkValues ( ) { return field_1_save_link_values ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOOKBOOL]\n" ) ; buffer . append ( "    .savelinkvalues  = " ) . append ( Integer . toHexString ( getSaveLinkValues ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOOKBOOL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_save_link_values ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; public interface DirectoryEntry extends Entry { public Iterator getEntries ( ) ; public boolean isEmpty ( ) ; public int getEntryCount ( ) ; public Entry getEntry ( final String name ) throws FileNotFoundException ; public DocumentEntry createDocument ( final String name , final InputStream stream ) throws IOException ; public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException ; public DirectoryEntry createDirectory ( final String name ) throws IOException ; public ClassID getStorageClsid ( ) ; public void setStorageClsid ( ClassID clsidStorage ) ; } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; public class HSSFCellStyle { private ExtendedFormatRecord format = null ; private short index = 0 ; private short fontindex = 0 ; public final static short ALIGN_GENERAL = 0x0 ; public final static short ALIGN_LEFT = 0x1 ; public final static short ALIGN_CENTER = 0x2 ; public final static short ALIGN_RIGHT = 0x3 ; public final static short ALIGN_FILL = 0x4 ; public final static short ALIGN_JUSTIFY = 0x5 ; public final static short ALIGN_CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short BORDER_NONE = 0x0 ; public final static short BORDER_THIN = 0x1 ; public final static short BORDER_MEDIUM = 0x2 ; public final static short BORDER_DASHED = 0x3 ; public final static short BORDER_HAIR = 0x4 ; public final static short BORDER_THICK = 0x5 ; public final static short BORDER_DOUBLE = 0x6 ; public final static short BORDER_DOTTED = 0x7 ; public final static short BORDER_MEDIUM_DASHED = 0x8 ; public final static short BORDER_DASH_DOT = 0x9 ; public final static short BORDER_MEDIUM_DASH_DOT = 0xA ; public final static short BORDER_DASH_DOT_DOT = 0xB ; public final static short BORDER_MEDIUM_DASH_DOT_DOT = 0xC ; public final static short BORDER_SLANTED_DASH_DOT = 0xD ; public final static short NO_FILL = 0 ; public final static short SOLID_FOREGROUND = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; protected HSSFCellStyle ( short index , ExtendedFormatRecord rec ) { this . index = index ; format = rec ; } public short getIndex ( ) { return index ; } public void setDataFormat ( short fmt ) { format . setFormatIndex ( fmt ) ; } public short getDataFormat ( ) { return format . getFormatIndex ( ) ; } public void setFont ( HSSFFont font ) { format . setIndentNotParentFont ( true ) ; fontindex = font . getIndex ( ) ; format . setFontIndex ( fontindex ) ; } public short getFontIndex ( ) { return format . getFontIndex ( ) ; } public void setHidden ( boolean hidden ) { format . setIndentNotParentCellOptions ( true ) ; format . setHidden ( hidden ) ; } public boolean getHidden ( ) { return format . isHidden ( ) ; } public void setLocked ( boolean locked ) { format . setIndentNotParentCellOptions ( true ) ; format . setLocked ( locked ) ; } public boolean getLocked ( ) { return format . isLocked ( ) ; } public void setAlignment ( short align ) { format . setIndentNotParentAlignment ( true ) ; format . setAlignment ( align ) ; } public short getAlignment ( ) { return format . getAlignment ( ) ; } public void setWrapText ( boolean wrapped ) { format . setIndentNotParentAlignment ( true ) ; format . setWrapText ( wrapped ) ; } public boolean getWrapText ( ) { return format . getWrapText ( ) ; } public void setVerticalAlignment ( short align ) { format . setVerticalAlignment ( align ) ; } public short getVerticalAlignment ( ) { return format . getVerticalAlignment ( ) ; } public void setRotation ( short rotation ) { if ( ( rotation < 0 ) && ( rotation >= - 90 ) ) { rotation = ( short ) ( 90 - rotation ) ; } else if ( ( rotation < - 90 ) || ( rotation > 90 ) ) throw new IllegalArgumentException ( "The rotation must be between -90 and 90 degrees" ) ; format . setRotation ( rotation ) ; } public short getRotation ( ) { short rotation = format . getRotation ( ) ; if ( rotation > 90 ) rotation = ( short ) ( 90 - rotation ) ; return rotation ; } public void setIndention ( short indent ) { format . setIndent ( indent ) ; } public short getIndention ( ) { return format . getIndent ( ) ; } public void setBorderLeft ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderLeft ( border ) ; } public short getBorderLeft ( ) { return format . getBorderLeft ( ) ; } public void setBorderRight ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderRight ( border ) ; } public short getBorderRight ( ) { return format . getBorderRight ( ) ; } public void setBorderTop ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderTop ( border ) ; } public short getBorderTop ( ) { return format . getBorderTop ( ) ; } public void setBorderBottom ( short border ) { format . setIndentNotParentBorder ( true ) ; format . setBorderBottom ( border ) ; } public short getBorderBottom ( ) { return format . getBorderBottom ( ) ; } public void setLeftBorderColor ( short color ) { format . setLeftBorderPaletteIdx ( color ) ; } public short getLeftBorderColor ( ) { return format . getLeftBorderPaletteIdx ( ) ; } public void setRightBorderColor ( short color ) { format . setRightBorderPaletteIdx ( color ) ; } public short getRightBorderColor ( ) { return format . getRightBorderPaletteIdx ( ) ; } public void setTopBorderColor ( short color ) { format . setTopBorderPaletteIdx ( color ) ; } public short getTopBorderColor ( ) { return format . getTopBorderPaletteIdx ( ) ; } public void setBottomBorderColor ( short color ) { format . setBottomBorderPaletteIdx ( color ) ; } public short getBottomBorderColor ( ) { return format . getBottomBorderPaletteIdx ( ) ; } public void setFillPattern ( short fp ) { format . setAdtlFillPattern ( fp ) ; } public short getFillPattern ( ) { return format . getAdtlFillPattern ( ) ; } public void setFillBackgroundColor ( short bg ) { format . setFillBackground ( bg ) ; } public short getFillBackgroundColor ( ) { return format . getFillBackground ( ) ; } public void setFillForegroundColor ( short bg ) { format . setFillForeground ( bg ) ; } public short getFillForegroundColor ( ) { return format . getFillForeground ( ) ; } } 	0
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class SupBookRecord extends Record { public final static short sid = 0x1AE ; private short field_1_number_of_sheets ; private short field_2_flag ; public SupBookRecord ( ) { setFlag ( ( short ) 0x401 ) ; } public SupBookRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SupBookRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Supbook RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_number_of_sheets = LittleEndian . getShort ( data , offset + 0 ) ; field_2_flag = LittleEndian . getShort ( data , offset + 2 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SUPBOOK]\n" ) ; buffer . append ( "numberosheets = " ) . append ( getNumberOfSheets ( ) ) . append ( '\n' ) ; buffer . append ( "flag          = " ) . append ( getFlag ( ) ) . append ( '\n' ) ; buffer . append ( "[/SUPBOOK]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 4 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_number_of_sheets ) ; LittleEndian . putShort ( data , 6 + offset , field_2_flag ) ; return getRecordSize ( ) ; } public void setNumberOfSheets ( short number ) { field_1_number_of_sheets = number ; } public short getNumberOfSheets ( ) { return field_1_number_of_sheets ; } public void setFlag ( short flag ) { field_2_flag = flag ; } public short getFlag ( ) { return field_2_flag ; } public int getRecordSize ( ) { return 4 + 4 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; public class BoolPtg extends Ptg { public final static int SIZE = 2 ; public final static byte sid = 0x1d ; private boolean field_1_value ; private String val ; private BoolPtg ( ) { } public BoolPtg ( byte [ ] data , int offset ) { field_1_value = ( data [ offset + 1 ] == 1 ) ; } public BoolPtg ( String formulaToken ) { field_1_value = ( formulaToken . equals ( "TRUE" ) ) ; } public void setValue ( boolean value ) { field_1_value = value ; } public boolean getValue ( ) { return field_1_value ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; array [ offset + 1 ] = ( byte ) ( field_1_value ? 1 : 0 ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return field_1_value ? "TRUE" : "FALSE" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { BoolPtg ptg = new BoolPtg ( ) ; ptg . field_1_value = field_1_value ; return ptg ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DSFRecord extends Record { public final static short sid = 0x161 ; private short field_1_dsf ; public DSFRecord ( ) { } public DSFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DSFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A DSF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_dsf = LittleEndian . getShort ( data , 0 + offset ) ; } public void setDsf ( short dsfflag ) { field_1_dsf = dsfflag ; } public short getDsf ( ) { return field_1_dsf ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DSF]\n" ) ; buffer . append ( "    .isDSF           = " ) . append ( Integer . toHexString ( getDsf ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/DSF]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getDsf ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; public class MissingArgPtg extends Ptg { private final static int SIZE = 1 ; public final static byte sid = 0x16 ; public MissingArgPtg ( ) { } public MissingArgPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return " " ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new MissingArgPtg ( ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class LineFormatRecord extends Record { public final static short sid = 0x1007 ; private int field_1_lineColor ; private short field_2_linePattern ; public final static short LINE_PATTERN_SOLID = 0 ; public final static short LINE_PATTERN_DASH = 1 ; public final static short LINE_PATTERN_DOT = 2 ; public final static short LINE_PATTERN_DASH_DOT = 3 ; public final static short LINE_PATTERN_DASH_DOT_DOT = 4 ; public final static short LINE_PATTERN_NONE = 5 ; public final static short LINE_PATTERN_DARK_GRAY_PATTERN = 6 ; public final static short LINE_PATTERN_MEDIUM_GRAY_PATTERN = 7 ; public final static short LINE_PATTERN_LIGHT_GRAY_PATTERN = 8 ; private short field_3_weight ; public final static short WEIGHT_HAIRLINE = - 1 ; public final static short WEIGHT_NARROW = 0 ; public final static short WEIGHT_MEDIUM = 1 ; public final static short WEIGHT_WIDE = 2 ; private short field_4_format ; private BitField auto = new BitField ( 0x1 ) ; private BitField drawTicks = new BitField ( 0x4 ) ; private BitField unknown = new BitField ( 0x4 ) ; private short field_5_colourPaletteIndex ; public LineFormatRecord ( ) { } public LineFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LineFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a LineFormat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_lineColor = LittleEndian . getInt ( data , pos + 0x0 + offset ) ; field_2_linePattern = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; field_3_weight = LittleEndian . getShort ( data , pos + 0x6 + offset ) ; field_4_format = LittleEndian . getShort ( data , pos + 0x8 + offset ) ; field_5_colourPaletteIndex = LittleEndian . getShort ( data , pos + 0xa + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[LINEFORMAT]\n" ) ; buffer . append ( "    .lineColor            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLineColor ( ) ) ) . append ( " (" ) . append ( getLineColor ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .linePattern          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLinePattern ( ) ) ) . append ( " (" ) . append ( getLinePattern ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .weight               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getWeight ( ) ) ) . append ( " (" ) . append ( getWeight ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .format               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFormat ( ) ) ) . append ( " (" ) . append ( getFormat ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .auto                     = " ) . append ( isAuto ( ) ) . append ( '\n' ) ; buffer . append ( "         .drawTicks                = " ) . append ( isDrawTicks ( ) ) . append ( '\n' ) ; buffer . append ( "         .unknown                  = " ) . append ( isUnknown ( ) ) . append ( '\n' ) ; buffer . append ( "    .colourPaletteIndex   = " ) . append ( "0x" ) . append ( HexDump . toHex ( getColourPaletteIndex ( ) ) ) . append ( " (" ) . append ( getColourPaletteIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/LINEFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset + pos , field_1_lineColor ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_2_linePattern ) ; LittleEndian . putShort ( data , 10 + offset + pos , field_3_weight ) ; LittleEndian . putShort ( data , 12 + offset + pos , field_4_format ) ; LittleEndian . putShort ( data , 14 + offset + pos , field_5_colourPaletteIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { LineFormatRecord rec = new LineFormatRecord ( ) ; rec . field_1_lineColor = field_1_lineColor ; rec . field_2_linePattern = field_2_linePattern ; rec . field_3_weight = field_3_weight ; rec . field_4_format = field_4_format ; rec . field_5_colourPaletteIndex = field_5_colourPaletteIndex ; return rec ; } public int getLineColor ( ) { return field_1_lineColor ; } public void setLineColor ( int field_1_lineColor ) { this . field_1_lineColor = field_1_lineColor ; } public short getLinePattern ( ) { return field_2_linePattern ; } public void setLinePattern ( short field_2_linePattern ) { this . field_2_linePattern = field_2_linePattern ; } public short getWeight ( ) { return field_3_weight ; } public void setWeight ( short field_3_weight ) { this . field_3_weight = field_3_weight ; } public short getFormat ( ) { return field_4_format ; } public void setFormat ( short field_4_format ) { this . field_4_format = field_4_format ; } public short getColourPaletteIndex ( ) { return field_5_colourPaletteIndex ; } public void setColourPaletteIndex ( short field_5_colourPaletteIndex ) { this . field_5_colourPaletteIndex = field_5_colourPaletteIndex ; } public void setAuto ( boolean value ) { field_4_format = auto . setShortBoolean ( field_4_format , value ) ; } public boolean isAuto ( ) { return auto . isSet ( field_4_format ) ; } public void setDrawTicks ( boolean value ) { field_4_format = drawTicks . setShortBoolean ( field_4_format , value ) ; } public boolean isDrawTicks ( ) { return drawTicks . isSet ( field_4_format ) ; } public void setUnknown ( boolean value ) { field_4_format = unknown . setShortBoolean ( field_4_format , value ) ; } public boolean isUnknown ( ) { return unknown . isSet ( field_4_format ) ; } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RKUtil ; public class RKRecord extends Record implements CellValueRecordInterface { public final static short sid = 0x27e ; public final static short RK_IEEE_NUMBER = 0 ; public final static short RK_IEEE_NUMBER_TIMES_100 = 1 ; public final static short RK_INTEGER = 2 ; public final static short RK_INTEGER_TIMES_100 = 3 ; private int field_1_row ; private short field_2_col ; private short field_3_xf_index ; private int field_4_rk_number ; public RKRecord ( ) { } public RKRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RKRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid RK RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_rk_number = LittleEndian . getInt ( data , 6 + offset ) ; } public int getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_col ; } public short getXFIndex ( ) { return field_3_xf_index ; } public int getRKField ( ) { return field_4_rk_number ; } public short getRKType ( ) { return ( short ) ( field_4_rk_number & 3 ) ; } public double getRKNumber ( ) { return RKUtil . decodeNumber ( field_4_rk_number ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[RK]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .col            = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .rknumber       = " ) . append ( Integer . toHexString ( getRKField ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .rktype     = " ) . append ( Integer . toHexString ( getRKType ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .rknumber   = " ) . append ( getRKNumber ( ) ) . append ( "\n" ) ; buffer . append ( "[/RK]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { NumberRecord rec = new NumberRecord ( ) ; rec . setColumn ( getColumn ( ) ) ; rec . setRow ( getRow ( ) ) ; rec . setValue ( getRKNumber ( ) ) ; rec . setXFIndex ( getXFIndex ( ) ) ; return rec . serialize ( offset , data ) ; } public static void main ( String ignored_args [ ] ) { int [ ] values = { 0x3FF00000 , 0x405EC001 , 0x02F1853A , 0x02F1853B , 0xFCDD699A } ; double [ ] rvalues = { 1 , 1.23 , 12345678 , 123456.78 , - 13149594 } ; for ( int j = 0 ; j < values . length ; j ++ ) { System . out . println ( "input = " + Integer . toHexString ( values [ j ] ) + " -> " + rvalues [ j ] + ": " + RKUtil . decodeNumber ( values [ j ] ) ) ; } } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public void setColumn ( short col ) { } public void setRow ( int row ) { } public void setXFIndex ( short xf ) { } public Object clone ( ) { RKRecord rec = new RKRecord ( ) ; rec . field_1_row = field_1_row ; rec . field_2_col = field_2_col ; rec . field_3_xf_index = field_3_xf_index ; rec . field_4_rk_number = field_4_rk_number ; return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class NotEqualPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0e ; public NotEqualPtg ( ) { } public NotEqualPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "<>" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new NotEqualPtg ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IOUtils ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LongField ; import org . apache . poi . util . ShortField ; public class HeaderBlockReader implements HeaderBlockConstants { private IntegerField _bat_count ; private IntegerField _property_start ; private IntegerField _sbat_start ; private IntegerField _xbat_start ; private IntegerField _xbat_count ; private byte [ ] _data ; public HeaderBlockReader ( final InputStream stream ) throws IOException { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; int byte_count = IOUtils . readFully ( stream , _data ) ; if ( byte_count != POIFSConstants . BIG_BLOCK_SIZE ) { String type = " byte" + ( ( byte_count == 1 ) ? ( "" ) : ( "s" ) ) ; throw new IOException ( "Unable to read entire header; " + byte_count + type + " read; expected " + POIFSConstants . BIG_BLOCK_SIZE + " bytes" ) ; } LongField signature = new LongField ( _signature_offset , _data ) ; if ( signature . get ( ) != _signature ) { throw new IOException ( "Invalid header signature; read " + signature . get ( ) + ", expected " + _signature ) ; } _bat_count = new IntegerField ( _bat_count_offset , _data ) ; _property_start = new IntegerField ( _property_start_offset , _data ) ; _sbat_start = new IntegerField ( _sbat_start_offset , _data ) ; _xbat_start = new IntegerField ( _xbat_start_offset , _data ) ; _xbat_count = new IntegerField ( _xbat_count_offset , _data ) ; } public int getPropertyStart ( ) { return _property_start . get ( ) ; } public int getSBATStart ( ) { return _sbat_start . get ( ) ; } public int getBATCount ( ) { return _bat_count . get ( ) ; } public int [ ] getBATArray ( ) { int [ ] result = new int [ _max_bats_in_header ] ; int offset = _bat_array_offset ; for ( int j = 0 ; j < _max_bats_in_header ; j ++ ) { result [ j ] = LittleEndian . getInt ( _data , offset ) ; offset += LittleEndianConsts . INT_SIZE ; } return result ; } public int getXBATCount ( ) { return _xbat_count . get ( ) ; } public int getXBATIndex ( ) { return _xbat_start . get ( ) ; } } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class InterfaceHdrRecord extends Record { public final static short sid = 0xe1 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public InterfaceHdrRecord ( ) { } public InterfaceHdrRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public InterfaceHdrRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A INTERFACEHDR RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INTERFACEHDR]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/INTERFACEHDR]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . hssf . dev ; import java . io . InputStream ; import java . io . IOException ; import java . io . ByteArrayInputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . util . Random ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . model . * ; import org . apache . poi . hssf . usermodel . * ; import org . apache . poi . hssf . util . * ; public class HSSF { private String filename = null ; private InputStream stream = null ; private Record [ ] records = null ; protected HSSFWorkbook hssfworkbook = null ; public HSSF ( String filename ) throws IOException { this . filename = filename ; POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; hssfworkbook = new HSSFWorkbook ( fs ) ; } public HSSF ( String filename , boolean write ) throws IOException { short rownum = 0 ; FileOutputStream out = new FileOutputStream ( filename ) ; HSSFWorkbook wb = new HSSFWorkbook ( ) ; HSSFSheet s = wb . createSheet ( ) ; HSSFRow r = null ; HSSFCell c = null ; HSSFCellStyle cs = wb . createCellStyle ( ) ; HSSFCellStyle cs2 = wb . createCellStyle ( ) ; HSSFCellStyle cs3 = wb . createCellStyle ( ) ; HSSFFont f = wb . createFont ( ) ; HSSFFont f2 = wb . createFont ( ) ; f . setFontHeightInPoints ( ( short ) 12 ) ; f . setColor ( ( short ) 0xA ) ; f . setBoldweight ( f . BOLDWEIGHT_BOLD ) ; f2 . setFontHeightInPoints ( ( short ) 10 ) ; f2 . setColor ( ( short ) 0xf ) ; f2 . setBoldweight ( f2 . BOLDWEIGHT_BOLD ) ; cs . setFont ( f ) ; cs . setDataFormat ( HSSFDataFormat . getBuiltinFormat ( "($#,##0_);[Red]($#,##0)" ) ) ; cs2 . setBorderBottom ( cs2 . BORDER_THIN ) ; cs2 . setFillPattern ( ( short ) 1 ) ; cs2 . setFillForegroundColor ( ( short ) 0xA ) ; cs2 . setFont ( f2 ) ; wb . setSheetName ( 0 , "HSSF Test" ) ; for ( rownum = ( short ) 0 ; rownum < 300 ; rownum ++ ) { r = s . createRow ( rownum ) ; if ( ( rownum % 2 ) == 0 ) { r . setHeight ( ( short ) 0x249 ) ; } for ( short cellnum = ( short ) 0 ; cellnum < 50 ; cellnum += 2 ) { c = r . createCell ( cellnum , HSSFCell . CELL_TYPE_NUMERIC ) ; c . setCellValue ( rownum * 10000 + cellnum + ( ( ( double ) rownum / 1000 ) + ( ( double ) cellnum / 10000 ) ) ) ; if ( ( rownum % 2 ) == 0 ) { c . setCellStyle ( cs ) ; } c = r . createCell ( ( short ) ( cellnum + 1 ) , HSSFCell . CELL_TYPE_STRING ) ; c . setCellValue ( "TEST" ) ; s . setColumnWidth ( ( short ) ( cellnum + 1 ) , ( short ) ( ( 50 * 8 ) / ( ( double ) 1 / 20 ) ) ) ; if ( ( rownum % 2 ) == 0 ) { c . setCellStyle ( cs2 ) ; } } } rownum ++ ; rownum ++ ; r = s . createRow ( rownum ) ; cs3 . setBorderBottom ( cs3 . BORDER_THICK ) ; for ( short cellnum = ( short ) 0 ; cellnum < 50 ; cellnum ++ ) { c = r . createCell ( cellnum , HSSFCell . CELL_TYPE_BLANK ) ; c . setCellStyle ( cs3 ) ; } s . addMergedRegion ( new Region ( ( short ) 0 , ( short ) 0 , ( short ) 3 , ( short ) 3 ) ) ; s . addMergedRegion ( new Region ( ( short ) 100 , ( short ) 100 , ( short ) 110 , ( short ) 110 ) ) ; s = wb . createSheet ( ) ; wb . setSheetName ( 1 , "DeletedSheet" ) ; wb . removeSheetAt ( 1 ) ; wb . write ( out ) ; out . close ( ) ; } public HSSF ( String infile , String outfile , boolean write ) throws IOException { this . filename = filename ; POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; hssfworkbook = new HSSFWorkbook ( fs ) ; } public static void main ( String [ ] args ) { if ( args . length < 2 ) { } else if ( args . length == 2 ) { if ( args [ 1 ] . toLowerCase ( ) . equals ( "write" ) ) { System . out . println ( "Write mode" ) ; try { long time = System . currentTimeMillis ( ) ; HSSF hssf = new HSSF ( args [ 0 ] , true ) ; System . out . println ( "" + ( System . currentTimeMillis ( ) - time ) + " ms generation time" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "readwrite test" ) ; try { HSSF hssf = new HSSF ( args [ 0 ] ) ; HSSFWorkbook wb = hssf . hssfworkbook ; FileOutputStream stream = new FileOutputStream ( args [ 1 ] ) ; wb . write ( stream ) ; stream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } else if ( ( args . length == 3 ) && args [ 2 ] . toLowerCase ( ) . equals ( "modify1" ) ) { try { HSSF hssf = new HSSF ( args [ 0 ] ) ; HSSFWorkbook wb = hssf . hssfworkbook ; FileOutputStream stream = new FileOutputStream ( args [ 1 ] ) ; HSSFSheet sheet = wb . getSheetAt ( 0 ) ; for ( int k = 0 ; k < 25 ; k ++ ) { HSSFRow row = sheet . getRow ( k ) ; sheet . removeRow ( row ) ; } for ( int k = 74 ; k < 100 ; k ++ ) { HSSFRow row = sheet . getRow ( k ) ; sheet . removeRow ( row ) ; } HSSFRow row = sheet . getRow ( 39 ) ; HSSFCell cell = row . getCell ( ( short ) 3 ) ; cell . setCellType ( HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( "MODIFIED CELL!!!!!" ) ; wb . write ( stream ) ; stream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class SubtractPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x04 ; public SubtractPtg ( ) { } public SubtractPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "-" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( "-" ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new SubtractPtg ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . ListManagedBlock ; import org . apache . poi . poifs . storage . DocumentBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; import org . apache . poi . util . HexDump ; public class POIFSDocument implements BATManaged , BlockWritable , POIFSViewable { private DocumentProperty _property ; private int _size ; private SmallBlockStore _small_store ; private BigBlockStore _big_store ; public POIFSDocument ( final String name , final RawDataBlock [ ] blocks , final int length ) throws IOException { _size = length ; _big_store = new BigBlockStore ( blocks ) ; _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final SmallDocumentBlock [ ] blocks , final int length ) { _size = length ; try { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; } catch ( IOException ignored ) { } _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( blocks ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final ListManagedBlock [ ] blocks , final int length ) throws IOException { _size = length ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( Property . isSmall ( _size ) ) { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; _small_store = new SmallBlockStore ( blocks ) ; } else { _big_store = new BigBlockStore ( blocks ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; _size = 0 ; while ( true ) { DocumentBlock block = new DocumentBlock ( stream ) ; int blockSize = block . size ( ) ; if ( blockSize > 0 ) { blocks . add ( block ) ; _size += blockSize ; } if ( block . partiallyRead ( ) ) { break ; } } DocumentBlock [ ] bigBlocks = ( DocumentBlock [ ] ) blocks . toArray ( new DocumentBlock [ 0 ] ) ; _big_store = new BigBlockStore ( bigBlocks ) ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( SmallDocumentBlock . convert ( bigBlocks , _size ) ) ; _big_store = new BigBlockStore ( new DocumentBlock [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final int size , final POIFSDocumentPath path , final POIFSWriterListener writer ) throws IOException { _size = size ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( path , name , size , writer ) ; _big_store = new BigBlockStore ( new Object [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _big_store = new BigBlockStore ( path , name , size , writer ) ; } } public BlockWritable [ ] getSmallBlocks ( ) { return _small_store . getBlocks ( ) ; } public int getSize ( ) { return _size ; } void read ( final byte [ ] buffer , final int offset ) { if ( _property . shouldUseSmallBlocks ( ) ) { SmallDocumentBlock . read ( _small_store . getBlocks ( ) , buffer , offset ) ; } else { DocumentBlock . read ( _big_store . getBlocks ( ) , buffer , offset ) ; } } DocumentProperty getDocumentProperty ( ) { return _property ; } public void writeBlocks ( final OutputStream stream ) throws IOException { _big_store . writeBlocks ( stream ) ; } public int countBlocks ( ) { return _big_store . countBlocks ( ) ; } public void setStartBlock ( final int index ) { _property . setStartBlock ( index ) ; } public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ 1 ] ; String result ; try { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; BlockWritable [ ] blocks = null ; if ( _big_store . isValid ( ) ) { blocks = _big_store . getBlocks ( ) ; } else if ( _small_store . isValid ( ) ) { blocks = _small_store . getBlocks ( ) ; } if ( blocks != null ) { for ( int k = 0 ; k < blocks . length ; k ++ ) { blocks [ k ] . writeBlocks ( output ) ; } byte [ ] data = output . toByteArray ( ) ; if ( data . length > _property . getSize ( ) ) { byte [ ] tmp = new byte [ _property . getSize ( ) ] ; System . arraycopy ( data , 0 , tmp , 0 , tmp . length ) ; data = tmp ; } output = new ByteArrayOutputStream ( ) ; HexDump . dump ( data , 0 , output , 0 ) ; result = output . toString ( ) ; } else { result = "<NO DATA>" ; } } catch ( IOException e ) { result = e . getMessage ( ) ; } results [ 0 ] = result ; return results ; } public Iterator getViewableIterator ( ) { return Collections . EMPTY_LIST . iterator ( ) ; } public boolean preferArray ( ) { return true ; } public String getShortDescription ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Document: \"" ) . append ( _property . getName ( ) ) . append ( "\"" ) ; buffer . append ( " size = " ) . append ( getSize ( ) ) ; return buffer . toString ( ) ; } private class SmallBlockStore { private SmallDocumentBlock [ ] smallBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; SmallBlockStore ( final Object [ ] blocks ) { smallBlocks = new SmallDocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { smallBlocks [ j ] = ( SmallDocumentBlock ) blocks [ j ] ; } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } SmallBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { smallBlocks = new SmallDocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( smallBlocks . length > 0 ) || ( writer != null ) ) ; } BlockWritable [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; smallBlocks = SmallDocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return smallBlocks ; } } private class BigBlockStore { private DocumentBlock [ ] bigBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; BigBlockStore ( final Object [ ] blocks ) throws IOException { bigBlocks = new DocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { if ( blocks [ j ] instanceof DocumentBlock ) { bigBlocks [ j ] = ( DocumentBlock ) blocks [ j ] ; } else { bigBlocks [ j ] = new DocumentBlock ( ( RawDataBlock ) blocks [ j ] ) ; } } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } BigBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { bigBlocks = new DocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( bigBlocks . length > 0 ) || ( writer != null ) ) ; } DocumentBlock [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; bigBlocks = DocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return bigBlocks ; } void writeBlocks ( OutputStream stream ) throws IOException { if ( isValid ( ) ) { if ( writer != null ) { DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; dstream . writeFiller ( countBlocks ( ) * POIFSConstants . BIG_BLOCK_SIZE , DocumentBlock . getFillByte ( ) ) ; } else { for ( int k = 0 ; k < bigBlocks . length ; k ++ ) { bigBlocks [ k ] . writeBlocks ( stream ) ; } } } } int countBlocks ( ) { int rval = 0 ; if ( isValid ( ) ) { if ( writer != null ) { rval = ( size + POIFSConstants . BIG_BLOCK_SIZE - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ; } else { rval = bigBlocks . length ; } } return rval ; } } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class InterfaceEndRecord extends Record { public final static short sid = 0xe2 ; public InterfaceEndRecord ( ) { } public InterfaceEndRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public InterfaceEndRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A INTERFACEEND RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INTERFACEEND]\n" ) ; buffer . append ( "[/INTERFACEEND]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x00 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1
package org . apache . poi . poifs . property ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . util . ByteField ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . ShortField ; public abstract class Property implements Child , POIFSViewable { static final private byte _default_fill = ( byte ) 0x00 ; static final private int _name_size_offset = 0x40 ; static final private int _max_name_length = ( _name_size_offset / LittleEndianConsts . SHORT_SIZE ) - 1 ; static final protected int _NO_INDEX = - 1 ; static final private int _node_color_offset = 0x43 ; static final private int _previous_property_offset = 0x44 ; static final private int _next_property_offset = 0x48 ; static final private int _child_property_offset = 0x4C ; static final private int _storage_clsid_offset = 0x50 ; static final private int _user_flags_offset = 0x60 ; static final private int _seconds_1_offset = 0x64 ; static final private int _days_1_offset = 0x68 ; static final private int _seconds_2_offset = 0x6C ; static final private int _days_2_offset = 0x70 ; static final private int _start_block_offset = 0x74 ; static final private int _size_offset = 0x78 ; static final protected byte _NODE_BLACK = 1 ; static final protected byte _NODE_RED = 0 ; static final private int _big_block_minimum_bytes = 4096 ; private String _name ; private ShortField _name_size ; private ByteField _property_type ; private ByteField _node_color ; private IntegerField _previous_property ; private IntegerField _next_property ; private IntegerField _child_property ; private ClassID _storage_clsid ; private IntegerField _user_flags ; private IntegerField _seconds_1 ; private IntegerField _days_1 ; private IntegerField _seconds_2 ; private IntegerField _days_2 ; private IntegerField _start_block ; private IntegerField _size ; private byte [ ] _raw_data ; private int _index ; private Child _next_child ; private Child _previous_child ; protected Property ( ) { _raw_data = new byte [ POIFSConstants . PROPERTY_SIZE ] ; Arrays . fill ( _raw_data , _default_fill ) ; _name_size = new ShortField ( _name_size_offset ) ; _property_type = new ByteField ( PropertyConstants . PROPERTY_TYPE_OFFSET ) ; _node_color = new ByteField ( _node_color_offset ) ; _previous_property = new IntegerField ( _previous_property_offset , _NO_INDEX , _raw_data ) ; _next_property = new IntegerField ( _next_property_offset , _NO_INDEX , _raw_data ) ; _child_property = new IntegerField ( _child_property_offset , _NO_INDEX , _raw_data ) ; _storage_clsid = new ClassID ( _raw_data , _storage_clsid_offset ) ; _user_flags = new IntegerField ( _user_flags_offset , 0 , _raw_data ) ; _seconds_1 = new IntegerField ( _seconds_1_offset , 0 , _raw_data ) ; _days_1 = new IntegerField ( _days_1_offset , 0 , _raw_data ) ; _seconds_2 = new IntegerField ( _seconds_2_offset , 0 , _raw_data ) ; _days_2 = new IntegerField ( _days_2_offset , 0 , _raw_data ) ; _start_block = new IntegerField ( _start_block_offset ) ; _size = new IntegerField ( _size_offset , 0 , _raw_data ) ; _index = _NO_INDEX ; setName ( "" ) ; setNextChild ( null ) ; setPreviousChild ( null ) ; } protected Property ( final int index , final byte [ ] array , final int offset ) { _raw_data = new byte [ POIFSConstants . PROPERTY_SIZE ] ; System . arraycopy ( array , offset , _raw_data , 0 , POIFSConstants . PROPERTY_SIZE ) ; _name_size = new ShortField ( _name_size_offset , _raw_data ) ; _property_type = new ByteField ( PropertyConstants . PROPERTY_TYPE_OFFSET , _raw_data ) ; _node_color = new ByteField ( _node_color_offset , _raw_data ) ; _previous_property = new IntegerField ( _previous_property_offset , _raw_data ) ; _next_property = new IntegerField ( _next_property_offset , _raw_data ) ; _child_property = new IntegerField ( _child_property_offset , _raw_data ) ; _storage_clsid = new ClassID ( _raw_data , _storage_clsid_offset ) ; _user_flags = new IntegerField ( _user_flags_offset , 0 , _raw_data ) ; _seconds_1 = new IntegerField ( _seconds_1_offset , _raw_data ) ; _days_1 = new IntegerField ( _days_1_offset , _raw_data ) ; _seconds_2 = new IntegerField ( _seconds_2_offset , _raw_data ) ; _days_2 = new IntegerField ( _days_2_offset , _raw_data ) ; _start_block = new IntegerField ( _start_block_offset , _raw_data ) ; _size = new IntegerField ( _size_offset , _raw_data ) ; _index = index ; int name_length = ( _name_size . get ( ) / LittleEndianConsts . SHORT_SIZE ) - 1 ; if ( name_length < 1 ) { _name = "" ; } else { char [ ] char_array = new char [ name_length ] ; int name_offset = 0 ; for ( int j = 0 ; j < name_length ; j ++ ) { char_array [ j ] = ( char ) new ShortField ( name_offset , _raw_data ) . get ( ) ; name_offset += LittleEndianConsts . SHORT_SIZE ; } _name = new String ( char_array , 0 , name_length ) ; } _next_child = null ; _previous_child = null ; } public void writeData ( final OutputStream stream ) throws IOException { stream . write ( _raw_data ) ; } public void setStartBlock ( final int startBlock ) { _start_block . set ( startBlock , _raw_data ) ; } public int getStartBlock ( ) { return _start_block . get ( ) ; } public int getSize ( ) { return _size . get ( ) ; } public boolean shouldUseSmallBlocks ( ) { return Property . isSmall ( _size . get ( ) ) ; } public static boolean isSmall ( final int length ) { return length < _big_block_minimum_bytes ; } public String getName ( ) { return _name ; } abstract public boolean isDirectory ( ) ; public ClassID getStorageClsid ( ) { return _storage_clsid ; } protected final void setName ( final String name ) { char [ ] char_array = name . toCharArray ( ) ; int limit = Math . min ( char_array . length , _max_name_length ) ; _name = new String ( char_array , 0 , limit ) ; short offset = 0 ; int j = 0 ; for ( ; j < limit ; j ++ ) { new ShortField ( offset , ( short ) char_array [ j ] , _raw_data ) ; offset += LittleEndianConsts . SHORT_SIZE ; } for ( ; j < _max_name_length + 1 ; j ++ ) { new ShortField ( offset , ( short ) 0 , _raw_data ) ; offset += LittleEndianConsts . SHORT_SIZE ; } _name_size . set ( ( short ) ( ( limit + 1 ) * LittleEndianConsts . SHORT_SIZE ) , _raw_data ) ; } public void setStorageClsid ( ClassID clsidStorage ) { _storage_clsid = clsidStorage ; if ( clsidStorage == null ) { Arrays . fill ( _raw_data , _storage_clsid_offset , _storage_clsid_offset + ClassID . LENGTH , ( byte ) 0 ) ; } else { clsidStorage . write ( _raw_data , _storage_clsid_offset ) ; } } protected void setPropertyType ( final byte propertyType ) { _property_type . set ( propertyType , _raw_data ) ; } protected void setNodeColor ( final byte nodeColor ) { _node_color . set ( nodeColor , _raw_data ) ; } protected void setChildProperty ( final int child ) { _child_property . set ( child , _raw_data ) ; } protected int getChildIndex ( ) { return _child_property . get ( ) ; } protected void setSize ( final int size ) { _size . set ( size , _raw_data ) ; } protected void setIndex ( final int index ) { _index = index ; } protected int getIndex ( ) { return _index ; } abstract protected void preWrite ( ) ; int getNextChildIndex ( ) { return _next_property . get ( ) ; } int getPreviousChildIndex ( ) { return _previous_property . get ( ) ; } static boolean isValidIndex ( int index ) { return index != _NO_INDEX ; } public Child getNextChild ( ) { return _next_child ; } public Child getPreviousChild ( ) { return _previous_child ; } public void setNextChild ( final Child child ) { _next_child = child ; _next_property . set ( ( child == null ) ? _NO_INDEX : ( ( Property ) child ) . getIndex ( ) , _raw_data ) ; } public void setPreviousChild ( final Child child ) { _previous_child = child ; _previous_property . set ( ( child == null ) ? _NO_INDEX : ( ( Property ) child ) . getIndex ( ) , _raw_data ) ; } public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ 5 ] ; results [ 0 ] = "Name          = \"" + getName ( ) + "\"" ; results [ 1 ] = "Property Type = " + _property_type . get ( ) ; results [ 2 ] = "Node Color    = " + _node_color . get ( ) ; long time = _days_1 . get ( ) ; time <<= 32 ; time += ( ( long ) _seconds_1 . get ( ) ) & 0x0000FFFFL ; results [ 3 ] = "Time 1        = " + time ; time = _days_2 . get ( ) ; time <<= 32 ; time += ( ( long ) _seconds_2 . get ( ) ) & 0x0000FFFFL ; results [ 4 ] = "Time 2        = " + time ; return results ; } public Iterator getViewableIterator ( ) { return Collections . EMPTY_LIST . iterator ( ) ; } public boolean preferArray ( ) { return true ; } public String getShortDescription ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Property: \"" ) . append ( getName ( ) ) . append ( "\"" ) ; return buffer . toString ( ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import org . apache . poi . util . LittleEndian ; public class ContinueRecord extends Record { public final static short sid = 0x003C ; private byte [ ] field_1_data ; public ContinueRecord ( ) { } public ContinueRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ContinueRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public byte [ ] serialize ( ) { byte [ ] retval = new byte [ field_1_data . length + 4 ] ; serialize ( 0 , retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , offset , sid ) ; LittleEndian . putShort ( data , offset + 2 , ( short ) field_1_data . length ) ; System . arraycopy ( field_1_data , 0 , data , offset + 4 , field_1_data . length ) ; return field_1_data . length + 4 ; } public void setData ( byte [ ] data ) { field_1_data = data ; } public byte [ ] getData ( ) { return field_1_data ; } public static byte [ ] processContinue ( byte [ ] data ) { int records = ( data . length / 8214 ) ; int offset = 8214 ; ArrayList crs = new ArrayList ( records ) ; int totalsize = 8214 ; byte [ ] retval = null ; for ( int cr = 0 ; cr < records ; cr ++ ) { ContinueRecord contrec = new ContinueRecord ( ) ; int arraysize = Math . min ( ( 8214 - 4 ) , ( data . length - offset ) ) ; byte [ ] crdata = new byte [ arraysize ] ; System . arraycopy ( data , offset , crdata , 0 , arraysize ) ; offset += crdata . length ; contrec . setData ( crdata ) ; crs . add ( contrec . serialize ( ) ) ; } for ( int cr = 0 ; cr < records ; cr ++ ) { totalsize += ( ( byte [ ] ) crs . get ( cr ) ) . length ; } retval = new byte [ totalsize ] ; offset = 8214 ; System . arraycopy ( data , 0 , retval , 0 , 8214 ) ; for ( int cr = 0 ; cr < records ; cr ++ ) { byte [ ] src = ( byte [ ] ) crs . get ( cr ) ; System . arraycopy ( src , 0 , retval , offset , src . length ) ; offset += src . length ; } return retval ; } protected void fillFields ( byte [ ] ignored_parm1 , short ignored_parm2 ) { this . field_1_data = ignored_parm1 ; } protected void validateSid ( short id ) { if ( id != ContinueRecord . sid ) { throw new RecordFormatException ( "Not a Continue Record" ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CONTINUE RECORD]\n" ) ; buffer . append ( "    .id        = " ) . append ( Integer . toHexString ( sid ) ) . append ( "\n" ) ; buffer . append ( "[/CONTINUE RECORD]\n" ) ; return buffer . toString ( ) ; } public short getSid ( ) { return this . sid ; } protected void fillFields ( byte [ ] ignored_parm1 , short ignored_parm2 , int ignored_parm3 ) { } public Object clone ( ) { ContinueRecord clone = new ContinueRecord ( ) ; clone . setData ( field_1_data ) ; return clone ; } } 	0
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1
package org . apache . poi . hssf . util ; import java . util . * ; public class HSSFColor { private final static int PALETTE_SIZE = 56 ; private final static int DISTINCT_COLOR_COUNT = 46 ; public HSSFColor ( ) { } public final static Hashtable getIndexHash ( ) { Hashtable hash = new Hashtable ( PALETTE_SIZE ) ; hash . put ( new Integer ( HSSFColor . BLACK . index ) , new HSSFColor . BLACK ( ) ) ; hash . put ( new Integer ( HSSFColor . BROWN . index ) , new HSSFColor . BROWN ( ) ) ; hash . put ( new Integer ( HSSFColor . OLIVE_GREEN . index ) , new HSSFColor . OLIVE_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_GREEN . index ) , new HSSFColor . DARK_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_TEAL . index ) , new HSSFColor . DARK_TEAL ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_BLUE . index ) , new HSSFColor . DARK_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_BLUE . index2 ) , new HSSFColor . DARK_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . INDIGO . index ) , new HSSFColor . INDIGO ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_80_PERCENT . index ) , new HSSFColor . GREY_80_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . ORANGE . index ) , new HSSFColor . ORANGE ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_YELLOW . index ) , new HSSFColor . DARK_YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . GREEN . index ) , new HSSFColor . GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . TEAL . index ) , new HSSFColor . TEAL ( ) ) ; hash . put ( new Integer ( HSSFColor . TEAL . index2 ) , new HSSFColor . TEAL ( ) ) ; hash . put ( new Integer ( HSSFColor . BLUE . index ) , new HSSFColor . BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . BLUE . index2 ) , new HSSFColor . BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . BLUE_GREY . index ) , new HSSFColor . BLUE_GREY ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_50_PERCENT . index ) , new HSSFColor . GREY_50_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . RED . index ) , new HSSFColor . RED ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_ORANGE . index ) , new HSSFColor . LIGHT_ORANGE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIME . index ) , new HSSFColor . LIME ( ) ) ; hash . put ( new Integer ( HSSFColor . SEA_GREEN . index ) , new HSSFColor . SEA_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . AQUA . index ) , new HSSFColor . AQUA ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_BLUE . index ) , new HSSFColor . LIGHT_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . VIOLET . index ) , new HSSFColor . VIOLET ( ) ) ; hash . put ( new Integer ( HSSFColor . VIOLET . index2 ) , new HSSFColor . VIOLET ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_40_PERCENT . index ) , new HSSFColor . GREY_40_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . PINK . index ) , new HSSFColor . PINK ( ) ) ; hash . put ( new Integer ( HSSFColor . PINK . index2 ) , new HSSFColor . PINK ( ) ) ; hash . put ( new Integer ( HSSFColor . GOLD . index ) , new HSSFColor . GOLD ( ) ) ; hash . put ( new Integer ( HSSFColor . YELLOW . index ) , new HSSFColor . YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . YELLOW . index2 ) , new HSSFColor . YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . BRIGHT_GREEN . index ) , new HSSFColor . BRIGHT_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . BRIGHT_GREEN . index2 ) , new HSSFColor . BRIGHT_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . TURQUOISE . index ) , new HSSFColor . TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . TURQUOISE . index2 ) , new HSSFColor . TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_RED . index ) , new HSSFColor . DARK_RED ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_RED . index2 ) , new HSSFColor . DARK_RED ( ) ) ; hash . put ( new Integer ( HSSFColor . SKY_BLUE . index ) , new HSSFColor . SKY_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . PLUM . index ) , new HSSFColor . PLUM ( ) ) ; hash . put ( new Integer ( HSSFColor . PLUM . index2 ) , new HSSFColor . PLUM ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_25_PERCENT . index ) , new HSSFColor . GREY_25_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . ROSE . index ) , new HSSFColor . ROSE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_YELLOW . index ) , new HSSFColor . LIGHT_YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_GREEN . index ) , new HSSFColor . LIGHT_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_TURQUOISE . index ) , new HSSFColor . LIGHT_TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_TURQUOISE . index2 ) , new HSSFColor . LIGHT_TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . PALE_BLUE . index ) , new HSSFColor . PALE_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . LAVENDER . index ) , new HSSFColor . LAVENDER ( ) ) ; hash . put ( new Integer ( HSSFColor . WHITE . index ) , new HSSFColor . WHITE ( ) ) ; hash . put ( new Integer ( HSSFColor . CORNFLOWER_BLUE . index ) , new HSSFColor . CORNFLOWER_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . LEMON_CHIFFON . index ) , new HSSFColor . LEMON_CHIFFON ( ) ) ; hash . put ( new Integer ( HSSFColor . MAROON . index ) , new HSSFColor . MAROON ( ) ) ; hash . put ( new Integer ( HSSFColor . ORCHID . index ) , new HSSFColor . ORCHID ( ) ) ; hash . put ( new Integer ( HSSFColor . CORAL . index ) , new HSSFColor . CORAL ( ) ) ; hash . put ( new Integer ( HSSFColor . ROYAL_BLUE . index ) , new HSSFColor . ROYAL_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_CORNFLOWER_BLUE . index ) , new HSSFColor . LIGHT_CORNFLOWER_BLUE ( ) ) ; return hash ; } public final static Hashtable getTripletHash ( ) { Hashtable hash = new Hashtable ( DISTINCT_COLOR_COUNT ) ; hash . put ( HSSFColor . BLACK . hexString , new HSSFColor . BLACK ( ) ) ; hash . put ( HSSFColor . BROWN . hexString , new HSSFColor . BROWN ( ) ) ; hash . put ( HSSFColor . OLIVE_GREEN . hexString , new HSSFColor . OLIVE_GREEN ( ) ) ; hash . put ( HSSFColor . DARK_GREEN . hexString , new HSSFColor . DARK_GREEN ( ) ) ; hash . put ( HSSFColor . DARK_TEAL . hexString , new HSSFColor . DARK_TEAL ( ) ) ; hash . put ( HSSFColor . DARK_BLUE . hexString , new HSSFColor . DARK_BLUE ( ) ) ; hash . put ( HSSFColor . INDIGO . hexString , new HSSFColor . INDIGO ( ) ) ; hash . put ( HSSFColor . GREY_80_PERCENT . hexString , new HSSFColor . GREY_80_PERCENT ( ) ) ; hash . put ( HSSFColor . ORANGE . hexString , new HSSFColor . ORANGE ( ) ) ; hash . put ( HSSFColor . DARK_YELLOW . hexString , new HSSFColor . DARK_YELLOW ( ) ) ; hash . put ( HSSFColor . GREEN . hexString , new HSSFColor . GREEN ( ) ) ; hash . put ( HSSFColor . TEAL . hexString , new HSSFColor . TEAL ( ) ) ; hash . put ( HSSFColor . BLUE . hexString , new HSSFColor . BLUE ( ) ) ; hash . put ( HSSFColor . BLUE_GREY . hexString , new HSSFColor . BLUE_GREY ( ) ) ; hash . put ( HSSFColor . GREY_50_PERCENT . hexString , new HSSFColor . GREY_50_PERCENT ( ) ) ; hash . put ( HSSFColor . RED . hexString , new HSSFColor . RED ( ) ) ; hash . put ( HSSFColor . LIGHT_ORANGE . hexString , new HSSFColor . LIGHT_ORANGE ( ) ) ; hash . put ( HSSFColor . LIME . hexString , new HSSFColor . LIME ( ) ) ; hash . put ( HSSFColor . SEA_GREEN . hexString , new HSSFColor . SEA_GREEN ( ) ) ; hash . put ( HSSFColor . AQUA . hexString , new HSSFColor . AQUA ( ) ) ; hash . put ( HSSFColor . LIGHT_BLUE . hexString , new HSSFColor . LIGHT_BLUE ( ) ) ; hash . put ( HSSFColor . VIOLET . hexString , new HSSFColor . VIOLET ( ) ) ; hash . put ( HSSFColor . GREY_40_PERCENT . hexString , new HSSFColor . GREY_40_PERCENT ( ) ) ; hash . put ( HSSFColor . PINK . hexString , new HSSFColor . PINK ( ) ) ; hash . put ( HSSFColor . GOLD . hexString , new HSSFColor . GOLD ( ) ) ; hash . put ( HSSFColor . YELLOW . hexString , new HSSFColor . YELLOW ( ) ) ; hash . put ( HSSFColor . BRIGHT_GREEN . hexString , new HSSFColor . BRIGHT_GREEN ( ) ) ; hash . put ( HSSFColor . BRIGHT_GREEN . hexString , new HSSFColor . TURQUOISE ( ) ) ; hash . put ( HSSFColor . DARK_RED . hexString , new HSSFColor . DARK_RED ( ) ) ; hash . put ( HSSFColor . SKY_BLUE . hexString , new HSSFColor . SKY_BLUE ( ) ) ; hash . put ( HSSFColor . PLUM . hexString , new HSSFColor . PLUM ( ) ) ; hash . put ( HSSFColor . GREY_25_PERCENT . hexString , new HSSFColor . GREY_25_PERCENT ( ) ) ; hash . put ( HSSFColor . ROSE . hexString , new HSSFColor . ROSE ( ) ) ; hash . put ( HSSFColor . LIGHT_YELLOW . hexString , new HSSFColor . LIGHT_YELLOW ( ) ) ; hash . put ( HSSFColor . LIGHT_GREEN . hexString , new HSSFColor . LIGHT_GREEN ( ) ) ; hash . put ( HSSFColor . LIGHT_TURQUOISE . hexString , new HSSFColor . LIGHT_TURQUOISE ( ) ) ; hash . put ( HSSFColor . PALE_BLUE . hexString , new HSSFColor . PALE_BLUE ( ) ) ; hash . put ( HSSFColor . LAVENDER . hexString , new HSSFColor . LAVENDER ( ) ) ; hash . put ( HSSFColor . WHITE . hexString , new HSSFColor . WHITE ( ) ) ; hash . put ( HSSFColor . CORNFLOWER_BLUE . hexString , new HSSFColor . CORNFLOWER_BLUE ( ) ) ; hash . put ( HSSFColor . LEMON_CHIFFON . hexString , new HSSFColor . LEMON_CHIFFON ( ) ) ; hash . put ( HSSFColor . MAROON . hexString , new HSSFColor . MAROON ( ) ) ; hash . put ( HSSFColor . ORCHID . hexString , new HSSFColor . ORCHID ( ) ) ; hash . put ( HSSFColor . CORAL . hexString , new HSSFColor . CORAL ( ) ) ; hash . put ( HSSFColor . ROYAL_BLUE . hexString , new HSSFColor . ROYAL_BLUE ( ) ) ; hash . put ( HSSFColor . LIGHT_CORNFLOWER_BLUE . hexString , new HSSFColor . LIGHT_CORNFLOWER_BLUE ( ) ) ; return hash ; } public short getIndex ( ) { return BLACK . index ; } public short [ ] getTriplet ( ) { return BLACK . triplet ; } public String getHexString ( ) { return BLACK . hexString ; } public final static class BLACK extends HSSFColor { public final static short index = 0x8 ; public final static short [ ] triplet = { 0 , 0 , 0 } ; public final static String hexString = "0:0:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BROWN extends HSSFColor { public final static short index = 0x3c ; public final static short [ ] triplet = { 153 , 51 , 0 } ; public final static String hexString = "9999:3333:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public static class OLIVE_GREEN extends HSSFColor { public final static short index = 0x3b ; public final static short [ ] triplet = { 51 , 51 , 0 } ; public final static String hexString = "3333:3333:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_GREEN extends HSSFColor { public final static short index = 0x3a ; public final static short [ ] triplet = { 0 , 51 , 0 } ; public final static String hexString = "0:3333:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_TEAL extends HSSFColor { public final static short index = 0x38 ; public final static short [ ] triplet = { 0 , 51 , 102 } ; public final static String hexString = "0:3333:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_BLUE extends HSSFColor { public final static short index = 0x12 ; public final static short index2 = 0x20 ; public final static short [ ] triplet = { 0 , 0 , 128 } ; public final static String hexString = "0:0:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class INDIGO extends HSSFColor { public final static short index = 0x3e ; public final static short [ ] triplet = { 51 , 51 , 153 } ; public final static String hexString = "3333:3333:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_80_PERCENT extends HSSFColor { public final static short index = 0x3f ; public final static short [ ] triplet = { 51 , 51 , 51 } ; public final static String hexString = "3333:3333:3333" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_RED extends HSSFColor { public final static short index = 0x10 ; public final static short index2 = 0x25 ; public final static short [ ] triplet = { 128 , 0 , 0 } ; public final static String hexString = "8080:0:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ORANGE extends HSSFColor { public final static short index = 0x35 ; public final static short [ ] triplet = { 255 , 102 , 0 } ; public final static String hexString = "FFFF:6666:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_YELLOW extends HSSFColor { public final static short index = 0x13 ; public final static short [ ] triplet = { 128 , 128 , 0 } ; public final static String hexString = "8080:8080:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREEN extends HSSFColor { public final static short index = 0x11 ; public final static short [ ] triplet = { 0 , 128 , 0 } ; public final static String hexString = "0:8080:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class TEAL extends HSSFColor { public final static short index = 0x15 ; public final static short index2 = 0x26 ; public final static short [ ] triplet = { 0 , 128 , 128 } ; public final static String hexString = "0:8080:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BLUE extends HSSFColor { public final static short index = 0xc ; public final static short index2 = 0x27 ; public final static short [ ] triplet = { 0 , 0 , 255 } ; public final static String hexString = "0:0:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BLUE_GREY extends HSSFColor { public final static short index = 0x36 ; public final static short [ ] triplet = { 102 , 102 , 153 } ; public final static String hexString = "6666:6666:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_50_PERCENT extends HSSFColor { public final static short index = 0x17 ; public final static short [ ] triplet = { 128 , 128 , 128 } ; public final static String hexString = "8080:8080:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class RED extends HSSFColor { public final static short index = 0xa ; public final static short [ ] triplet = { 255 , 0 , 0 } ; public final static String hexString = "FFFF:0:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_ORANGE extends HSSFColor { public final static short index = 0x34 ; public final static short [ ] triplet = { 255 , 153 , 0 } ; public final static String hexString = "FFFF:9999:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIME extends HSSFColor { public final static short index = 0x32 ; public final static short [ ] triplet = { 153 , 204 , 0 } ; public final static String hexString = "9999:CCCC:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class SEA_GREEN extends HSSFColor { public final static short index = 0x39 ; public final static short [ ] triplet = { 51 , 153 , 102 } ; public final static String hexString = "3333:9999:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class AQUA extends HSSFColor { public final static short index = 0x31 ; public final static short [ ] triplet = { 51 , 204 , 204 } ; public final static String hexString = "3333:CCCC:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_BLUE extends HSSFColor { public final static short index = 0x30 ; public final static short [ ] triplet = { 51 , 102 , 255 } ; public final static String hexString = "3333:6666:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class VIOLET extends HSSFColor { public final static short index = 0x14 ; public final static short index2 = 0x24 ; public final static short [ ] triplet = { 128 , 0 , 128 } ; public final static String hexString = "8080:0:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_40_PERCENT extends HSSFColor { public final static short index = 0x37 ; public final static short [ ] triplet = { 150 , 150 , 150 } ; public final static String hexString = "9696:9696:9696" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class PINK extends HSSFColor { public final static short index = 0xe ; public final static short index2 = 0x21 ; public final static short [ ] triplet = { 255 , 0 , 255 } ; public final static String hexString = "FFFF:0:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GOLD extends HSSFColor { public final static short index = 0x33 ; public final static short [ ] triplet = { 255 , 204 , 0 } ; public final static String hexString = "FFFF:CCCC:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class YELLOW extends HSSFColor { public final static short index = 0xd ; public final static short index2 = 0x22 ; public final static short [ ] triplet = { 255 , 255 , 0 } ; public final static String hexString = "FFFF:FFFF:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BRIGHT_GREEN extends HSSFColor { public final static short index = 0xb ; public final static short index2 = 0x23 ; public final static short [ ] triplet = { 0 , 255 , 0 } ; public final static String hexString = "0:FFFF:0" ; public short getIndex ( ) { return index ; } public String getHexString ( ) { return hexString ; } public short [ ] getTriplet ( ) { return triplet ; } } public final static class TURQUOISE extends HSSFColor { public final static short index = 0xf ; public final static short index2 = 0x23 ; public final static short [ ] triplet = { 0 , 255 , 255 } ; public final static String hexString = "0:FFFF:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class SKY_BLUE extends HSSFColor { public final static short index = 0x28 ; public final static short [ ] triplet = { 0 , 204 , 255 } ; public final static String hexString = "0:CCCC:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class PLUM extends HSSFColor { public final static short index = 0x3d ; public final static short index2 = 0x19 ; public final static short [ ] triplet = { 153 , 51 , 102 } ; public final static String hexString = "9999:3333:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_25_PERCENT extends HSSFColor { public final static short index = 0x16 ; public final static short [ ] triplet = { 192 , 192 , 192 } ; public final static String hexString = "C0C0:C0C0:C0C0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ROSE extends HSSFColor { public final static short index = 0x2d ; public final static short [ ] triplet = { 255 , 153 , 204 } ; public final static String hexString = "FFFF:9999:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class TAN extends HSSFColor { public final static short index = 0x2f ; public final static short [ ] triplet = { 255 , 204 , 153 } ; public final static String hexString = "FFFF:CCCC:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_YELLOW extends HSSFColor { public final static short index = 0x2b ; public final static short [ ] triplet = { 255 , 255 , 153 } ; public final static String hexString = "FFFF:FFFF:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_GREEN extends HSSFColor { public final static short index = 0x2a ; public final static short [ ] triplet = { 204 , 255 , 204 } ; public final static String hexString = "CCCC:FFFF:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_TURQUOISE extends HSSFColor { public final static short index = 0x29 ; public final static short index2 = 0x1b ; public final static short [ ] triplet = { 204 , 255 , 255 } ; public final static String hexString = "CCCC:FFFF:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class PALE_BLUE extends HSSFColor { public final static short index = 0x2c ; public final static short [ ] triplet = { 153 , 204 , 255 } ; public final static String hexString = "9999:CCCC:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LAVENDER extends HSSFColor { public final static short index = 0x2e ; public final static short [ ] triplet = { 204 , 153 , 255 } ; public final static String hexString = "CCCC:9999:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class WHITE extends HSSFColor { public final static short index = 0x9 ; public final static short [ ] triplet = { 255 , 255 , 255 } ; public final static String hexString = "FFFF:FFFF:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class CORNFLOWER_BLUE extends HSSFColor { public final static short index = 0x18 ; public final static short [ ] triplet = { 153 , 153 , 255 } ; public final static String hexString = "9999:9999:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LEMON_CHIFFON extends HSSFColor { public final static short index = 0x1a ; public final static short [ ] triplet = { 255 , 255 , 204 } ; public final static String hexString = "FFFF:FFFF:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class MAROON extends HSSFColor { public final static short index = 0x19 ; public final static short [ ] triplet = { 153 , 51 , 102 } ; public final static String hexString = "9999:3333:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ORCHID extends HSSFColor { public final static short index = 0x1c ; public final static short [ ] triplet = { 102 , 0 , 102 } ; public final static String hexString = "6666:0:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class CORAL extends HSSFColor { public final static short index = 0x1d ; public final static short [ ] triplet = { 255 , 128 , 128 } ; public final static String hexString = "FFFF:8080:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ROYAL_BLUE extends HSSFColor { public final static short index = 0x1e ; public final static short [ ] triplet = { 0 , 102 , 204 } ; public final static String hexString = "0:6666:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_CORNFLOWER_BLUE extends HSSFColor { public final static short index = 0x1f ; public final static short [ ] triplet = { 204 , 204 , 255 } ; public final static String hexString = "CCCC:CCCC:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class RefModeRecord extends Record { public final static short sid = 0xf ; public final static short USE_A1_MODE = 1 ; public final static short USE_R1C1_MODE = 0 ; private short field_1_mode ; public RefModeRecord ( ) { } public RefModeRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RefModeRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An RefMode RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_mode = LittleEndian . getShort ( data , 0 + offset ) ; } public void setMode ( short mode ) { field_1_mode = mode ; } public short getMode ( ) { return field_1_mode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[REFMODE]\n" ) ; buffer . append ( "    .mode           = " ) . append ( Integer . toHexString ( getMode ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/REFMODE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , getMode ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { RefModeRecord rec = new RefModeRecord ( ) ; rec . field_1_mode = field_1_mode ; return rec ; } } 	0
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class FormatRecord extends Record { public final static short sid = 0x41e ; private short field_1_index_code ; private short field_2_formatstring_len ; private short field_3_unicode_len ; private boolean field_3_unicode_flag ; private String field_4_formatstring ; public FormatRecord ( ) { } public FormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_index_code = LittleEndian . getShort ( data , 0 + offset ) ; field_3_unicode_len = LittleEndian . getShort ( data , 2 + offset ) ; field_2_formatstring_len = field_3_unicode_len ; field_3_unicode_flag = ( data [ 4 + offset ] & ( byte ) 0x01 ) != 0 ; if ( field_3_unicode_flag ) { field_4_formatstring = StringUtil . getFromUnicodeHigh ( data , 5 + offset , field_3_unicode_len ) ; } else { field_4_formatstring = StringUtil . getFromCompressedUnicode ( data , 5 + offset , field_3_unicode_len ) ; } } public void setIndexCode ( short index ) { field_1_index_code = index ; } public void setFormatStringLength ( byte len ) { field_2_formatstring_len = len ; field_3_unicode_len = len ; } public void setUnicodeFlag ( boolean unicode ) { field_3_unicode_flag = unicode ; } public void setFormatString ( String fs ) { field_4_formatstring = fs ; } public short getIndexCode ( ) { return field_1_index_code ; } public short getFormatStringLength ( ) { return field_3_unicode_flag ? field_3_unicode_len : field_2_formatstring_len ; } public boolean getUnicodeFlag ( ) { return field_3_unicode_flag ; } public String getFormatString ( ) { return field_4_formatstring ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FORMAT]\n" ) ; buffer . append ( "    .indexcode       = " ) . append ( Integer . toHexString ( getIndexCode ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .unicode length  = " ) . append ( Integer . toHexString ( field_3_unicode_len ) ) . append ( "\n" ) ; buffer . append ( "    .isUnicode       = " ) . append ( field_3_unicode_flag ) . append ( "\n" ) ; buffer . append ( "    .formatstring    = " ) . append ( getFormatString ( ) ) . append ( "\n" ) ; buffer . append ( "[/FORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 2 + 2 + 1 + ( ( field_3_unicode_flag ) ? 2 * field_3_unicode_len : field_3_unicode_len ) ) ) ; LittleEndian . putShort ( data , 4 + offset , getIndexCode ( ) ) ; LittleEndian . putShort ( data , 6 + offset , field_3_unicode_len ) ; data [ 8 + offset ] = ( byte ) ( ( field_3_unicode_flag ) ? 0x01 : 0x00 ) ; if ( field_3_unicode_flag ) { StringUtil . putUncompressedUnicode ( getFormatString ( ) , data , 9 + offset ) ; } else { StringUtil . putCompressedUnicode ( getFormatString ( ) , data , 9 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 9 + ( ( field_3_unicode_flag ) ? 2 * field_3_unicode_len : field_3_unicode_len ) ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class SaveRecalcRecord extends Record { public final static short sid = 0x5f ; private short field_1_recalc ; public SaveRecalcRecord ( ) { } public SaveRecalcRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SaveRecalcRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Save Recalc RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_recalc = LittleEndian . getShort ( data , 0 + offset ) ; } public void setRecalc ( boolean recalc ) { field_1_recalc = ( short ) ( ( recalc == true ) ? 1 : 0 ) ; } public boolean getRecalc ( ) { return ( field_1_recalc == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SAVERECALC]\n" ) ; buffer . append ( "    .recalc         = " ) . append ( getRecalc ( ) ) . append ( "\n" ) ; buffer . append ( "[/SAVERECALC]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_recalc ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SaveRecalcRecord rec = new SaveRecalcRecord ( ) ; rec . field_1_recalc = field_1_recalc ; return rec ; } } 	0
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class EOFRecord extends Record { public final static short sid = 0x0A ; public EOFRecord ( ) { } public EOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public EOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An EOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EOF]\n" ) ; buffer . append ( "[/EOF]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { EOFRecord rec = new EOFRecord ( ) ; return rec ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class EqualPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0b ; public EqualPtg ( ) { } public EqualPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "=" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new EqualPtg ( ) ; } } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class DefaultDataLabelTextPropertiesRecord extends Record { public final static short sid = 0x1024 ; private short field_1_categoryDataType ; public final static short CATEGORY_DATA_TYPE_SHOW_LABELS_CHARACTERISTIC = 0 ; public final static short CATEGORY_DATA_TYPE_VALUE_AND_PERCENTAGE_CHARACTERISTIC = 1 ; public final static short CATEGORY_DATA_TYPE_ALL_TEXT_CHARACTERISTIC = 2 ; public DefaultDataLabelTextPropertiesRecord ( ) { } public DefaultDataLabelTextPropertiesRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DefaultDataLabelTextPropertiesRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a DefaultDataLabelTextProperties record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_categoryDataType = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DEFAULTTEXT]\n" ) ; buffer . append ( "    .categoryDataType     = " ) . append ( "0x" ) . append ( HexDump . toHex ( getCategoryDataType ( ) ) ) . append ( " (" ) . append ( getCategoryDataType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/DEFAULTTEXT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_categoryDataType ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { DefaultDataLabelTextPropertiesRecord rec = new DefaultDataLabelTextPropertiesRecord ( ) ; rec . field_1_categoryDataType = field_1_categoryDataType ; return rec ; } public short getCategoryDataType ( ) { return field_1_categoryDataType ; } public void setCategoryDataType ( short field_1_categoryDataType ) { this . field_1_categoryDataType = field_1_categoryDataType ; } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SeriesListRecord extends Record { public final static short sid = 0x1016 ; private short [ ] field_1_seriesNumbers ; public SeriesListRecord ( ) { } public SeriesListRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesListRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesList record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_seriesNumbers = LittleEndian . getShortArray ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SERIESLIST]\n" ) ; buffer . append ( "    .seriesNumbers        = " ) . append ( " (" ) . append ( getSeriesNumbers ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SERIESLIST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShortArray ( data , 4 + offset + pos , field_1_seriesNumbers ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + field_1_seriesNumbers . length * 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SeriesListRecord rec = new SeriesListRecord ( ) ; rec . field_1_seriesNumbers = field_1_seriesNumbers ; return rec ; } public short [ ] getSeriesNumbers ( ) { return field_1_seriesNumbers ; } public void setSeriesNumbers ( short [ ] field_1_seriesNumbers ) { this . field_1_seriesNumbers = field_1_seriesNumbers ; } } 	0
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class AddPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x03 ; private final static String ADD = "+" ; public AddPtg ( ) { } public AddPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "+" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( ADD ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new AddPtg ( ) ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; public class DirectoryNode extends EntryNode implements DirectoryEntry , POIFSViewable { private Map _entries ; private POIFSFileSystem _filesystem ; private POIFSDocumentPath _path ; DirectoryNode ( final DirectoryProperty property , final POIFSFileSystem filesystem , final DirectoryNode parent ) { super ( property , parent ) ; if ( parent == null ) { _path = new POIFSDocumentPath ( ) ; } else { _path = new POIFSDocumentPath ( parent . _path , new String [ ] { property . getName ( ) } ) ; } _filesystem = filesystem ; _entries = new HashMap ( ) ; Iterator iter = property . getChildren ( ) ; while ( iter . hasNext ( ) ) { Property child = ( Property ) iter . next ( ) ; Entry childNode = null ; if ( child . isDirectory ( ) ) { childNode = new DirectoryNode ( ( DirectoryProperty ) child , _filesystem , this ) ; } else { childNode = new DocumentNode ( ( DocumentProperty ) child , this ) ; } _entries . put ( childNode . getName ( ) , childNode ) ; } } public POIFSDocumentPath getPath ( ) { return _path ; } DocumentEntry createDocument ( final POIFSDocument document ) throws IOException { DocumentProperty property = document . getDocumentProperty ( ) ; DocumentNode rval = new DocumentNode ( property , this ) ; ( ( DirectoryProperty ) getProperty ( ) ) . addChild ( property ) ; _filesystem . addDocument ( document ) ; _entries . put ( property . getName ( ) , rval ) ; return rval ; } boolean changeName ( final String oldName , final String newName ) { boolean rval = false ; EntryNode child = ( EntryNode ) _entries . get ( oldName ) ; if ( child != null ) { rval = ( ( DirectoryProperty ) getProperty ( ) ) . changeName ( child . getProperty ( ) , newName ) ; if ( rval ) { _entries . remove ( oldName ) ; _entries . put ( child . getProperty ( ) . getName ( ) , child ) ; } } return rval ; } boolean deleteEntry ( final EntryNode entry ) { boolean rval = ( ( DirectoryProperty ) getProperty ( ) ) . deleteChild ( entry . getProperty ( ) ) ; if ( rval ) { _entries . remove ( entry . getName ( ) ) ; _filesystem . remove ( entry ) ; } return rval ; } public Iterator getEntries ( ) { return _entries . values ( ) . iterator ( ) ; } public boolean isEmpty ( ) { return _entries . isEmpty ( ) ; } public int getEntryCount ( ) { return _entries . size ( ) ; } public Entry getEntry ( final String name ) throws FileNotFoundException { Entry rval = null ; if ( name != null ) { rval = ( Entry ) _entries . get ( name ) ; } if ( rval == null ) { throw new FileNotFoundException ( "no such entry: \"" + name + "\"" ) ; } return rval ; } public DocumentEntry createDocument ( final String name , final InputStream stream ) throws IOException { return createDocument ( new POIFSDocument ( name , stream ) ) ; } public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException { return createDocument ( new POIFSDocument ( name , size , _path , writer ) ) ; } public DirectoryEntry createDirectory ( final String name ) throws IOException { DirectoryProperty property = new DirectoryProperty ( name ) ; DirectoryNode rval = new DirectoryNode ( property , _filesystem , this ) ; ( ( DirectoryProperty ) getProperty ( ) ) . addChild ( property ) ; _filesystem . addDirectory ( property ) ; _entries . put ( name , rval ) ; return rval ; } public ClassID getStorageClsid ( ) { return getProperty ( ) . getStorageClsid ( ) ; } public void setStorageClsid ( ClassID clsidStorage ) { getProperty ( ) . setStorageClsid ( clsidStorage ) ; } public boolean isDirectoryEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return isEmpty ( ) ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; SortedMap sortedEntries = new TreeMap ( _entries ) ; Iterator iter = sortedEntries . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { components . add ( iter . next ( ) ) ; } return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1
package org . apache . poi . dev ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import java . io . File ; public class RecordGenerator { public static void main ( String [ ] args ) throws Exception { Class . forName ( "org.apache.poi.generator.FieldIterator" ) ; if ( args . length != 4 ) { System . out . println ( "Usage:" ) ; System . out . println ( "  java org.apache.poi.hssf.util.RecordGenerator RECORD_DEFINTIONS RECORD_STYLES DEST_SRC_PATH TEST_SRC_PATH" ) ; } else { generateRecords ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; } } private static void generateRecords ( String defintionsDir , String recordStyleDir , String destSrcPathDir , String testSrcPathDir ) throws Exception { File definitionsFile = new File ( defintionsDir ) ; for ( int i = 0 ; i < definitionsFile . listFiles ( ) . length ; i ++ ) { File file = definitionsFile . listFiles ( ) [ i ] ; if ( file . isFile ( ) && ( file . getName ( ) . endsWith ( "_record.xml" ) || file . getName ( ) . endsWith ( "_type.xml" ) ) ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( file ) ; Element record = document . getDocumentElement ( ) ; String extendstg = record . getElementsByTagName ( "extends" ) . item ( 0 ) . getFirstChild ( ) . getNodeValue ( ) ; String suffix = record . getElementsByTagName ( "suffix" ) . item ( 0 ) . getFirstChild ( ) . getNodeValue ( ) ; String recordName = record . getAttributes ( ) . getNamedItem ( "name" ) . getNodeValue ( ) ; String packageName = record . getAttributes ( ) . getNamedItem ( "package" ) . getNodeValue ( ) ; packageName = packageName . replace ( '.' , '/' ) ; String destinationPath = destSrcPathDir + "/" + packageName ; File destinationPathFile = new File ( destinationPath ) ; destinationPathFile . mkdirs ( ) ; String destinationFilepath = destinationPath + "/" + recordName + suffix + ".java" ; String args [ ] = new String [ ] { "-in" , file . getAbsolutePath ( ) , "-xsl" , recordStyleDir + "/" + extendstg . toLowerCase ( ) + ".xsl" , "-out" , destinationFilepath , "-TEXT" } ; org . apache . xalan . xslt . Process . main ( args ) ; System . out . println ( "Generated " + suffix + ": " + destinationFilepath ) ; destinationPath = testSrcPathDir + "/" + packageName ; destinationPathFile = new File ( destinationPath ) ; destinationPathFile . mkdirs ( ) ; destinationFilepath = destinationPath + "/Test" + recordName + suffix + ".java" ; if ( new File ( destinationFilepath ) . exists ( ) == false ) { String temp = ( recordStyleDir + "/" + extendstg . toLowerCase ( ) + "_test.xsl" ) ; args = new String [ ] { "-in" , file . getAbsolutePath ( ) , "-xsl" , temp , "-out" , destinationFilepath , "-TEXT" } ; org . apache . xalan . xslt . Process . main ( args ) ; System . out . println ( "Generated test: " + destinationFilepath ) ; } else { System . out . println ( "Skipped test generation: " + destinationFilepath ) ; } } } } } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class PlotAreaRecord extends Record { public final static short sid = 0x1035 ; public PlotAreaRecord ( ) { } public PlotAreaRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PlotAreaRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a PlotArea record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PLOTAREA]\n" ) ; buffer . append ( "[/PLOTAREA]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { PlotAreaRecord rec = new PlotAreaRecord ( ) ; return rec ; } } 	0
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1
package org . apache . poi . hssf . record ; public interface CellValueRecordInterface { public int getRow ( ) ; public short getColumn ( ) ; public void setRow ( int row ) ; public void setColumn ( short col ) ; public void setXFIndex ( short xf ) ; public short getXFIndex ( ) ; public boolean isBefore ( CellValueRecordInterface i ) ; public boolean isAfter ( CellValueRecordInterface i ) ; public boolean isEqual ( CellValueRecordInterface i ) ; public Object clone ( ) ; } 	0
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DateWindow1904Record extends Record { public final static short sid = 0x22 ; private short field_1_window ; public DateWindow1904Record ( ) { } public DateWindow1904Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DateWindow1904Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A 1904 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_window = LittleEndian . getShort ( data , 0 + offset ) ; } public void setWindowing ( short window ) { field_1_window = window ; } public short getWindowing ( ) { return field_1_window ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[1904]\n" ) ; buffer . append ( "    .is1904          = " ) . append ( Integer . toHexString ( getWindowing ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/1904]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getWindowing ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class RefreshAllRecord extends Record { public final static short sid = 0x1B7 ; private short field_1_refreshall ; public RefreshAllRecord ( ) { } public RefreshAllRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RefreshAllRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A REFRESHALL RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_refreshall = LittleEndian . getShort ( data , 0 + offset ) ; } public void setRefreshAll ( boolean refreshall ) { if ( refreshall ) { field_1_refreshall = 1 ; } else { field_1_refreshall = 0 ; } } public boolean getRefreshAll ( ) { return ( field_1_refreshall == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[REFRESHALL]\n" ) ; buffer . append ( "    .refreshall      = " ) . append ( getRefreshAll ( ) ) . append ( "\n" ) ; buffer . append ( "[/REFRESHALL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_refreshall ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . LittleEndian ; import java . util . Stack ; import java . util . Iterator ; public class LinkedDataFormulaField implements CustomField { Stack formulaTokens = new Stack ( ) ; public int getSize ( ) { int size = 0 ; for ( Iterator iterator = formulaTokens . iterator ( ) ; iterator . hasNext ( ) ; ) { Ptg token = ( Ptg ) iterator . next ( ) ; size += token . getSize ( ) ; } return size + 2 ; } public int fillField ( byte [ ] data , short size , int offset ) { short tokenSize = LittleEndian . getShort ( data , offset ) ; formulaTokens = getParsedExpressionTokens ( data , size , offset + 2 ) ; return tokenSize + 2 ; } public void toString ( StringBuffer buffer ) { for ( int k = 0 ; k < formulaTokens . size ( ) ; k ++ ) { buffer . append ( "Formula " ) . append ( k ) . append ( "=" ) . append ( formulaTokens . get ( k ) . toString ( ) ) . append ( "\n" ) . append ( ( ( Ptg ) formulaTokens . get ( k ) ) . toDebugString ( ) ) . append ( "\n" ) ; } } public String toString ( ) { StringBuffer b = new StringBuffer ( ) ; toString ( b ) ; return b . toString ( ) ; } public int serializeField ( int offset , byte [ ] data ) { int size = getSize ( ) ; LittleEndian . putShort ( data , offset , ( short ) ( size - 2 ) ) ; int pos = offset + 2 ; for ( Iterator iterator = formulaTokens . iterator ( ) ; iterator . hasNext ( ) ; ) { Ptg ptg = ( Ptg ) iterator . next ( ) ; ptg . writeBytes ( data , pos ) ; pos += ptg . getSize ( ) ; } return size ; } public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } private Stack getParsedExpressionTokens ( byte [ ] data , short size , int offset ) { Stack stack = new Stack ( ) ; int pos = offset ; while ( pos < size ) { Ptg ptg = Ptg . createPtg ( data , pos ) ; pos += ptg . getSize ( ) ; stack . push ( ptg ) ; } return stack ; } public void setFormulaTokens ( Stack formulaTokens ) { this . formulaTokens = ( Stack ) formulaTokens . clone ( ) ; } public Stack getFormulaTokens ( ) { return ( Stack ) this . formulaTokens . clone ( ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1
package org . apache . poi . hssf . util ; public class CellReference { private int row ; private int col ; private String sheetName ; private boolean rowAbs ; private boolean colAbs ; public CellReference ( String cellRef ) { String [ ] parts = separateRefParts ( cellRef ) ; sheetName = parts [ 0 ] ; String ref = parts [ 1 ] ; if ( ref . charAt ( 0 ) == '$' ) { colAbs = true ; ref = ref . substring ( 1 ) ; } col = convertColStringToNum ( ref ) ; ref = parts [ 2 ] ; if ( ref . charAt ( 0 ) == '$' ) { rowAbs = true ; ref = ref . substring ( 1 ) ; } row = Integer . parseInt ( ref ) - 1 ; } public CellReference ( int pRow , int pCol ) { this ( pRow , pCol , false , false ) ; } public CellReference ( int pRow , int pCol , boolean pAbsRow , boolean pAbsCol ) { row = pRow ; col = pCol ; rowAbs = pAbsRow ; colAbs = pAbsCol ; } public int getRow ( ) { return row ; } public short getCol ( ) { return ( short ) col ; } public boolean isRowAbsolute ( ) { return rowAbs ; } public boolean isColAbsolute ( ) { return colAbs ; } public String getSheetName ( ) { return sheetName ; } private int convertColStringToNum ( String ref ) { int len = ref . length ( ) ; int retval = 0 ; int pos = 0 ; for ( int k = ref . length ( ) - 1 ; k > - 1 ; k -- ) { char thechar = ref . charAt ( k ) ; if ( pos == 0 ) { retval += ( Character . getNumericValue ( thechar ) - 9 ) ; } else { retval += ( Character . getNumericValue ( thechar ) - 9 ) * ( pos * 26 ) ; } pos ++ ; } return retval - 1 ; } private String [ ] separateRefParts ( String reference ) { String retval [ ] = new String [ 3 ] ; int start = reference . indexOf ( "!" ) ; if ( start != - 1 ) retval [ 0 ] = reference . substring ( 0 , start ) ; start += 1 ; int length = reference . length ( ) ; char [ ] chars = reference . toCharArray ( ) ; int loc = start ; if ( chars [ loc ] == '$' ) loc ++ ; for ( ; loc < chars . length ; loc ++ ) { if ( Character . isDigit ( chars [ loc ] ) || chars [ loc ] == '$' ) { break ; } } retval [ 1 ] = reference . substring ( start , loc ) ; retval [ 2 ] = reference . substring ( loc ) ; return retval ; } private static String convertNumToColString ( int col ) { String retval = null ; int mod = col % 26 ; int div = col / 26 ; char small = ( char ) ( mod + 65 ) ; char big = ( char ) ( div + 64 ) ; if ( div == 0 ) { retval = "" + small ; } else { retval = "" + big + "" + small ; } return retval ; } public String toString ( ) { StringBuffer retval = new StringBuffer ( ) ; retval . append ( ( colAbs ) ? "$" : "" ) ; retval . append ( convertNumToColString ( col ) ) ; retval . append ( ( rowAbs ) ? "$" : "" ) ; retval . append ( row + 1 ) ; return retval . toString ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DeltaRecord extends Record { public final static short sid = 0x10 ; public final static double DEFAULT_VALUE = 0.0010 ; private double field_1_max_change ; public DeltaRecord ( ) { } public DeltaRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DeltaRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A DELTA RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_max_change = LittleEndian . getDouble ( data , 0 + offset ) ; } public void setMaxChange ( double maxChange ) { field_1_max_change = maxChange ; } public double getMaxChange ( ) { return field_1_max_change ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DELTA]\n" ) ; buffer . append ( "    .maxchange      = " ) . append ( getMaxChange ( ) ) . append ( "\n" ) ; buffer . append ( "[/DELTA]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x8 ) ; LittleEndian . putDouble ( data , 4 + offset , getMaxChange ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 12 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { DeltaRecord rec = new DeltaRecord ( ) ; rec . field_1_max_change = field_1_max_change ; return rec ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; public class NumberPtg extends Ptg { public final static int SIZE = 9 ; public final static byte sid = 0x1f ; private double field_1_value ; private NumberPtg ( ) { } public NumberPtg ( byte [ ] data , int offset ) { setValue ( LittleEndian . getDouble ( data , offset + 1 ) ) ; } public NumberPtg ( String value ) { setValue ( Double . parseDouble ( value ) ) ; } public void setValue ( double value ) { field_1_value = value ; } public double getValue ( ) { return field_1_value ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; LittleEndian . putDouble ( array , offset + 1 , getValue ( ) ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return "" + getValue ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { NumberPtg ptg = new NumberPtg ( ) ; ptg . field_1_value = field_1_value ; return ptg ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1
package org . apache . poi . hpsf ; public class MarkUnsupportedException extends HPSFException { public MarkUnsupportedException ( ) { super ( ) ; } public MarkUnsupportedException ( final String msg ) { super ( msg ) ; } public MarkUnsupportedException ( final Throwable reason ) { super ( reason ) ; } public MarkUnsupportedException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndianConsts ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; class SSTRecordSizeCalculator { private UnicodeString unistr = null ; private int stringReminant = 0 ; private int unipos = 0 ; private boolean isRemainingString = false ; private int totalBytesWritten = 0 ; private boolean finished = false ; private boolean firstRecord = true ; private int totalWritten = 0 ; private int recordSize = 0 ; private List recordLengths = new ArrayList ( ) ; private int pos = 0 ; private Map strings ; public SSTRecordSizeCalculator ( Map strings ) { this . strings = strings ; } public int getRecordSize ( ) { initVars ( ) ; int retval ; int totalStringSpaceRequired = SSTSerializer . calculateUnicodeSize ( strings ) ; if ( totalStringSpaceRequired > SSTRecord . MAX_DATA_SPACE ) { retval = sizeOverContinuation ( totalStringSpaceRequired ) ; } else { retval = SSTRecord . SST_RECORD_OVERHEAD + totalStringSpaceRequired ; recordLengths . add ( new Integer ( totalStringSpaceRequired ) ) ; } return retval ; } public List getRecordLengths ( ) { return recordLengths ; } private int sizeOverContinuation ( int totalStringSpaceRequired ) { int retval ; while ( ! finished ) { recordSize = 0 ; pos = 0 ; if ( firstRecord ) { addMaxLengthRecordSize ( ) ; } else { pos = 0 ; int toBeWritten = ( totalStringSpaceRequired - totalBytesWritten ) + ( isRemainingString ? 1 : 0 ) ; int size = Math . min ( SSTRecord . MAX_RECORD_SIZE - SSTRecord . STD_RECORD_OVERHEAD , toBeWritten ) ; if ( size == toBeWritten ) { finished = true ; } recordSize = size + SSTRecord . STD_RECORD_OVERHEAD ; recordLengths . add ( new Integer ( size ) ) ; pos = 4 ; } if ( isRemainingString ) { calcReminant ( ) ; } calcRemainingStrings ( ) ; totalWritten += recordSize ; } retval = totalWritten ; return retval ; } private void addMaxLengthRecordSize ( ) { recordSize = SSTRecord . MAX_RECORD_SIZE ; pos = 12 ; firstRecord = false ; recordLengths . add ( new Integer ( recordSize - SSTRecord . STD_RECORD_OVERHEAD ) ) ; } private void calcRemainingStrings ( ) { for ( ; unipos < strings . size ( ) ; unipos ++ ) { int available = SSTRecord . MAX_RECORD_SIZE - pos ; Integer intunipos = new Integer ( unipos ) ; unistr = ( ( UnicodeString ) strings . get ( intunipos ) ) ; if ( unistr . getRecordSize ( ) <= available ) { totalBytesWritten += unistr . getRecordSize ( ) ; pos += unistr . getRecordSize ( ) ; } else { if ( available >= SSTRecord . STRING_MINIMAL_OVERHEAD ) { int toBeWritten = unistr . maxBrokenLength ( available ) ; totalBytesWritten += toBeWritten ; stringReminant = ( unistr . getRecordSize ( ) - toBeWritten ) + LittleEndianConsts . BYTE_SIZE ; if ( available != toBeWritten ) { int shortrecord = recordSize - ( available - toBeWritten ) ; recordLengths . set ( recordLengths . size ( ) - 1 , new Integer ( shortrecord - SSTRecord . STD_RECORD_OVERHEAD ) ) ; recordSize = shortrecord ; } isRemainingString = true ; unipos ++ ; } else { int shortrecord = recordSize - available ; recordLengths . set ( recordLengths . size ( ) - 1 , new Integer ( shortrecord - SSTRecord . STD_RECORD_OVERHEAD ) ) ; recordSize = shortrecord ; } break ; } } } private void calcReminant ( ) { int available = SSTRecord . MAX_RECORD_SIZE - pos ; if ( stringReminant <= available ) { totalBytesWritten += stringReminant - 1 ; pos += stringReminant ; isRemainingString = false ; } else { int toBeWritten = unistr . maxBrokenLength ( available ) ; if ( available != toBeWritten ) { int shortrecord = recordSize - ( available - toBeWritten ) ; recordLengths . set ( recordLengths . size ( ) - 1 , new Integer ( shortrecord - SSTRecord . STD_RECORD_OVERHEAD ) ) ; recordSize = shortrecord ; } totalBytesWritten += toBeWritten - 1 ; pos += toBeWritten ; stringReminant -= toBeWritten - 1 ; isRemainingString = true ; } } private void initVars ( ) { unistr = null ; stringReminant = 0 ; unipos = 0 ; isRemainingString = false ; totalBytesWritten = 0 ; finished = false ; firstRecord = true ; totalWritten = 0 ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class UnitsRecord extends Record { public final static short sid = 0x1001 ; private short field_1_units ; public UnitsRecord ( ) { } public UnitsRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public UnitsRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Units record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_units = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[UNITS]\n" ) ; buffer . append ( "    .units                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getUnits ( ) ) ) . append ( " (" ) . append ( getUnits ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/UNITS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_units ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { UnitsRecord rec = new UnitsRecord ( ) ; rec . field_1_units = field_1_units ; return rec ; } public short getUnits ( ) { return field_1_units ; } public void setUnits ( short field_1_units ) { this . field_1_units = field_1_units ; } } 	0
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class DividePtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x06 ; public DividePtg ( ) { } public DividePtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "/" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { DividePtg ptg = new DividePtg ( ) ; return ptg ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hpsf ; public class HPSFException extends Exception { private Throwable reason ; public HPSFException ( ) { super ( ) ; } public HPSFException ( final String msg ) { super ( msg ) ; } public HPSFException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HPSFException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; public class BoundSheetRecord extends Record { public final static short sid = 0x85 ; private int field_1_position_of_BOF ; private short field_2_option_flags ; private byte field_3_sheetname_length ; private byte field_4_compressed_unicode_flag ; private String field_5_sheetname ; public BoundSheetRecord ( ) { } public BoundSheetRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BoundSheetRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Bound Sheet RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_position_of_BOF = LittleEndian . getInt ( data , 0 + offset ) ; field_2_option_flags = LittleEndian . getShort ( data , 4 + offset ) ; field_3_sheetname_length = data [ 6 + offset ] ; field_4_compressed_unicode_flag = data [ 7 + offset ] ; int nameLength = LittleEndian . ubyteToInt ( field_3_sheetname_length ) ; if ( ( field_4_compressed_unicode_flag & 0x01 ) == 1 ) { field_5_sheetname = StringUtil . getFromUnicodeHigh ( data , 8 + offset , nameLength ) ; } else { field_5_sheetname = StringUtil . getFromCompressedUnicode ( data , 8 + offset , nameLength ) ; } } public void setPositionOfBof ( int pos ) { field_1_position_of_BOF = pos ; } public void setOptionFlags ( short flags ) { field_2_option_flags = flags ; } public void setSheetnameLength ( byte len ) { field_3_sheetname_length = len ; } public void setCompressedUnicodeFlag ( byte flag ) { field_4_compressed_unicode_flag = flag ; } public void setSheetname ( String sheetname ) { if ( ( sheetname == null ) || ( sheetname . length ( ) == 0 ) || ( sheetname . length ( ) > 31 ) || ( sheetname . indexOf ( "/" ) > - 1 ) || ( sheetname . indexOf ( "\\" ) > - 1 ) || ( sheetname . indexOf ( "?" ) > - 1 ) || ( sheetname . indexOf ( "*" ) > - 1 ) || ( sheetname . indexOf ( "]" ) > - 1 ) || ( sheetname . indexOf ( "[" ) > - 1 ) ) { throw new IllegalArgumentException ( "Sheet name cannot be blank, greater than 31 chars, or contain any of /\\*?[]" ) ; } field_5_sheetname = sheetname ; } public int getPositionOfBof ( ) { return field_1_position_of_BOF ; } public short getOptionFlags ( ) { return field_2_option_flags ; } public byte getSheetnameLength ( ) { return field_3_sheetname_length ; } public byte getRawSheetnameLength ( ) { return ( byte ) ( ( ( field_4_compressed_unicode_flag & 0x01 ) == 1 ) ? 2 * field_3_sheetname_length : field_3_sheetname_length ) ; } public byte getCompressedUnicodeFlag ( ) { return field_4_compressed_unicode_flag ; } public String getSheetname ( ) { return field_5_sheetname ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOUNDSHEET]\n" ) ; buffer . append ( "    .bof             = " ) . append ( Integer . toHexString ( getPositionOfBof ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .optionflags     = " ) . append ( Integer . toHexString ( getOptionFlags ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .sheetname length= " ) . append ( Integer . toHexString ( getSheetnameLength ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .unicodeflag     = " ) . append ( Integer . toHexString ( getCompressedUnicodeFlag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .sheetname       = " ) . append ( getSheetname ( ) ) . append ( "\n" ) ; buffer . append ( "[/BOUNDSHEET]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 8 + getRawSheetnameLength ( ) ) ) ; LittleEndian . putInt ( data , 4 + offset , getPositionOfBof ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getOptionFlags ( ) ) ; data [ 10 + offset ] = ( byte ) ( getSheetnameLength ( ) ) ; data [ 11 + offset ] = getCompressedUnicodeFlag ( ) ; if ( ( field_4_compressed_unicode_flag & 0x01 ) == 1 ) StringUtil . putUncompressedUnicode ( getSheetname ( ) , data , 12 + offset ) ; else StringUtil . putCompressedUnicode ( getSheetname ( ) , data , 12 + offset ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 12 + getRawSheetnameLength ( ) ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . hssf . record ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class SelectionRecord extends Record { public final static short sid = 0x1d ; private byte field_1_pane ; private int field_2_row_active_cell ; private short field_3_col_active_cell ; private short field_4_ref_active_cell ; private short field_5_num_refs ; private ArrayList field_6_refs ; public SelectionRecord ( ) { } public SelectionRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SelectionRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid Selection RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_pane = data [ 0 + offset ] ; field_2_row_active_cell = LittleEndian . getUShort ( data , 1 + offset ) ; field_3_col_active_cell = LittleEndian . getShort ( data , 3 + offset ) ; field_4_ref_active_cell = LittleEndian . getShort ( data , 5 + offset ) ; field_5_num_refs = LittleEndian . getShort ( data , 7 + offset ) ; } public void setPane ( byte pane ) { field_1_pane = pane ; } public void setActiveCellRow ( int row ) { field_2_row_active_cell = row ; } public void setActiveCellCol ( short col ) { field_3_col_active_cell = col ; } public void setActiveCellRef ( short ref ) { field_4_ref_active_cell = ref ; } public void setNumRefs ( short refs ) { field_5_num_refs = refs ; } public byte getPane ( ) { return field_1_pane ; } public int getActiveCellRow ( ) { return field_2_row_active_cell ; } public short getActiveCellCol ( ) { return field_3_col_active_cell ; } public short getActiveCellRef ( ) { return field_4_ref_active_cell ; } public short getNumRefs ( ) { return field_5_num_refs ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SELECTION]\n" ) ; buffer . append ( "    .pane            = " ) . append ( Integer . toHexString ( getPane ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .activecellrow   = " ) . append ( Integer . toHexString ( getActiveCellRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .activecellcol   = " ) . append ( Integer . toHexString ( getActiveCellCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .activecellref   = " ) . append ( Integer . toHexString ( getActiveCellRef ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .numrefs         = " ) . append ( Integer . toHexString ( getNumRefs ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/SELECTION]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 15 ) ; data [ 4 + offset ] = getPane ( ) ; LittleEndian . putShort ( data , 5 + offset , ( short ) getActiveCellRow ( ) ) ; LittleEndian . putShort ( data , 7 + offset , getActiveCellCol ( ) ) ; LittleEndian . putShort ( data , 9 + offset , getActiveCellRef ( ) ) ; LittleEndian . putShort ( data , 11 + offset , ( short ) 1 ) ; LittleEndian . putShort ( data , 13 + offset , ( short ) getActiveCellRow ( ) ) ; LittleEndian . putShort ( data , 15 + offset , ( short ) getActiveCellRow ( ) ) ; data [ 17 + offset ] = ( byte ) getActiveCellCol ( ) ; data [ 18 + offset ] = ( byte ) getActiveCellCol ( ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 19 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SelectionRecord rec = new SelectionRecord ( ) ; rec . field_1_pane = field_1_pane ; rec . field_2_row_active_cell = field_2_row_active_cell ; rec . field_3_col_active_cell = field_3_col_active_cell ; rec . field_4_ref_active_cell = field_4_ref_active_cell ; rec . field_5_num_refs = field_5_num_refs ; rec . field_6_refs = field_6_refs ; return rec ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . util ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . * ; public class POILogFactory { private static Map _loggers = new HashMap ( ) ; ; private POILogFactory ( ) { } public static POILogger getLogger ( final Class theclass ) { return getLogger ( theclass . getName ( ) ) ; } public static POILogger getLogger ( final String cat ) { POILogger logger = null ; if ( _loggers . containsKey ( cat ) ) { logger = ( POILogger ) _loggers . get ( cat ) ; } else { try { String loggerClassName = System . getProperty ( "org.apache.poi.util.POILogger" ) ; Class loggerClass = Class . forName ( loggerClassName ) ; logger = ( POILogger ) loggerClass . newInstance ( ) ; } catch ( Exception e ) { logger = new NullLogger ( ) ; } logger . initialize ( cat ) ; _loggers . put ( cat , logger ) ; } return logger ; } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BoolErrRecord extends Record implements CellValueRecordInterface , Comparable { public final static short sid = 0x205 ; private int field_1_row ; private short field_2_column ; private short field_3_xf_index ; private byte field_4_bBoolErr ; private byte field_5_fError ; public BoolErrRecord ( ) { } public BoolErrRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BoolErrRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_column = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_bBoolErr = data [ 6 + offset ] ; field_5_fError = data [ 7 + offset ] ; } public void setRow ( int row ) { field_1_row = row ; } public void setColumn ( short col ) { field_2_column = col ; } public void setXFIndex ( short xf ) { field_3_xf_index = xf ; } public void setValue ( boolean value ) { field_4_bBoolErr = value ? ( byte ) 1 : ( byte ) 0 ; field_5_fError = ( byte ) 0 ; } public void setValue ( byte value ) { if ( ( value == 0 ) || ( value == 7 ) || ( value == 15 ) || ( value == 23 ) || ( value == 29 ) || ( value == 36 ) || ( value == 42 ) ) { field_4_bBoolErr = value ; field_5_fError = ( byte ) 1 ; } else { throw new RuntimeException ( "Error Value can only be 0,7,15,23,29,36 or 42. It cannot be " + value ) ; } } public int getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_column ; } public short getXFIndex ( ) { return field_3_xf_index ; } public boolean getBooleanValue ( ) { return ( field_4_bBoolErr != 0 ) ; } public byte getErrorValue ( ) { return field_4_bBoolErr ; } public boolean isBoolean ( ) { return ( field_5_fError == ( byte ) 0 ) ; } public void setError ( boolean val ) { field_5_fError = ( byte ) ( val == false ? 0 : 1 ) ; } public boolean isError ( ) { return ( field_5_fError != ( byte ) 0 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOOLERR]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .col            = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; if ( isBoolean ( ) ) { buffer . append ( "    .booleanValue   = " ) . append ( getBooleanValue ( ) ) . append ( "\n" ) ; } else { buffer . append ( "    .errorValue     = " ) . append ( getErrorValue ( ) ) . append ( "\n" ) ; } buffer . append ( "[/BOOLERR]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 8 ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; data [ 10 + offset ] = field_4_bBoolErr ; data [ 11 + offset ] = field_5_fError ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 12 ; } protected void validateSid ( short id ) { if ( id != this . sid ) { throw new RecordFormatException ( "Not a valid BoolErrRecord" ) ; } } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } public Object clone ( ) { BoolErrRecord rec = new BoolErrRecord ( ) ; rec . field_1_row = field_1_row ; rec . field_2_column = field_2_column ; rec . field_3_xf_index = field_3_xf_index ; rec . field_4_bBoolErr = field_4_bBoolErr ; rec . field_5_fError = field_5_fError ; return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class FrameRecord extends Record { public final static short sid = 0x1032 ; private short field_1_borderType ; public final static short BORDER_TYPE_REGULAR = 0 ; public final static short BORDER_TYPE_SHADOW = 1 ; private short field_2_options ; private BitField autoSize = new BitField ( 0x1 ) ; private BitField autoPosition = new BitField ( 0x2 ) ; public FrameRecord ( ) { } public FrameRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FrameRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Frame record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_borderType = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_options = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FRAME]\n" ) ; buffer . append ( "    .borderType           = " ) . append ( "0x" ) . append ( HexDump . toHex ( getBorderType ( ) ) ) . append ( " (" ) . append ( getBorderType ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .autoSize                 = " ) . append ( isAutoSize ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoPosition             = " ) . append ( isAutoPosition ( ) ) . append ( '\n' ) ; buffer . append ( "[/FRAME]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_borderType ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { FrameRecord rec = new FrameRecord ( ) ; rec . field_1_borderType = field_1_borderType ; rec . field_2_options = field_2_options ; return rec ; } public short getBorderType ( ) { return field_1_borderType ; } public void setBorderType ( short field_1_borderType ) { this . field_1_borderType = field_1_borderType ; } public short getOptions ( ) { return field_2_options ; } public void setOptions ( short field_2_options ) { this . field_2_options = field_2_options ; } public void setAutoSize ( boolean value ) { field_2_options = autoSize . setShortBoolean ( field_2_options , value ) ; } public boolean isAutoSize ( ) { return autoSize . isSet ( field_2_options ) ; } public void setAutoPosition ( boolean value ) { field_2_options = autoPosition . setShortBoolean ( field_2_options , value ) ; } public boolean isAutoPosition ( ) { return autoPosition . isSet ( field_2_options ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class GridsetRecord extends Record { public final static short sid = 0x82 ; public short field_1_gridset_flag ; public GridsetRecord ( ) { } public GridsetRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public GridsetRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Gridset RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_gridset_flag = LittleEndian . getShort ( data , 0 + offset ) ; } public void setGridset ( boolean gridset ) { if ( gridset == true ) { field_1_gridset_flag = 1 ; } else { field_1_gridset_flag = 0 ; } } public boolean getGridset ( ) { return ( field_1_gridset_flag == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[GRIDSET]\n" ) ; buffer . append ( "    .gridset        = " ) . append ( getGridset ( ) ) . append ( "\n" ) ; buffer . append ( "[/GRIDSET]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_gridset_flag ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { GridsetRecord rec = new GridsetRecord ( ) ; rec . field_1_gridset_flag = field_1_gridset_flag ; return rec ; } } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LongField ; import org . apache . poi . util . ShortField ; public interface HeaderBlockConstants { public static final long _signature = 0xE11AB1A1E011CFD0L ; public static final int _bat_array_offset = 0x4c ; public static final int _max_bats_in_header = ( POIFSConstants . BIG_BLOCK_SIZE - _bat_array_offset ) / LittleEndianConsts . INT_SIZE ; public static final int _signature_offset = 0 ; public static final int _bat_count_offset = 0x2C ; public static final int _property_start_offset = 0x30 ; public static final int _sbat_start_offset = 0x3C ; public static final int _sbat_block_count_offset = 0x40 ; public static final int _xbat_start_offset = 0x44 ; public static final int _xbat_count_offset = 0x48 ; } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; public class FuncPtg extends AbstractFunctionPtg { public final static byte sid = 0x21 ; public final static int SIZE = 3 ; private int numParams = 0 ; private FuncPtg ( ) { } public FuncPtg ( byte [ ] data , int offset ) { offset ++ ; field_2_fnc_index = LittleEndian . getShort ( data , offset + 0 ) ; try { numParams = ( ( Integer ) functionData [ field_2_fnc_index ] [ 2 ] ) . intValue ( ) ; } catch ( NullPointerException npe ) { numParams = 0 ; } } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_2_fnc_index ) ; } public int getNumberOfOperands ( ) { return numParams ; } public Object clone ( ) { FuncPtg ptg = new FuncPtg ( ) ; ptg . field_2_fnc_index = field_2_fnc_index ; ptg . setClass ( ptgClass ) ; return ptg ; } public int getSize ( ) { return SIZE ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   numArgs(internal)=" ) . append ( this . numParams ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1
package org . apache . poi . hssf . dev ; import java . io . InputStream ; import java . io . IOException ; import java . io . ByteArrayInputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . util . List ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . HexDump ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . * ; import org . apache . poi . hssf . model . * ; import org . apache . poi . hssf . usermodel . * ; public class FormulaViewer { private String file ; private boolean list = false ; public FormulaViewer ( ) { } public void run ( ) throws Exception { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( file ) ) ; List records = RecordFactory . createRecords ( fs . createDocumentInputStream ( "Workbook" ) ) ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( Record ) records . get ( k ) ; if ( record . getSid ( ) == FormulaRecord . sid ) { if ( list ) { listFormula ( ( FormulaRecord ) record ) ; } else { parseFormulaRecord ( ( FormulaRecord ) record ) ; } } } } private void listFormula ( FormulaRecord record ) { String sep = "~" ; List tokens = record . getParsedExpression ( ) ; int numptgs = record . getNumberOfExpressionTokens ( ) ; Ptg token = null ; String name , numArg ; if ( tokens != null ) { token = ( Ptg ) tokens . get ( numptgs - 1 ) ; if ( token instanceof FuncPtg ) { numArg = String . valueOf ( numptgs - 1 ) ; } else { numArg = String . valueOf ( - 1 ) ; } StringBuffer buf = new StringBuffer ( ) ; if ( token instanceof ExpPtg ) return ; buf . append ( name = ( ( OperationPtg ) token ) . toFormulaString ( ( Workbook ) null ) ) ; buf . append ( sep ) ; switch ( token . getPtgClass ( ) ) { case Ptg . CLASS_REF : buf . append ( "REF" ) ; break ; case Ptg . CLASS_VALUE : buf . append ( "VALUE" ) ; break ; case Ptg . CLASS_ARRAY : buf . append ( "ARRAY" ) ; break ; } buf . append ( sep ) ; if ( numptgs > 1 ) { token = ( Ptg ) tokens . get ( numptgs - 2 ) ; switch ( token . getPtgClass ( ) ) { case Ptg . CLASS_REF : buf . append ( "REF" ) ; break ; case Ptg . CLASS_VALUE : buf . append ( "VALUE" ) ; break ; case Ptg . CLASS_ARRAY : buf . append ( "ARRAY" ) ; break ; } } else { buf . append ( "VALUE" ) ; } buf . append ( sep ) ; buf . append ( numArg ) ; System . out . println ( buf . toString ( ) ) ; } else { System . out . println ( "#NAME" ) ; } } public void parseFormulaRecord ( FormulaRecord record ) { System . out . println ( "==============================" ) ; System . out . print ( "row = " + record . getRow ( ) ) ; System . out . println ( ", col = " + record . getColumn ( ) ) ; System . out . println ( "value = " + record . getValue ( ) ) ; System . out . print ( "xf = " + record . getXFIndex ( ) ) ; System . out . print ( ", number of ptgs = " + record . getNumberOfExpressionTokens ( ) ) ; System . out . println ( ", options = " + record . getOptions ( ) ) ; System . out . println ( "RPN List = " + formulaString ( record ) ) ; System . out . println ( "Formula text = " + composeFormula ( record ) ) ; } private String formulaString ( FormulaRecord record ) { StringBuffer formula = new StringBuffer ( "=" ) ; int numptgs = record . getNumberOfExpressionTokens ( ) ; List tokens = record . getParsedExpression ( ) ; Ptg token ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < numptgs ; i ++ ) { token = ( Ptg ) tokens . get ( i ) ; buf . append ( token . toFormulaString ( ( Workbook ) null ) ) ; switch ( token . getPtgClass ( ) ) { case Ptg . CLASS_REF : buf . append ( "(R)" ) ; break ; case Ptg . CLASS_VALUE : buf . append ( "(V)" ) ; break ; case Ptg . CLASS_ARRAY : buf . append ( "(A)" ) ; break ; } buf . append ( ' ' ) ; } return buf . toString ( ) ; } private String composeFormula ( FormulaRecord record ) { return org . apache . poi . hssf . model . FormulaParser . toFormulaString ( ( Workbook ) null , record . getParsedExpression ( ) ) ; } public void setFile ( String file ) { this . file = file ; } public void setList ( boolean list ) { this . list = list ; } public static void main ( String args [ ] ) { if ( ( args == null ) || ( args . length > 2 ) || args [ 0 ] . equals ( "--help" ) ) { System . out . println ( "FormulaViewer .8 proof that the devil lies in the details (or just in BIFF8 files in general)" ) ; System . out . println ( "usage: Give me a big fat file name" ) ; } else if ( args [ 0 ] . equals ( "--listFunctions" ) ) { try { FormulaViewer viewer = new FormulaViewer ( ) ; viewer . setFile ( args [ 1 ] ) ; viewer . setList ( true ) ; viewer . run ( ) ; } catch ( Exception e ) { System . out . println ( "Whoops!" ) ; e . printStackTrace ( ) ; } } else { try { FormulaViewer viewer = new FormulaViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( Exception e ) { System . out . println ( "Whoops!" ) ; e . printStackTrace ( ) ; } } } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BinaryTree ; import java . util . List ; import java . util . ArrayList ; import java . util . Map ; class SSTSerializer { private List recordLengths ; private BinaryTree strings ; private int numStrings ; private int numUniqueStrings ; private SSTRecordHeader sstRecordHeader ; int [ ] bucketAbsoluteOffsets ; int [ ] bucketRelativeOffsets ; int startOfSST , startOfRecord ; public SSTSerializer ( List recordLengths , BinaryTree strings , int numStrings , int numUniqueStrings ) { this . recordLengths = recordLengths ; this . strings = strings ; this . numStrings = numStrings ; this . numUniqueStrings = numUniqueStrings ; this . sstRecordHeader = new SSTRecordHeader ( numStrings , numUniqueStrings ) ; int infoRecs = ExtSSTRecord . getNumberOfInfoRecsForStrings ( strings . size ( ) ) ; this . bucketAbsoluteOffsets = new int [ infoRecs ] ; this . bucketRelativeOffsets = new int [ infoRecs ] ; } public int serialize ( int record_size , int offset , byte [ ] data ) { int record_length_index = 0 ; if ( calculateUnicodeSize ( ) > SSTRecord . MAX_DATA_SPACE ) serializeLargeRecord ( record_size , record_length_index , data , offset ) ; else serializeSingleSSTRecord ( data , offset , record_length_index ) ; return record_size ; } public static int calculateUnicodeSize ( Map strings ) { int retval = 0 ; for ( int k = 0 ; k < strings . size ( ) ; k ++ ) { retval += getUnicodeString ( strings , k ) . getRecordSize ( ) ; } return retval ; } public int calculateUnicodeSize ( ) { return calculateUnicodeSize ( strings ) ; } private void serializeSingleSSTRecord ( byte [ ] data , int offset , int record_length_index ) { int len = ( ( Integer ) recordLengths . get ( record_length_index ) ) . intValue ( ) ; int recordSize = SSTRecord . SST_RECORD_OVERHEAD + len - SSTRecord . STD_RECORD_OVERHEAD ; sstRecordHeader . writeSSTHeader ( data , 0 + offset , recordSize ) ; int pos = SSTRecord . SST_RECORD_OVERHEAD ; for ( int k = 0 ; k < strings . size ( ) ; k ++ ) { if ( k % ExtSSTRecord . DEFAULT_BUCKET_SIZE == 0 ) { int index = k / ExtSSTRecord . DEFAULT_BUCKET_SIZE ; if ( index < ExtSSTRecord . MAX_BUCKETS ) { bucketAbsoluteOffsets [ index ] = pos ; bucketRelativeOffsets [ index ] = pos ; } } System . arraycopy ( getUnicodeString ( k ) . serialize ( ) , 0 , data , pos + offset , getUnicodeString ( k ) . getRecordSize ( ) ) ; pos += getUnicodeString ( k ) . getRecordSize ( ) ; } } private void serializeLargeRecord ( int record_size , int record_length_index , byte [ ] buffer , int offset ) { startOfSST = offset ; byte [ ] stringReminant = null ; int stringIndex = 0 ; boolean lastneedcontinue = false ; boolean first_record = true ; int totalWritten = 0 ; while ( totalWritten != record_size ) { int recordLength = ( ( Integer ) recordLengths . get ( record_length_index ++ ) ) . intValue ( ) ; RecordProcessor recordProcessor = new RecordProcessor ( buffer , recordLength , numStrings , numUniqueStrings ) ; startOfRecord = offset + totalWritten ; recordProcessor . writeRecordHeader ( offset , totalWritten , recordLength , first_record ) ; first_record = false ; if ( lastneedcontinue ) { lastneedcontinue = stringReminant . length > recordProcessor . getAvailable ( ) ; stringReminant = recordProcessor . writeStringRemainder ( lastneedcontinue , stringReminant , offset , totalWritten ) ; } for ( ; stringIndex < strings . size ( ) ; stringIndex ++ ) { UnicodeString unistr = getUnicodeString ( stringIndex ) ; if ( stringIndex % ExtSSTRecord . DEFAULT_BUCKET_SIZE == 0 ) { int index = stringIndex / ExtSSTRecord . DEFAULT_BUCKET_SIZE ; if ( index < ExtSSTRecord . MAX_BUCKETS ) { bucketAbsoluteOffsets [ index ] = offset + totalWritten + recordProcessor . getRecordOffset ( ) - startOfSST ; bucketRelativeOffsets [ index ] = offset + totalWritten + recordProcessor . getRecordOffset ( ) - startOfRecord ; } } if ( unistr . getRecordSize ( ) <= recordProcessor . getAvailable ( ) ) { recordProcessor . writeWholeString ( unistr , offset , totalWritten ) ; } else { if ( recordProcessor . getAvailable ( ) >= SSTRecord . STRING_MINIMAL_OVERHEAD ) { stringReminant = recordProcessor . writePartString ( unistr , offset , totalWritten ) ; lastneedcontinue = true ; stringIndex ++ ; } break ; } } totalWritten += recordLength + SSTRecord . STD_RECORD_OVERHEAD ; } } private UnicodeString getUnicodeString ( int index ) { return getUnicodeString ( strings , index ) ; } private static UnicodeString getUnicodeString ( Map strings , int index ) { Integer intunipos = new Integer ( index ) ; return ( ( UnicodeString ) strings . get ( intunipos ) ) ; } public int getRecordSize ( ) { SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator ( strings ) ; int recordSize = calculator . getRecordSize ( ) ; recordLengths = calculator . getRecordLengths ( ) ; return recordSize ; } public List getRecordLengths ( ) { return recordLengths ; } public int [ ] getBucketAbsoluteOffsets ( ) { return bucketAbsoluteOffsets ; } public int [ ] getBucketRelativeOffsets ( ) { return bucketRelativeOffsets ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . PrintSetupRecord ; public class HSSFPrintSetup extends Object { public final short LETTER_PAPERSIZE = 1 ; public final short LEGAL_PAPERSIZE = 5 ; public final short EXECUTIVE_PAPERSIZE = 7 ; public final short A4_PAPERSIZE = 9 ; public final short A5_PAPERSIZE = 11 ; public final short ENVELOPE_10_PAPERSIZE = 20 ; public final short ENVELOPE_DL_PAPERSIZE = 27 ; public final short ENVELOPE_CS_PAPERSIZE = 28 ; public final short ENVELOPE_MONARCH_PAPERSIZE = 37 ; PrintSetupRecord printSetupRecord ; protected HSSFPrintSetup ( PrintSetupRecord printSetupRecord ) { this . printSetupRecord = printSetupRecord ; } public void setPaperSize ( short size ) { printSetupRecord . setPaperSize ( size ) ; } public void setScale ( short scale ) { printSetupRecord . setScale ( scale ) ; } public void setPageStart ( short start ) { printSetupRecord . setPageStart ( start ) ; } public void setFitWidth ( short width ) { printSetupRecord . setFitWidth ( width ) ; } public void setFitHeight ( short height ) { printSetupRecord . setFitHeight ( height ) ; } public void setOptions ( short options ) { printSetupRecord . setOptions ( options ) ; } public void setLeftToRight ( boolean ltor ) { printSetupRecord . setLeftToRight ( ltor ) ; } public void setLandscape ( boolean ls ) { printSetupRecord . setLandscape ( ! ls ) ; } public void setValidSettings ( boolean valid ) { printSetupRecord . setValidSettings ( valid ) ; } public void setNoColor ( boolean mono ) { printSetupRecord . setNoColor ( mono ) ; } public void setDraft ( boolean d ) { printSetupRecord . setDraft ( d ) ; } public void setNotes ( boolean printnotes ) { printSetupRecord . setNotes ( printnotes ) ; } public void setNoOrientation ( boolean orientation ) { printSetupRecord . setNoOrientation ( orientation ) ; } public void setUsePage ( boolean page ) { printSetupRecord . setUsePage ( page ) ; } public void setHResolution ( short resolution ) { printSetupRecord . setHResolution ( resolution ) ; } public void setVResolution ( short resolution ) { printSetupRecord . setVResolution ( resolution ) ; } public void setHeaderMargin ( double headermargin ) { printSetupRecord . setHeaderMargin ( headermargin ) ; } public void setFooterMargin ( double footermargin ) { printSetupRecord . setFooterMargin ( footermargin ) ; } public void setCopies ( short copies ) { printSetupRecord . setCopies ( copies ) ; } public short getPaperSize ( ) { return printSetupRecord . getPaperSize ( ) ; } public short getScale ( ) { return printSetupRecord . getScale ( ) ; } public short getPageStart ( ) { return printSetupRecord . getPageStart ( ) ; } public short getFitWidth ( ) { return printSetupRecord . getFitWidth ( ) ; } public short getFitHeight ( ) { return printSetupRecord . getFitHeight ( ) ; } public short getOptions ( ) { return printSetupRecord . getOptions ( ) ; } public boolean getLeftToRight ( ) { return printSetupRecord . getLeftToRight ( ) ; } public boolean getLandscape ( ) { return ! printSetupRecord . getLandscape ( ) ; } public boolean getValidSettings ( ) { return printSetupRecord . getValidSettings ( ) ; } public boolean getNoColor ( ) { return printSetupRecord . getNoColor ( ) ; } public boolean getDraft ( ) { return printSetupRecord . getDraft ( ) ; } public boolean getNotes ( ) { return printSetupRecord . getNotes ( ) ; } public boolean getNoOrientation ( ) { return printSetupRecord . getNoOrientation ( ) ; } public boolean getUsePage ( ) { return printSetupRecord . getUsePage ( ) ; } public short getHResolution ( ) { return printSetupRecord . getHResolution ( ) ; } public short getVResolution ( ) { return printSetupRecord . getVResolution ( ) ; } public double getHeaderMargin ( ) { return printSetupRecord . getHeaderMargin ( ) ; } public double getFooterMargin ( ) { return printSetupRecord . getFooterMargin ( ) ; } public short getCopies ( ) { return printSetupRecord . getCopies ( ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; public class DocumentOutputStream extends OutputStream { private OutputStream stream ; private int limit ; private int written ; DocumentOutputStream ( final OutputStream stream , final int limit ) { this . stream = stream ; this . limit = limit ; this . written = 0 ; } public void write ( final int b ) throws IOException { limitCheck ( 1 ) ; stream . write ( b ) ; } public void write ( final byte b [ ] ) throws IOException { write ( b , 0 , b . length ) ; } public void write ( final byte b [ ] , final int off , final int len ) throws IOException { limitCheck ( len ) ; stream . write ( b , off , len ) ; } public void flush ( ) throws IOException { stream . flush ( ) ; } public void close ( ) throws IOException { } void writeFiller ( final int totalLimit , final byte fill ) throws IOException { if ( totalLimit > written ) { byte [ ] filler = new byte [ totalLimit - written ] ; Arrays . fill ( filler , fill ) ; stream . write ( filler ) ; } } private void limitCheck ( final int toBeWritten ) throws IOException { if ( ( written + toBeWritten ) > limit ) { throw new IOException ( "tried to write too much data" ) ; } written += toBeWritten ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; public class IndexRecord extends Record { public final static short sid = 0x20B ; public final static int DBCELL_CAPACITY = 30 ; public int field_1_zero ; public int field_2_first_row ; public int field_3_last_row_add1 ; public int field_4_zero ; public IntList field_5_dbcells ; public IndexRecord ( ) { } public IndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public IndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Index RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_5_dbcells = new IntList ( DBCELL_CAPACITY ) ; field_1_zero = LittleEndian . getInt ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getInt ( data , 4 + offset ) ; field_3_last_row_add1 = LittleEndian . getInt ( data , 8 + offset ) ; field_4_zero = LittleEndian . getInt ( data , 12 + offset ) ; for ( int k = 16 ; k < size ; k = k + 4 ) { field_5_dbcells . add ( LittleEndian . getInt ( data , k + offset ) ) ; } } public void setFirstRow ( int row ) { field_2_first_row = row ; } public void setLastRowAdd1 ( int row ) { field_3_last_row_add1 = row ; } public void addDbcell ( int cell ) { if ( field_5_dbcells == null ) { field_5_dbcells = new IntList ( ) ; } field_5_dbcells . add ( cell ) ; } public void setDbcell ( int cell , int value ) { field_5_dbcells . set ( cell , value ) ; } public int getFirstRow ( ) { return field_2_first_row ; } public int getLastRowAdd1 ( ) { return field_3_last_row_add1 ; } public int getNumDbcells ( ) { if ( field_5_dbcells == null ) { return 0 ; } return field_5_dbcells . size ( ) ; } public int getDbcellAt ( int cellnum ) { return field_5_dbcells . get ( cellnum ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INDEX]\n" ) ; buffer . append ( "    .firstrow       = " ) . append ( Integer . toHexString ( getFirstRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .lastrowadd1    = " ) . append ( Integer . toHexString ( getLastRowAdd1 ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumDbcells ( ) ; k ++ ) { buffer . append ( "    .dbcell_" + k + "       = " ) . append ( Integer . toHexString ( getDbcellAt ( k ) ) ) . append ( "\n" ) ; } buffer . append ( "[/INDEX]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 16 + ( getNumDbcells ( ) * 4 ) ) ) ; LittleEndian . putInt ( data , 4 + offset , 0 ) ; LittleEndian . putInt ( data , 8 + offset , getFirstRow ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getLastRowAdd1 ( ) ) ; LittleEndian . putInt ( data , 16 + offset , 0 ) ; for ( int k = 0 ; k < getNumDbcells ( ) ; k ++ ) { LittleEndian . putInt ( data , ( k * 4 ) + 20 + offset , getDbcellAt ( k ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 + ( getNumDbcells ( ) * 4 ) ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { IndexRecord rec = new IndexRecord ( ) ; rec . field_1_zero = field_1_zero ; rec . field_2_first_row = field_2_first_row ; rec . field_3_last_row_add1 = field_3_last_row_add1 ; rec . field_4_zero = field_4_zero ; rec . field_5_dbcells = new IntList ( ) ; rec . field_5_dbcells . addAll ( field_5_dbcells ) ; return rec ; } } 	0
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class MMSRecord extends Record { public final static short sid = 0xC1 ; private byte field_1_addMenuCount ; private byte field_2_delMenuCount ; public MMSRecord ( ) { } public MMSRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MMSRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A MMS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_addMenuCount = data [ 0 + offset ] ; field_2_delMenuCount = data [ 1 + offset ] ; } public void setAddMenuCount ( byte am ) { field_1_addMenuCount = am ; } public void setDelMenuCount ( byte dm ) { field_2_delMenuCount = dm ; } public byte getAddMenuCount ( ) { return field_1_addMenuCount ; } public byte getDelMenuCount ( ) { return field_2_delMenuCount ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MMS]\n" ) ; buffer . append ( "    .addMenu        = " ) . append ( Integer . toHexString ( getAddMenuCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .delMenu        = " ) . append ( Integer . toHexString ( getDelMenuCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/MMS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; data [ 4 + offset ] = getAddMenuCount ( ) ; data [ 5 + offset ] = getDelMenuCount ( ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . hpsf ; public class UnexpectedPropertySetTypeException extends HPSFException { public UnexpectedPropertySetTypeException ( ) { super ( ) ; } public UnexpectedPropertySetTypeException ( final String msg ) { super ( msg ) ; } public UnexpectedPropertySetTypeException ( final Throwable reason ) { super ( reason ) ; } public UnexpectedPropertySetTypeException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableReader { private IntList _entries ; public BlockAllocationTableReader ( final int block_count , final int [ ] block_array , final int xbat_count , final int xbat_index , final BlockList raw_block_list ) throws IOException { this ( ) ; if ( block_count <= 0 ) { throw new IOException ( "Illegal block count; minimum count is 1, got " + block_count + " instead" ) ; } RawDataBlock blocks [ ] = new RawDataBlock [ block_count ] ; int limit = Math . min ( block_count , block_array . length ) ; int block_index ; for ( block_index = 0 ; block_index < limit ; block_index ++ ) { blocks [ block_index ] = ( RawDataBlock ) raw_block_list . remove ( block_array [ block_index ] ) ; } if ( block_index < block_count ) { if ( xbat_index < 0 ) { throw new IOException ( "BAT count exceeds limit, yet XBAT index indicates no valid entries" ) ; } int chain_index = xbat_index ; int max_entries_per_block = BATBlock . entriesPerXBATBlock ( ) ; int chain_index_offset = BATBlock . getXBATChainOffset ( ) ; for ( int j = 0 ; j < xbat_count ; j ++ ) { limit = Math . min ( block_count - block_index , max_entries_per_block ) ; byte [ ] data = raw_block_list . remove ( chain_index ) . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { blocks [ block_index ++ ] = ( RawDataBlock ) raw_block_list . remove ( LittleEndian . getInt ( data , offset ) ) ; offset += LittleEndianConsts . INT_SIZE ; } chain_index = LittleEndian . getInt ( data , chain_index_offset ) ; if ( chain_index == POIFSConstants . END_OF_CHAIN ) { break ; } } } if ( block_index != block_count ) { throw new IOException ( "Could not find all blocks" ) ; } setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( final ListManagedBlock [ ] blocks , final BlockList raw_block_list ) throws IOException { this ( ) ; setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( ) { _entries = new IntList ( ) ; } ListManagedBlock [ ] fetchBlocks ( final int startBlock , final BlockList blockList ) throws IOException { List blocks = new ArrayList ( ) ; int currentBlock = startBlock ; while ( currentBlock != POIFSConstants . END_OF_CHAIN ) { blocks . add ( blockList . remove ( currentBlock ) ) ; currentBlock = _entries . get ( currentBlock ) ; } return ( ListManagedBlock [ ] ) blocks . toArray ( new ListManagedBlock [ 0 ] ) ; } boolean isUsed ( final int index ) { boolean rval = false ; try { rval = _entries . get ( index ) != - 1 ; } catch ( IndexOutOfBoundsException ignored ) { } return rval ; } int getNextBlockIndex ( final int index ) throws IOException { if ( isUsed ( index ) ) { return _entries . get ( index ) ; } else { throw new IOException ( "index " + index + " is unused" ) ; } } private void setEntries ( final ListManagedBlock [ ] blocks , final BlockList raw_blocks ) throws IOException { int limit = BATBlock . entriesPerBlock ( ) ; for ( int block_index = 0 ; block_index < blocks . length ; block_index ++ ) { byte [ ] data = blocks [ block_index ] . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { int entry = LittleEndian . getInt ( data , offset ) ; if ( entry == POIFSConstants . UNUSED_BLOCK ) { raw_blocks . zap ( _entries . size ( ) ) ; } _entries . add ( entry ) ; offset += LittleEndianConsts . INT_SIZE ; } blocks [ block_index ] = null ; } raw_blocks . setBAT ( this ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1
package org . apache . poi . util ; import java . util . * ; public final class BinaryTree extends AbstractMap { private Node [ ] _root = new Node [ ] { null , null } ; private int _size = 0 ; private int _modifications = 0 ; private Set [ ] _key_set = new Set [ ] { null , null } ; private Set [ ] _entry_set = new Set [ ] { null , null } ; private Collection [ ] _value_collection = new Collection [ ] { null , null } ; private static final int _KEY = 0 ; private static final int _VALUE = 1 ; private static final int _INDEX_SUM = _KEY + _VALUE ; private static final int _MINIMUM_INDEX = 0 ; private static final int _INDEX_COUNT = 2 ; private static final String [ ] _data_name = new String [ ] { "key" , "value" } ; public BinaryTree ( ) { } public BinaryTree ( final Map map ) throws ClassCastException , NullPointerException , IllegalArgumentException { putAll ( map ) ; } public Object getKeyForValue ( final Object value ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) value , _VALUE ) ; } public Object removeValue ( final Object value ) { return doRemove ( ( Comparable ) value , _VALUE ) ; } public Set entrySetByValue ( ) { if ( _entry_set [ _VALUE ] == null ) { _entry_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; return ( node != null ) && node . getData ( _KEY ) . equals ( key ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; if ( ( node != null ) && node . getData ( _KEY ) . equals ( key ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _VALUE ] ; } public Set keySetByValue ( ) { if ( _key_set [ _VALUE ] == null ) { _key_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _VALUE ] ; } public Collection valuesByValue ( ) { if ( _value_collection [ _VALUE ] == null ) { _value_collection [ _VALUE ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _VALUE ] ; } private Object doRemove ( final Comparable o , final int index ) { Node node = lookup ( o , index ) ; Object rval = null ; if ( node != null ) { rval = node . getData ( oppositeIndex ( index ) ) ; doRedBlackDelete ( node ) ; } return rval ; } private Object doGet ( final Comparable o , final int index ) { checkNonNullComparable ( o , index ) ; Node node = lookup ( o , index ) ; return ( ( node == null ) ? null : node . getData ( oppositeIndex ( index ) ) ) ; } private int oppositeIndex ( final int index ) { return _INDEX_SUM - index ; } private Node lookup ( final Comparable data , final int index ) { Node rval = null ; Node node = _root [ index ] ; while ( node != null ) { int cmp = compare ( data , node . getData ( index ) ) ; if ( cmp == 0 ) { rval = node ; break ; } else { node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; } } return rval ; } private static int compare ( final Comparable o1 , final Comparable o2 ) { return ( ( Comparable ) o1 ) . compareTo ( o2 ) ; } private static Node leastNode ( final Node node , final int index ) { Node rval = node ; if ( rval != null ) { while ( rval . getLeft ( index ) != null ) { rval = rval . getLeft ( index ) ; } } return rval ; } private Node nextGreater ( final Node node , final int index ) { Node rval = null ; if ( node == null ) { rval = null ; } else if ( node . getRight ( index ) != null ) { rval = leastNode ( node . getRight ( index ) , index ) ; } else { Node parent = node . getParent ( index ) ; Node child = node ; while ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { child = parent ; parent = parent . getParent ( index ) ; } rval = parent ; } return rval ; } private static void copyColor ( final Node from , final Node to , final int index ) { if ( to != null ) { if ( from == null ) { to . setBlack ( index ) ; } else { to . copyColor ( from , index ) ; } } } private static boolean isRed ( final Node node , final int index ) { return ( ( node == null ) ? false : node . isRed ( index ) ) ; } private static boolean isBlack ( final Node node , final int index ) { return ( ( node == null ) ? true : node . isBlack ( index ) ) ; } private static void makeRed ( final Node node , final int index ) { if ( node != null ) { node . setRed ( index ) ; } } private static void makeBlack ( final Node node , final int index ) { if ( node != null ) { node . setBlack ( index ) ; } } private static Node getGrandParent ( final Node node , final int index ) { return getParent ( getParent ( node , index ) , index ) ; } private static Node getParent ( final Node node , final int index ) { return ( ( node == null ) ? null : node . getParent ( index ) ) ; } private static Node getRightChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getRight ( index ) ; } private static Node getLeftChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getLeft ( index ) ; } private static boolean isLeftChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getLeft ( index ) ) ) ; } private static boolean isRightChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getRight ( index ) ) ) ; } private void rotateLeft ( final Node node , final int index ) { Node right_child = node . getRight ( index ) ; node . setRight ( right_child . getLeft ( index ) , index ) ; if ( right_child . getLeft ( index ) != null ) { right_child . getLeft ( index ) . setParent ( node , index ) ; } right_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = right_child ; } else if ( node . getParent ( index ) . getLeft ( index ) == node ) { node . getParent ( index ) . setLeft ( right_child , index ) ; } else { node . getParent ( index ) . setRight ( right_child , index ) ; } right_child . setLeft ( node , index ) ; node . setParent ( right_child , index ) ; } private void rotateRight ( final Node node , final int index ) { Node left_child = node . getLeft ( index ) ; node . setLeft ( left_child . getRight ( index ) , index ) ; if ( left_child . getRight ( index ) != null ) { left_child . getRight ( index ) . setParent ( node , index ) ; } left_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = left_child ; } else if ( node . getParent ( index ) . getRight ( index ) == node ) { node . getParent ( index ) . setRight ( left_child , index ) ; } else { node . getParent ( index ) . setLeft ( left_child , index ) ; } left_child . setRight ( node , index ) ; node . setParent ( left_child , index ) ; } private void doRedBlackInsert ( final Node inserted_node , final int index ) { Node current_node = inserted_node ; makeRed ( current_node , index ) ; while ( ( current_node != null ) && ( current_node != _root [ index ] ) && ( isRed ( current_node . getParent ( index ) , index ) ) ) { if ( isLeftChild ( getParent ( current_node , index ) , index ) ) { Node y = getRightChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isRightChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateLeft ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateRight ( getGrandParent ( current_node , index ) , index ) ; } } } else { Node y = getLeftChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isLeftChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateRight ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateLeft ( getGrandParent ( current_node , index ) , index ) ; } } } } makeBlack ( _root [ index ] , index ) ; } private void doRedBlackDelete ( final Node deleted_node ) { for ( int index = _MINIMUM_INDEX ; index < _INDEX_COUNT ; index ++ ) { if ( ( deleted_node . getLeft ( index ) != null ) && ( deleted_node . getRight ( index ) != null ) ) { swapPosition ( nextGreater ( deleted_node , index ) , deleted_node , index ) ; } Node replacement = ( ( deleted_node . getLeft ( index ) != null ) ? deleted_node . getLeft ( index ) : deleted_node . getRight ( index ) ) ; if ( replacement != null ) { replacement . setParent ( deleted_node . getParent ( index ) , index ) ; if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = replacement ; } else if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( replacement , index ) ; } else { deleted_node . getParent ( index ) . setRight ( replacement , index ) ; } deleted_node . setLeft ( null , index ) ; deleted_node . setRight ( null , index ) ; deleted_node . setParent ( null , index ) ; if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( replacement , index ) ; } } else { if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = null ; } else { if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( deleted_node , index ) ; } if ( deleted_node . getParent ( index ) != null ) { if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( null , index ) ; } else { deleted_node . getParent ( index ) . setRight ( null , index ) ; } deleted_node . setParent ( null , index ) ; } } } } shrink ( ) ; } private void doRedBlackDeleteFixup ( final Node replacement_node , final int index ) { Node current_node = replacement_node ; while ( ( current_node != _root [ index ] ) && ( isBlack ( current_node , index ) ) ) { if ( isLeftChild ( current_node , index ) ) { Node sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) && isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateRight ( sibling_node , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getRightChild ( sibling_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } else { Node sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getRightChild ( sibling_node , index ) , index ) && isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeBlack ( getRightChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateLeft ( sibling_node , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } } makeBlack ( current_node , index ) ; } private void swapPosition ( final Node x , final Node y , final int index ) { Node x_old_parent = x . getParent ( index ) ; Node x_old_left_child = x . getLeft ( index ) ; Node x_old_right_child = x . getRight ( index ) ; Node y_old_parent = y . getParent ( index ) ; Node y_old_left_child = y . getLeft ( index ) ; Node y_old_right_child = y . getRight ( index ) ; boolean x_was_left_child = ( x . getParent ( index ) != null ) && ( x == x . getParent ( index ) . getLeft ( index ) ) ; boolean y_was_left_child = ( y . getParent ( index ) != null ) && ( y == y . getParent ( index ) . getLeft ( index ) ) ; if ( x == y_old_parent ) { x . setParent ( y , index ) ; if ( y_was_left_child ) { y . setLeft ( x , index ) ; y . setRight ( x_old_right_child , index ) ; } else { y . setRight ( x , index ) ; y . setLeft ( x_old_left_child , index ) ; } } else { x . setParent ( y_old_parent , index ) ; if ( y_old_parent != null ) { if ( y_was_left_child ) { y_old_parent . setLeft ( x , index ) ; } else { y_old_parent . setRight ( x , index ) ; } } y . setLeft ( x_old_left_child , index ) ; y . setRight ( x_old_right_child , index ) ; } if ( y == x_old_parent ) { y . setParent ( x , index ) ; if ( x_was_left_child ) { x . setLeft ( y , index ) ; x . setRight ( y_old_right_child , index ) ; } else { x . setRight ( y , index ) ; x . setLeft ( y_old_left_child , index ) ; } } else { y . setParent ( x_old_parent , index ) ; if ( x_old_parent != null ) { if ( x_was_left_child ) { x_old_parent . setLeft ( y , index ) ; } else { x_old_parent . setRight ( y , index ) ; } } x . setLeft ( y_old_left_child , index ) ; x . setRight ( y_old_right_child , index ) ; } if ( x . getLeft ( index ) != null ) { x . getLeft ( index ) . setParent ( x , index ) ; } if ( x . getRight ( index ) != null ) { x . getRight ( index ) . setParent ( x , index ) ; } if ( y . getLeft ( index ) != null ) { y . getLeft ( index ) . setParent ( y , index ) ; } if ( y . getRight ( index ) != null ) { y . getRight ( index ) . setParent ( y , index ) ; } x . swapColors ( y , index ) ; if ( _root [ index ] == x ) { _root [ index ] = y ; } else if ( _root [ index ] == y ) { _root [ index ] = x ; } } private static void checkNonNullComparable ( final Object o , final int index ) { if ( o == null ) { throw new NullPointerException ( _data_name [ index ] + " cannot be null" ) ; } if ( ! ( o instanceof Comparable ) ) { throw new ClassCastException ( _data_name [ index ] + " must be Comparable" ) ; } } private static void checkKey ( final Object key ) { checkNonNullComparable ( key , _KEY ) ; } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , _VALUE ) ; } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; checkValue ( value ) ; } private void modify ( ) { _modifications ++ ; } private void grow ( ) { modify ( ) ; _size ++ ; } private void shrink ( ) { modify ( ) ; _size -- ; } private void insertValue ( final Node newNode ) throws IllegalArgumentException { Node node = _root [ _VALUE ] ; while ( true ) { int cmp = compare ( newNode . getData ( _VALUE ) , node . getData ( _VALUE ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate value (\"" + newNode . getData ( _VALUE ) + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _VALUE ) != null ) { node = node . getLeft ( _VALUE ) ; } else { node . setLeft ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } else { if ( node . getRight ( _VALUE ) != null ) { node = node . getRight ( _VALUE ) ; } else { node . setRight ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } } } public int size ( ) { return _size ; } public boolean containsKey ( final Object key ) throws ClassCastException , NullPointerException { checkKey ( key ) ; return lookup ( ( Comparable ) key , _KEY ) != null ; } public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookup ( ( Comparable ) value , _VALUE ) != null ; } public Object get ( final Object key ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) key , _KEY ) ; } public Object put ( final Object key , final Object value ) throws ClassCastException , NullPointerException , IllegalArgumentException { checkKeyAndValue ( key , value ) ; Node node = _root [ _KEY ] ; if ( node == null ) { Node root = new Node ( ( Comparable ) key , ( Comparable ) value ) ; _root [ _KEY ] = root ; _root [ _VALUE ] = root ; grow ( ) ; } else { while ( true ) { int cmp = compare ( ( Comparable ) key , node . getData ( _KEY ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate key (\"" + key + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _KEY ) != null ) { node = node . getLeft ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setLeft ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } else { if ( node . getRight ( _KEY ) != null ) { node = node . getRight ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setRight ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } } } return null ; } public Object remove ( final Object key ) { return doRemove ( ( Comparable ) key , _KEY ) ; } public void clear ( ) { modify ( ) ; _size = 0 ; _root [ _KEY ] = null ; _root [ _VALUE ] = null ; } public Set keySet ( ) { if ( _key_set [ _KEY ] == null ) { _key_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _KEY ] ; } public Collection values ( ) { if ( _value_collection [ _KEY ] == null ) { _value_collection [ _KEY ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _KEY ] ; } public Set entrySet ( ) { if ( _entry_set [ _KEY ] == null ) { _entry_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; return ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; if ( ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _KEY ] ; } private abstract class BinaryTreeIterator implements Iterator { private int _expected_modifications ; protected Node _last_returned_node ; private Node _next_node ; private int _type ; BinaryTreeIterator ( final int type ) { _type = type ; _expected_modifications = BinaryTree . this . _modifications ; _last_returned_node = null ; _next_node = leastNode ( _root [ _type ] , _type ) ; } protected abstract Object doGetNext ( ) ; public final boolean hasNext ( ) { return _next_node != null ; } public final Object next ( ) throws NoSuchElementException , ConcurrentModificationException { if ( _next_node == null ) { throw new NoSuchElementException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } _last_returned_node = _next_node ; _next_node = nextGreater ( _next_node , _type ) ; return doGetNext ( ) ; } public final void remove ( ) throws IllegalStateException , ConcurrentModificationException { if ( _last_returned_node == null ) { throw new IllegalStateException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } doRedBlackDelete ( _last_returned_node ) ; _expected_modifications ++ ; _last_returned_node = null ; } } private static final class Node implements Map . Entry { private Comparable [ ] _data ; private Node [ ] _left ; private Node [ ] _right ; private Node [ ] _parent ; private boolean [ ] _black ; private int _hashcode ; private boolean _calculated_hashcode ; Node ( final Comparable key , final Comparable value ) { _data = new Comparable [ ] { key , value } ; _left = new Node [ ] { null , null } ; _right = new Node [ ] { null , null } ; _parent = new Node [ ] { null , null } ; _black = new boolean [ ] { true , true } ; _calculated_hashcode = false ; } private Comparable getData ( final int index ) { return _data [ index ] ; } private void setLeft ( final Node node , final int index ) { _left [ index ] = node ; } private Node getLeft ( final int index ) { return _left [ index ] ; } private void setRight ( final Node node , final int index ) { _right [ index ] = node ; } private Node getRight ( final int index ) { return _right [ index ] ; } private void setParent ( final Node node , final int index ) { _parent [ index ] = node ; } private Node getParent ( final int index ) { return _parent [ index ] ; } private void swapColors ( final Node node , final int index ) { _black [ index ] ^= node . _black [ index ] ; node . _black [ index ] ^= _black [ index ] ; _black [ index ] ^= node . _black [ index ] ; } private boolean isBlack ( final int index ) { return _black [ index ] ; } private boolean isRed ( final int index ) { return ! _black [ index ] ; } private void setBlack ( final int index ) { _black [ index ] = true ; } private void setRed ( final int index ) { _black [ index ] = false ; } private void copyColor ( final Node node , final int index ) { _black [ index ] = node . _black [ index ] ; } public Object getKey ( ) { return _data [ _KEY ] ; } public Object getValue ( ) { return _data [ _VALUE ] ; } public Object setValue ( Object ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( "Map.Entry.setValue is not supported" ) ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry e = ( Map . Entry ) o ; return _data [ _KEY ] . equals ( e . getKey ( ) ) && _data [ _VALUE ] . equals ( e . getValue ( ) ) ; } public int hashCode ( ) { if ( ! _calculated_hashcode ) { _hashcode = _data [ _KEY ] . hashCode ( ) ^ _data [ _VALUE ] . hashCode ( ) ; _calculated_hashcode = true ; } return _hashcode ; } } } 	0
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1
package org . apache . poi . poifs . eventfilesystem ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentDescriptor ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; class POIFSReaderRegistry { private Set omnivorousListeners ; private Map selectiveListeners ; private Map chosenDocumentDescriptors ; POIFSReaderRegistry ( ) { omnivorousListeners = new HashSet ( ) ; selectiveListeners = new HashMap ( ) ; chosenDocumentDescriptors = new HashMap ( ) ; } void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String documentName ) { if ( ! omnivorousListeners . contains ( listener ) ) { Set descriptors = ( Set ) selectiveListeners . get ( listener ) ; if ( descriptors == null ) { descriptors = new HashSet ( ) ; selectiveListeners . put ( listener , descriptors ) ; } DocumentDescriptor descriptor = new DocumentDescriptor ( path , documentName ) ; if ( descriptors . add ( descriptor ) ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; if ( listeners == null ) { listeners = new HashSet ( ) ; chosenDocumentDescriptors . put ( descriptor , listeners ) ; } listeners . add ( listener ) ; } } } void registerListener ( final POIFSReaderListener listener ) { if ( ! omnivorousListeners . contains ( listener ) ) { removeSelectiveListener ( listener ) ; omnivorousListeners . add ( listener ) ; } } Iterator getListeners ( final POIFSDocumentPath path , final String name ) { Set rval = new HashSet ( omnivorousListeners ) ; Set selectiveListeners = ( Set ) chosenDocumentDescriptors . get ( new DocumentDescriptor ( path , name ) ) ; if ( selectiveListeners != null ) { rval . addAll ( selectiveListeners ) ; } return rval . iterator ( ) ; } private void removeSelectiveListener ( final POIFSReaderListener listener ) { Set selectedDescriptors = ( Set ) selectiveListeners . remove ( listener ) ; if ( selectedDescriptors != null ) { Iterator iter = selectedDescriptors . iterator ( ) ; while ( iter . hasNext ( ) ) { dropDocument ( listener , ( DocumentDescriptor ) iter . next ( ) ) ; } } } private void dropDocument ( final POIFSReaderListener listener , final DocumentDescriptor descriptor ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; listeners . remove ( listener ) ; if ( listeners . size ( ) == 0 ) { chosenDocumentDescriptors . remove ( descriptor ) ; } } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1
package org . apache . poi . hssf . eventusermodel ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; import org . apache . poi . hssf . record . RecordFormatException ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . ContinueRecord ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; public class HSSFEventFactory { public HSSFEventFactory ( ) { } public void processWorkbookEvents ( HSSFRequest req , POIFSFileSystem fs ) throws IOException { InputStream in = fs . createDocumentInputStream ( "Workbook" ) ; processEvents ( req , in ) ; } public short abortableProcessWorkbookEvents ( HSSFRequest req , POIFSFileSystem fs ) throws IOException , HSSFUserException { InputStream in = fs . createDocumentInputStream ( "Workbook" ) ; return abortableProcessEvents ( req , in ) ; } public void processEvents ( HSSFRequest req , InputStream in ) throws IOException { try { genericProcessEvents ( req , in ) ; } catch ( HSSFUserException hue ) { } } public short abortableProcessEvents ( HSSFRequest req , InputStream in ) throws IOException , HSSFUserException { return genericProcessEvents ( req , in ) ; } protected short genericProcessEvents ( HSSFRequest req , InputStream in ) throws IOException , HSSFUserException { short userCode = 0 ; short sid = 0 ; process : try { byte [ ] sidbytes = new byte [ 2 ] ; int bytesread = in . read ( sidbytes ) ; Record rec = null ; while ( bytesread > 0 ) { sid = LittleEndian . getShort ( sidbytes ) ; if ( sid == 0 ) break ; if ( ( rec != null ) && ( sid != ContinueRecord . sid ) ) { userCode = req . processRecord ( rec ) ; if ( userCode != 0 ) break process ; } if ( sid != ContinueRecord . sid ) { short size = LittleEndian . readShort ( in ) ; byte [ ] data = new byte [ size ] ; if ( data . length > 0 ) { in . read ( data ) ; } Record [ ] recs = RecordFactory . createRecord ( sid , size , data ) ; if ( recs . length > 1 ) { for ( int k = 0 ; k < ( recs . length - 1 ) ; k ++ ) { userCode = req . processRecord ( recs [ k ] ) ; if ( userCode != 0 ) break process ; } } rec = recs [ recs . length - 1 ] ; } else { short size = LittleEndian . readShort ( in ) ; byte [ ] data = new byte [ size ] ; if ( data . length > 0 ) { in . read ( data ) ; } rec . processContinueRecord ( data ) ; } bytesread = in . read ( sidbytes ) ; } if ( rec != null ) { userCode = req . processRecord ( rec ) ; if ( userCode != 0 ) break process ; } } catch ( IOException e ) { throw new RecordFormatException ( "Error reading bytes" + "while processing record sid=" + sid ) ; } return userCode ; } } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class EndRecord extends Record { public static final short sid = 0x1034 ; public EndRecord ( ) { } public EndRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public EndRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An END RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[END]\n" ) ; buffer . append ( "[/END]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . Record ; public class WorkbookRecordList { private List records = new ArrayList ( ) ; private int protpos = 0 ; private int bspos = 0 ; private int tabpos = 0 ; private int fontpos = 0 ; private int xfpos = 0 ; private int backuppos = 0 ; private int namepos = 0 ; private int supbookpos = 0 ; private int externsheetPos = 0 ; private int palettepos = - 1 ; public void setRecords ( List records ) { this . records = records ; } public int size ( ) { return records . size ( ) ; } public Record get ( int i ) { return ( Record ) records . get ( i ) ; } public void add ( int pos , Record r ) { records . add ( pos , r ) ; if ( getProtpos ( ) >= pos ) setProtpos ( protpos + 1 ) ; if ( getBspos ( ) >= pos ) setBspos ( bspos + 1 ) ; if ( getTabpos ( ) >= pos ) setTabpos ( tabpos + 1 ) ; if ( getFontpos ( ) >= pos ) setFontpos ( fontpos + 1 ) ; if ( getXfpos ( ) >= pos ) setXfpos ( xfpos + 1 ) ; if ( getBackuppos ( ) >= pos ) setBackuppos ( backuppos + 1 ) ; if ( getNamepos ( ) >= pos ) setNamepos ( namepos + 1 ) ; if ( getSupbookpos ( ) >= pos ) setSupbookpos ( supbookpos + 1 ) ; if ( ( getPalettepos ( ) != - 1 ) && ( getPalettepos ( ) >= pos ) ) setPalettepos ( palettepos + 1 ) ; if ( getExternsheetPos ( ) >= pos ) setExternsheetPos ( getExternsheetPos ( ) + 1 ) ; } public List getRecords ( ) { return records ; } public Iterator iterator ( ) { return records . iterator ( ) ; } public void remove ( int pos ) { records . remove ( pos ) ; if ( getProtpos ( ) >= pos ) setProtpos ( protpos - 1 ) ; if ( getBspos ( ) >= pos ) setBspos ( bspos - 1 ) ; if ( getTabpos ( ) >= pos ) setTabpos ( tabpos - 1 ) ; if ( getFontpos ( ) >= pos ) setFontpos ( fontpos - 1 ) ; if ( getXfpos ( ) >= pos ) setXfpos ( xfpos - 1 ) ; if ( getBackuppos ( ) >= pos ) setBackuppos ( backuppos - 1 ) ; if ( getNamepos ( ) >= pos ) setNamepos ( getNamepos ( ) - 1 ) ; if ( getSupbookpos ( ) >= pos ) setSupbookpos ( getSupbookpos ( ) - 1 ) ; if ( ( getPalettepos ( ) != - 1 ) && ( getPalettepos ( ) >= pos ) ) setPalettepos ( palettepos - 1 ) ; if ( getExternsheetPos ( ) >= pos ) setExternsheetPos ( getExternsheetPos ( ) - 1 ) ; } public int getProtpos ( ) { return protpos ; } public void setProtpos ( int protpos ) { this . protpos = protpos ; } public int getBspos ( ) { return bspos ; } public void setBspos ( int bspos ) { this . bspos = bspos ; } public int getTabpos ( ) { return tabpos ; } public void setTabpos ( int tabpos ) { this . tabpos = tabpos ; } public int getFontpos ( ) { return fontpos ; } public void setFontpos ( int fontpos ) { this . fontpos = fontpos ; } public int getXfpos ( ) { return xfpos ; } public void setXfpos ( int xfpos ) { this . xfpos = xfpos ; } public int getBackuppos ( ) { return backuppos ; } public void setBackuppos ( int backuppos ) { this . backuppos = backuppos ; } public int getPalettepos ( ) { return palettepos ; } public void setPalettepos ( int palettepos ) { this . palettepos = palettepos ; } public int getNamepos ( ) { return namepos ; } public int getSupbookpos ( ) { return supbookpos ; } public void setNamepos ( int namepos ) { this . namepos = namepos ; } public void setSupbookpos ( int supbookpos ) { this . supbookpos = supbookpos ; } public int getExternsheetPos ( ) { return externsheetPos ; } public void setExternsheetPos ( int externsheetPos ) { this . externsheetPos = externsheetPos ; } } 	0
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class PrintSetupRecord extends Record { public final static short sid = 0xa1 ; private short field_1_paper_size ; private short field_2_scale ; private short field_3_page_start ; private short field_4_fit_width ; private short field_5_fit_height ; private short field_6_options ; static final private BitField lefttoright = new BitField ( 0x01 ) ; static final private BitField landscape = new BitField ( 0x02 ) ; static final private BitField validsettings = new BitField ( 0x04 ) ; static final private BitField nocolor = new BitField ( 0x08 ) ; static final private BitField draft = new BitField ( 0x10 ) ; static final private BitField notes = new BitField ( 0x20 ) ; static final private BitField noOrientation = new BitField ( 0x40 ) ; static final private BitField usepage = new BitField ( 0x80 ) ; private short field_7_hresolution ; private short field_8_vresolution ; private double field_9_headermargin ; private double field_10_footermargin ; private short field_11_copies ; public PrintSetupRecord ( ) { } public PrintSetupRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PrintSetupRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid PrintSetup record RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_paper_size = LittleEndian . getShort ( data , 0 + offset ) ; field_2_scale = LittleEndian . getShort ( data , 2 + offset ) ; field_3_page_start = LittleEndian . getShort ( data , 4 + offset ) ; field_4_fit_width = LittleEndian . getShort ( data , 6 + offset ) ; field_5_fit_height = LittleEndian . getShort ( data , 8 + offset ) ; field_6_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_hresolution = LittleEndian . getShort ( data , 12 + offset ) ; field_8_vresolution = LittleEndian . getShort ( data , 14 + offset ) ; field_9_headermargin = LittleEndian . getDouble ( data , 16 + offset ) ; field_10_footermargin = LittleEndian . getDouble ( data , 24 + offset ) ; field_11_copies = LittleEndian . getShort ( data , 32 + offset ) ; } public void setPaperSize ( short size ) { field_1_paper_size = size ; } public void setScale ( short scale ) { field_2_scale = scale ; } public void setPageStart ( short start ) { field_3_page_start = start ; } public void setFitWidth ( short width ) { field_4_fit_width = width ; } public void setFitHeight ( short height ) { field_5_fit_height = height ; } public void setOptions ( short options ) { field_6_options = options ; } public void setLeftToRight ( boolean ltor ) { field_6_options = lefttoright . setShortBoolean ( field_6_options , ltor ) ; } public void setLandscape ( boolean ls ) { field_6_options = landscape . setShortBoolean ( field_6_options , ls ) ; } public void setValidSettings ( boolean valid ) { field_6_options = validsettings . setShortBoolean ( field_6_options , valid ) ; } public void setNoColor ( boolean mono ) { field_6_options = nocolor . setShortBoolean ( field_6_options , mono ) ; } public void setDraft ( boolean d ) { field_6_options = draft . setShortBoolean ( field_6_options , d ) ; } public void setNotes ( boolean printnotes ) { field_6_options = notes . setShortBoolean ( field_6_options , printnotes ) ; } public void setNoOrientation ( boolean orientation ) { field_6_options = noOrientation . setShortBoolean ( field_6_options , orientation ) ; } public void setUsePage ( boolean page ) { field_6_options = usepage . setShortBoolean ( field_6_options , page ) ; } public void setHResolution ( short resolution ) { field_7_hresolution = resolution ; } public void setVResolution ( short resolution ) { field_8_vresolution = resolution ; } public void setHeaderMargin ( double headermargin ) { field_9_headermargin = headermargin ; } public void setFooterMargin ( double footermargin ) { field_10_footermargin = footermargin ; } public void setCopies ( short copies ) { field_11_copies = copies ; } public short getPaperSize ( ) { return field_1_paper_size ; } public short getScale ( ) { return field_2_scale ; } public short getPageStart ( ) { return field_3_page_start ; } public short getFitWidth ( ) { return field_4_fit_width ; } public short getFitHeight ( ) { return field_5_fit_height ; } public short getOptions ( ) { return field_6_options ; } public boolean getLeftToRight ( ) { return lefttoright . isSet ( field_6_options ) ; } public boolean getLandscape ( ) { return landscape . isSet ( field_6_options ) ; } public boolean getValidSettings ( ) { return validsettings . isSet ( field_6_options ) ; } public boolean getNoColor ( ) { return nocolor . isSet ( field_6_options ) ; } public boolean getDraft ( ) { return draft . isSet ( field_6_options ) ; } public boolean getNotes ( ) { return notes . isSet ( field_6_options ) ; } public boolean getNoOrientation ( ) { return noOrientation . isSet ( field_6_options ) ; } public boolean getUsePage ( ) { return usepage . isSet ( field_6_options ) ; } public short getHResolution ( ) { return field_7_hresolution ; } public short getVResolution ( ) { return field_8_vresolution ; } public double getHeaderMargin ( ) { return field_9_headermargin ; } public double getFooterMargin ( ) { return field_10_footermargin ; } public short getCopies ( ) { return field_11_copies ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PRINTSETUP]\n" ) ; buffer . append ( "    .papersize      = " ) . append ( getPaperSize ( ) ) . append ( "\n" ) ; buffer . append ( "    .scale          = " ) . append ( getScale ( ) ) . append ( "\n" ) ; buffer . append ( "    .pagestart      = " ) . append ( getPageStart ( ) ) . append ( "\n" ) ; buffer . append ( "    .fitwidth       = " ) . append ( getFitWidth ( ) ) . append ( "\n" ) ; buffer . append ( "    .fitheight      = " ) . append ( getFitHeight ( ) ) . append ( "\n" ) ; buffer . append ( "    .options        = " ) . append ( getOptions ( ) ) . append ( "\n" ) ; buffer . append ( "        .ltor       = " ) . append ( getLeftToRight ( ) ) . append ( "\n" ) ; buffer . append ( "        .landscape  = " ) . append ( getLandscape ( ) ) . append ( "\n" ) ; buffer . append ( "        .valid      = " ) . append ( getValidSettings ( ) ) . append ( "\n" ) ; buffer . append ( "        .mono       = " ) . append ( getNoColor ( ) ) . append ( "\n" ) ; buffer . append ( "        .draft      = " ) . append ( getDraft ( ) ) . append ( "\n" ) ; buffer . append ( "        .notes      = " ) . append ( getNotes ( ) ) . append ( "\n" ) ; buffer . append ( "        .noOrientat = " ) . append ( getNoOrientation ( ) ) . append ( "\n" ) ; buffer . append ( "        .usepage    = " ) . append ( getUsePage ( ) ) . append ( "\n" ) ; buffer . append ( "    .hresolution    = " ) . append ( getHResolution ( ) ) . append ( "\n" ) ; buffer . append ( "    .vresolution    = " ) . append ( getVResolution ( ) ) . append ( "\n" ) ; buffer . append ( "    .headermargin   = " ) . append ( getHeaderMargin ( ) ) . append ( "\n" ) ; buffer . append ( "    .footermargin   = " ) . append ( getFooterMargin ( ) ) . append ( "\n" ) ; buffer . append ( "    .copies         = " ) . append ( getCopies ( ) ) . append ( "\n" ) ; buffer . append ( "[/PRINTSETUP]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 34 ) ; LittleEndian . putShort ( data , 4 + offset , getPaperSize ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getScale ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getPageStart ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getFitWidth ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getFitHeight ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getHResolution ( ) ) ; LittleEndian . putShort ( data , 18 + offset , getVResolution ( ) ) ; LittleEndian . putDouble ( data , 20 + offset , getHeaderMargin ( ) ) ; LittleEndian . putDouble ( data , 28 + offset , getFooterMargin ( ) ) ; LittleEndian . putShort ( data , 36 + offset , getCopies ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 38 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { PrintSetupRecord rec = new PrintSetupRecord ( ) ; rec . field_1_paper_size = field_1_paper_size ; rec . field_2_scale = field_2_scale ; rec . field_3_page_start = field_3_page_start ; rec . field_4_fit_width = field_4_fit_width ; rec . field_5_fit_height = field_5_fit_height ; rec . field_6_options = field_6_options ; rec . field_7_hresolution = field_7_hresolution ; rec . field_8_vresolution = field_8_vresolution ; rec . field_9_headermargin = field_9_headermargin ; rec . field_10_footermargin = field_10_footermargin ; rec . field_11_copies = field_11_copies ; return rec ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class SeriesToChartGroupRecord extends Record { public final static short sid = 0x1045 ; private short field_1_chartGroupIndex ; public SeriesToChartGroupRecord ( ) { } public SeriesToChartGroupRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public SeriesToChartGroupRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a SeriesToChartGroup record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_chartGroupIndex = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SeriesToChartGroup]\n" ) ; buffer . append ( "    .chartGroupIndex      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getChartGroupIndex ( ) ) ) . append ( " (" ) . append ( getChartGroupIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/SeriesToChartGroup]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_chartGroupIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { SeriesToChartGroupRecord rec = new SeriesToChartGroupRecord ( ) ; rec . field_1_chartGroupIndex = field_1_chartGroupIndex ; return rec ; } public short getChartGroupIndex ( ) { return field_1_chartGroupIndex ; } public void setChartGroupIndex ( short field_1_chartGroupIndex ) { this . field_1_chartGroupIndex = field_1_chartGroupIndex ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ProtectionRev4Record extends Record { public final static short sid = 0x1af ; private short field_1_protect ; public ProtectionRev4Record ( ) { } public ProtectionRev4Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ProtectionRev4Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROTECTION REV 4 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public boolean getProtect ( ) { return ( field_1_protect == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROT4REV]\n" ) ; buffer . append ( "    .protect         = " ) . append ( getProtect ( ) ) . append ( "\n" ) ; buffer . append ( "[/PROT4REV]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_protect ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . BitField ; public class StyleRecord extends Record { public final static short sid = 0x293 ; public final static short STYLE_USER_DEFINED = 0 ; public final static short STYLE_BUILT_IN = 1 ; private short field_1_xf_index ; private byte field_2_builtin_style ; private byte field_3_outline_style_level ; private short field_2_name_length ; private byte field_3_string_options ; private BitField fHighByte ; private String field_4_name ; public StyleRecord ( ) { } public StyleRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public StyleRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A STYLE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { fHighByte = new BitField ( 0x01 ) ; field_1_xf_index = LittleEndian . getShort ( data , 0 + offset ) ; if ( getType ( ) == STYLE_BUILT_IN ) { field_2_builtin_style = data [ 2 + offset ] ; field_3_outline_style_level = data [ 3 + offset ] ; } else if ( getType ( ) == STYLE_USER_DEFINED ) { field_2_name_length = LittleEndian . getShort ( data , 2 + offset ) ; field_3_string_options = data [ 4 + offset ] ; if ( fHighByte . isSet ( field_3_string_options ) ) { field_4_name = StringUtil . getFromUnicode ( data , offset + 5 , field_2_name_length ) ; } else { field_4_name = StringUtil . getFromCompressedUnicode ( data , offset + 5 , field_2_name_length ) ; } } } public void setIndex ( short index ) { field_1_xf_index = index ; } public void setType ( short type ) { field_1_xf_index = setField ( field_1_xf_index , type , 0x8000 , 15 ) ; } public void setXFIndex ( short index ) { field_1_xf_index = setField ( field_1_xf_index , index , 0x1FFF , 0 ) ; } public void setNameLength ( byte length ) { field_2_name_length = length ; } public void setName ( String name ) { field_4_name = name ; } public void setBuiltin ( byte builtin ) { field_2_builtin_style = builtin ; } public void setOutlineStyleLevel ( byte level ) { field_3_outline_style_level = level ; } public short getIndex ( ) { return field_1_xf_index ; } public short getType ( ) { return ( short ) ( ( field_1_xf_index & 0x8000 ) > > 15 ) ; } public short getXFIndex ( ) { return ( short ) ( field_1_xf_index & 0x1FFF ) ; } public short getNameLength ( ) { return field_2_name_length ; } public String getName ( ) { return field_4_name ; } public byte getBuiltin ( ) { return field_2_builtin_style ; } public byte getOutlineStyleLevel ( ) { return field_3_outline_style_level ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[STYLE]\n" ) ; buffer . append ( "    .xf_index_raw    = " ) . append ( Integer . toHexString ( getIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .type        = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .xf_index    = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; if ( getType ( ) == STYLE_BUILT_IN ) { buffer . append ( "    .builtin_style   = " ) . append ( Integer . toHexString ( getBuiltin ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .outline_level   = " ) . append ( Integer . toHexString ( getOutlineStyleLevel ( ) ) ) . append ( "\n" ) ; } else if ( getType ( ) == STYLE_USER_DEFINED ) { buffer . append ( "    .name_length     = " ) . append ( Integer . toHexString ( getNameLength ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .name            = " ) . append ( getName ( ) ) . append ( "\n" ) ; } buffer . append ( "[/STYLE]\n" ) ; return buffer . toString ( ) ; } private short setField ( int fieldValue , int new_value , int mask , int shiftLeft ) { return ( short ) ( ( fieldValue & ~ mask ) | ( ( new_value << shiftLeft ) & mask ) ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; if ( getType ( ) == STYLE_BUILT_IN ) { LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x04 ) ) ; } else { LittleEndian . putShort ( data , 2 + offset , ( ( short ) ( getRecordSize ( ) - 4 ) ) ) ; } LittleEndian . putShort ( data , 4 + offset , getIndex ( ) ) ; if ( getType ( ) == STYLE_BUILT_IN ) { data [ 6 + offset ] = getBuiltin ( ) ; data [ 7 + offset ] = getOutlineStyleLevel ( ) ; } else { LittleEndian . putShort ( data , 6 + offset , getNameLength ( ) ) ; data [ 8 + offset ] = this . field_3_string_options ; StringUtil . putCompressedUnicode ( getName ( ) , data , 9 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval ; if ( getType ( ) == STYLE_BUILT_IN ) { retval = 8 ; } else { if ( fHighByte . isSet ( field_3_string_options ) ) { retval = 9 + 2 * getNameLength ( ) ; } else { retval = 9 + getNameLength ( ) ; } } return retval ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; public class LessEqualPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0a ; public LessEqualPtg ( ) { } public LessEqualPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "<=" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new LessEqualPtg ( ) ; } } 	0
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1
package org . apache . poi . util ; import java . io . * ; import java . util . List ; import java . util . ArrayList ; public class HexRead { public static byte [ ] readData ( String filename ) throws IOException { File file = new File ( filename ) ; FileInputStream stream = new FileInputStream ( file ) ; try { return readData ( stream , - 1 ) ; } finally { stream . close ( ) ; } } public static byte [ ] readData ( String filename , String section ) throws IOException { File file = new File ( filename ) ; FileInputStream stream = new FileInputStream ( file ) ; try { StringBuffer sectionText = new StringBuffer ( ) ; boolean inSection = false ; int c = stream . read ( ) ; while ( c != - 1 ) { switch ( c ) { case '[' : inSection = true ; break ; case '\n' : case '\r' : inSection = false ; sectionText = new StringBuffer ( ) ; break ; case ']' : inSection = false ; if ( sectionText . toString ( ) . equals ( section ) ) return readData ( stream , '[' ) ; sectionText = new StringBuffer ( ) ; break ; default : if ( inSection ) sectionText . append ( ( char ) c ) ; } c = stream . read ( ) ; } } finally { stream . close ( ) ; } throw new IOException ( "Section '" + section + "' not found" ) ; } static public byte [ ] readData ( InputStream stream , int eofChar ) throws IOException { int characterCount = 0 ; byte b = ( byte ) 0 ; List bytes = new ArrayList ( ) ; boolean done = false ; while ( ! done ) { int count = stream . read ( ) ; char baseChar = 'a' ; if ( count == eofChar ) break ; switch ( count ) { case '#' : readToEOL ( stream ) ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : b <<= 4 ; b += ( byte ) ( count - '0' ) ; characterCount ++ ; if ( characterCount == 2 ) { bytes . add ( new Byte ( b ) ) ; characterCount = 0 ; b = ( byte ) 0 ; } break ; case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : baseChar = 'A' ; case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : b <<= 4 ; b += ( byte ) ( count + 10 - baseChar ) ; characterCount ++ ; if ( characterCount == 2 ) { bytes . add ( new Byte ( b ) ) ; characterCount = 0 ; b = ( byte ) 0 ; } break ; case - 1 : done = true ; break ; default : break ; } } Byte [ ] polished = ( Byte [ ] ) bytes . toArray ( new Byte [ 0 ] ) ; byte [ ] rval = new byte [ polished . length ] ; for ( int j = 0 ; j < polished . length ; j ++ ) { rval [ j ] = polished [ j ] . byteValue ( ) ; } return rval ; } static public byte [ ] readFromString ( String data ) throws IOException { return readData ( new ByteArrayInputStream ( data . getBytes ( ) ) , - 1 ) ; } static private void readToEOL ( InputStream stream ) throws IOException { int c = stream . read ( ) ; while ( c != - 1 && c != '\n' && c != '\r' ) { c = stream . read ( ) ; } } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class ValueRangeRecord extends Record { public final static short sid = 0x101f ; private double field_1_minimumAxisValue ; private double field_2_maximumAxisValue ; private double field_3_majorIncrement ; private double field_4_minorIncrement ; private double field_5_categoryAxisCross ; private short field_6_options ; private BitField automaticMinimum = new BitField ( 0x1 ) ; private BitField automaticMaximum = new BitField ( 0x2 ) ; private BitField automaticMajor = new BitField ( 0x4 ) ; private BitField automaticMinor = new BitField ( 0x8 ) ; private BitField automaticCategoryCrossing = new BitField ( 0x10 ) ; private BitField logarithmicScale = new BitField ( 0x20 ) ; private BitField valuesInReverse = new BitField ( 0x40 ) ; private BitField crossCategoryAxisAtMaximum = new BitField ( 0x80 ) ; private BitField reserved = new BitField ( 0x100 ) ; public ValueRangeRecord ( ) { } public ValueRangeRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ValueRangeRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a ValueRange record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_minimumAxisValue = LittleEndian . getDouble ( data , pos + 0x0 + offset ) ; field_2_maximumAxisValue = LittleEndian . getDouble ( data , pos + 0x8 + offset ) ; field_3_majorIncrement = LittleEndian . getDouble ( data , pos + 0x10 + offset ) ; field_4_minorIncrement = LittleEndian . getDouble ( data , pos + 0x18 + offset ) ; field_5_categoryAxisCross = LittleEndian . getDouble ( data , pos + 0x20 + offset ) ; field_6_options = LittleEndian . getShort ( data , pos + 0x28 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[VALUERANGE]\n" ) ; buffer . append ( "    .minimumAxisValue     = " ) . append ( " (" ) . append ( getMinimumAxisValue ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .maximumAxisValue     = " ) . append ( " (" ) . append ( getMaximumAxisValue ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .majorIncrement       = " ) . append ( " (" ) . append ( getMajorIncrement ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .minorIncrement       = " ) . append ( " (" ) . append ( getMinorIncrement ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .categoryAxisCross    = " ) . append ( " (" ) . append ( getCategoryAxisCross ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .automaticMinimum         = " ) . append ( isAutomaticMinimum ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMaximum         = " ) . append ( isAutomaticMaximum ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMajor           = " ) . append ( isAutomaticMajor ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMinor           = " ) . append ( isAutomaticMinor ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticCategoryCrossing     = " ) . append ( isAutomaticCategoryCrossing ( ) ) . append ( '\n' ) ; buffer . append ( "         .logarithmicScale         = " ) . append ( isLogarithmicScale ( ) ) . append ( '\n' ) ; buffer . append ( "         .valuesInReverse          = " ) . append ( isValuesInReverse ( ) ) . append ( '\n' ) ; buffer . append ( "         .crossCategoryAxisAtMaximum     = " ) . append ( isCrossCategoryAxisAtMaximum ( ) ) . append ( '\n' ) ; buffer . append ( "         .reserved                 = " ) . append ( isReserved ( ) ) . append ( '\n' ) ; buffer . append ( "[/VALUERANGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putDouble ( data , 4 + offset + pos , field_1_minimumAxisValue ) ; LittleEndian . putDouble ( data , 12 + offset + pos , field_2_maximumAxisValue ) ; LittleEndian . putDouble ( data , 20 + offset + pos , field_3_majorIncrement ) ; LittleEndian . putDouble ( data , 28 + offset + pos , field_4_minorIncrement ) ; LittleEndian . putDouble ( data , 36 + offset + pos , field_5_categoryAxisCross ) ; LittleEndian . putShort ( data , 44 + offset + pos , field_6_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 8 + 8 + 8 + 8 + 8 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { ValueRangeRecord rec = new ValueRangeRecord ( ) ; rec . field_1_minimumAxisValue = field_1_minimumAxisValue ; rec . field_2_maximumAxisValue = field_2_maximumAxisValue ; rec . field_3_majorIncrement = field_3_majorIncrement ; rec . field_4_minorIncrement = field_4_minorIncrement ; rec . field_5_categoryAxisCross = field_5_categoryAxisCross ; rec . field_6_options = field_6_options ; return rec ; } public double getMinimumAxisValue ( ) { return field_1_minimumAxisValue ; } public void setMinimumAxisValue ( double field_1_minimumAxisValue ) { this . field_1_minimumAxisValue = field_1_minimumAxisValue ; } public double getMaximumAxisValue ( ) { return field_2_maximumAxisValue ; } public void setMaximumAxisValue ( double field_2_maximumAxisValue ) { this . field_2_maximumAxisValue = field_2_maximumAxisValue ; } public double getMajorIncrement ( ) { return field_3_majorIncrement ; } public void setMajorIncrement ( double field_3_majorIncrement ) { this . field_3_majorIncrement = field_3_majorIncrement ; } public double getMinorIncrement ( ) { return field_4_minorIncrement ; } public void setMinorIncrement ( double field_4_minorIncrement ) { this . field_4_minorIncrement = field_4_minorIncrement ; } public double getCategoryAxisCross ( ) { return field_5_categoryAxisCross ; } public void setCategoryAxisCross ( double field_5_categoryAxisCross ) { this . field_5_categoryAxisCross = field_5_categoryAxisCross ; } public short getOptions ( ) { return field_6_options ; } public void setOptions ( short field_6_options ) { this . field_6_options = field_6_options ; } public void setAutomaticMinimum ( boolean value ) { field_6_options = automaticMinimum . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMinimum ( ) { return automaticMinimum . isSet ( field_6_options ) ; } public void setAutomaticMaximum ( boolean value ) { field_6_options = automaticMaximum . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMaximum ( ) { return automaticMaximum . isSet ( field_6_options ) ; } public void setAutomaticMajor ( boolean value ) { field_6_options = automaticMajor . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMajor ( ) { return automaticMajor . isSet ( field_6_options ) ; } public void setAutomaticMinor ( boolean value ) { field_6_options = automaticMinor . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMinor ( ) { return automaticMinor . isSet ( field_6_options ) ; } public void setAutomaticCategoryCrossing ( boolean value ) { field_6_options = automaticCategoryCrossing . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticCategoryCrossing ( ) { return automaticCategoryCrossing . isSet ( field_6_options ) ; } public void setLogarithmicScale ( boolean value ) { field_6_options = logarithmicScale . setShortBoolean ( field_6_options , value ) ; } public boolean isLogarithmicScale ( ) { return logarithmicScale . isSet ( field_6_options ) ; } public void setValuesInReverse ( boolean value ) { field_6_options = valuesInReverse . setShortBoolean ( field_6_options , value ) ; } public boolean isValuesInReverse ( ) { return valuesInReverse . isSet ( field_6_options ) ; } public void setCrossCategoryAxisAtMaximum ( boolean value ) { field_6_options = crossCategoryAxisAtMaximum . setShortBoolean ( field_6_options , value ) ; } public boolean isCrossCategoryAxisAtMaximum ( ) { return crossCategoryAxisAtMaximum . isSet ( field_6_options ) ; } public void setReserved ( boolean value ) { field_6_options = reserved . setShortBoolean ( field_6_options , value ) ; } public boolean isReserved ( ) { return reserved . isSet ( field_6_options ) ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class ObjectLinkRecord extends Record { public final static short sid = 0x1027 ; private short field_1_anchorId ; public final static short ANCHOR_ID_CHART_TITLE = 1 ; public final static short ANCHOR_ID_Y_AXIS = 2 ; public final static short ANCHOR_ID_X_AXIS = 3 ; public final static short ANCHOR_ID_SERIES_OR_POINT = 4 ; public final static short ANCHOR_ID_Z_AXIS = 7 ; private short field_2_link1 ; private short field_3_link2 ; public ObjectLinkRecord ( ) { } public ObjectLinkRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ObjectLinkRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a ObjectLink record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_anchorId = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; field_2_link1 = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_3_link2 = LittleEndian . getShort ( data , pos + 0x4 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[OBJECTLINK]\n" ) ; buffer . append ( "    .anchorId             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getAnchorId ( ) ) ) . append ( " (" ) . append ( getAnchorId ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .link1                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLink1 ( ) ) ) . append ( " (" ) . append ( getLink1 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .link2                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getLink2 ( ) ) ) . append ( " (" ) . append ( getLink2 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/OBJECTLINK]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_anchorId ) ; LittleEndian . putShort ( data , 6 + offset + pos , field_2_link1 ) ; LittleEndian . putShort ( data , 8 + offset + pos , field_3_link2 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { ObjectLinkRecord rec = new ObjectLinkRecord ( ) ; rec . field_1_anchorId = field_1_anchorId ; rec . field_2_link1 = field_2_link1 ; rec . field_3_link2 = field_3_link2 ; return rec ; } public short getAnchorId ( ) { return field_1_anchorId ; } public void setAnchorId ( short field_1_anchorId ) { this . field_1_anchorId = field_1_anchorId ; } public short getLink1 ( ) { return field_2_link1 ; } public void setLink1 ( short field_2_link1 ) { this . field_2_link1 = field_2_link1 ; } public short getLink2 ( ) { return field_3_link2 ; } public void setLink2 ( short field_3_link2 ) { this . field_3_link2 = field_3_link2 ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class AxisUsedRecord extends Record { public final static short sid = 0x1046 ; private short field_1_numAxis ; public AxisUsedRecord ( ) { } public AxisUsedRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AxisUsedRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a AxisUsed record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_numAxis = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AXISUSED]\n" ) ; buffer . append ( "    .numAxis              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getNumAxis ( ) ) ) . append ( " (" ) . append ( getNumAxis ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/AXISUSED]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_numAxis ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { AxisUsedRecord rec = new AxisUsedRecord ( ) ; rec . field_1_numAxis = field_1_numAxis ; return rec ; } public short getNumAxis ( ) { return field_1_numAxis ; } public void setNumAxis ( short field_1_numAxis ) { this . field_1_numAxis = field_1_numAxis ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PasswordRev4Record extends Record { public final static short sid = 0x1BC ; private short field_1_password ; public PasswordRev4Record ( ) { } public PasswordRev4Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PasswordRev4Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROT4REVPASSWORD RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_password = LittleEndian . getShort ( data , 0 + offset ) ; } public void setPassword ( short pw ) { field_1_password = pw ; } public short getPassword ( ) { return field_1_password ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROT4REVPASSWORD]\n" ) ; buffer . append ( "    .password       = " ) . append ( Integer . toHexString ( getPassword ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/PROT4REVPASSWORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getPassword ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class ChartRecord extends Record { public final static short sid = 0x1002 ; private int field_1_x ; private int field_2_y ; private int field_3_width ; private int field_4_height ; public ChartRecord ( ) { } public ChartRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ChartRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Chart record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_x = LittleEndian . getInt ( data , pos + 0x0 + offset ) ; field_2_y = LittleEndian . getInt ( data , pos + 0x4 + offset ) ; field_3_width = LittleEndian . getInt ( data , pos + 0x8 + offset ) ; field_4_height = LittleEndian . getInt ( data , pos + 0xc + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CHART]\n" ) ; buffer . append ( "    .x                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getX ( ) ) ) . append ( " (" ) . append ( getX ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .y                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getY ( ) ) ) . append ( " (" ) . append ( getY ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .width                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getWidth ( ) ) ) . append ( " (" ) . append ( getWidth ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .height               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getHeight ( ) ) ) . append ( " (" ) . append ( getHeight ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/CHART]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset + pos , field_1_x ) ; LittleEndian . putInt ( data , 8 + offset + pos , field_2_y ) ; LittleEndian . putInt ( data , 12 + offset + pos , field_3_width ) ; LittleEndian . putInt ( data , 16 + offset + pos , field_4_height ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 + 4 + 4 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { ChartRecord rec = new ChartRecord ( ) ; rec . field_1_x = field_1_x ; rec . field_2_y = field_2_y ; rec . field_3_width = field_3_width ; rec . field_4_height = field_4_height ; return rec ; } public int getX ( ) { return field_1_x ; } public void setX ( int field_1_x ) { this . field_1_x = field_1_x ; } public int getY ( ) { return field_2_y ; } public void setY ( int field_2_y ) { this . field_2_y = field_2_y ; } public int getWidth ( ) { return field_3_width ; } public void setWidth ( int field_3_width ) { this . field_3_width = field_3_width ; } public int getHeight ( ) { return field_4_height ; } public void setHeight ( int field_4_height ) { this . field_4_height = field_4_height ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . HeaderRecord ; public class HSSFHeader extends Object { HeaderRecord headerRecord ; String left ; String center ; String right ; protected HSSFHeader ( HeaderRecord headerRecord ) { this . headerRecord = headerRecord ; String head = headerRecord . getHeader ( ) ; while ( head != null && head . length ( ) > 1 ) { int pos = head . length ( ) ; switch ( head . substring ( 1 , 2 ) . charAt ( 0 ) ) { case 'L' : if ( head . indexOf ( "&C" ) >= 0 ) { pos = Math . min ( pos , head . indexOf ( "&C" ) ) ; } if ( head . indexOf ( "&R" ) >= 0 ) { pos = Math . min ( pos , head . indexOf ( "&R" ) ) ; } left = head . substring ( 2 , pos ) ; head = head . substring ( pos ) ; break ; case 'C' : if ( head . indexOf ( "&L" ) >= 0 ) { pos = Math . min ( pos , head . indexOf ( "&L" ) ) ; } if ( head . indexOf ( "&R" ) >= 0 ) { pos = Math . min ( pos , head . indexOf ( "&R" ) ) ; } center = head . substring ( 2 , pos ) ; head = head . substring ( pos ) ; break ; case 'R' : if ( head . indexOf ( "&C" ) >= 0 ) { pos = Math . min ( pos , head . indexOf ( "&C" ) ) ; } if ( head . indexOf ( "&L" ) >= 0 ) { pos = Math . min ( pos , head . indexOf ( "&L" ) ) ; } right = head . substring ( 2 , pos ) ; head = head . substring ( pos ) ; break ; default : head = null ; } } } public String getLeft ( ) { return left ; } public void setLeft ( String newLeft ) { left = newLeft ; createHeaderString ( ) ; } public String getCenter ( ) { return center ; } public void setCenter ( String newCenter ) { center = newCenter ; createHeaderString ( ) ; } public String getRight ( ) { return right ; } public void setRight ( String newRight ) { right = newRight ; createHeaderString ( ) ; } private void createHeaderString ( ) { headerRecord . setHeader ( "&C" + ( center == null ? "" : center ) + "&L" + ( left == null ? "" : left ) + "&R" + ( right == null ? "" : right ) ) ; headerRecord . setHeaderLength ( ( byte ) headerRecord . getHeader ( ) . length ( ) ) ; } public static String fontSize ( short size ) { return "&" + size ; } public static String font ( String font , String style ) { return "&\"" + font + "," + style + "\"" ; } public static String page ( ) { return "&P" ; } public static String numPages ( ) { return "&N" ; } public static String date ( ) { return "&D" ; } public static String time ( ) { return "&T" ; } public static String file ( ) { return "&F" ; } public static String tab ( ) { return "&A" ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . BitField ; public class FontRecord extends Record { public final static short sid = 0x31 ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private short field_1_font_height ; private short field_2_attributes ; static final private BitField italic = new BitField ( 0x02 ) ; static final private BitField strikeout = new BitField ( 0x08 ) ; static final private BitField macoutline = new BitField ( 0x10 ) ; static final private BitField macshadow = new BitField ( 0x20 ) ; private short field_3_color_palette_index ; private short field_4_bold_weight ; private short field_5_super_sub_script ; private byte field_6_underline ; private byte field_7_family ; private byte field_8_charset ; private byte field_9_zero = 0 ; private byte field_10_font_name_len ; private String field_11_font_name ; public FontRecord ( ) { } public FontRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FontRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FONT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_height = LittleEndian . getShort ( data , 0 + offset ) ; field_2_attributes = LittleEndian . getShort ( data , 2 + offset ) ; field_3_color_palette_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_bold_weight = LittleEndian . getShort ( data , 6 + offset ) ; field_5_super_sub_script = LittleEndian . getShort ( data , 8 + offset ) ; field_6_underline = data [ 10 + offset ] ; field_7_family = data [ 11 + offset ] ; field_8_charset = data [ 12 + offset ] ; field_9_zero = data [ 13 + offset ] ; field_10_font_name_len = data [ 14 + offset ] ; if ( field_10_font_name_len > 0 ) { if ( data [ 15 ] == 0 ) { field_11_font_name = StringUtil . getFromCompressedUnicode ( data , 16 , LittleEndian . ubyteToInt ( field_10_font_name_len ) ) ; } else { field_11_font_name = StringUtil . getFromUnicodeHigh ( data , 16 , field_10_font_name_len ) ; } } } public void setFontHeight ( short height ) { field_1_font_height = height ; } public void setAttributes ( short attributes ) { field_2_attributes = attributes ; } public void setItalic ( boolean italics ) { field_2_attributes = italic . setShortBoolean ( field_2_attributes , italics ) ; } public void setStrikeout ( boolean strike ) { field_2_attributes = strikeout . setShortBoolean ( field_2_attributes , strike ) ; } public void setMacoutline ( boolean mac ) { field_2_attributes = macoutline . setShortBoolean ( field_2_attributes , mac ) ; } public void setMacshadow ( boolean mac ) { field_2_attributes = macshadow . setShortBoolean ( field_2_attributes , mac ) ; } public void setColorPaletteIndex ( short cpi ) { field_3_color_palette_index = cpi ; } public void setBoldWeight ( short bw ) { field_4_bold_weight = bw ; } public void setSuperSubScript ( short sss ) { field_5_super_sub_script = sss ; } public void setUnderline ( byte u ) { field_6_underline = u ; } public void setFamily ( byte f ) { field_7_family = f ; } public void setCharset ( byte charset ) { field_8_charset = charset ; } public void setFontNameLength ( byte len ) { field_10_font_name_len = len ; } public void setFontName ( String fn ) { field_11_font_name = fn ; } public short getFontHeight ( ) { return field_1_font_height ; } public short getAttributes ( ) { return field_2_attributes ; } public boolean isItalic ( ) { return italic . isSet ( field_2_attributes ) ; } public boolean isStruckout ( ) { return strikeout . isSet ( field_2_attributes ) ; } public boolean isMacoutlined ( ) { return macoutline . isSet ( field_2_attributes ) ; } public boolean isMacshadowed ( ) { return macshadow . isSet ( field_2_attributes ) ; } public short getColorPaletteIndex ( ) { return field_3_color_palette_index ; } public short getBoldWeight ( ) { return field_4_bold_weight ; } public short getSuperSubScript ( ) { return field_5_super_sub_script ; } public byte getUnderline ( ) { return field_6_underline ; } public byte getFamily ( ) { return field_7_family ; } public byte getCharset ( ) { return field_8_charset ; } public byte getFontNameLength ( ) { return field_10_font_name_len ; } public String getFontName ( ) { return field_11_font_name ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FONT]\n" ) ; buffer . append ( "    .fontheight      = " ) . append ( Integer . toHexString ( getFontHeight ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .attributes      = " ) . append ( Integer . toHexString ( getAttributes ( ) ) ) . append ( "\n" ) ; buffer . append ( "         .italic     = " ) . append ( isItalic ( ) ) . append ( "\n" ) ; buffer . append ( "         .strikout   = " ) . append ( isStruckout ( ) ) . append ( "\n" ) ; buffer . append ( "         .macoutlined= " ) . append ( isMacoutlined ( ) ) . append ( "\n" ) ; buffer . append ( "         .macshadowed= " ) . append ( isMacshadowed ( ) ) . append ( "\n" ) ; buffer . append ( "    .colorpalette    = " ) . append ( Integer . toHexString ( getColorPaletteIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .boldweight      = " ) . append ( Integer . toHexString ( getBoldWeight ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .supersubscript  = " ) . append ( Integer . toHexString ( getSuperSubScript ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .underline       = " ) . append ( Integer . toHexString ( getUnderline ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .family          = " ) . append ( Integer . toHexString ( getFamily ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .charset         = " ) . append ( Integer . toHexString ( getCharset ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .namelength      = " ) . append ( Integer . toHexString ( getFontNameLength ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fontname        = " ) . append ( getFontName ( ) ) . append ( "\n" ) ; buffer . append ( "[/FONT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int realflen = getFontNameLength ( ) * 2 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 15 + realflen + 1 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontHeight ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getAttributes ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getColorPaletteIndex ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBoldWeight ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getSuperSubScript ( ) ) ; data [ 14 + offset ] = getUnderline ( ) ; data [ 15 + offset ] = getFamily ( ) ; data [ 16 + offset ] = getCharset ( ) ; data [ 17 + offset ] = ( ( byte ) 0 ) ; data [ 18 + offset ] = getFontNameLength ( ) ; data [ 19 + offset ] = ( byte ) 1 ; if ( getFontName ( ) != null ) { StringUtil . putUncompressedUnicode ( getFontName ( ) , data , 20 + offset ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return ( getFontNameLength ( ) * 2 ) + 20 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class LabelSSTRecord extends Record implements CellValueRecordInterface , Comparable { public final static short sid = 0xfd ; private int field_1_row ; private short field_2_column ; private short field_3_xf_index ; private int field_4_sst_index ; public LabelSSTRecord ( ) { } public LabelSSTRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public LabelSSTRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid LabelSST RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_column = LittleEndian . getShort ( data , 2 + offset ) ; field_3_xf_index = LittleEndian . getShort ( data , 4 + offset ) ; field_4_sst_index = LittleEndian . getInt ( data , 6 + offset ) ; } public void setRow ( int row ) { field_1_row = row ; } public void setColumn ( short col ) { field_2_column = col ; } public void setXFIndex ( short index ) { field_3_xf_index = index ; } public void setSSTIndex ( int index ) { field_4_sst_index = index ; } public int getRow ( ) { return field_1_row ; } public short getColumn ( ) { return field_2_column ; } public short getXFIndex ( ) { return field_3_xf_index ; } public int getSSTIndex ( ) { return field_4_sst_index ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[LABELSST]\n" ) ; buffer . append ( "    .row            = " ) . append ( Integer . toHexString ( getRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .column         = " ) . append ( Integer . toHexString ( getColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .xfindex        = " ) . append ( Integer . toHexString ( getXFIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .sstindex       = " ) . append ( Integer . toHexString ( getSSTIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/LABELSST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 10 ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) getRow ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getXFIndex ( ) ) ; LittleEndian . putInt ( data , 10 + offset , getSSTIndex ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 14 ; } public short getSid ( ) { return this . sid ; } public boolean isBefore ( CellValueRecordInterface i ) { if ( this . getRow ( ) > i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) > i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isAfter ( CellValueRecordInterface i ) { if ( this . getRow ( ) < i . getRow ( ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) < i . getColumn ( ) ) ) { return false ; } if ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) { return false ; } return true ; } public boolean isEqual ( CellValueRecordInterface i ) { return ( ( this . getRow ( ) == i . getRow ( ) ) && ( this . getColumn ( ) == i . getColumn ( ) ) ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public int compareTo ( Object obj ) { CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return 0 ; } if ( this . getRow ( ) < loc . getRow ( ) ) { return - 1 ; } if ( this . getRow ( ) > loc . getRow ( ) ) { return 1 ; } if ( this . getColumn ( ) < loc . getColumn ( ) ) { return - 1 ; } if ( this . getColumn ( ) > loc . getColumn ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof CellValueRecordInterface ) ) { return false ; } CellValueRecordInterface loc = ( CellValueRecordInterface ) obj ; if ( ( this . getRow ( ) == loc . getRow ( ) ) && ( this . getColumn ( ) == loc . getColumn ( ) ) ) { return true ; } return false ; } public Object clone ( ) { LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . field_1_row = field_1_row ; rec . field_2_column = field_2_column ; rec . field_3_xf_index = field_3_xf_index ; rec . field_4_sst_index = field_4_sst_index ; return rec ; } } 	0
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class TextRecord extends Record { public final static short sid = 0x1025 ; private byte field_1_horizontalAlignment ; public final static byte HORIZONTAL_ALIGNMENT_LEFT = 1 ; public final static byte HORIZONTAL_ALIGNMENT_CENTER = 2 ; public final static byte HORIZONTAL_ALIGNMENT_BOTTOM = 3 ; public final static byte HORIZONTAL_ALIGNMENT_JUSTIFY = 4 ; private byte field_2_verticalAlignment ; public final static byte VERTICAL_ALIGNMENT_TOP = 1 ; public final static byte VERTICAL_ALIGNMENT_CENTER = 2 ; public final static byte VERTICAL_ALIGNMENT_BOTTOM = 3 ; public final static byte VERTICAL_ALIGNMENT_JUSTIFY = 4 ; private short field_3_displayMode ; public final static short DISPLAY_MODE_TRANSPARENT = 1 ; public final static short DISPLAY_MODE_OPAQUE = 2 ; private int field_4_rgbColor ; private int field_5_x ; private int field_6_y ; private int field_7_width ; private int field_8_height ; private short field_9_options1 ; private BitField autoColor = new BitField ( 0x1 ) ; private BitField showKey = new BitField ( 0x2 ) ; private BitField showValue = new BitField ( 0x4 ) ; private BitField vertical = new BitField ( 0x8 ) ; private BitField autoGeneratedText = new BitField ( 0x10 ) ; private BitField generated = new BitField ( 0x20 ) ; private BitField autoLabelDeleted = new BitField ( 0x40 ) ; private BitField autoBackground = new BitField ( 0x80 ) ; private BitField rotation = new BitField ( 0x0700 ) ; public final static short ROTATION_NONE = 0 ; public final static short ROTATION_TOP_TO_BOTTOM = 1 ; public final static short ROTATION_ROTATED_90_DEGREES = 2 ; public final static short ROTATION_ROTATED_90_DEGREES_CLOCKWISE = 3 ; private BitField showCategoryLabelAsPercentage = new BitField ( 0x800 ) ; private BitField showValueAsPercentage = new BitField ( 0x1000 ) ; private BitField showBubbleSizes = new BitField ( 0x2000 ) ; private BitField showLabel = new BitField ( 0x4000 ) ; private short field_10_indexOfColorValue ; private short field_11_options2 ; private BitField dataLabelPlacement = new BitField ( 0x000F ) ; public final static short DATA_LABEL_PLACEMENT_CHART_DEPENDENT = 0 ; public final static short DATA_LABEL_PLACEMENT_OUTSIDE = 1 ; public final static short DATA_LABEL_PLACEMENT_INSIDE = 2 ; public final static short DATA_LABEL_PLACEMENT_CENTER = 3 ; public final static short DATA_LABEL_PLACEMENT_AXIS = 4 ; public final static short DATA_LABEL_PLACEMENT_ABOVE = 5 ; public final static short DATA_LABEL_PLACEMENT_BELOW = 6 ; public final static short DATA_LABEL_PLACEMENT_LEFT = 7 ; public final static short DATA_LABEL_PLACEMENT_RIGHT = 8 ; public final static short DATA_LABEL_PLACEMENT_AUTO = 9 ; public final static short DATA_LABEL_PLACEMENT_USER_MOVED = 10 ; private short field_12_textRotation ; public TextRecord ( ) { } public TextRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public TextRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Text record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_horizontalAlignment = data [ pos + 0x0 + offset ] ; field_2_verticalAlignment = data [ pos + 0x1 + offset ] ; field_3_displayMode = LittleEndian . getShort ( data , pos + 0x2 + offset ) ; field_4_rgbColor = LittleEndian . getInt ( data , pos + 0x4 + offset ) ; field_5_x = LittleEndian . getInt ( data , pos + 0x8 + offset ) ; field_6_y = LittleEndian . getInt ( data , pos + 0xc + offset ) ; field_7_width = LittleEndian . getInt ( data , pos + 0x10 + offset ) ; field_8_height = LittleEndian . getInt ( data , pos + 0x14 + offset ) ; field_9_options1 = LittleEndian . getShort ( data , pos + 0x18 + offset ) ; field_10_indexOfColorValue = LittleEndian . getShort ( data , pos + 0x1a + offset ) ; field_11_options2 = LittleEndian . getShort ( data , pos + 0x1c + offset ) ; field_12_textRotation = LittleEndian . getShort ( data , pos + 0x1e + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[TEXT]\n" ) ; buffer . append ( "    .horizontalAlignment  = " ) . append ( "0x" ) . append ( HexDump . toHex ( getHorizontalAlignment ( ) ) ) . append ( " (" ) . append ( getHorizontalAlignment ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .verticalAlignment    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getVerticalAlignment ( ) ) ) . append ( " (" ) . append ( getVerticalAlignment ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .displayMode          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getDisplayMode ( ) ) ) . append ( " (" ) . append ( getDisplayMode ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .rgbColor             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getRgbColor ( ) ) ) . append ( " (" ) . append ( getRgbColor ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .x                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getX ( ) ) ) . append ( " (" ) . append ( getX ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .y                    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getY ( ) ) ) . append ( " (" ) . append ( getY ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .width                = " ) . append ( "0x" ) . append ( HexDump . toHex ( getWidth ( ) ) ) . append ( " (" ) . append ( getWidth ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .height               = " ) . append ( "0x" ) . append ( HexDump . toHex ( getHeight ( ) ) ) . append ( " (" ) . append ( getHeight ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options1             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions1 ( ) ) ) . append ( " (" ) . append ( getOptions1 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .autoColor                = " ) . append ( isAutoColor ( ) ) . append ( '\n' ) ; buffer . append ( "         .showKey                  = " ) . append ( isShowKey ( ) ) . append ( '\n' ) ; buffer . append ( "         .showValue                = " ) . append ( isShowValue ( ) ) . append ( '\n' ) ; buffer . append ( "         .vertical                 = " ) . append ( isVertical ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoGeneratedText        = " ) . append ( isAutoGeneratedText ( ) ) . append ( '\n' ) ; buffer . append ( "         .generated                = " ) . append ( isGenerated ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoLabelDeleted         = " ) . append ( isAutoLabelDeleted ( ) ) . append ( '\n' ) ; buffer . append ( "         .autoBackground           = " ) . append ( isAutoBackground ( ) ) . append ( '\n' ) ; buffer . append ( "         .rotation                 = " ) . append ( getRotation ( ) ) . append ( '\n' ) ; buffer . append ( "         .showCategoryLabelAsPercentage     = " ) . append ( isShowCategoryLabelAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .showValueAsPercentage     = " ) . append ( isShowValueAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .showBubbleSizes          = " ) . append ( isShowBubbleSizes ( ) ) . append ( '\n' ) ; buffer . append ( "         .showLabel                = " ) . append ( isShowLabel ( ) ) . append ( '\n' ) ; buffer . append ( "    .indexOfColorValue    = " ) . append ( "0x" ) . append ( HexDump . toHex ( getIndexOfColorValue ( ) ) ) . append ( " (" ) . append ( getIndexOfColorValue ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .options2             = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions2 ( ) ) ) . append ( " (" ) . append ( getOptions2 ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .dataLabelPlacement       = " ) . append ( getDataLabelPlacement ( ) ) . append ( '\n' ) ; buffer . append ( "    .textRotation         = " ) . append ( "0x" ) . append ( HexDump . toHex ( getTextRotation ( ) ) ) . append ( " (" ) . append ( getTextRotation ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/TEXT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; data [ 4 + offset + pos ] = field_1_horizontalAlignment ; data [ 5 + offset + pos ] = field_2_verticalAlignment ; LittleEndian . putShort ( data , 6 + offset + pos , field_3_displayMode ) ; LittleEndian . putInt ( data , 8 + offset + pos , field_4_rgbColor ) ; LittleEndian . putInt ( data , 12 + offset + pos , field_5_x ) ; LittleEndian . putInt ( data , 16 + offset + pos , field_6_y ) ; LittleEndian . putInt ( data , 20 + offset + pos , field_7_width ) ; LittleEndian . putInt ( data , 24 + offset + pos , field_8_height ) ; LittleEndian . putShort ( data , 28 + offset + pos , field_9_options1 ) ; LittleEndian . putShort ( data , 30 + offset + pos , field_10_indexOfColorValue ) ; LittleEndian . putShort ( data , 32 + offset + pos , field_11_options2 ) ; LittleEndian . putShort ( data , 34 + offset + pos , field_12_textRotation ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 1 + 1 + 2 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { TextRecord rec = new TextRecord ( ) ; rec . field_1_horizontalAlignment = field_1_horizontalAlignment ; rec . field_2_verticalAlignment = field_2_verticalAlignment ; rec . field_3_displayMode = field_3_displayMode ; rec . field_4_rgbColor = field_4_rgbColor ; rec . field_5_x = field_5_x ; rec . field_6_y = field_6_y ; rec . field_7_width = field_7_width ; rec . field_8_height = field_8_height ; rec . field_9_options1 = field_9_options1 ; rec . field_10_indexOfColorValue = field_10_indexOfColorValue ; rec . field_11_options2 = field_11_options2 ; rec . field_12_textRotation = field_12_textRotation ; return rec ; } public byte getHorizontalAlignment ( ) { return field_1_horizontalAlignment ; } public void setHorizontalAlignment ( byte field_1_horizontalAlignment ) { this . field_1_horizontalAlignment = field_1_horizontalAlignment ; } public byte getVerticalAlignment ( ) { return field_2_verticalAlignment ; } public void setVerticalAlignment ( byte field_2_verticalAlignment ) { this . field_2_verticalAlignment = field_2_verticalAlignment ; } public short getDisplayMode ( ) { return field_3_displayMode ; } public void setDisplayMode ( short field_3_displayMode ) { this . field_3_displayMode = field_3_displayMode ; } public int getRgbColor ( ) { return field_4_rgbColor ; } public void setRgbColor ( int field_4_rgbColor ) { this . field_4_rgbColor = field_4_rgbColor ; } public int getX ( ) { return field_5_x ; } public void setX ( int field_5_x ) { this . field_5_x = field_5_x ; } public int getY ( ) { return field_6_y ; } public void setY ( int field_6_y ) { this . field_6_y = field_6_y ; } public int getWidth ( ) { return field_7_width ; } public void setWidth ( int field_7_width ) { this . field_7_width = field_7_width ; } public int getHeight ( ) { return field_8_height ; } public void setHeight ( int field_8_height ) { this . field_8_height = field_8_height ; } public short getOptions1 ( ) { return field_9_options1 ; } public void setOptions1 ( short field_9_options1 ) { this . field_9_options1 = field_9_options1 ; } public short getIndexOfColorValue ( ) { return field_10_indexOfColorValue ; } public void setIndexOfColorValue ( short field_10_indexOfColorValue ) { this . field_10_indexOfColorValue = field_10_indexOfColorValue ; } public short getOptions2 ( ) { return field_11_options2 ; } public void setOptions2 ( short field_11_options2 ) { this . field_11_options2 = field_11_options2 ; } public short getTextRotation ( ) { return field_12_textRotation ; } public void setTextRotation ( short field_12_textRotation ) { this . field_12_textRotation = field_12_textRotation ; } public void setAutoColor ( boolean value ) { field_9_options1 = autoColor . setShortBoolean ( field_9_options1 , value ) ; } public boolean isAutoColor ( ) { return autoColor . isSet ( field_9_options1 ) ; } public void setShowKey ( boolean value ) { field_9_options1 = showKey . setShortBoolean ( field_9_options1 , value ) ; } public boolean isShowKey ( ) { return showKey . isSet ( field_9_options1 ) ; } public void setShowValue ( boolean value ) { field_9_options1 = showValue . setShortBoolean ( field_9_options1 , value ) ; } public boolean isShowValue ( ) { return showValue . isSet ( field_9_options1 ) ; } public void setVertical ( boolean value ) { field_9_options1 = vertical . setShortBoolean ( field_9_options1 , value ) ; } public boolean isVertical ( ) { return vertical . isSet ( field_9_options1 ) ; } public void setAutoGeneratedText ( boolean value ) { field_9_options1 = autoGeneratedText . setShortBoolean ( field_9_options1 , value ) ; } public boolean isAutoGeneratedText ( ) { return autoGeneratedText . isSet ( field_9_options1 ) ; } public void setGenerated ( boolean value ) { field_9_options1 = generated . setShortBoolean ( field_9_options1 , value ) ; } public boolean isGenerated ( ) { return generated . isSet ( field_9_options1 ) ; } public void setAutoLabelDeleted ( boolean value ) { field_9_options1 = autoLabelDeleted . setShortBoolean ( field_9_options1 , value ) ; } public boolean isAutoLabelDeleted ( ) { return autoLabelDeleted . isSet ( field_9_options1 ) ; } public void setAutoBackground ( boolean value ) { field_9_options1 = autoBackground . setShortBoolean ( field_9_options1 , value ) ; } public boolean isAutoBackground ( ) { return autoBackground . isSet ( field_9_options1 ) ; } public void setRotation ( short value ) { field_9_options1 = rotation . setShortValue ( field_9_options1 , value ) ; } public short getRotation ( ) { return rotation . getShortValue ( field_9_options1 ) ; } public void setShowCategoryLabelAsPercentage ( boolean value ) { field_9_options1 = showCategoryLabelAsPercentage . setShortBoolean ( field_9_options1 , value ) ; } public boolean isShowCategoryLabelAsPercentage ( ) { return showCategoryLabelAsPercentage . isSet ( field_9_options1 ) ; } public void setShowValueAsPercentage ( boolean value ) { field_9_options1 = showValueAsPercentage . setShortBoolean ( field_9_options1 , value ) ; } public boolean isShowValueAsPercentage ( ) { return showValueAsPercentage . isSet ( field_9_options1 ) ; } public void setShowBubbleSizes ( boolean value ) { field_9_options1 = showBubbleSizes . setShortBoolean ( field_9_options1 , value ) ; } public boolean isShowBubbleSizes ( ) { return showBubbleSizes . isSet ( field_9_options1 ) ; } public void setShowLabel ( boolean value ) { field_9_options1 = showLabel . setShortBoolean ( field_9_options1 , value ) ; } public boolean isShowLabel ( ) { return showLabel . isSet ( field_9_options1 ) ; } public void setDataLabelPlacement ( short value ) { field_11_options2 = dataLabelPlacement . setShortValue ( field_11_options2 , value ) ; } public short getDataLabelPlacement ( ) { return dataLabelPlacement . getShortValue ( field_11_options2 ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DBCellRecord extends Record { public final static short sid = 0xd7 ; private int field_1_row_offset ; private short [ ] field_2_cell_offsets ; public DBCellRecord ( ) { } public DBCellRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DBCellRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid DBCell RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row_offset = LittleEndian . getUShort ( data , 0 + offset ) ; field_2_cell_offsets = new short [ ( size - 4 ) / 2 ] ; int element = 0 ; for ( int k = 4 ; k < data . length ; k += 2 ) { field_2_cell_offsets [ element ++ ] = LittleEndian . getShort ( data , k + offset ) ; } } public void setRowOffset ( int offset ) { field_1_row_offset = offset ; } public void addCellOffset ( short offset ) { if ( field_2_cell_offsets == null ) { field_2_cell_offsets = new short [ 1 ] ; } else { short [ ] temp = new short [ field_2_cell_offsets . length + 1 ] ; System . arraycopy ( field_2_cell_offsets , 0 , temp , 0 , field_2_cell_offsets . length ) ; field_2_cell_offsets = temp ; } field_2_cell_offsets [ field_2_cell_offsets . length - 1 ] = offset ; } public int getRowOffset ( ) { return field_1_row_offset ; } public short getCellOffsetAt ( int index ) { return field_2_cell_offsets [ index ] ; } public int getNumCellOffsets ( ) { return field_2_cell_offsets . length ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DBCELL]\n" ) ; buffer . append ( "    .rowoffset       = " ) . append ( Integer . toHexString ( getRowOffset ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumCellOffsets ( ) ; k ++ ) { buffer . append ( "    .cell_" + k + "          = " ) . append ( Integer . toHexString ( getCellOffsetAt ( k ) ) ) . append ( "\n" ) ; } buffer . append ( "[/DBCELL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { if ( field_2_cell_offsets == null ) { field_2_cell_offsets = new short [ 0 ] ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) ( 4 + ( getNumCellOffsets ( ) * 2 ) ) ) ) ; LittleEndian . putInt ( data , 4 + offset , getRowOffset ( ) ) ; for ( int k = 0 ; k < getNumCellOffsets ( ) ; k ++ ) { LittleEndian . putShort ( data , 8 + k + offset , getCellOffsetAt ( k ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 + ( getNumCellOffsets ( ) * 2 ) ; } public short getSid ( ) { return this . sid ; } public boolean isInValueSection ( ) { return true ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class DatRecord extends Record { public final static short sid = 0x1063 ; private short field_1_options ; private BitField horizontalBorder = new BitField ( 0x1 ) ; private BitField verticalBorder = new BitField ( 0x2 ) ; private BitField border = new BitField ( 0x4 ) ; private BitField showSeriesKey = new BitField ( 0x8 ) ; public DatRecord ( ) { } public DatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Dat record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_options = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DAT]\n" ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .horizontalBorder         = " ) . append ( isHorizontalBorder ( ) ) . append ( '\n' ) ; buffer . append ( "         .verticalBorder           = " ) . append ( isVerticalBorder ( ) ) . append ( '\n' ) ; buffer . append ( "         .border                   = " ) . append ( isBorder ( ) ) . append ( '\n' ) ; buffer . append ( "         .showSeriesKey            = " ) . append ( isShowSeriesKey ( ) ) . append ( '\n' ) ; buffer . append ( "[/DAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { DatRecord rec = new DatRecord ( ) ; rec . field_1_options = field_1_options ; return rec ; } public short getOptions ( ) { return field_1_options ; } public void setOptions ( short field_1_options ) { this . field_1_options = field_1_options ; } public void setHorizontalBorder ( boolean value ) { field_1_options = horizontalBorder . setShortBoolean ( field_1_options , value ) ; } public boolean isHorizontalBorder ( ) { return horizontalBorder . isSet ( field_1_options ) ; } public void setVerticalBorder ( boolean value ) { field_1_options = verticalBorder . setShortBoolean ( field_1_options , value ) ; } public boolean isVerticalBorder ( ) { return verticalBorder . isSet ( field_1_options ) ; } public void setBorder ( boolean value ) { field_1_options = border . setShortBoolean ( field_1_options , value ) ; } public boolean isBorder ( ) { return border . isSet ( field_1_options ) ; } public void setShowSeriesKey ( boolean value ) { field_1_options = showSeriesKey . setShortBoolean ( field_1_options , value ) ; } public boolean isShowSeriesKey ( ) { return showSeriesKey . isSet ( field_1_options ) ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . poifs . property ; public interface PropertyConstants { public static final int PROPERTY_TYPE_OFFSET = 0x42 ; public static final byte DIRECTORY_TYPE = 1 ; public static final byte DOCUMENT_TYPE = 2 ; public static final byte ROOT_TYPE = 5 ; } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public abstract class SpecialPropertySet extends PropertySet { private PropertySet delegate ; public SpecialPropertySet ( PropertySet ps ) { delegate = ps ; } public int getByteOrder ( ) { return delegate . getByteOrder ( ) ; } public int getFormat ( ) { return delegate . getFormat ( ) ; } public long getOSVersion ( ) { return delegate . getOSVersion ( ) ; } public ClassID getClassID ( ) { return delegate . getClassID ( ) ; } public long getSectionCount ( ) { return delegate . getSectionCount ( ) ; } public List getSections ( ) { return delegate . getSections ( ) ; } public boolean isSummaryInformation ( ) { return delegate . isSummaryInformation ( ) ; } public boolean isDocumentSummaryInformation ( ) { return delegate . isDocumentSummaryInformation ( ) ; } public Section getSingleSection ( ) { return delegate . getSingleSection ( ) ; } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DefaultColWidthRecord extends Record { public final static short sid = 0x55 ; private short field_1_col_width ; public DefaultColWidthRecord ( ) { } public DefaultColWidthRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DefaultColWidthRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A DefaultColWidth RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_col_width = LittleEndian . getShort ( data , 0 + offset ) ; } public void setColWidth ( short height ) { field_1_col_width = height ; } public short getColWidth ( ) { return field_1_col_width ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DEFAULTCOLWIDTH]\n" ) ; buffer . append ( "    .colwidth      = " ) . append ( Integer . toHexString ( getColWidth ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/DEFAULTCOLWIDTH]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , getColWidth ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { DefaultColWidthRecord rec = new DefaultColWidthRecord ( ) ; rec . field_1_col_width = field_1_col_width ; return rec ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . usermodel ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . HCenterRecord ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RowRecord ; import org . apache . poi . hssf . record . SCLRecord ; import org . apache . poi . hssf . record . VCenterRecord ; import org . apache . poi . hssf . record . WSBoolRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . util . Region ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFSheet { private static final int DEBUG = POILogger . DEBUG ; public static final short LeftMargin = Sheet . LeftMargin ; public static final short RightMargin = Sheet . RightMargin ; public static final short TopMargin = Sheet . TopMargin ; public static final short BottomMargin = Sheet . BottomMargin ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public final static int INITIAL_CAPACITY = 20 ; private Sheet sheet ; private TreeMap rows ; private Workbook book ; private int firstrow ; private int lastrow ; private static POILogger log = POILogFactory . getLogger ( HSSFSheet . class ) ; protected HSSFSheet ( Workbook book ) { sheet = Sheet . createSheet ( ) ; rows = new TreeMap ( ) ; this . book = book ; } protected HSSFSheet ( Workbook book , Sheet sheet ) { this . sheet = sheet ; rows = new TreeMap ( ) ; this . book = book ; setPropertiesFromSheet ( sheet ) ; } HSSFSheet cloneSheet ( Workbook book ) { return new HSSFSheet ( book , sheet . cloneSheet ( ) ) ; } private void setPropertiesFromSheet ( Sheet sheet ) { int sloc = sheet . getLoc ( ) ; RowRecord row = sheet . getNextRow ( ) ; while ( row != null ) { createRowFromRecord ( row ) ; row = sheet . getNextRow ( ) ; } sheet . setLoc ( sloc ) ; CellValueRecordInterface cval = sheet . getNextValueRecord ( ) ; long timestart = System . currentTimeMillis ( ) ; log . log ( DEBUG , "Time at start of cell creating in HSSF sheet = " , new Long ( timestart ) ) ; HSSFRow lastrow = null ; while ( cval != null ) { long cellstart = System . currentTimeMillis ( ) ; HSSFRow hrow = lastrow ; if ( ( lastrow == null ) || ( lastrow . getRowNum ( ) != cval . getRow ( ) ) ) { hrow = getRow ( cval . getRow ( ) ) ; } if ( hrow != null ) { lastrow = hrow ; log . log ( DEBUG , "record id = " + Integer . toHexString ( ( ( Record ) cval ) . getSid ( ) ) ) ; hrow . createCellFromRecord ( cval ) ; cval = sheet . getNextValueRecord ( ) ; log . log ( DEBUG , "record took " , new Long ( System . currentTimeMillis ( ) - cellstart ) ) ; } else { cval = null ; } } log . log ( DEBUG , "total sheet cell creation took " , new Long ( System . currentTimeMillis ( ) - timestart ) ) ; } public HSSFRow createRow ( int rownum ) { HSSFRow row = new HSSFRow ( book , sheet , rownum ) ; addRow ( row , true ) ; return row ; } private HSSFRow createRowFromRecord ( RowRecord row ) { HSSFRow hrow = new HSSFRow ( book , sheet , row ) ; addRow ( hrow , false ) ; return hrow ; } public void removeRow ( HSSFRow row ) { sheet . setLoc ( sheet . getDimsLoc ( ) ) ; if ( rows . size ( ) > 0 ) { rows . remove ( row ) ; if ( row . getRowNum ( ) == getLastRowNum ( ) ) { lastrow = findLastRow ( lastrow ) ; } if ( row . getRowNum ( ) == getFirstRowNum ( ) ) { firstrow = findFirstRow ( firstrow ) ; } Iterator iter = row . cellIterator ( ) ; while ( iter . hasNext ( ) ) { HSSFCell cell = ( HSSFCell ) iter . next ( ) ; sheet . removeValueRecord ( row . getRowNum ( ) , cell . getCellValueRecord ( ) ) ; } sheet . removeRow ( row . getRowRecord ( ) ) ; } } private int findLastRow ( int lastrow ) { int rownum = lastrow - 1 ; HSSFRow r = getRow ( rownum ) ; while ( r == null && rownum >= 0 ) { r = getRow ( -- rownum ) ; } return rownum ; } private int findFirstRow ( int firstrow ) { int rownum = firstrow + 1 ; HSSFRow r = getRow ( rownum ) ; while ( r == null && rownum <= getLastRowNum ( ) ) { r = getRow ( ++ rownum ) ; } if ( rownum > getLastRowNum ( ) ) return - 1 ; return rownum ; } private void addRow ( HSSFRow row , boolean addLow ) { rows . put ( row , row ) ; if ( addLow ) { sheet . addRow ( row . getRowRecord ( ) ) ; } if ( row . getRowNum ( ) > getLastRowNum ( ) ) { lastrow = row . getRowNum ( ) ; } if ( row . getRowNum ( ) < getFirstRowNum ( ) ) { firstrow = row . getRowNum ( ) ; } } public HSSFRow getRow ( int rownum ) { HSSFRow row = new HSSFRow ( ) ; row . setRowNum ( rownum ) ; return ( HSSFRow ) rows . get ( row ) ; } public int getPhysicalNumberOfRows ( ) { return rows . size ( ) ; } public int getFirstRowNum ( ) { return firstrow ; } public int getLastRowNum ( ) { return lastrow ; } public void setColumnWidth ( short column , short width ) { sheet . setColumnWidth ( column , width ) ; } public short getColumnWidth ( short column ) { return sheet . getColumnWidth ( column ) ; } public short getDefaultColumnWidth ( ) { return sheet . getDefaultColumnWidth ( ) ; } public short getDefaultRowHeight ( ) { return sheet . getDefaultRowHeight ( ) ; } public float getDefaultRowHeightInPoints ( ) { return ( sheet . getDefaultRowHeight ( ) / 20 ) ; } public void setDefaultColumnWidth ( short width ) { sheet . setDefaultColumnWidth ( width ) ; } public void setDefaultRowHeight ( short height ) { sheet . setDefaultRowHeight ( height ) ; } public void setDefaultRowHeightInPoints ( float height ) { sheet . setDefaultRowHeight ( ( short ) ( height * 20 ) ) ; } public boolean isGridsPrinted ( ) { return sheet . isGridsPrinted ( ) ; } public void setGridsPrinted ( boolean value ) { sheet . setGridsPrinted ( value ) ; } public int addMergedRegion ( Region region ) { return sheet . addMergedRegion ( region . getRowFrom ( ) , region . getColumnFrom ( ) , region . getRowTo ( ) , region . getColumnTo ( ) ) ; } public void setVerticallyCenter ( boolean value ) { VCenterRecord record = ( VCenterRecord ) sheet . findFirstRecordBySid ( VCenterRecord . sid ) ; record . setVCenter ( value ) ; } public boolean getVerticallyCenter ( boolean value ) { VCenterRecord record = ( VCenterRecord ) sheet . findFirstRecordBySid ( VCenterRecord . sid ) ; return record . getVCenter ( ) ; } public void setHorizontallyCenter ( boolean value ) { HCenterRecord record = ( HCenterRecord ) sheet . findFirstRecordBySid ( HCenterRecord . sid ) ; record . setHCenter ( value ) ; } public boolean getHorizontallyCenter ( ) { HCenterRecord record = ( HCenterRecord ) sheet . findFirstRecordBySid ( HCenterRecord . sid ) ; return record . getHCenter ( ) ; } public void removeMergedRegion ( int index ) { sheet . removeMergedRegion ( index ) ; } public int getNumMergedRegions ( ) { return sheet . getNumMergedRegions ( ) ; } public Region getMergedRegionAt ( int index ) { return new Region ( sheet . getMergedRegionAt ( index ) ) ; } public Iterator rowIterator ( ) { return rows . values ( ) . iterator ( ) ; } protected Sheet getSheet ( ) { return sheet ; } public void setAlternativeExpression ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setAlternateExpression ( b ) ; } public void setAlternativeFormula ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setAlternateFormula ( b ) ; } public void setAutobreaks ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setAutobreaks ( b ) ; } public void setDialog ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setDialog ( b ) ; } public void setDisplayGuts ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setDisplayGuts ( b ) ; } public void setFitToPage ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setFitToPage ( b ) ; } public void setRowSumsBelow ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setRowSumsBelow ( b ) ; } public void setRowSumsRight ( boolean b ) { WSBoolRecord record = ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ; record . setRowSumsRight ( b ) ; } public boolean getAlternateExpression ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getAlternateExpression ( ) ; } public boolean getAlternateFormula ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getAlternateFormula ( ) ; } public boolean getAutobreaks ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getAutobreaks ( ) ; } public boolean getDialog ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getDialog ( ) ; } public boolean getDisplayGuts ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getDisplayGuts ( ) ; } public boolean getFitToPage ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getFitToPage ( ) ; } public boolean getRowSumsBelow ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getRowSumsBelow ( ) ; } public boolean getRowSumsRight ( ) { return ( ( WSBoolRecord ) sheet . findFirstRecordBySid ( WSBoolRecord . sid ) ) . getRowSumsRight ( ) ; } public boolean isPrintGridlines ( ) { return getSheet ( ) . getPrintGridlines ( ) . getPrintGridlines ( ) ; } public void setPrintGridlines ( boolean newPrintGridlines ) { getSheet ( ) . getPrintGridlines ( ) . setPrintGridlines ( newPrintGridlines ) ; } public HSSFPrintSetup getPrintSetup ( ) { return new HSSFPrintSetup ( getSheet ( ) . getPrintSetup ( ) ) ; } public HSSFHeader getHeader ( ) { return new HSSFHeader ( getSheet ( ) . getHeader ( ) ) ; } public HSSFFooter getFooter ( ) { return new HSSFFooter ( getSheet ( ) . getFooter ( ) ) ; } public void setSelected ( boolean sel ) { getSheet ( ) . setSelected ( sel ) ; } public double getMargin ( short margin ) { return getSheet ( ) . getMargin ( margin ) ; } public void setMargin ( short margin , double size ) { getSheet ( ) . setMargin ( margin , size ) ; } public boolean getProtect ( ) { return getSheet ( ) . getProtect ( ) . getProtect ( ) ; } public void setProtect ( boolean protect ) { getSheet ( ) . getProtect ( ) . setProtect ( protect ) ; } public void setZoom ( int numerator , int denominator ) { if ( numerator < 1 || numerator > 65535 ) throw new IllegalArgumentException ( "Numerator must be greater than 1 and less than 65536" ) ; if ( denominator < 1 || denominator > 65535 ) throw new IllegalArgumentException ( "Denominator must be greater than 1 and less than 65536" ) ; SCLRecord sclRecord = new SCLRecord ( ) ; sclRecord . setNumerator ( ( short ) numerator ) ; sclRecord . setDenominator ( ( short ) denominator ) ; getSheet ( ) . setSCLRecord ( sclRecord ) ; } protected void shiftMerged ( int startRow , int endRow , int n , boolean isRow ) { List shiftedRegions = new ArrayList ( ) ; for ( int i = 0 ; i < this . getNumMergedRegions ( ) ; i ++ ) { Region merged = this . getMergedRegionAt ( i ) ; boolean inStart = ( merged . getRowFrom ( ) >= startRow || merged . getRowTo ( ) >= startRow ) ; boolean inEnd = ( merged . getRowTo ( ) <= endRow || merged . getRowFrom ( ) <= endRow ) ; if ( ! ( inStart && inEnd ) ) continue ; if ( ! merged . contains ( startRow - 1 , ( short ) 0 ) && ! merged . contains ( endRow + 1 , ( short ) 0 ) ) { merged . setRowFrom ( merged . getRowFrom ( ) + n ) ; merged . setRowTo ( merged . getRowTo ( ) + n ) ; shiftedRegions . add ( merged ) ; this . removeMergedRegion ( i ) ; i = i - 1 ; } } Iterator iterator = shiftedRegions . iterator ( ) ; while ( iterator . hasNext ( ) ) { Region region = ( Region ) iterator . next ( ) ; this . addMergedRegion ( region ) ; } } public void shiftRows ( int startRow , int endRow , int n ) { shiftRows ( startRow , endRow , n , false , false ) ; } public void shiftRows ( int startRow , int endRow , int n , boolean copyRowHeight , boolean resetOriginalRowHeight ) { int s , e , inc ; if ( n < 0 ) { s = startRow ; e = endRow ; inc = 1 ; } else { s = endRow ; e = startRow ; inc = - 1 ; } shiftMerged ( startRow , endRow , n , true ) ; for ( int rowNum = s ; rowNum >= startRow && rowNum <= endRow && rowNum >= 0 && rowNum < 65536 ; rowNum += inc ) { HSSFRow row = getRow ( rowNum ) ; HSSFRow row2Replace = getRow ( rowNum + n ) ; if ( row2Replace == null ) row2Replace = createRow ( rowNum + n ) ; HSSFCell cell ; for ( short col = row2Replace . getFirstCellNum ( ) ; col <= row2Replace . getLastCellNum ( ) ; col ++ ) { cell = row2Replace . getCell ( col ) ; if ( cell != null ) row2Replace . removeCell ( cell ) ; } if ( row == null ) continue ; else { if ( copyRowHeight ) { row2Replace . setHeight ( row . getHeight ( ) ) ; } if ( resetOriginalRowHeight ) { row . setHeight ( ( short ) 0xff ) ; } } for ( short col = row . getFirstCellNum ( ) ; col <= row . getLastCellNum ( ) ; col ++ ) { cell = row . getCell ( col ) ; if ( cell != null ) { row . removeCell ( cell ) ; CellValueRecordInterface cellRecord = cell . getCellValueRecord ( ) ; cellRecord . setRow ( rowNum + n ) ; row2Replace . createCellFromRecord ( cellRecord ) ; sheet . addValueRecord ( rowNum + n , cellRecord ) ; } } } if ( endRow == lastrow || endRow + n > lastrow ) lastrow = Math . min ( endRow + n , 65535 ) ; if ( startRow == firstrow || startRow + n < firstrow ) firstrow = Math . max ( startRow + n , 0 ) ; } protected void insertChartRecords ( List records ) { int window2Loc = sheet . findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; sheet . getRecords ( ) . addAll ( window2Loc , records ) ; } public void createFreezePane ( int colSplit , int rowSplit , int leftmostColumn , int topRow ) { if ( colSplit < 0 || colSplit > 255 ) throw new IllegalArgumentException ( "Column must be between 0 and 255" ) ; if ( rowSplit < 0 || rowSplit > 65535 ) throw new IllegalArgumentException ( "Row must be between 0 and 65535" ) ; if ( leftmostColumn < colSplit ) throw new IllegalArgumentException ( "leftmostColumn parameter must not be less than colSplit parameter" ) ; if ( topRow < rowSplit ) throw new IllegalArgumentException ( "topRow parameter must not be less than leftmostColumn parameter" ) ; getSheet ( ) . createFreezePane ( colSplit , rowSplit , topRow , leftmostColumn ) ; } public void createFreezePane ( int colSplit , int rowSplit ) { createFreezePane ( colSplit , rowSplit , colSplit , rowSplit ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int leftmostColumn , int topRow , int activePane ) { getSheet ( ) . createSplitPane ( xSplitPos , ySplitPos , topRow , leftmostColumn , activePane ) ; } public void setDisplayGridlines ( boolean show ) { sheet . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return sheet . isDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { sheet . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return sheet . isDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { sheet . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return sheet . isDisplayRowColHeadings ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; public interface HSSFListener { public void processRecord ( Record record ) ; } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class WindowOneRecord extends Record { public final static short sid = 0x3d ; private short field_1_h_hold ; private short field_2_v_hold ; private short field_3_width ; private short field_4_height ; private short field_5_options ; static final private BitField hidden = new BitField ( 0x01 ) ; static final private BitField iconic = new BitField ( 0x02 ) ; static final private BitField reserved = new BitField ( 0x04 ) ; static final private BitField hscroll = new BitField ( 0x08 ) ; static final private BitField vscroll = new BitField ( 0x10 ) ; static final private BitField tabs = new BitField ( 0x20 ) ; private short field_6_selected_tab ; private short field_7_displayed_tab ; private short field_8_num_selected_tabs ; private short field_9_tab_width_ratio ; public WindowOneRecord ( ) { } public WindowOneRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowOneRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WINDOW1 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_h_hold = LittleEndian . getShort ( data , 0 + offset ) ; field_2_v_hold = LittleEndian . getShort ( data , 2 + offset ) ; field_3_width = LittleEndian . getShort ( data , 4 + offset ) ; field_4_height = LittleEndian . getShort ( data , 6 + offset ) ; field_5_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_selected_tab = LittleEndian . getShort ( data , 10 + offset ) ; field_7_displayed_tab = LittleEndian . getShort ( data , 12 + offset ) ; field_8_num_selected_tabs = LittleEndian . getShort ( data , 14 + offset ) ; field_9_tab_width_ratio = LittleEndian . getShort ( data , 16 + offset ) ; } public void setHorizontalHold ( short h ) { field_1_h_hold = h ; } public void setVerticalHold ( short v ) { field_2_v_hold = v ; } public void setWidth ( short w ) { field_3_width = w ; } public void setHeight ( short h ) { field_4_height = h ; } public void setOptions ( short o ) { field_5_options = o ; } public void setHidden ( boolean ishidden ) { field_5_options = hidden . setShortBoolean ( field_5_options , ishidden ) ; } public void setIconic ( boolean isiconic ) { field_5_options = iconic . setShortBoolean ( field_5_options , isiconic ) ; } public void setDisplayHorizonalScrollbar ( boolean scroll ) { field_5_options = hscroll . setShortBoolean ( field_5_options , scroll ) ; } public void setDisplayVerticalScrollbar ( boolean scroll ) { field_5_options = vscroll . setShortBoolean ( field_5_options , scroll ) ; } public void setDisplayTabs ( boolean disptabs ) { field_5_options = tabs . setShortBoolean ( field_5_options , disptabs ) ; } public void setSelectedTab ( short s ) { field_6_selected_tab = s ; } public void setDisplayedTab ( short t ) { field_7_displayed_tab = t ; } public void setNumSelectedTabs ( short n ) { field_8_num_selected_tabs = n ; } public void setTabWidthRatio ( short r ) { field_9_tab_width_ratio = r ; } public short getHorizontalHold ( ) { return field_1_h_hold ; } public short getVerticalHold ( ) { return field_2_v_hold ; } public short getWidth ( ) { return field_3_width ; } public short getHeight ( ) { return field_4_height ; } public short getOptions ( ) { return field_5_options ; } public boolean getHidden ( ) { return hidden . isSet ( field_5_options ) ; } public boolean getIconic ( ) { return iconic . isSet ( field_5_options ) ; } public boolean getDisplayHorizontalScrollbar ( ) { return hscroll . isSet ( field_5_options ) ; } public boolean getDisplayVerticalScrollbar ( ) { return vscroll . isSet ( field_5_options ) ; } public boolean getDisplayTabs ( ) { return tabs . isSet ( field_5_options ) ; } public short getSelectedTab ( ) { return field_6_selected_tab ; } public short getDisplayedTab ( ) { return field_7_displayed_tab ; } public short getNumSelectedTabs ( ) { return field_8_num_selected_tabs ; } public short getTabWidthRatio ( ) { return field_9_tab_width_ratio ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOW1]\n" ) ; buffer . append ( "    .h_hold          = " ) . append ( Integer . toHexString ( getHorizontalHold ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .v_hold          = " ) . append ( Integer . toHexString ( getVerticalHold ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .width           = " ) . append ( Integer . toHexString ( getWidth ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .height          = " ) . append ( Integer . toHexString ( getHeight ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .options         = " ) . append ( Integer . toHexString ( getOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .hidden      = " ) . append ( getHidden ( ) ) . append ( "\n" ) ; buffer . append ( "        .iconic      = " ) . append ( getIconic ( ) ) . append ( "\n" ) ; buffer . append ( "        .hscroll     = " ) . append ( getDisplayHorizontalScrollbar ( ) ) . append ( "\n" ) ; buffer . append ( "        .vscroll     = " ) . append ( getDisplayVerticalScrollbar ( ) ) . append ( "\n" ) ; buffer . append ( "        .tabs        = " ) . append ( getDisplayTabs ( ) ) . append ( "\n" ) ; buffer . append ( "    .selectedtab     = " ) . append ( Integer . toHexString ( getSelectedTab ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .displayedtab    = " ) . append ( Integer . toHexString ( getDisplayedTab ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .numselectedtabs = " ) . append ( Integer . toHexString ( getNumSelectedTabs ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .tabwidthratio   = " ) . append ( Integer . toHexString ( getTabWidthRatio ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOW1]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x12 ) ) ; LittleEndian . putShort ( data , 4 + offset , getHorizontalHold ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getVerticalHold ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getWidth ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getHeight ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getSelectedTab ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getDisplayedTab ( ) ) ; LittleEndian . putShort ( data , 18 + offset , getNumSelectedTabs ( ) ) ; LittleEndian . putShort ( data , 20 + offset , getTabWidthRatio ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class ColumnInfoRecord extends Record { public static final short sid = 0x7d ; private short field_1_first_col ; private short field_2_last_col ; private short field_3_col_width ; private short field_4_xf_index ; private short field_5_options ; static final private BitField hidden = new BitField ( 0x01 ) ; static final private BitField outlevel = new BitField ( 0x0700 ) ; static final private BitField collapsed = new BitField ( 0x1000 ) ; private short field_6_reserved ; public ColumnInfoRecord ( ) { } public ColumnInfoRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ColumnInfoRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_first_col = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_col_width = LittleEndian . getShort ( data , 4 + offset ) ; field_4_xf_index = LittleEndian . getShort ( data , 6 + offset ) ; field_5_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_reserved = data [ 10 + offset ] ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A COLINFO RECORD!!" ) ; } } public void setFirstColumn ( short fc ) { field_1_first_col = fc ; } public void setLastColumn ( short lc ) { field_2_last_col = lc ; } public void setColumnWidth ( short cw ) { field_3_col_width = cw ; } public void setXFIndex ( short xfi ) { field_4_xf_index = xfi ; } public void setOptions ( short options ) { field_5_options = options ; } public void setHidden ( boolean ishidden ) { field_5_options = hidden . setShortBoolean ( field_5_options , ishidden ) ; } public void setOutlineLevel ( short olevel ) { field_5_options = outlevel . setShortValue ( field_5_options , olevel ) ; } public void setCollapsed ( boolean iscollapsed ) { field_5_options = collapsed . setShortBoolean ( field_5_options , iscollapsed ) ; } public short getFirstColumn ( ) { return field_1_first_col ; } public short getLastColumn ( ) { return field_2_last_col ; } public short getColumnWidth ( ) { return field_3_col_width ; } public short getXFIndex ( ) { return field_4_xf_index ; } public short getOptions ( ) { return field_5_options ; } public boolean getHidden ( ) { return hidden . isSet ( field_5_options ) ; } public short getOutlineLevel ( ) { return outlevel . getShortValue ( field_5_options ) ; } public boolean getCollapsed ( ) { return collapsed . isSet ( field_5_options ) ; } public short getSid ( ) { return sid ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 12 ) ; LittleEndian . putShort ( data , 4 + offset , getFirstColumn ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getLastColumn ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getColumnWidth ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getXFIndex ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , ( short ) 0x0 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 16 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[COLINFO]\n" ) ; buffer . append ( "colfirst       = " ) . append ( getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "collast        = " ) . append ( getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "colwidth       = " ) . append ( getColumnWidth ( ) ) . append ( "\n" ) ; buffer . append ( "xfindex        = " ) . append ( getXFIndex ( ) ) . append ( "\n" ) ; buffer . append ( "options        = " ) . append ( getOptions ( ) ) . append ( "\n" ) ; buffer . append ( "  hidden       = " ) . append ( getHidden ( ) ) . append ( "\n" ) ; buffer . append ( "  olevel       = " ) . append ( getOutlineLevel ( ) ) . append ( "\n" ) ; buffer . append ( "  collapsed    = " ) . append ( getCollapsed ( ) ) . append ( "\n" ) ; buffer . append ( "[/COLINFO]\n" ) ; return buffer . toString ( ) ; } public Object clone ( ) { ColumnInfoRecord rec = new ColumnInfoRecord ( ) ; rec . field_1_first_col = field_1_first_col ; rec . field_2_last_col = field_2_last_col ; rec . field_3_col_width = field_3_col_width ; rec . field_4_xf_index = field_4_xf_index ; rec . field_5_options = field_5_options ; rec . field_6_reserved = field_6_reserved ; return rec ; } } 	0
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LongField ; import org . apache . poi . util . ShortField ; public class HeaderBlockWriter extends BigBlock implements HeaderBlockConstants { private static final byte _default_value = ( byte ) 0xFF ; private IntegerField _bat_count ; private IntegerField _property_start ; private IntegerField _sbat_start ; private IntegerField _sbat_block_count ; private IntegerField _xbat_start ; private IntegerField _xbat_count ; private byte [ ] _data ; public HeaderBlockWriter ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; new LongField ( _signature_offset , _signature , _data ) ; new IntegerField ( 0x08 , 0 , _data ) ; new IntegerField ( 0x0c , 0 , _data ) ; new IntegerField ( 0x10 , 0 , _data ) ; new IntegerField ( 0x14 , 0 , _data ) ; new ShortField ( 0x18 , ( short ) 0x3b , _data ) ; new ShortField ( 0x1a , ( short ) 0x3 , _data ) ; new ShortField ( 0x1c , ( short ) - 2 , _data ) ; new ShortField ( 0x1e , ( short ) 0x9 , _data ) ; new IntegerField ( 0x20 , 0x6 , _data ) ; new IntegerField ( 0x24 , 0 , _data ) ; new IntegerField ( 0x28 , 0 , _data ) ; _bat_count = new IntegerField ( _bat_count_offset , 0 , _data ) ; _property_start = new IntegerField ( _property_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; new IntegerField ( 0x34 , 0 , _data ) ; new IntegerField ( 0x38 , 0x1000 , _data ) ; _sbat_start = new IntegerField ( _sbat_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; _sbat_block_count = new IntegerField ( _sbat_block_count_offset , 0 , _data ) ; _xbat_start = new IntegerField ( _xbat_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; _xbat_count = new IntegerField ( _xbat_count_offset , 0 , _data ) ; } public BATBlock [ ] setBATBlocks ( final int blockCount , final int startBlock ) { BATBlock [ ] rvalue ; _bat_count . set ( blockCount , _data ) ; int limit = Math . min ( blockCount , _max_bats_in_header ) ; int offset = _bat_array_offset ; for ( int j = 0 ; j < limit ; j ++ ) { new IntegerField ( offset , startBlock + j , _data ) ; offset += LittleEndianConsts . INT_SIZE ; } if ( blockCount > _max_bats_in_header ) { int excess_blocks = blockCount - _max_bats_in_header ; int [ ] excess_block_array = new int [ excess_blocks ] ; for ( int j = 0 ; j < excess_blocks ; j ++ ) { excess_block_array [ j ] = startBlock + j + _max_bats_in_header ; } rvalue = BATBlock . createXBATBlocks ( excess_block_array , startBlock + blockCount ) ; _xbat_start . set ( startBlock + blockCount , _data ) ; } else { rvalue = BATBlock . createXBATBlocks ( new int [ 0 ] , 0 ) ; _xbat_start . set ( POIFSConstants . END_OF_CHAIN , _data ) ; } _xbat_count . set ( rvalue . length , _data ) ; return rvalue ; } public void setPropertyStart ( final int startBlock ) { _property_start . set ( startBlock , _data ) ; } public void setSBATStart ( final int startBlock ) { _sbat_start . set ( startBlock , _data ) ; } public void setSBATBlockCount ( final int count ) { _sbat_block_count . set ( count , _data ) ; } static int calculateXBATStorageRequirements ( final int blockCount ) { return ( blockCount > _max_bats_in_header ) ? BATBlock . calculateXBATStorageRequirements ( blockCount - _max_bats_in_header ) : 0 ; } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public interface FixedField { public void readFromBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public void readFromStream ( InputStream stream ) throws IOException , BufferUnderrunException ; public void writeToBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public String toString ( ) ; } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; public class GreaterEqualPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0c ; public GreaterEqualPtg ( ) { } public GreaterEqualPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return ">=" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new GreaterEqualPtg ( ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1
package org . apache . poi . hpsf ; public class NoSingleSectionException extends HPSFRuntimeException { public NoSingleSectionException ( ) { super ( ) ; } public NoSingleSectionException ( final String msg ) { super ( msg ) ; } public NoSingleSectionException ( final Throwable reason ) { super ( reason ) ; } public NoSingleSectionException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DimensionsRecord extends Record { public final static short sid = 0x200 ; private int field_1_first_row ; private int field_2_last_row ; private short field_3_first_col ; private short field_4_last_col ; private short field_5_zero ; public DimensionsRecord ( ) { } public DimensionsRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DimensionsRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A valid DIMENSIONS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_first_row = LittleEndian . getInt ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getInt ( data , 4 + offset ) ; field_3_first_col = LittleEndian . getShort ( data , 8 + offset ) ; field_4_last_col = LittleEndian . getShort ( data , 10 + offset ) ; field_5_zero = LittleEndian . getShort ( data , 12 + offset ) ; } public void setFirstRow ( int row ) { field_1_first_row = row ; } public void setLastRow ( int row ) { field_2_last_row = row ; } public void setFirstCol ( short col ) { field_3_first_col = col ; } public void setLastCol ( short col ) { field_4_last_col = col ; } public int getFirstRow ( ) { return field_1_first_row ; } public int getLastRow ( ) { return field_2_last_row ; } public short getFirstCol ( ) { return field_3_first_col ; } public short getLastCol ( ) { return field_4_last_col ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DIMENSIONS]\n" ) ; buffer . append ( "    .firstrow       = " ) . append ( Integer . toHexString ( getFirstRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .lastrow        = " ) . append ( Integer . toHexString ( getLastRow ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .firstcol       = " ) . append ( Integer . toHexString ( getFirstCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .lastcol        = " ) . append ( Integer . toHexString ( getLastCol ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .zero           = " ) . append ( Integer . toHexString ( field_5_zero ) ) . append ( "\n" ) ; buffer . append ( "[/DIMENSIONS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 14 ) ; LittleEndian . putInt ( data , 4 + offset , getFirstRow ( ) ) ; LittleEndian . putInt ( data , 8 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getFirstCol ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getLastCol ( ) ) ; LittleEndian . putShort ( data , 16 + offset , ( short ) 0 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 18 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { DimensionsRecord rec = new DimensionsRecord ( ) ; rec . field_1_first_row = field_1_first_row ; rec . field_2_last_row = field_2_last_row ; rec . field_3_first_col = field_3_first_col ; rec . field_4_last_col = field_4_last_col ; rec . field_5_zero = field_5_zero ; return rec ; } } 	0
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class UnaryPlusPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x12 ; private final static String ADD = "+" ; public UnaryPlusPtg ( ) { } public UnaryPlusPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return this . TYPE_UNARY ; } public int getNumberOfOperands ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "+" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( ADD ) ; buffer . append ( operands [ 0 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new UnaryPlusPtg ( ) ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1
package org . apache . poi . hssf . record ; import java . io . InputStream ; import java . io . IOException ; import java . util . * ; import java . lang . reflect . Constructor ; import org . apache . poi . util . LittleEndian ; public class RecordFactory { private static int NUM_RECORDS = 10000 ; private static final Class [ ] records ; static { if ( FormulaRecord . EXPERIMENTAL_FORMULA_SUPPORT_ENABLED ) { records = new Class [ ] { BOFRecord . class , InterfaceHdrRecord . class , MMSRecord . class , InterfaceEndRecord . class , WriteAccessRecord . class , CodepageRecord . class , DSFRecord . class , TabIdRecord . class , FnGroupCountRecord . class , WindowProtectRecord . class , ProtectRecord . class , PasswordRecord . class , ProtectionRev4Record . class , PasswordRev4Record . class , WindowOneRecord . class , BackupRecord . class , HideObjRecord . class , DateWindow1904Record . class , PrecisionRecord . class , RefreshAllRecord . class , BookBoolRecord . class , FontRecord . class , FormatRecord . class , ExtendedFormatRecord . class , StyleRecord . class , UseSelFSRecord . class , BoundSheetRecord . class , CountryRecord . class , SSTRecord . class , ExtSSTRecord . class , EOFRecord . class , IndexRecord . class , CalcModeRecord . class , CalcCountRecord . class , RefModeRecord . class , IterationRecord . class , DeltaRecord . class , SaveRecalcRecord . class , PrintHeadersRecord . class , PrintGridlinesRecord . class , GridsetRecord . class , GutsRecord . class , DefaultRowHeightRecord . class , WSBoolRecord . class , HeaderRecord . class , FooterRecord . class , HCenterRecord . class , VCenterRecord . class , PrintSetupRecord . class , DefaultColWidthRecord . class , DimensionsRecord . class , RowRecord . class , LabelSSTRecord . class , RKRecord . class , NumberRecord . class , DBCellRecord . class , WindowTwoRecord . class , SelectionRecord . class , ContinueRecord . class , LabelRecord . class , BlankRecord . class , ColumnInfoRecord . class , MulRKRecord . class , MulBlankRecord . class , MergeCellsRecord . class , FormulaRecord . class , BoolErrRecord . class , ExternSheetRecord . class , NameRecord . class , LeftMarginRecord . class , RightMarginRecord . class , TopMarginRecord . class , BottomMarginRecord . class , PaletteRecord . class , StringRecord . class , RecalcIdRecord . class , SharedFormulaRecord . class } ; } else { records = new Class [ ] { BOFRecord . class , InterfaceHdrRecord . class , MMSRecord . class , InterfaceEndRecord . class , WriteAccessRecord . class , CodepageRecord . class , DSFRecord . class , TabIdRecord . class , FnGroupCountRecord . class , WindowProtectRecord . class , ProtectRecord . class , PasswordRecord . class , ProtectionRev4Record . class , PasswordRev4Record . class , WindowOneRecord . class , BackupRecord . class , HideObjRecord . class , DateWindow1904Record . class , PrecisionRecord . class , RefreshAllRecord . class , BookBoolRecord . class , FontRecord . class , FormatRecord . class , ExtendedFormatRecord . class , StyleRecord . class , UseSelFSRecord . class , BoundSheetRecord . class , CountryRecord . class , SSTRecord . class , ExtSSTRecord . class , EOFRecord . class , IndexRecord . class , CalcModeRecord . class , CalcCountRecord . class , RefModeRecord . class , IterationRecord . class , DeltaRecord . class , SaveRecalcRecord . class , PrintHeadersRecord . class , PrintGridlinesRecord . class , GridsetRecord . class , GutsRecord . class , DefaultRowHeightRecord . class , WSBoolRecord . class , HeaderRecord . class , FooterRecord . class , HCenterRecord . class , VCenterRecord . class , PrintSetupRecord . class , DefaultColWidthRecord . class , DimensionsRecord . class , RowRecord . class , LabelSSTRecord . class , RKRecord . class , NumberRecord . class , DBCellRecord . class , WindowTwoRecord . class , SelectionRecord . class , ContinueRecord . class , LabelRecord . class , BlankRecord . class , ColumnInfoRecord . class , MulRKRecord . class , MulBlankRecord . class , MergeCellsRecord . class , BoolErrRecord . class , ExternSheetRecord . class , NameRecord . class , LeftMarginRecord . class , RightMarginRecord . class , TopMarginRecord . class , BottomMarginRecord . class , PaletteRecord . class , StringRecord . class , RecalcIdRecord . class , SharedFormulaRecord . class } ; } } private static Map recordsMap = recordsToMap ( records ) ; public static void setCapacity ( int capacity ) { NUM_RECORDS = capacity ; } public static List createRecords ( InputStream in ) throws RecordFormatException { ArrayList records = new ArrayList ( NUM_RECORDS ) ; Record last_record = null ; try { short rectype = 0 ; do { rectype = LittleEndian . readShort ( in ) ; if ( rectype != 0 ) { short recsize = LittleEndian . readShort ( in ) ; byte [ ] data = new byte [ ( int ) recsize ] ; in . read ( data ) ; Record [ ] recs = createRecord ( rectype , recsize , data ) ; if ( recs . length > 1 ) { for ( int k = 0 ; k < recs . length ; k ++ ) { records . add ( recs [ k ] ) ; last_record = recs [ k ] ; } } else { Record record = recs [ 0 ] ; if ( record != null ) { if ( rectype == ContinueRecord . sid && ! ( last_record instanceof ContinueRecord ) && ! ( last_record instanceof UnknownRecord ) ) { if ( last_record == null ) { throw new RecordFormatException ( "First record is a ContinueRecord??" ) ; } last_record . processContinueRecord ( data ) ; } else { last_record = record ; records . add ( record ) ; } } } } } while ( rectype != 0 ) ; } catch ( IOException e ) { throw new RecordFormatException ( "Error reading bytes" ) ; } return records ; } public static Record [ ] createRecord ( short rectype , short size , byte [ ] data ) { Record retval = null ; Record [ ] realretval = null ; try { Constructor constructor = ( Constructor ) recordsMap . get ( new Short ( rectype ) ) ; if ( constructor != null ) { retval = ( Record ) constructor . newInstance ( new Object [ ] { new Short ( rectype ) , new Short ( size ) , data } ) ; } else { retval = new UnknownRecord ( rectype , size , data ) ; } } catch ( Exception introspectionException ) { introspectionException . printStackTrace ( ) ; throw new RecordFormatException ( "Unable to construct record instance, the following exception occured: " + introspectionException . getMessage ( ) ) ; } if ( retval instanceof RKRecord ) { RKRecord rk = ( RKRecord ) retval ; NumberRecord num = new NumberRecord ( ) ; num . setColumn ( rk . getColumn ( ) ) ; num . setRow ( rk . getRow ( ) ) ; num . setXFIndex ( rk . getXFIndex ( ) ) ; num . setValue ( rk . getRKNumber ( ) ) ; retval = num ; } else if ( retval instanceof DBCellRecord ) { retval = null ; } else if ( retval instanceof MulRKRecord ) { MulRKRecord mrk = ( MulRKRecord ) retval ; realretval = new Record [ mrk . getNumColumns ( ) ] ; for ( int k = 0 ; k < mrk . getNumColumns ( ) ; k ++ ) { NumberRecord nr = new NumberRecord ( ) ; nr . setColumn ( ( short ) ( k + mrk . getFirstColumn ( ) ) ) ; nr . setRow ( mrk . getRow ( ) ) ; nr . setXFIndex ( mrk . getXFAt ( k ) ) ; nr . setValue ( mrk . getRKNumberAt ( k ) ) ; realretval [ k ] = nr ; } } else if ( retval instanceof MulBlankRecord ) { MulBlankRecord mb = ( MulBlankRecord ) retval ; realretval = new Record [ mb . getNumColumns ( ) ] ; for ( int k = 0 ; k < mb . getNumColumns ( ) ; k ++ ) { BlankRecord br = new BlankRecord ( ) ; br . setColumn ( ( short ) ( k + mb . getFirstColumn ( ) ) ) ; br . setRow ( mb . getRow ( ) ) ; br . setXFIndex ( mb . getXFAt ( k ) ) ; realretval [ k ] = br ; } } if ( realretval == null ) { realretval = new Record [ 1 ] ; realretval [ 0 ] = retval ; } return realretval ; } public static short [ ] getAllKnownRecordSIDs ( ) { short [ ] results = new short [ recordsMap . size ( ) ] ; int i = 0 ; for ( Iterator iterator = recordsMap . keySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Short sid = ( Short ) iterator . next ( ) ; results [ i ++ ] = sid . shortValue ( ) ; } return results ; } private static Map recordsToMap ( Class [ ] records ) { Map result = new HashMap ( ) ; Constructor constructor ; for ( int i = 0 ; i < records . length ; i ++ ) { Class record = null ; short sid = 0 ; record = records [ i ] ; try { sid = record . getField ( "sid" ) . getShort ( null ) ; constructor = record . getConstructor ( new Class [ ] { short . class , short . class , byte [ ] . class } ) ; } catch ( Exception illegalArgumentException ) { throw new RecordFormatException ( "Unable to determine record types" ) ; } result . put ( new Short ( sid ) , constructor ) ; } return result ; } } 	0
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1
package org . apache . poi . poifs . filesystem ; public interface DocumentEntry extends Entry { public int getSize ( ) ; } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class SharedFormulaRecord extends Record { public final static short sid = 0x4BC ; private short size = 0 ; private byte [ ] thedata = null ; int offset = 0 ; public SharedFormulaRecord ( ) { } public SharedFormulaRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; this . fillFields ( data , size , 0 ) ; } public int serialize ( int offset , byte [ ] data ) { if ( thedata == null ) { thedata = new byte [ 0 ] ; } LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( thedata . length ) ) ; if ( thedata . length > 0 ) { System . arraycopy ( thedata , 0 , data , 4 + offset , thedata . length ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { int retval = 4 ; if ( thedata != null ) { retval += thedata . length ; } return retval ; } protected void validateSid ( short id ) { if ( id != this . sid ) { throw new RecordFormatException ( "Not a valid SharedFormula" ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[SHARED FORMULA RECORD:" + Integer . toHexString ( sid ) + "]\n" ) ; buffer . append ( "    .id        = " ) . append ( Integer . toHexString ( sid ) ) . append ( "\n" ) ; buffer . append ( "[/SHARED FORMULA RECORD]\n" ) ; return buffer . toString ( ) ; } public short getSid ( ) { return this . sid ; } protected void fillFields ( byte [ ] data , short size , int offset ) { thedata = new byte [ size ] ; System . arraycopy ( data , 0 , thedata , 0 , size ) ; } public boolean isInValueSection ( ) { return true ; } public boolean isValue ( ) { return true ; } public Object clone ( ) { SharedFormulaRecord rec = new SharedFormulaRecord ( ) ; rec . offset = offset ; rec . size = size ; rec . thedata = thedata ; return rec ; } } 	0
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1
package org . apache . poi . hssf . record . formula ; public abstract class ControlPtg extends Ptg { } 	0
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class PlotGrowthRecord extends Record { public final static short sid = 0x1064 ; private int field_1_horizontalScale ; private int field_2_verticalScale ; public PlotGrowthRecord ( ) { } public PlotGrowthRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PlotGrowthRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a PlotGrowth record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_horizontalScale = LittleEndian . getInt ( data , pos + 0x0 + offset ) ; field_2_verticalScale = LittleEndian . getInt ( data , pos + 0x4 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PLOTGROWTH]\n" ) ; buffer . append ( "    .horizontalScale      = " ) . append ( "0x" ) . append ( HexDump . toHex ( getHorizontalScale ( ) ) ) . append ( " (" ) . append ( getHorizontalScale ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "    .verticalScale        = " ) . append ( "0x" ) . append ( HexDump . toHex ( getVerticalScale ( ) ) ) . append ( " (" ) . append ( getVerticalScale ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/PLOTGROWTH]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putInt ( data , 4 + offset + pos , field_1_horizontalScale ) ; LittleEndian . putInt ( data , 8 + offset + pos , field_2_verticalScale ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 4 + 4 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { PlotGrowthRecord rec = new PlotGrowthRecord ( ) ; rec . field_1_horizontalScale = field_1_horizontalScale ; rec . field_2_verticalScale = field_2_verticalScale ; return rec ; } public int getHorizontalScale ( ) { return field_1_horizontalScale ; } public void setHorizontalScale ( int field_1_horizontalScale ) { this . field_1_horizontalScale = field_1_horizontalScale ; } public int getVerticalScale ( ) { return field_2_verticalScale ; } public void setVerticalScale ( int field_2_verticalScale ) { this . field_2_verticalScale = field_2_verticalScale ; } } 	0
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1
package org . apache . poi . hpsf ; public class IllegalPropertySetDataException extends HPSFRuntimeException { public IllegalPropertySetDataException ( ) { super ( ) ; } public IllegalPropertySetDataException ( final String msg ) { super ( msg ) ; } public IllegalPropertySetDataException ( final Throwable reason ) { super ( reason ) ; } public IllegalPropertySetDataException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1
package org . apache . poi . poifs . property ; import java . util . * ; import java . io . IOException ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class RootProperty extends DirectoryProperty { RootProperty ( ) { super ( "Root Entry" ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . ROOT_TYPE ) ; setStartBlock ( POIFSConstants . END_OF_CHAIN ) ; } protected RootProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; } public void setSize ( int size ) { super . setSize ( SmallDocumentBlock . calcSize ( size ) ) ; } } 	0
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class UnaryMinusPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x13 ; private final static String MINUS = "-" ; public UnaryMinusPtg ( ) { } public UnaryMinusPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return this . TYPE_UNARY ; } public int getNumberOfOperands ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "+" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( MINUS ) ; buffer . append ( operands [ 0 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new UnaryPlusPtg ( ) ; } } 	0
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1
package org . apache . poi . poifs . storage ; import java . util . * ; public class SmallDocumentBlockList extends BlockListImpl { public SmallDocumentBlockList ( final List blocks ) { setBlocks ( ( SmallDocumentBlock [ ] ) blocks . toArray ( new SmallDocumentBlock [ 0 ] ) ) ; } } 	0
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; public class FormulaRecordAggregate extends Record implements CellValueRecordInterface , Comparable { public final static short sid = - 2000 ; private FormulaRecord formulaRecord ; private StringRecord stringRecord ; private SharedFormulaRecord sharedFormulaRecord ; public FormulaRecordAggregate ( FormulaRecord formulaRecord , StringRecord stringRecord ) { this . formulaRecord = formulaRecord ; this . stringRecord = stringRecord ; } public FormulaRecordAggregate ( FormulaRecord formulaRecord , StringRecord stringRecord , SharedFormulaRecord sharedRecord ) { this . formulaRecord = formulaRecord ; this . stringRecord = stringRecord ; this . sharedFormulaRecord = sharedRecord ; } protected void validateSid ( short id ) { } protected void fillFields ( byte [ ] data , short size , int offset ) { } public int serialize ( int offset , byte [ ] data ) { int pos = offset ; pos += formulaRecord . serialize ( pos , data ) ; if ( this . getSharedFormulaRecord ( ) != null ) { pos += getSharedFormulaRecord ( ) . serialize ( pos , data ) ; } if ( stringRecord != null ) { pos += stringRecord . serialize ( pos , data ) ; } return pos - offset ; } public int getRecordSize ( ) { int size = formulaRecord . getRecordSize ( ) + ( stringRecord == null ? 0 : stringRecord . getRecordSize ( ) ) ; size += ( getSharedFormulaRecord ( ) == null ) ? 0 : getSharedFormulaRecord ( ) . getRecordSize ( ) ; return size ; } public short getSid ( ) { return sid ; } public void setStringRecord ( StringRecord stringRecord ) { this . stringRecord = stringRecord ; } public void setFormulaRecord ( FormulaRecord formulaRecord ) { this . formulaRecord = formulaRecord ; } public FormulaRecord getFormulaRecord ( ) { return formulaRecord ; } public StringRecord getStringRecord ( ) { return stringRecord ; } public boolean isEqual ( CellValueRecordInterface i ) { return formulaRecord . isEqual ( i ) ; } public boolean isAfter ( CellValueRecordInterface i ) { return formulaRecord . isAfter ( i ) ; } public boolean isBefore ( CellValueRecordInterface i ) { return formulaRecord . isBefore ( i ) ; } public short getXFIndex ( ) { return formulaRecord . getXFIndex ( ) ; } public void setXFIndex ( short xf ) { formulaRecord . setXFIndex ( xf ) ; } public void setColumn ( short col ) { formulaRecord . setColumn ( col ) ; } public void setRow ( int row ) { formulaRecord . setRow ( row ) ; } public short getColumn ( ) { return formulaRecord . getColumn ( ) ; } public int getRow ( ) { return formulaRecord . getRow ( ) ; } public int compareTo ( Object o ) { return formulaRecord . compareTo ( o ) ; } public boolean equals ( Object obj ) { return formulaRecord . equals ( obj ) ; } public String toString ( ) { return formulaRecord . toString ( ) ; } public Object clone ( ) { StringRecord clonedString = ( stringRecord == null ) ? null : ( StringRecord ) stringRecord . clone ( ) ; SharedFormulaRecord clonedShared = ( sharedFormulaRecord == null ) ? null : ( SharedFormulaRecord ) sharedFormulaRecord . clone ( ) ; return new FormulaRecordAggregate ( ( FormulaRecord ) this . formulaRecord . clone ( ) , clonedString , clonedShared ) ; } public SharedFormulaRecord getSharedFormulaRecord ( ) { return sharedFormulaRecord ; } public void setSharedFormulaRecord ( SharedFormulaRecord sharedFormulaRecord ) { this . sharedFormulaRecord = sharedFormulaRecord ; } public boolean isInValueSection ( ) { return true ; } public String getStringValue ( ) { if ( stringRecord == null ) return null ; return stringRecord . getString ( ) ; } } 	0
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1
package org . apache . poi . poifs . filesystem ; import java . io . * ; public class DocumentInputStream extends InputStream { private int _current_offset ; private int _marked_offset ; private int _document_size ; private boolean _closed ; private POIFSDocument _document ; private byte [ ] _tiny_buffer ; static private final int EOD = - 1 ; public DocumentInputStream ( final DocumentEntry document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; if ( document instanceof DocumentNode ) { _document = ( ( DocumentNode ) document ) . getDocument ( ) ; } else { throw new IOException ( "Cannot open internal document storage" ) ; } } public DocumentInputStream ( final POIFSDocument document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; _document = document ; } public int available ( ) throws IOException { dieIfClosed ( ) ; return _document_size - _current_offset ; } public void close ( ) throws IOException { _closed = true ; } public void mark ( int ignoredReadlimit ) { _marked_offset = _current_offset ; } public boolean markSupported ( ) { return true ; } public int read ( ) throws IOException { dieIfClosed ( ) ; if ( atEOD ( ) ) { return EOD ; } if ( _tiny_buffer == null ) { _tiny_buffer = new byte [ 1 ] ; } _document . read ( _tiny_buffer , _current_offset ++ ) ; return ( ( int ) _tiny_buffer [ 0 ] ) & 0x000000FF ; } public int read ( final byte [ ] b ) throws IOException , NullPointerException { return read ( b , 0 , b . length ) ; } public int read ( final byte [ ] b , final int off , final int len ) throws IOException , NullPointerException , IndexOutOfBoundsException { dieIfClosed ( ) ; if ( b == null ) { throw new NullPointerException ( "buffer is null" ) ; } if ( ( off < 0 ) || ( len < 0 ) || ( b . length < ( off + len ) ) ) { throw new IndexOutOfBoundsException ( "can't read past buffer boundaries" ) ; } if ( len == 0 ) { return 0 ; } if ( atEOD ( ) ) { return EOD ; } int limit = Math . min ( available ( ) , len ) ; if ( ( off == 0 ) && ( limit == b . length ) ) { _document . read ( b , _current_offset ) ; } else { byte [ ] buffer = new byte [ limit ] ; _document . read ( buffer , _current_offset ) ; System . arraycopy ( buffer , 0 , b , off , limit ) ; } _current_offset += limit ; return limit ; } public void reset ( ) { _current_offset = _marked_offset ; } public long skip ( final long n ) throws IOException { dieIfClosed ( ) ; if ( n < 0 ) { return 0 ; } int new_offset = _current_offset + ( int ) n ; if ( new_offset < _current_offset ) { new_offset = _document_size ; } else if ( new_offset > _document_size ) { new_offset = _document_size ; } long rval = new_offset - _current_offset ; _current_offset = new_offset ; return rval ; } private void dieIfClosed ( ) throws IOException { if ( _closed ) { throw new IOException ( "cannot perform requested operation on a closed stream" ) ; } } private boolean atEOD ( ) { return _current_offset == _document_size ; } } 	0
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; public class MemErrPtg extends Ptg { public final static short sid = 0x27 ; private final static int SIZE = 7 ; private int field_1_reserved ; private short field_2_subex_len ; public MemErrPtg ( ) { } public MemErrPtg ( byte [ ] data , int offset ) { field_1_reserved = LittleEndian . getInt ( data , 0 ) ; field_2_subex_len = LittleEndian . getShort ( data , 4 ) ; } public void setReserved ( int res ) { field_1_reserved = res ; } public int getReserved ( ) { return field_1_reserved ; } public void setSubexpressionLength ( short subexlen ) { field_2_subex_len = subexlen ; } public short getSubexpressionLength ( ) { return field_2_subex_len ; } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return "ERR#" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { MemErrPtg ptg = new MemErrPtg ( ) ; ptg . field_1_reserved = field_1_reserved ; ptg . field_2_subex_len = field_2_subex_len ; return ptg ; } } 	0
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class AreaRecord extends Record { public final static short sid = 0x101A ; private short field_1_formatFlags ; private BitField stacked = new BitField ( 0x1 ) ; private BitField displayAsPercentage = new BitField ( 0x2 ) ; private BitField shadow = new BitField ( 0x4 ) ; public AreaRecord ( ) { } public AreaRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public AreaRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a Area record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_formatFlags = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[AREA]\n" ) ; buffer . append ( "    .formatFlags          = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFormatFlags ( ) ) ) . append ( " (" ) . append ( getFormatFlags ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "         .stacked                  = " ) . append ( isStacked ( ) ) . append ( '\n' ) ; buffer . append ( "         .displayAsPercentage      = " ) . append ( isDisplayAsPercentage ( ) ) . append ( '\n' ) ; buffer . append ( "         .shadow                   = " ) . append ( isShadow ( ) ) . append ( '\n' ) ; buffer . append ( "[/AREA]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_formatFlags ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { AreaRecord rec = new AreaRecord ( ) ; rec . field_1_formatFlags = field_1_formatFlags ; return rec ; } public short getFormatFlags ( ) { return field_1_formatFlags ; } public void setFormatFlags ( short field_1_formatFlags ) { this . field_1_formatFlags = field_1_formatFlags ; } public void setStacked ( boolean value ) { field_1_formatFlags = stacked . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isStacked ( ) { return stacked . isSet ( field_1_formatFlags ) ; } public void setDisplayAsPercentage ( boolean value ) { field_1_formatFlags = displayAsPercentage . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isDisplayAsPercentage ( ) { return displayAsPercentage . isSet ( field_1_formatFlags ) ; } public void setShadow ( boolean value ) { field_1_formatFlags = shadow . setShortBoolean ( field_1_formatFlags , value ) ; } public boolean isShadow ( ) { return shadow . isSet ( field_1_formatFlags ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1
package org . apache . poi . poifs . dev ; import java . util . Iterator ; public interface POIFSViewable { public Object [ ] getViewableArray ( ) ; public Iterator getViewableIterator ( ) ; public boolean preferArray ( ) ; public String getShortDescription ( ) ; } 	0
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1
package org . apache . poi . poifs . filesystem ; public interface POIFSWriterListener { public void processPOIFSWriterEvent ( POIFSWriterEvent event ) ; } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1
package org . apache . poi . poifs . filesystem ; public class DocumentDescriptor { private POIFSDocumentPath path ; private String name ; private int hashcode = 0 ; public DocumentDescriptor ( final POIFSDocumentPath path , final String name ) { if ( path == null ) { throw new NullPointerException ( "path must not be null" ) ; } if ( name == null ) { throw new NullPointerException ( "name must not be null" ) ; } if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "name cannot be empty" ) ; } this . path = path ; this . name = name ; } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { DocumentDescriptor descriptor = ( DocumentDescriptor ) o ; rval = this . path . equals ( descriptor . path ) && this . name . equals ( descriptor . name ) ; } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { hashcode = path . hashCode ( ) ^ name . hashCode ( ) ; } return hashcode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( 40 * ( path . length ( ) + 1 ) ) ; for ( int j = 0 ; j < path . length ( ) ; j ++ ) { buffer . append ( path . getComponent ( j ) ) . append ( "/" ) ; } buffer . append ( name ) ; return buffer . toString ( ) ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class FontIndexRecord extends Record { public final static short sid = 0x1026 ; private short field_1_fontIndex ; public FontIndexRecord ( ) { } public FontIndexRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FontIndexRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a FontIndex record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { int pos = 0 ; field_1_fontIndex = LittleEndian . getShort ( data , pos + 0x0 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FONTX]\n" ) ; buffer . append ( "    .fontIndex            = " ) . append ( "0x" ) . append ( HexDump . toHex ( getFontIndex ( ) ) ) . append ( " (" ) . append ( getFontIndex ( ) ) . append ( " )" ) ; buffer . append ( System . getProperty ( "line.separator" ) ) ; buffer . append ( "[/FONTX]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { int pos = 0 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset + pos , field_1_fontIndex ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { FontIndexRecord rec = new FontIndexRecord ( ) ; rec . field_1_fontIndex = field_1_fontIndex ; return rec ; } public short getFontIndex ( ) { return field_1_fontIndex ; } public void setFontIndex ( short field_1_fontIndex ) { this . field_1_fontIndex = field_1_fontIndex ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ProtectRecord extends Record { public final static short sid = 0x12 ; private short field_1_protect ; public ProtectRecord ( ) { } public ProtectRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ProtectRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROTECT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public boolean getProtect ( ) { return ( field_1_protect == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROTECT]\n" ) ; buffer . append ( "    .protect         = " ) . append ( getProtect ( ) ) . append ( "\n" ) ; buffer . append ( "[/PROTECT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_protect ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { ProtectRecord rec = new ProtectRecord ( ) ; rec . field_1_protect = field_1_protect ; return rec ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ByteField implements FixedField { private static final byte _default_value = 0 ; private byte _value ; private final int _offset ; public ByteField ( final int offset ) throws ArrayIndexOutOfBoundsException { this ( offset , _default_value ) ; } public ByteField ( final int offset , final byte value ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "offset cannot be negative" ) ; } _offset = offset ; set ( value ) ; } public ByteField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ByteField ( final int offset , final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset , value ) ; writeToBytes ( data ) ; } public byte get ( ) { return _value ; } public void set ( final byte value ) { _value = value ; } public void set ( final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { set ( value ) ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = data [ _offset ] ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = ( LittleEndian . readFromStream ( stream , LittleEndianConsts . BYTE_SIZE ) ) [ 0 ] ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { data [ _offset ] = _value ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; class BlockListImpl implements BlockList { private ListManagedBlock [ ] _blocks ; private BlockAllocationTableReader _bat ; protected BlockListImpl ( ) { _blocks = new ListManagedBlock [ 0 ] ; _bat = null ; } protected void setBlocks ( final ListManagedBlock [ ] blocks ) { _blocks = blocks ; } public void zap ( final int index ) { if ( ( index >= 0 ) && ( index < _blocks . length ) ) { _blocks [ index ] = null ; } } public ListManagedBlock remove ( final int index ) throws IOException { ListManagedBlock result = null ; try { result = _blocks [ index ] ; if ( result == null ) { throw new IOException ( "block[ " + index + " ] already removed" ) ; } _blocks [ index ] = null ; } catch ( ArrayIndexOutOfBoundsException ignored ) { throw new IOException ( "Cannot remove block[ " + index + " ]; out of range" ) ; } return result ; } public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException { if ( _bat == null ) { throw new IOException ( "Improperly initialized list: no block allocation table provided" ) ; } return _bat . fetchBlocks ( startBlock , this ) ; } public void setBAT ( final BlockAllocationTableReader bat ) throws IOException { if ( _bat != null ) { throw new IOException ( "Attempt to replace existing BlockAllocationTable" ) ; } _bat = bat ; } } 	0
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PasswordRecord extends Record { public final static short sid = 0x13 ; private short field_1_password ; public PasswordRecord ( ) { } public PasswordRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PasswordRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PASSWORD RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_password = LittleEndian . getShort ( data , 0 + offset ) ; } public void setPassword ( short password ) { field_1_password = password ; } public short getPassword ( ) { return field_1_password ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PASSWORD]\n" ) ; buffer . append ( "    .password       = " ) . append ( Integer . toHexString ( getPassword ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/PASSWORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getPassword ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { PasswordRecord clone = new PasswordRecord ( ) ; clone . setPassword ( field_1_password ) ; return clone ; } } 	0
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class ReferencePtg extends Ptg { private final static int SIZE = 5 ; public final static byte sid = 0x24 ; private short field_1_row ; private short field_2_col ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private ReferencePtg ( ) { } public ReferencePtg ( String cellref ) { CellReference c = new CellReference ( cellref ) ; setRow ( ( short ) c . getRow ( ) ) ; setColumn ( ( short ) c . getCol ( ) ) ; setColRelative ( ! c . isColAbsolute ( ) ) ; setRowRelative ( ! c . isRowAbsolute ( ) ) ; } public ReferencePtg ( byte [ ] data , int offset ) { offset ++ ; field_1_row = LittleEndian . getShort ( data , offset + 0 ) ; field_2_col = LittleEndian . getShort ( data , offset + 2 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( "[ValueReferencePtg]\n" ) ; buffer . append ( "row = " ) . append ( getRow ( ) ) . append ( "\n" ) ; buffer . append ( "col = " ) . append ( getColumnRaw ( ) ) . append ( "\n" ) ; buffer . append ( "rowrelative = " ) . append ( isRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "colrelative = " ) . append ( isColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_col ) ; } public void setRow ( short row ) { field_1_row = row ; } public short getRow ( ) { return field_1_row ; } public boolean isRowRelative ( ) { return rowRelative . isSet ( field_2_col ) ; } public void setRowRelative ( boolean rel ) { field_2_col = rowRelative . setShortBoolean ( field_2_col , rel ) ; } public boolean isColRelative ( ) { return colRelative . isSet ( field_2_col ) ; } public void setColRelative ( boolean rel ) { field_2_col = colRelative . setShortBoolean ( field_2_col , rel ) ; } public void setColumnRaw ( short col ) { field_2_col = col ; } public short getColumnRaw ( ) { return field_2_col ; } public void setColumn ( short col ) { field_2_col = col ; } public short getColumn ( ) { return rowRelative . setShortBoolean ( colRelative . setShortBoolean ( field_2_col , false ) , false ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getRow ( ) , getColumn ( ) , ! isRowRelative ( ) , ! isColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { ReferencePtg ptg = new ReferencePtg ( ) ; ptg . field_1_row = field_1_row ; ptg . field_2_col = field_2_col ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class TabIdRecord extends Record { public final static short sid = 0x13d ; public short [ ] field_1_tabids ; public TabIdRecord ( ) { } public TabIdRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public TabIdRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A TABID RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_tabids = new short [ size / 2 ] ; for ( int k = 0 ; k < field_1_tabids . length ; k ++ ) { field_1_tabids [ k ] = LittleEndian . getShort ( data , ( k * 2 ) + offset ) ; } } public void setTabIdArray ( short [ ] array ) { field_1_tabids = array ; } public short [ ] getTabIdArray ( ) { return field_1_tabids ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[TABID]\n" ) ; buffer . append ( "    .elements        = " ) . append ( field_1_tabids . length ) . append ( "\n" ) ; for ( int k = 0 ; k < field_1_tabids . length ; k ++ ) { buffer . append ( "    .element_" + k + "       = " ) . append ( field_1_tabids [ k ] ) . append ( "\n" ) ; } buffer . append ( "[/TABID]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { short [ ] tabids = getTabIdArray ( ) ; short length = ( short ) ( tabids . length * 2 ) ; int byteoffset = 4 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) length ) ) ; for ( int k = 0 ; k < ( length / 2 ) ; k ++ ) { LittleEndian . putShort ( data , byteoffset + offset , tabids [ k ] ) ; byteoffset += 2 ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + ( getTabIdArray ( ) . length * 2 ) ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1
package org . apache . poi . hssf . record ; public abstract class Record { public Record ( ) { } public Record ( short id , short size , byte [ ] data ) { validateSid ( id ) ; fillFields ( data , size ) ; } public Record ( short id , short size , byte [ ] data , int offset ) { validateSid ( id ) ; fillFields ( data , size , offset ) ; } protected abstract void validateSid ( short id ) ; protected void fillFields ( byte [ ] data , short size ) { fillFields ( data , size , 0 ) ; } protected abstract void fillFields ( byte [ ] data , short size , int offset ) ; public byte [ ] serialize ( ) { byte [ ] retval = new byte [ getRecordSize ( ) ] ; serialize ( 0 , retval ) ; return retval ; } public abstract int serialize ( int offset , byte [ ] data ) ; public int getRecordSize ( ) { return serialize ( ) . length ; } public boolean isValue ( ) { return false ; } public boolean isInValueSection ( ) { return false ; } public String toString ( ) { return super . toString ( ) ; } public void processContinueRecord ( byte [ ] record ) { } public abstract short getSid ( ) ; public Object clone ( ) { throw new RuntimeException ( "The class " + getClass ( ) . getName ( ) + " needs to define a clone method" ) ; } } 	0
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class RecalcIdRecord extends Record { public final static short sid = 0x1c1 ; public short [ ] field_1_recalcids ; private boolean isNeeded = false ; public RecalcIdRecord ( ) { } public RecalcIdRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RecalcIdRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A RECALCID RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_recalcids = new short [ size / 2 ] ; for ( int k = 0 ; k < field_1_recalcids . length ; k ++ ) { field_1_recalcids [ k ] = LittleEndian . getShort ( data , ( k * 2 ) + offset ) ; } } public void setRecalcIdArray ( short [ ] array ) { field_1_recalcids = array ; } public short [ ] getRecalcIdArray ( ) { return field_1_recalcids ; } public void setIsNeeded ( boolean isNeeded ) { this . isNeeded = isNeeded ; } public boolean isNeeded ( ) { return isNeeded ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[RECALCID]\n" ) ; buffer . append ( "    .elements        = " ) . append ( field_1_recalcids . length ) . append ( "\n" ) ; for ( int k = 0 ; k < field_1_recalcids . length ; k ++ ) { buffer . append ( "    .element_" + k + "       = " ) . append ( field_1_recalcids [ k ] ) . append ( "\n" ) ; } buffer . append ( "[/RECALCID]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { short [ ] tabids = getRecalcIdArray ( ) ; short length = ( short ) ( tabids . length * 2 ) ; int byteoffset = 4 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) length ) ) ; for ( int k = 0 ; k < ( length / 2 ) ; k ++ ) { LittleEndian . putShort ( data , byteoffset + offset , tabids [ k ] ) ; byteoffset += 2 ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + ( getRecalcIdArray ( ) . length * 2 ) ; } public short getSid ( ) { return this . sid ; } } 	0
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PrintHeadersRecord extends Record { public final static short sid = 0x2a ; private short field_1_print_headers ; public PrintHeadersRecord ( ) { } public PrintHeadersRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PrintHeadersRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PrintHeaders RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_print_headers = LittleEndian . getShort ( data , 0 + offset ) ; } public void setPrintHeaders ( boolean p ) { if ( p == true ) { field_1_print_headers = 1 ; } else { field_1_print_headers = 0 ; } } public boolean getPrintHeaders ( ) { return ( field_1_print_headers == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PRINTHEADERS]\n" ) ; buffer . append ( "    .printheaders   = " ) . append ( getPrintHeaders ( ) ) . append ( "\n" ) ; buffer . append ( "[/PRINTHEADERS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , field_1_print_headers ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { PrintHeadersRecord rec = new PrintHeadersRecord ( ) ; rec . field_1_print_headers = field_1_print_headers ; return rec ; } } 	0
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1
package org . apache . poi . util ; import java . util . * ; public class ShortList { private short [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public ShortList ( ) { this ( _default_size ) ; } public ShortList ( final ShortList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public ShortList ( final int initialCapacity ) { _array = new short [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final short value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final short value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final ShortList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final ShortList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final ShortList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { ShortList other = ( ShortList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public short get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final short o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final short o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public short remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public short set ( final int index , final short element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public short [ ] toArray ( ) { short [ ] rval = new short [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public short [ ] toArray ( final short [ ] a ) { short [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; short [ ] new_array = new short [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FooterRecord ; public class HSSFFooter extends Object { FooterRecord footerRecord ; String left ; String center ; String right ; protected HSSFFooter ( FooterRecord footerRecord ) { this . footerRecord = footerRecord ; String foot = footerRecord . getFooter ( ) ; while ( foot != null && foot . length ( ) > 1 ) { int pos = foot . length ( ) ; switch ( foot . substring ( 1 , 2 ) . charAt ( 0 ) ) { case 'L' : if ( foot . indexOf ( "&C" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&C" ) ) ; } if ( foot . indexOf ( "&R" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&R" ) ) ; } left = foot . substring ( 2 , pos ) ; foot = foot . substring ( pos ) ; break ; case 'C' : if ( foot . indexOf ( "&L" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&L" ) ) ; } if ( foot . indexOf ( "&R" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&R" ) ) ; } center = foot . substring ( 2 , pos ) ; foot = foot . substring ( pos ) ; break ; case 'R' : if ( foot . indexOf ( "&C" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&C" ) ) ; } if ( foot . indexOf ( "&L" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&L" ) ) ; } right = foot . substring ( 2 , pos ) ; foot = foot . substring ( pos ) ; break ; default : foot = null ; } } } public String getLeft ( ) { return left ; } public void setLeft ( String newLeft ) { left = newLeft ; createFooterString ( ) ; } public String getCenter ( ) { return center ; } public void setCenter ( String newCenter ) { center = newCenter ; createFooterString ( ) ; } public String getRight ( ) { return right ; } public void setRight ( String newRight ) { right = newRight ; createFooterString ( ) ; } private void createFooterString ( ) { footerRecord . setFooter ( "&C" + ( center == null ? "" : center ) + "&L" + ( left == null ? "" : left ) + "&R" + ( right == null ? "" : right ) ) ; footerRecord . setFooterLength ( ( byte ) footerRecord . getFooter ( ) . length ( ) ) ; } public static String fontSize ( short size ) { return "&" + size ; } public static String font ( String font , String style ) { return "&\"" + font + "," + style + "\"" ; } public static String page ( ) { return "&P" ; } public static String numPages ( ) { return "&N" ; } public static String date ( ) { return "&D" ; } public static String time ( ) { return "&T" ; } public static String file ( ) { return "&F" ; } public static String tab ( ) { return "&A" ; } } 	0
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class HCenterRecord extends Record { public final static short sid = 0x83 ; private short field_1_hcenter ; public HCenterRecord ( ) { } public HCenterRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public HCenterRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A HCenter RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_hcenter = LittleEndian . getShort ( data , 0 + offset ) ; } public void setHCenter ( boolean hc ) { if ( hc == true ) { field_1_hcenter = 1 ; } else { field_1_hcenter = 0 ; } } public boolean getHCenter ( ) { return ( field_1_hcenter == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[HCENTER]\n" ) ; buffer . append ( "    .hcenter        = " ) . append ( getHCenter ( ) ) . append ( "\n" ) ; buffer . append ( "[/HCENTER]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) 0x2 ) ; LittleEndian . putShort ( data , 4 + offset , ( short ) field_1_hcenter ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { HCenterRecord rec = new HCenterRecord ( ) ; rec . field_1_hcenter = field_1_hcenter ; return rec ; } } 	0
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1
package org . apache . poi . util ; import java . util . * ; public class IntList { private int [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public IntList ( ) { this ( _default_size ) ; } public IntList ( final IntList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public IntList ( final int initialCapacity ) { _array = new int [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final int value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final int value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final IntList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final IntList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final IntList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { IntList other = ( IntList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public int get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final int o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final int o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public int remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public int set ( final int index , final int element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public int [ ] toArray ( ) { int [ ] rval = new int [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public int [ ] toArray ( final int [ ] a ) { int [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; int [ ] new_array = new int [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1
