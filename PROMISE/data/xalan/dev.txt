package org . apache . xpath . res ; public class XPATHErrorResources_sv extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funktionen current() är inte tillåten i ett matchningsmönster!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funktionen current() tar inte emot argument!" } , { ER_DOCUMENT_REPLACED , "Implementeringen av funktionen document() har ersatts av org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Kontext saknar ägardokument!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() har för många argument." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() har för många argument." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() har för många argument." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() har för många argument." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() har för många argument." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() har för många argument." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string.length() har för många argument." } , { ER_TRANSLATE_TAKES_3_ARGS , "Funktionen translate() tar emot tre argument!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funktionen unparsed-entity-uri borde ta emot ett argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Namespace-axel inte implementerad än!" } , { ER_UNKNOWN_AXIS , "okänd axel: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "okänd matchningshandling!" } , { ER_INCORRECT_ARG_LENGTH , "Nodtests argumentlängd i processing-instruction() är inte korrekt!" } , { ER_CANT_CONVERT_TO_NUMBER , "Kan inte konvertera {0} till ett nummer" } , { ER_CANT_CONVERT_TO_NODELIST , "Kan inte konvertera {0} till en NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Kan inte konvertera {0} till en NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Kan inte konvertera {0} till en type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Matchningsmönster i getMatchScore förväntat!" } , { ER_COULDNOT_GET_VAR_NAMED , "Kunde inte hämta variabeln {0}" } , { ER_UNKNOWN_OPCODE , "FEL! Okänd op-kod: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Ytterligare otillåtna tecken: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Litteral omges av fel sorts citationstecken... dubbla citationstecken förväntade!" } , { ER_EXPECTED_SINGLE_QUOTE , "Litteral omges av fel sorts citationstecken... enkla citationstecken förväntade!" } , { ER_EMPTY_EXPRESSION , "Tomt uttryck!" } , { ER_EXPECTED_BUT_FOUND , "{0} förväntat, men hittade: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmerares försäkran är inte korrekt! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...)-argument är inte längre valfri med 19990709 XPath-utkast." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Hittade ',' men inget föregående argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Hittade ',' men inget efterföljande argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predikat]' or '.[predikat]' är otillåten syntax.  Använd 'self::node()[predikat]' istället." } , { ER_ILLEGAL_AXIS_NAME , "otillåtet axel-namn: {0}" } , { ER_UNKNOWN_NODETYPE , "okänd nodtyp: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Mönsterlitteral {0} måste sättas inom citationstecken!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} kunde inte formateras till ett nummer" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Kunde inte skapa XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Fel! Hittade inte xpath select-uttryck (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "FEL! Hittade inte ENDOP efter OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Fel inträffade!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}" } , { ER_AXES_NOT_ALLOWED , "Enbart barn::- och attribut::- axlar är tillåtna i matchningsmönster!  Regelvidriga axlar = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() har ett felaktigt antal argument." } , { ER_COUNT_TAKES_1_ARG , "Funktionen count borde ta emot ett argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Hittade inte funktionen: {0}" } , { ER_UNSUPPORTED_ENCODING , "Ej understödd kodning: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem inträffade i DTM i getNextSibling... försöker återhämta" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmerarfel: EmptyNodeList kan inte skrivas till." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory understöds inte av XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) understöds inte av XPathContext! Kan inte öppna {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API-tecken(char ch[]... hanteras inte av DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... hanteras inte av DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison kan inte hantera noder av typen {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper kan inte hantera noder av typen {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse-fel: SystemID - {0} rad - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse-fel" } , { ER_INVALID_UTF16_SURROGATE , "Ogiltigt UTF-16-surrogat upptäckt: {0} ?" } , { ER_OIERROR , "IO-fel" } , { ER_CANNOT_CREATE_URL , "Kan inte skapa url för: {0}" } , { ER_XPATH_READOBJECT , "I XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "funktionstecken saknas." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Kan inte hantera XPath-typ: {0}" } , { ER_NODESET_NOT_MUTABLE , "NodeSet är oföränderlig" } , { ER_NODESETDTM_NOT_MUTABLE , "NodeSetDTM är oföränderlig" } , { ER_VAR_NOT_RESOLVABLE , "Variabel ej lösbar: {0}" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmerares försäkran: okänd op-kod: {0}" } , { ER_ZERO_OR_ONE , "0 eller 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() understöds inte av XRTreeFragSelectWrapper!" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() understöds inte av XRTreeFragSelectWrapper!" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() understöds inte av XRStringForChars!" } , { ER_COULD_NOT_FIND_VAR , "Hittade inte variabeln med namn {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars kan inte ta en sträng som argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer-argumentet får inte vara null" } , { ER_TWO_OR_THREE , "2 eller 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variabeln användes innan den bands!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB kan inte ha en sträng som argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Fel! Anger roten för en \"walker\" till null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Detta NodeSetDTM kan inte iterera till en tidigare nod!" } , { ER_NODESET_CANNOT_ITERATE , "Detta NodeSet kan inte iterera till en tidigare nod!" } , { ER_NODESETDTM_CANNOT_INDEX , "Detta NodeSetDTM har inte funktioner för indexering och räkning!" } , { ER_NODESET_CANNOT_INDEX , "Detta NodeSet har inte funktioner för indexering och räkning!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Det går inte att anropa setShouldCacheNodes efter att nextNode har anropats!" } , { ER_ONLY_ALLOWS , "{0} tillåter bara {1} argument" } , { ER_UNKNOWN_STEP , "Programmerarkontroll i getNextStepPos: okänt steg Typ: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "En relativ sökväg förväntades efter token '/' eller '//'." } , { ER_EXPECTED_LOC_PATH , "En plats förväntades, men följande token påträffades:  {0}" } , { ER_EXPECTED_LOC_STEP , "Ett platssteg förväntades efter token  '/' eller '//'." } , { ER_EXPECTED_NODE_TEST , "Ett nodtest som matchar antingen NCName:* eller QName förväntades." } , { ER_EXPECTED_STEP_PATTERN , "Ett stegmönster förväntades, men '/' påträffades." } , { ER_EXPECTED_REL_PATH_PATTERN , "Ett mönster för relativ sökväg förväntades." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Det går inte att konvertera {0} till ett Booleskt värde." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Det går inte att konvertera {0} till en enda nod. Gäller typerna ANY_UNORDERED_NODE_TYPE och FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Det går inte att erhålla längd för ögonblicksbild på typ: {0}. Gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Det går inte att iterera över den icke itererbara typen: {0}" } , { ER_DOC_MUTATED , "Dokumentet har ändrats sedan resultatet genererades. Iterering ogiltig." } , { ER_INVALID_XPATH_TYPE , "Ogiltigt XPath-typargument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Tomt XPath-resultatobjekt" } , { ER_INCOMPATIBLE_TYPES , "Den genererade typen: {0} kan inte bearbetas i den angivna typen: {1}" } , { ER_NULL_RESOLVER , "Det går inte att lösa prefixet utan prefixlösare." } , { ER_CANT_CONVERT_TO_STRING , "Det går inte att konvertera {0} till en sträng." } , { ER_NON_SNAPSHOT_TYPE , "Det går inte att anropa snapshotItem på typ: {0}. Metoden gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Kontextnoden tillhör inte dokumentet som är bundet till denna XPathEvaluator." } , { ER_WRONG_NODETYPE , "Kontextnoden kan inte hanteras." } , { ER_XPATH_ERROR , "Okänt fel i XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "locale-namnet i format-number-funktionen ännu inte hanterat!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL-Egenskap understöds inte: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Gör för närvarande inte någonting med namespace {0} i egenskap: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException vid försök att få tillgång till XSL-systemegenskap: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Gammal syntax: quo(...) är inte längre definierad i XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath behöver ett deriverat objekt för att implementera nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "funktionstecken saknas." } , { WG_COULDNOT_FIND_FUNCTION , "Hittade inte funktion: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Kan inte skapa URL från: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Alternativet -E understöds inte för DTM-tolk" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}" } , { WG_UNSUPPORTED_ENCODING , "Ej understödd kodning: {0}" } , { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "version" , ">>>>>>> Xalan Version" } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Rad //" } , { "column" , "Kolumn //" } , { "xsldone" , "XSLProcessor färdig" } , { "xpath_option" , "xpath-alternativ" } , { "optionIN" , "    [-in inputXMLURL]" } , { "optionSelect" , "[-select xpath-uttryck]" } , { "optionMatch" , "   [-match matchningsmönster (för matchningsdiagnostik)]" } , { "optionAnyExpr" , "Eller bara ett xpath-uttryck kommer att göra en diagnostik-dump" } , { "noParsermsg1" , "XSL-Process misslyckades." } , { "noParsermsg2" , "** Hittade inte tolk **" } , { "noParsermsg3" , "Vänligen kontrollera din classpath" } , { "noParsermsg4" , "Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från" } , { "noParsermsg5" , "IBMs AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "DÅLIG_KOD" ; public static final String FORMAT_FAILDE = "FORMATTERING_MISSLYCKADES" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//fel" ; public static final String ERROR_HEADER = "Fel: " ; public static final String WARNING_HEADER = "Varning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MÖNSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class TransletOutput extends Instruction { private Expression _filename ; private boolean _append ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "TransletOutput: " + _filename ) ; } public void parseContents ( Parser parser ) { String filename = getAttribute ( "file" ) ; String append = getAttribute ( "append" ) ; if ( ( filename == null ) || ( filename . equals ( EMPTYSTRING ) ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "file" ) ; } _filename = AttributeValue . create ( this , filename , parser ) ; if ( append != null && ( append . toLowerCase ( ) . equals ( "yes" ) || append . toLowerCase ( ) . equals ( "true" ) ) ) { _append = true ; } else _append = false ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type type = _filename . typeCheck ( stable ) ; if ( type instanceof StringType == false ) { _filename = new CastExpr ( _filename , Type . String ) ; } typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; final int open = cpg . addMethodref ( TRANSLET_CLASS , "openOutputHandler" , "(" + STRING_SIG + "Z)" + TRANSLET_OUTPUT_SIG ) ; final int close = cpg . addMethodref ( TRANSLET_CLASS , "closeOutputHandler" , "(" + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( classGen . loadTranslet ( ) ) ; _filename . translate ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , _append ) ) ; il . append ( new INVOKEVIRTUAL ( open ) ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( close ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	0
package org . apache . xalan . lib ; import java . util . Hashtable ; import java . util . StringTokenizer ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . xslt . EnvironmentCheck ; import org . apache . xpath . NodeSet ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . w3c . dom . traversal . NodeIterator ; import org . xml . sax . SAXNotSupportedException ; public class Extensions { private static Document m_doc = null ; private static Extensions m_instance = new Extensions ( ) ; private Extensions ( ) { } public static NodeSet nodeset ( ExpressionContext myProcessor , Object rtf ) { String textNodeValue ; if ( rtf instanceof NodeIterator ) { return new NodeSet ( ( NodeIterator ) rtf ) ; } else { if ( rtf instanceof String ) { textNodeValue = ( String ) rtf ; } else if ( rtf instanceof Boolean ) { textNodeValue = new XBoolean ( ( ( Boolean ) rtf ) . booleanValue ( ) ) . str ( ) ; } else if ( rtf instanceof Double ) { textNodeValue = new XNumber ( ( ( Double ) rtf ) . doubleValue ( ) ) . str ( ) ; } else { textNodeValue = rtf . toString ( ) ; } try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document myDoc = db . newDocument ( ) ; Text textNode = myDoc . createTextNode ( textNodeValue ) ; DocumentFragment docFrag = myDoc . createDocumentFragment ( ) ; docFrag . appendChild ( textNode ) ; return new NodeSet ( docFrag ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } } } public static NodeList intersection ( NodeList nl1 , NodeList nl2 ) { return ExsltSets . intersection ( nl1 , nl2 ) ; } public static NodeList difference ( NodeList nl1 , NodeList nl2 ) { return ExsltSets . difference ( nl1 , nl2 ) ; } public static NodeList distinct ( NodeList nl ) { return ExsltSets . distinct ( nl ) ; } public static boolean hasSameNodes ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; if ( ns1 . getLength ( ) != ns2 . getLength ( ) ) return false ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ! ns2 . contains ( n ) ) return false ; } return true ; } public static XObject evaluate ( ExpressionContext myContext , String xpathExpr ) throws SAXNotSupportedException { return ExsltDynamic . evaluate ( myContext , xpathExpr ) ; } public static NodeList tokenize ( String toTokenize , String delims ) { try { if ( m_doc == null ) { synchronized ( m_instance ) { if ( m_doc == null ) m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } } } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } StringTokenizer lTokenizer = new StringTokenizer ( toTokenize , delims ) ; NodeSet resultSet = new NodeSet ( ) ; synchronized ( m_doc ) { while ( lTokenizer . hasMoreTokens ( ) ) { resultSet . addNode ( m_doc . createTextNode ( lTokenizer . nextToken ( ) ) ) ; } } return resultSet ; } public static NodeList tokenize ( String toTokenize ) { return tokenize ( toTokenize , " \t\n\r" ) ; } public static Node checkEnvironment ( ExpressionContext myContext ) { Document factoryDocument ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; factoryDocument = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } Node resultNode = null ; try { resultNode = checkEnvironmentUsingWhich ( myContext , factoryDocument ) ; if ( null != resultNode ) return resultNode ; EnvironmentCheck envChecker = new EnvironmentCheck ( ) ; Hashtable h = envChecker . getEnvironmentHash ( ) ; resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; envChecker . appendEnvironmentReport ( resultNode , factoryDocument , h ) ; envChecker = null ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return resultNode ; } private static Node checkEnvironmentUsingWhich ( ExpressionContext myContext , Document factoryDocument ) { final String WHICH_CLASSNAME = "org.apache.env.Which" ; final String WHICH_METHODNAME = "which" ; final Class WHICH_METHOD_ARGS [ ] = { java . util . Hashtable . class , java . lang . String . class , java . lang . String . class } ; try { Class clazz = Class . forName ( WHICH_CLASSNAME ) ; if ( null == clazz ) return null ; java . lang . reflect . Method method = clazz . getMethod ( WHICH_METHODNAME , WHICH_METHOD_ARGS ) ; Hashtable report = new Hashtable ( ) ; Object [ ] methodArgs = { report , "XmlCommons;Xalan;Xerces;Crimson;Ant" , "" } ; Object returnValue = method . invoke ( null , methodArgs ) ; Node resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; org . apache . xml . utils . Hashtree2Node . appendHashToNode ( report , "whichReport" , resultNode , factoryDocument ) ; return resultNode ; } catch ( Throwable t ) { return null ; } } } 	1
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . util . Properties ; import javax . xml . transform . Result ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . Trie ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ToHTMLStream extends ToStream { protected BoolStack m_isRawStack = new BoolStack ( ) ; private boolean m_inBlockElem = false ; protected static CharInfo m_htmlcharInfo = CharInfo . getCharInfo ( CharInfo . HTML_ENTITIES_RESOURCE ) ; static Trie m_elementFlags = new Trie ( ) ; static { m_elementFlags . put ( "BASEFONT" , new ElemDesc ( 0 | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "FRAME" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FRAMESET" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "NOFRAMES" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "ISINDEX" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "APPLET" , new ElemDesc ( 0 | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "CENTER" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "DIR" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "MENU" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TT" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "I" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "B" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "BIG" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "SMALL" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "EM" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "STRONG" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "DFN" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "CODE" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "SAMP" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "KBD" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "VAR" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "CITE" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "ABBR" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "ACRONYM" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "SUP" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "SUB" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "SPAN" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BDO" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BR" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "BODY" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "ADDRESS" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "DIV" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "A" , new ElemDesc ( 0 | ElemDesc . SPECIAL ) ) ; m_elementFlags . put ( "MAP" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "AREA" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LINK" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "IMG" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . EMPTY | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "OBJECT" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . HEADMISC | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "PARAM" , new ElemDesc ( 0 | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "HR" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "P" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "H1" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H2" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H3" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H4" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H5" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H6" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "PRE" , new ElemDesc ( 0 | ElemDesc . PREFORMATTED | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "Q" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BLOCKQUOTE" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "INS" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "DEL" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "DL" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "DT" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "DD" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "OL" , new ElemDesc ( 0 | ElemDesc . LIST | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "UL" , new ElemDesc ( 0 | ElemDesc . LIST | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LI" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FORM" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LABEL" , new ElemDesc ( 0 | ElemDesc . FORMCTRL ) ) ; m_elementFlags . put ( "INPUT" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "SELECT" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "OPTGROUP" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "OPTION" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "TEXTAREA" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "FIELDSET" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM ) ) ; m_elementFlags . put ( "LEGEND" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "BUTTON" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "TABLE" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "CAPTION" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "THEAD" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TFOOT" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TBODY" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "COLGROUP" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "COL" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TR" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TH" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "TD" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "HEAD" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . HEADELEM ) ) ; m_elementFlags . put ( "TITLE" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "BASE" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "META" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "STYLE" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . RAW | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "SCRIPT" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . HEADMISC | ElemDesc . RAW ) ) ; m_elementFlags . put ( "NOSCRIPT" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "HTML" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FONT" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "S" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "STRIKE" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "U" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "NOBR" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "IFRAME" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "LAYER" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "ILAYER" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; ElemDesc elemDesc ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "AREA" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "NOHREF" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BASE" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BLOCKQUOTE" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "Q" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "INS" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "DEL" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "A" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "NAME" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "LINK" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "INPUT" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "CHECKED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "ISMAP" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "READONLY" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "SELECT" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "MULTIPLE" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OPTGROUP" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OPTION" ) ; elemDesc . setAttr ( "SELECTED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "TEXTAREA" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "READONLY" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BUTTON" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "SCRIPT" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "FOR" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DEFER" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "IMG" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "ISMAP" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OBJECT" ) ; elemDesc . setAttr ( "CLASSID" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "CODEBASE" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DATA" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "ARCHIVE" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DECLARE" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "FORM" ) ; elemDesc . setAttr ( "ACTION" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "HEAD" ) ; elemDesc . setAttr ( "PROFILE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "FRAME" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "IFRAME" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "LAYER" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "ILAYER" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "DIV" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; } static private ElemDesc m_dummy = new ElemDesc ( 0 | ElemDesc . BLOCK ) ; private boolean m_specialEscapeURLs = true ; private boolean m_omitMetaTag = false ; private ElemDesc m_elementDesc = null ; public void setSpecialEscapeURLs ( boolean bool ) { m_specialEscapeURLs = bool ; } public void setOmitMetaTag ( boolean bool ) { m_omitMetaTag = bool ; } public void setOutputFormat ( Properties format ) { m_specialEscapeURLs = OutputPropertyUtils . getBooleanProperty ( OutputPropertiesFactory . S_USE_URL_ESCAPING , format ) ; m_omitMetaTag = OutputPropertyUtils . getBooleanProperty ( OutputPropertiesFactory . S_OMIT_META_TAG , format ) ; super . setOutputFormat ( format ) ; } private final boolean getSpecialEscapeURLs ( ) { return m_specialEscapeURLs ; } private final boolean getOmitMetaTag ( ) { return m_omitMetaTag ; } private final ElemDesc getElemDesc ( String name ) { if ( null != name ) { Object obj = m_elementFlags . get ( name ) ; if ( null != obj ) return ( ElemDesc ) obj ; } return m_dummy ; } public ToHTMLStream ( ) { super ( ) ; m_charInfo = m_htmlcharInfo ; m_prefixMap = new NamespaceMappings ( ) ; } private String m_currentElementName = null ; protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { super . startDocumentInternal ( ) ; m_needToCallStartDocument = false ; m_needToOutputDocTypeDecl = true ; m_startNewLine = false ; setOmitXMLDeclaration ( true ) ; if ( true == m_needToOutputDocTypeDecl ) { String doctypeSystem = getDoctypeSystem ( ) ; String doctypePublic = getDoctypePublic ( ) ; if ( ( null != doctypeSystem ) || ( null != doctypePublic ) ) { try { m_writer . write ( "<!DOCTYPE HTML" ) ; if ( null != doctypePublic ) { m_writer . write ( " PUBLIC \"" ) ; m_writer . write ( doctypePublic ) ; m_writer . write ( "\"" ) ; } if ( null != doctypeSystem ) { if ( null == doctypePublic ) m_writer . write ( " SYSTEM \"" ) ; else m_writer . write ( " \"" ) ; m_writer . write ( doctypeSystem ) ; m_writer . write ( "\"" ) ; } m_writer . write ( ">" ) ; outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } } m_needToOutputDocTypeDecl = false ; } public final void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( m_doIndent && ! m_isprevtext ) { try { outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } flushWriter ( ) ; super . fireEndDoc ( ) ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; else if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; if ( null != namespaceURI && namespaceURI . length ( ) > 0 ) { super . startElement ( namespaceURI , localName , name , atts ) ; return ; } try { boolean savedDoIndent = m_doIndent ; boolean noLineBreak ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } ElemDesc elemDesc = getElemDesc ( name ) ; m_elementLocalName = localName ; m_elementURI = namespaceURI ; m_elementName = name ; m_elementDesc = elemDesc ; boolean isBlockElement = elemDesc . is ( ElemDesc . BLOCK ) ; boolean isHeadElement = elemDesc . is ( ElemDesc . HEADELEM ) ; if ( m_ispreserve ) m_ispreserve = false ; else if ( m_doIndent && ( null != m_currentElementName ) && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = true ; indent ( ) ; } m_inBlockElem = ! isBlockElement ; m_isRawStack . push ( elemDesc . is ( ElemDesc . RAW ) ) ; m_currentElementName = name ; m_writer . write ( '<' ) ; m_writer . write ( name ) ; if ( atts != null ) addAttributes ( atts ) ; m_startTagOpen = true ; m_currentElemDepth ++ ; m_isprevtext = false ; m_doIndent = savedDoIndent ; if ( isHeadElement ) { if ( m_startTagOpen ) closeStartTag ( ) ; if ( ! m_omitMetaTag ) { if ( m_doIndent ) indent ( ) ; m_writer . write ( "<META http-equiv=\"Content-Type\" content=\"text/html; charset=" ) ; String encoding = getEncoding ( ) ; String encode = Encodings . getMimeEncoding ( encoding ) ; m_writer . write ( encode ) ; m_writer . write ( '"' ) ; m_writer . write ( '>' ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } } public final void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( null != namespaceURI && namespaceURI . length ( ) > 0 ) { super . endElement ( namespaceURI , localName , name ) ; return ; } m_currentElemDepth -- ; m_isRawStack . pop ( ) ; ElemDesc elemDesc = getElemDesc ( name ) ; m_elementDesc = elemDesc ; boolean isBlockElement = elemDesc . is ( ElemDesc . BLOCK ) ; boolean shouldIndent = false ; if ( m_ispreserve ) { m_ispreserve = false ; } else if ( m_doIndent && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = true ; shouldIndent = true ; } m_inBlockElem = ! isBlockElement ; try { if ( ! m_startTagOpen ) { if ( shouldIndent ) indent ( ) ; m_writer . write ( "</" ) ; m_writer . write ( name ) ; m_writer . write ( '>' ) ; m_currentElementName = name ; m_cdataSectionStates . pop ( ) ; if ( ! m_preserves . isEmpty ( ) ) m_preserves . pop ( ) ; } else { processAttributes ( ) ; if ( ! elemDesc . is ( ElemDesc . EMPTY ) ) { m_writer . write ( '>' ) ; m_writer . write ( '<' ) ; m_writer . write ( '/' ) ; m_writer . write ( name ) ; m_writer . write ( '>' ) ; } else { m_writer . write ( '>' ) ; } } if ( elemDesc . is ( ElemDesc . WHITESPACESENSITIVE ) ) m_ispreserve = true ; m_startTagOpen = false ; m_isprevtext = false ; } catch ( IOException e ) { throw new SAXException ( e ) ; } super . fireEndElem ( name ) ; } protected void processAttribute ( String name , String value , ElemDesc elemDesc ) throws IOException { m_writer . write ( ' ' ) ; if ( ( ( value . length ( ) == 0 ) || value . equalsIgnoreCase ( name ) ) && elemDesc != null && elemDesc . isAttrFlagSet ( name , ElemDesc . ATTREMPTY ) ) { m_writer . write ( name ) ; } else { m_writer . write ( name ) ; m_writer . write ( '=' ) ; m_writer . write ( '\"' ) ; if ( elemDesc != null && elemDesc . isAttrFlagSet ( name , ElemDesc . ATTRURL ) ) writeAttrURI ( value , m_specialEscapeURLs ) ; else writeAttrString ( value , this . getEncoding ( ) ) ; m_writer . write ( '\"' ) ; } } private boolean isASCIIDigit ( char c ) { return ( c >= '0' && c <= '9' ) ; } private String makeHHString ( int i ) { String s = Integer . toHexString ( i ) . toUpperCase ( ) ; if ( s . length ( ) == 1 ) { s = "0" + s ; } return s ; } private boolean isHHSign ( String str ) { boolean sign = true ; try { char r = ( char ) Integer . parseInt ( str , 16 ) ; } catch ( NumberFormatException e ) { sign = false ; } return sign ; } public void writeAttrURI ( String string , boolean doURLEscaping ) throws IOException { char [ ] stringArray = string . toCharArray ( ) ; int len = stringArray . length ; for ( int i = 0 ; i < len ; i ++ ) { char ch = stringArray [ i ] ; if ( ( ch < 32 ) || ( ch > 126 ) ) { if ( doURLEscaping ) { if ( ch <= 0x7F ) { m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( ch ) ) ; } else if ( ch <= 0x7FF ) { int high = ( ch > > 6 ) | 0xC0 ; int low = ( ch & 0x3F ) | 0x80 ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( high ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( low ) ) ; } else if ( isUTF16Surrogate ( ch ) ) { int highSurrogate = ( ( int ) ch ) & 0x03FF ; int wwww = ( ( highSurrogate & 0x03C0 ) > > 6 ) ; int uuuuu = wwww + 1 ; int zzzz = ( highSurrogate & 0x003C ) > > 2 ; int yyyyyy = ( ( highSurrogate & 0x0003 ) << 4 ) & 0x30 ; ch = stringArray [ ++ i ] ; int lowSurrogate = ( ( int ) ch ) & 0x03FF ; yyyyyy = yyyyyy | ( ( lowSurrogate & 0x03C0 ) > > 6 ) ; int xxxxxx = ( lowSurrogate & 0x003F ) ; int byte1 = 0xF0 | ( uuuuu > > 2 ) ; int byte2 = 0x80 | ( ( ( uuuuu & 0x03 ) << 4 ) & 0x30 ) | zzzz ; int byte3 = 0x80 | yyyyyy ; int byte4 = 0x80 | xxxxxx ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte1 ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte2 ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte3 ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte4 ) ) ; } else { int high = ( ch > > 12 ) | 0xE0 ; int middle = ( ( ch & 0x0FC0 ) > > 6 ) | 0x80 ; int low = ( ch & 0x3F ) | 0x80 ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( high ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( middle ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( low ) ) ; } } else if ( escapingNotNeeded ( ch ) ) { m_writer . write ( ch ) ; } else { m_writer . write ( "&#" ) ; m_writer . write ( Integer . toString ( ch ) ) ; m_writer . write ( ';' ) ; } } else if ( '%' == ch ) { m_writer . write ( ch ) ; } else if ( ch == '"' ) { if ( doURLEscaping ) m_writer . write ( "%22" ) ; else m_writer . write ( "&quot;" ) ; } else { m_writer . write ( ch ) ; } } } public void writeAttrString ( String string , String encoding ) throws IOException { final char chars [ ] = string . toCharArray ( ) ; final int strLen = chars . length ; for ( int i = 0 ; i < strLen ; i ++ ) { char ch = chars [ i ] ; if ( escapingNotNeeded ( ch ) && ( ! m_charInfo . isSpecial ( ch ) ) ) { m_writer . write ( ch ) ; } else if ( '<' == ch || '>' == ch ) { m_writer . write ( ch ) ; } else if ( ( '&' == ch ) && ( ( i + 1 ) < strLen ) && ( '{' == chars [ i + 1 ] ) ) { m_writer . write ( ch ) ; } else { int pos = accumDefaultEntity ( m_writer , ch , i , chars , strLen , false ) ; if ( i != pos ) { i = pos - 1 ; } else { if ( isUTF16Surrogate ( ch ) ) { i = writeUTF16Surrogate ( ch , chars , i , strLen ) ; } String entityName = m_charInfo . getEntityNameForChar ( ch ) ; if ( null != entityName ) { m_writer . write ( '&' ) ; m_writer . write ( entityName ) ; m_writer . write ( ';' ) ; } else if ( escapingNotNeeded ( ch ) ) { m_writer . write ( ch ) ; } else { m_writer . write ( "&#" ) ; m_writer . write ( Integer . toString ( ch ) ) ; m_writer . write ( ';' ) ; } } } } } public final void characters ( char chars [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_isRawStack . peekOrFalse ( ) ) { try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; writeNormalizedChars ( chars , start , length , false ) ; super . fireCharEvent ( chars , start , length ) ; return ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } else { super . characters ( chars , start , length ) ; } } public final void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ( null != m_currentElementName ) && ( m_currentElementName . equalsIgnoreCase ( "SCRIPT" ) || m_currentElementName . equalsIgnoreCase ( "STYLE" ) ) ) { try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; if ( shouldIndent ( ) ) indent ( ) ; writeNormalizedChars ( ch , start , length , true ) ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } else { super . cdata ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( target . equals ( Result . PI_DISABLE_OUTPUT_ESCAPING ) ) { startNonEscaping ( ) ; } else if ( target . equals ( Result . PI_ENABLE_OUTPUT_ESCAPING ) ) { endNonEscaping ( ) ; } else { try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; if ( shouldIndent ( ) ) indent ( ) ; m_writer . write ( "<?" + target ) ; if ( data . length ( ) > 0 && ! Character . isSpaceChar ( data . charAt ( 0 ) ) ) m_writer . write ( " " ) ; m_writer . write ( data + ">" ) ; if ( m_currentElemDepth <= 0 ) outputLineSep ( ) ; m_startNewLine = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } super . fireEscapingEvent ( target , data ) ; } public final void entityReference ( String name ) throws org . xml . sax . SAXException { try { m_writer . write ( "&" ) ; m_writer . write ( name ) ; m_writer . write ( ";" ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public final void endElement ( String elemName ) throws SAXException { endElement ( null , null , elemName ) ; } public void processAttributes ( ) throws IOException , SAXException { super . fireStartElem ( m_elementName ) ; int nAttrs = 0 ; if ( ( nAttrs = m_attributes . getLength ( ) ) > 0 ) { for ( int i = 0 ; i < nAttrs ; i ++ ) { processAttribute ( m_attributes . getQName ( i ) , m_attributes . getValue ( i ) , m_elementDesc ) ; } m_attributes . clear ( ) ; } } protected void closeStartTag ( ) throws SAXException { if ( m_startTagOpen ) { try { processAttributes ( ) ; m_writer . write ( '>' ) ; pushCdataSectionState ( ) ; m_isprevtext = false ; m_preserves . push ( m_ispreserve ) ; m_startTagOpen = false ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } } protected synchronized void init ( OutputStream output , Properties format ) throws UnsupportedEncodingException { if ( null == format ) { format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; } super . init ( output , format , false ) ; } public void setOutputStream ( OutputStream output ) { try { Properties format ; if ( null == m_format ) format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; else format = m_format ; init ( output , format , true ) ; } catch ( UnsupportedEncodingException uee ) { } } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } } 	1
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncConcat extends FunctionMultiArgs { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( m_arg0 . execute ( xctxt ) . str ( ) ) ; sb . append ( m_arg1 . execute ( xctxt ) . str ( ) ) ; if ( null != m_arg2 ) sb . append ( m_arg2 . execute ( xctxt ) . str ( ) ) ; if ( null != m_args ) { for ( int i = 0 ; i < m_args . length ; i ++ ) { sb . append ( m_args [ i ] . execute ( xctxt ) . str ( ) ) ; } } return new XString ( sb . toString ( ) ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "gtone" , null ) ) ; } } 	1
package org . apache . xpath . patterns ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . PsuedoNames ; import org . apache . xpath . objects . XObject ; public class StepPattern extends NodeTest implements SubContextList , ExpressionOwner { protected int m_axis ; public StepPattern ( int whatToShow , String namespace , String name , int axis , int axisForPredicate ) { super ( whatToShow , namespace , name ) ; m_axis = axis ; } public StepPattern ( int whatToShow , int axis , int axisForPredicate ) { super ( whatToShow ) ; m_axis = axis ; } String m_targetString ; public void calcTargetString ( ) { int whatToShow = getWhatToShow ( ) ; switch ( whatToShow ) { case DTMFilter . SHOW_COMMENT : m_targetString = PsuedoNames . PSEUDONAME_COMMENT ; break ; case DTMFilter . SHOW_TEXT : case DTMFilter . SHOW_CDATA_SECTION : case ( DTMFilter . SHOW_TEXT | DTMFilter . SHOW_CDATA_SECTION ) : m_targetString = PsuedoNames . PSEUDONAME_TEXT ; break ; case DTMFilter . SHOW_ALL : m_targetString = PsuedoNames . PSEUDONAME_ANY ; break ; case DTMFilter . SHOW_DOCUMENT : case DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT : m_targetString = PsuedoNames . PSEUDONAME_ROOT ; break ; case DTMFilter . SHOW_ELEMENT : if ( this . WILD == m_name ) m_targetString = PsuedoNames . PSEUDONAME_ANY ; else m_targetString = m_name ; break ; default : m_targetString = PsuedoNames . PSEUDONAME_ANY ; break ; } } public String getTargetString ( ) { return m_targetString ; } StepPattern m_relativePathPattern ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_predicates ) { for ( int i = 0 ; i < m_predicates . length ; i ++ ) { m_predicates [ i ] . fixupVariables ( vars , globalsSize ) ; } } if ( null != m_relativePathPattern ) { m_relativePathPattern . fixupVariables ( vars , globalsSize ) ; } } public void setRelativePathPattern ( StepPattern expr ) { m_relativePathPattern = expr ; expr . exprSetParent ( this ) ; calcScore ( ) ; } public StepPattern getRelativePathPattern ( ) { return m_relativePathPattern ; } public Expression [ ] getPredicates ( ) { return m_predicates ; } Expression [ ] m_predicates ; public boolean canTraverseOutsideSubtree ( ) { int n = getPredicateCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( getPredicate ( i ) . canTraverseOutsideSubtree ( ) ) return true ; } return false ; } public Expression getPredicate ( int i ) { return m_predicates [ i ] ; } public final int getPredicateCount ( ) { return ( null == m_predicates ) ? 0 : m_predicates . length ; } public void setPredicates ( Expression [ ] predicates ) { m_predicates = predicates ; if ( null != predicates ) { for ( int i = 0 ; i < predicates . length ; i ++ ) { predicates [ i ] . exprSetParent ( this ) ; } } calcScore ( ) ; } public void calcScore ( ) { if ( ( getPredicateCount ( ) > 0 ) || ( null != m_relativePathPattern ) ) { m_score = SCORE_OTHER ; } else super . calcScore ( ) ; if ( null == m_targetString ) calcTargetString ( ) ; } public XObject execute ( XPathContext xctxt , int currentNode ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( currentNode ) ; if ( dtm != null ) { int expType = dtm . getExpandedTypeID ( currentNode ) ; return execute ( xctxt , currentNode , dtm , expType ) ; } return NodeTest . SCORE_NONE ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt , xctxt . getCurrentNode ( ) ) ; } public XObject execute ( XPathContext xctxt , int currentNode , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { if ( m_whatToShow == NodeTest . SHOW_BYFUNCTION ) { if ( null != m_relativePathPattern ) { return m_relativePathPattern . execute ( xctxt ) ; } else return NodeTest . SCORE_NONE ; } XObject score ; score = super . execute ( xctxt , currentNode , dtm , expType ) ; if ( score == NodeTest . SCORE_NONE ) return NodeTest . SCORE_NONE ; if ( getPredicateCount ( ) != 0 ) { if ( ! executePredicates ( xctxt , dtm , currentNode ) ) return NodeTest . SCORE_NONE ; } if ( null != m_relativePathPattern ) return m_relativePathPattern . executeRelativePathPattern ( xctxt , dtm , currentNode ) ; return score ; } private final boolean checkProximityPosition ( XPathContext xctxt , int predPos , DTM dtm , int context , int pos ) { try { DTMAxisTraverser traverser = dtm . getAxisTraverser ( Axis . PRECEDINGSIBLING ) ; for ( int child = traverser . first ( context ) ; DTM . NULL != child ; child = traverser . next ( context , child ) ) { try { xctxt . pushCurrentNode ( child ) ; if ( NodeTest . SCORE_NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < predPos ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { throw new Error ( "Why: Should never have been called" ) ; } else if ( ! pred . boolWithSideEffects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } if ( pass ) pos -- ; if ( pos < 1 ) return false ; } } finally { xctxt . popCurrentNode ( ) ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new java . lang . RuntimeException ( se . getMessage ( ) ) ; } return ( pos == 1 ) ; } private final int getProximityPosition ( XPathContext xctxt , int predPos , boolean findLast ) { int pos = 0 ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int parent = dtm . getParent ( context ) ; try { DTMAxisTraverser traverser = dtm . getAxisTraverser ( Axis . CHILD ) ; for ( int child = traverser . first ( parent ) ; DTM . NULL != child ; child = traverser . next ( parent , child ) ) { try { xctxt . pushCurrentNode ( child ) ; if ( NodeTest . SCORE_NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < predPos ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { if ( ( pos + 1 ) != ( int ) pred . numWithSideEffects ( ) ) { pass = false ; break ; } } else if ( ! pred . boolWithSideEffects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } if ( pass ) pos ++ ; if ( ! findLast && child == context ) { return pos ; } } } finally { xctxt . popCurrentNode ( ) ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new java . lang . RuntimeException ( se . getMessage ( ) ) ; } return pos ; } public int getProximityPosition ( XPathContext xctxt ) { return getProximityPosition ( xctxt , xctxt . getPredicatePos ( ) , false ) ; } public int getLastPos ( XPathContext xctxt ) { return getProximityPosition ( xctxt , xctxt . getPredicatePos ( ) , true ) ; } protected final XObject executeRelativePathPattern ( XPathContext xctxt , DTM dtm , int currentNode ) throws javax . xml . transform . TransformerException { XObject score = NodeTest . SCORE_NONE ; int context = currentNode ; DTMAxisTraverser traverser ; traverser = dtm . getAxisTraverser ( m_axis ) ; for ( int relative = traverser . first ( context ) ; DTM . NULL != relative ; relative = traverser . next ( context , relative ) ) { try { xctxt . pushCurrentNode ( relative ) ; score = execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) break ; } finally { xctxt . popCurrentNode ( ) ; } } return score ; } protected final boolean executePredicates ( XPathContext xctxt , DTM dtm , int currentNode ) throws javax . xml . transform . TransformerException { boolean result = true ; boolean positionAlreadySeen = false ; int n = getPredicateCount ( ) ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < n ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { int pos = ( int ) pred . num ( ) ; if ( positionAlreadySeen ) { result = ( pos == 1 ) ; break ; } else { positionAlreadySeen = true ; if ( ! checkProximityPosition ( xctxt , i , dtm , currentNode , pos ) ) { result = false ; break ; } } } else if ( ! pred . boolWithSideEffects ( ) ) { result = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } return result ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( StepPattern pat = this ; pat != null ; pat = pat . m_relativePathPattern ) { if ( pat != this ) buf . append ( "/" ) ; buf . append ( Axis . names [ pat . m_axis ] ) ; buf . append ( "::" ) ; if ( 0x000005000 == pat . m_whatToShow ) { buf . append ( "doc()" ) ; } else if ( DTMFilter . SHOW_BYFUNCTION == pat . m_whatToShow ) { buf . append ( "function()" ) ; } else if ( DTMFilter . SHOW_ALL == pat . m_whatToShow ) { buf . append ( "node()" ) ; } else if ( DTMFilter . SHOW_TEXT == pat . m_whatToShow ) { buf . append ( "text()" ) ; } else if ( DTMFilter . SHOW_PROCESSING_INSTRUCTION == pat . m_whatToShow ) { buf . append ( "processing-instruction(" ) ; if ( null != pat . m_name ) { buf . append ( pat . m_name ) ; } buf . append ( ")" ) ; } else if ( DTMFilter . SHOW_COMMENT == pat . m_whatToShow ) { buf . append ( "comment()" ) ; } else if ( null != pat . m_name ) { if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( "@" ) ; } if ( null != pat . m_namespace ) { buf . append ( "{" ) ; buf . append ( pat . m_namespace ) ; buf . append ( "}" ) ; } buf . append ( pat . m_name ) ; } else if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( "@" ) ; } else if ( ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ) == pat . m_whatToShow ) { buf . append ( "doc-root()" ) ; } else { buf . append ( "?" + Integer . toHexString ( pat . m_whatToShow ) ) ; } if ( null != pat . m_predicates ) { for ( int i = 0 ; i < pat . m_predicates . length ; i ++ ) { buf . append ( "[" ) ; buf . append ( pat . m_predicates [ i ] ) ; buf . append ( "]" ) ; } } } return buf . toString ( ) ; } private static final boolean DEBUG_MATCHES = false ; public double getMatchScore ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { xctxt . pushCurrentNode ( context ) ; xctxt . pushCurrentExpressionNode ( context ) ; try { XObject score = execute ( xctxt ) ; return score . num ( ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popCurrentExpressionNode ( ) ; } } public void setAxis ( int axis ) { m_axis = axis ; } public int getAxis ( ) { return m_axis ; } class PredOwner implements ExpressionOwner { int m_index ; PredOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_predicates [ m_index ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( StepPattern . this ) ; m_predicates [ m_index ] = exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitMatchPattern ( owner , this ) ) { callSubtreeVisitors ( visitor ) ; } } protected void callSubtreeVisitors ( XPathVisitor visitor ) { if ( null != m_predicates ) { int n = m_predicates . length ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner predOwner = new PredOwner ( i ) ; if ( visitor . visitPredicate ( predOwner , m_predicates [ i ] ) ) { m_predicates [ i ] . callVisitors ( predOwner , visitor ) ; } } } if ( null != m_relativePathPattern ) { m_relativePathPattern . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_relativePathPattern ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_relativePathPattern = ( StepPattern ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; StepPattern sp = ( StepPattern ) expr ; if ( null != m_predicates ) { int n = m_predicates . length ; if ( ( null == sp . m_predicates ) || ( sp . m_predicates . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_predicates [ i ] . deepEquals ( sp . m_predicates [ i ] ) ) return false ; } } else if ( null != sp . m_predicates ) return false ; if ( null != m_relativePathPattern ) { if ( ! m_relativePathPattern . deepEquals ( sp . m_relativePathPattern ) ) return false ; } else if ( sp . m_relativePathPattern != null ) return false ; return true ; } } 	1
package org . apache . xalan . transformer ; public interface TransformSnapshot { } 	0
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class FunctionDef1Arg extends FunctionOneArg { protected int getArg0AsNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( null == m_arg0 ) ? xctxt . getCurrentNode ( ) : m_arg0 . asNode ( xctxt ) ; } public boolean Arg0IsNodesetExpr ( ) { return ( null == m_arg0 ) ? true : m_arg0 . isNodesetExpr ( ) ; } protected XMLString getArg0AsString ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( null == m_arg0 ) { int currentNode = xctxt . getCurrentNode ( ) ; if ( DTM . NULL == currentNode ) return XString . EMPTYSTRING ; else { DTM dtm = xctxt . getDTM ( currentNode ) ; return dtm . getStringValue ( currentNode ) ; } } else return m_arg0 . execute ( xctxt ) . xstr ( ) ; } protected double getArg0AsNumber ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( null == m_arg0 ) { int currentNode = xctxt . getCurrentNode ( ) ; if ( DTM . NULL == currentNode ) return 0 ; else { DTM dtm = xctxt . getDTM ( currentNode ) ; XMLString str = dtm . getStringValue ( currentNode ) ; return str . toDouble ( ) ; } } else return m_arg0 . execute ( xctxt ) . num ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum > 1 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ZERO_OR_ONE , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return ( null == m_arg0 ) ? false : super . canTraverseOutsideSubtree ( ) ; } } 	1
package org . apache . xalan . res ; public class XSLTErrorResources_zh_CN extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "错误：表达式中不能出现  '{'" } , { ER_ILLEGAL_ATTRIBUTE , "{0} 存在一个非法属性： {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode 在  xsl:apply-imports 为空！  " } , { ER_CANNOT_ADD , "无法将  {0} 添加到  {1} 中 " } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode 在  handleApplyTemplatesInstruction 为空！ " } , { ER_NO_NAME_ATTRIB , "{0} 必须具有一个名称属性。 " } , { ER_TEMPLATE_NOT_FOUND , "未找到命名的模板： {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "无法在  xsl:call-template 解析名称  AVI。 " } , { ER_REQUIRES_ATTRIB , "{0} 要求属性： {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} 必须具有一个  ''test'' 属性。 " } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "在级别属性中出现错误数值： {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction 名称不能为  'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction 名称必须是一个有效的  NCName： {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} 必须具有一个与模式相匹配的属性。 " } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} 需要一个名称或匹配属性。 " } , { ER_CANT_RESOLVE_NSPREFIX , "无法解析名称空间前缀： {0}" } , { ER_ILLEGAL_VALUE , "xml:space 存在一个非法数值： {0}" } , { ER_NO_OWNERDOC , "子节点没有一个属主文档！ " } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement 错误： {0}" } , { ER_NULL_CHILD , "正在尝试添加一个空的子节点！ " } , { ER_NEED_SELECT_ATTRIB , "{0} 需要一个选择属性。 " } , { ER_NEED_TEST_ATTRIB , "xsl:when 必须具有一个  'test' 属性。 " } , { ER_NEED_NAME_ATTRIB , "xsl:with-param 必须具有一个  'name' 属性。 " } , { ER_NO_CONTEXT_OWNERDOC , "上下文没有一个属主文档！ " } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "无法创建  XML TransformerFactory Liaison： {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: 运行不成功。 " } , { ER_NOT_SUCCESSFUL , "Xalan: 不成功。 " } , { ER_ENCODING_NOT_SUPPORTED , "不受支持的编码： {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "无法创建  TraceListener： {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key 需要一个  'name' 属性！ " } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key 需要一个  'match' 属性！ " } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key 需要一个  'use' 属性！ " } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} 需要一个  ''elements'' 属性！ " } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} 缺少  ''prefix'' 属性 " } , { ER_BAD_STYLESHEET_URL , "式样表单的  URL 错误： {0}" } , { ER_FILE_NOT_FOUND , "未找到式样表单文件： {0}" } , { ER_IOEXCEPTION , "式样表单文件中存在  IO 异常： {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) 无法在  {0} 中找到  href 属性  " } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} 直接或间接包含自身！ " } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude 错误， {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} 缺少  ''lang'' 属性 " } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) 将  {0} 元素放错位置？？ container 缺少  ''component'' 元素  " } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "仅能输出到  Element、 DocumentFragment、 Document 或  PrintWriter。 " } , { ER_PROCESS_ERROR , "StylesheetRoot.process 错误 " } , { ER_UNIMPLNODE_ERROR , "UnImplNode 错误： {0}" } , { ER_NO_SELECT_EXPRESSION , "错误！未找到  xpath 选择表达式  (-select)。 " } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "无法串行化一个  XSLProcessor！ " } , { ER_NO_INPUT_STYLESHEET , "未指定式样表单输入！ " } , { ER_FAILED_PROCESS_STYLESHEET , "运行式样表单错误！ " } , { ER_COULDNT_PARSE_DOC , "无法分析  {0} 文档！ " } , { ER_COULDNT_FIND_FRAGMENT , "未找到段： {0}" } , { ER_NODE_NOT_ELEMENT , "段标识符指向的节点不是一个元素： {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "每个节点必须具有一个匹配或名称属性 " } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "模板必须具有一个匹配或名称属性 " } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "无法复制文档框架！ " } , { ER_CANT_CREATE_ITEM , "无法在结果树中创建项： {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space 在源  XML 中存在一个非法数值： {0}" } , { ER_NO_XSLKEY_DECLARATION , "在  {0} 中未声明  xsl:key！ " } , { ER_CANT_CREATE_URL , "错误！无法在以下的  {0} 中创建  url： " } , { ER_XSLFUNCTIONS_UNSUPPORTED , "不支持  xsl:functions" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory 错误 " } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "不允许  (StylesheetHandler) {0} 在  stylesheet 的内部！ " } , { ER_RESULTNS_NOT_SUPPORTED , "不再支持  result-ns！请使用  xsl:output 替换。 " } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "不再支持  default-space！请使用  xsl:strip-space 或  xsl:preserve-space 替换。 " } , { ER_INDENTRESULT_NOT_SUPPORTED , "不再支持  indent-result！请使用  xsl:output 替换。 " } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} 存在一个非法属性： {1}" } , { ER_UNKNOWN_XSL_ELEM , "未知的  XSL 元素： {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort 仅能与  xsl:apply-templates 或  xsl:for-each 一起使用。 " } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) 将  xsl:when 放错位置！ " } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when 不是  xsl:choose 的父辈！ " } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) 将  xsl:otherwise 放错位置！ " } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise 不是  xsl:choose 的父辈！ " } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "不允许  (StylesheetHandler) {0} 在模板的内部！ " } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 扩展名称空间前缀  {1} 未知 " } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) 导入仅能在式样表单中作为第一个元素出现！ " } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} 直接或间接输入自身！ " } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space 存在一个非法数值： {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet 不成功！ " } , { ER_SAX_EXCEPTION , "SAX 异常 " } , { ER_XSLT_ERROR , "XSLT 错误 " } , { ER_CURRENCY_SIGN_ILLEGAL , "在格式模式字符串中不允许出现货币符号 " } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "在  Stylesheet DOM 中不支持文档函数！ " } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "无法分析无前缀分析器的前缀！ " } , { ER_REDIRECT_COULDNT_GET_FILENAME , "重定向扩展：无法得到文件  - 文件或选择属性必须返回有效的字符串。 " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "无法在重定向扩展中构建  FormatterListener！ " } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "在  exclude-result-prefixes 中的前缀不是有效的： {0}" } , { ER_MISSING_NS_URI , "在指定的前缀中缺少  URI 的名称空间 " } , { ER_MISSING_ARG_FOR_OPTION , "在选项  {0} 中缺少参数： " } , { ER_INVALID_OPTION , "无效的选项： {0}" } , { ER_MALFORMED_FORMAT_STRING , "格式不正确的字符串： {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要一个  'version' 属性！ " } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "属性： {0} 存在一个非法数值： {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose 需要  xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "不允许在  xls:for-each 中出现  xsl:apply-imports" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "无法为一个输出  DOM 节点使用  DTMLiaison...传送一个  org.apache.xpath.DOM2Helper！  " } , { ER_CANT_USE_DTM_FOR_INPUT , "无法为输入  DOM 节点使用  DTMLiaison...传送一个  org.apache.xpath.DOM2Helper！ " } , { ER_CALL_TO_EXT_FAILED , "调用扩展元素错误： {0}" } , { ER_PREFIX_MUST_RESOLVE , "必须将前缀解析为名称空间： {0}" } , { ER_INVALID_UTF16_SURROGATE , "检测到无效的  UTF-16 代理： {0}？  " } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} 被自身使用，将导致无限循环。  " } , { ER_CANNOT_MIX_XERCESDOM , "非  Xerces-DOM 输入与  Xerces-DOM 输出不能混合使用！ " } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "在  ElemTemplateElement.readObject 中： {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "找到多个命名的模板： {0}" } , { ER_INVALID_KEY_CALL , "无效的函数调用：不允许调用递归关键词 ()" } , { ER_REFERENCING_ITSELF , "变量  {0} 正在直接或间接地引用自身！ " } , { ER_ILLEGAL_DOMSOURCE_INPUT , "在  newTemplate 的  DOMSource 中，输入节点不能为空！  " } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "在选项中未找到类文件 {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "未找到需要的元素： {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream 不能为空 " } , { ER_URI_CANNOT_BE_NULL , "URI 不能为空 " } , { ER_FILE_CANNOT_BE_NULL , "File 不能为空 " } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource 不能为空 " } , { ER_CANNOT_INIT_BSFMGR , "无法初始化  BSF 管理器 " } , { ER_CANNOT_CMPL_EXTENSN , "无法编译扩展名 " } , { ER_CANNOT_CREATE_EXTENSN , "由于以下原因： {1}，无法创建扩展名： {0}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , " Instance 调用方法  {0} 时需要将对象实例作为第一个参数。 " } , { ER_INVALID_ELEMENT_NAME , "指定了无效的元素名称  {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "元素名称方法必须是静态的  {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "扩展函数  {0}： {1} 未知 " } , { ER_MORE_MATCH_CONSTRUCTOR , "适用于  {0} 的构造器的多个最佳匹配  " } , { ER_MORE_MATCH_METHOD , "适用于方法  {0} 的多个最佳匹配 " } , { ER_MORE_MATCH_ELEMENT , "适用于元素方法  {0} 的多个最佳匹配 " } , { ER_INVALID_CONTEXT_PASSED , "传送无效的上下文来求值  {0}" } , { ER_POOL_EXISTS , "池已存在 " } , { ER_NO_DRIVER_NAME , "未指定驱动器名称 " } , { ER_NO_URL , "未指定  URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "池的数量不足一个！ " } , { ER_INVALID_DRIVER , "指定了无效的驱动程序名称！ " } , { ER_NO_STYLESHEETROOT , "未找到式样表单的源位置！ " } , { ER_ILLEGAL_XMLSPACE_VALUE , "在  xml:space 中出现非法数值 " } , { ER_PROCESSFROMNODE_FAILED , "processFromNode 失败 " } , { ER_RESOURCE_COULD_NOT_LOAD , "[ {0} ] 资源无法装入： {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "缓冲区大小  <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "调用扩展时出现未知错误 " } , { ER_NO_NAMESPACE_DECL , "前缀  {0} 未声明相应的名称空间 " } , { ER_ELEM_CONTENT_NOT_ALLOWED , "在  lang=javaclass {0} 中不允许出现元素内容 " } , { ER_STYLESHEET_DIRECTED_TERMINATION , "指导式样表单终止 " } , { ER_ONE_OR_TWO , "1 或  2" } , { ER_TWO_OR_THREE , "2 或  3" } , { ER_COULD_NOT_LOAD_RESOURCE , "无法装入  {0}（检查  CLASSPATH），正在使用缺省值 " } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "无法初始化缺省模板 " } , { ER_RESULT_NULL , "结果不应为空 " } , { ER_RESULT_COULD_NOT_BE_SET , "无法设置结果 " } , { ER_NO_OUTPUT_SPECIFIED , "未指定输出 " } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "无法变换到一个类型的结果中  {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "无法变换一个类型源  {0}" } , { ER_NULL_CONTENT_HANDLER , "空的内容句柄 " } , { ER_NULL_ERROR_HANDLER , "空的错误句柄 " } , { ER_CANNOT_CALL_PARSE , "如果未设置  ContentHandler，则无法调用解析 " } , { ER_NO_PARENT_FOR_FILTER , "在过滤器中无父辈 " } , { ER_NO_STYLESHEET_IN_MEDIA , "在  {0}， media= {1} 中未找到式样表单  " } , { ER_NO_STYLESHEET_PI , "在  {0} 中未找到  xml-stylesheet PI：  " } , { ER_NOT_SUPPORTED , "不支持： {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "属性值  {0} 应当是一个布尔实例 " } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "无法在  {0} 中到达外部脚本 " } , { ER_RESOURCE_COULD_NOT_FIND , "未找到  [ {0} ] 资源。 \n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "无法识别输出属性： {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "创建  ElemLiteralResult 实例失败 " } , { ER_VALUE_SHOULD_BE_NUMBER , "{0} 的值应该包含可分析的数字 " } , { ER_VALUE_SHOULD_EQUAL , "{0} 的值应当是“是”或“非” " } , { ER_FAILED_CALLING_METHOD , "调用  {0} 方法失败 " } , { ER_FAILED_CREATING_ELEMTMPL , "创建  ElemTemplateElement 实例失败 " } , { ER_CHARS_NOT_ALLOWED , "在文档此处不允许出现字符 " } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" 属性不允许在  {1} 元素中出现！  " } , { ER_BAD_VALUE , "{0} 错误数值  {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "未找到  {0} 属性值 " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "无法识别  {0} 属性值 " } , { ER_NULL_URI_NAMESPACE , "试图用空  URI 生成名称空间前缀 " } , { ER_NUMBER_TOO_BIG , "试图格式化一个超过最大长整型整数的数 " } , { ER_CANNOT_FIND_SAX1_DRIVER , "找不到  SAX1 驱动程序类  {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "找到  SAX1 驱动程序类  {0} 但无法加载 " } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "加载了  SAX1 驱动程序类  {0} 但无法实例化 " } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 驱动程序类  {0} 无法实现  org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "未指定系统特性  org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Parser 变量必须为非空 " } , { ER_FEATURE , "特征：一个  {0}" } , { ER_PROPERTY , "特性：一个  {0}" } , { ER_NULL_ENTITY_RESOLVER , "空实体解析程序 " } , { ER_NULL_DTD_HANDLER , "空  DTD 处理程序 " } , { ER_NO_DRIVER_NAME_SPECIFIED , "未指定驱动程序名称！ " } , { ER_NO_URL_SPECIFIED , "未指定  URL！ " } , { ER_POOLSIZE_LESS_THAN_ONE , "池的大小小于  1！ " } , { ER_INVALID_DRIVER_NAME , "指定了无效驱动程序名称！ " } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "程序员错误！ expr 没有  ElemTemplateElement 父类！ " } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "RundundentExprEliminator 中的程序员声明： {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "样式表中的这个位置不允许出现  {0}！ " } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "样式表中的这个位置不允许非空格文本！ " } , { INVALID_TCHAR , "使用了非法值： {1}（在  CHAR 属性  {0} 中）。 CHAR 类型的属性必须只包含  1 个字符！ " } , { INVALID_QNAME , "使用了非法值： {1}（在  QNAME 属性  {0} 中） " } , { INVALID_ENUM , "使用了非法值： {1}（在  ENUM 属性  {0} 中）。有效值为： {2}。 " } , { INVALID_NMTOKEN , "使用了非法值： {1}（在  NMTOKEN 属性  {0} 中）  " } , { INVALID_NCNAME , "使用了非法值： {1}（在  NCNAME 属性  {0} 中）  " } , { INVALID_BOOLEAN , "使用了非法值： {1}（在布尔属性  {0} 中）  " } , { INVALID_NUMBER , "使用了非法值： {1}（在数字属性  {0} 中）  " } , { ER_ARG_LITERAL , "匹配模式中的  {0} 变量必须是文字。 " } , { ER_DUPLICATE_GLOBAL_VAR , "重复的全局变量声明。 " } , { ER_DUPLICATE_VAR , "重复的变量声明。 " } , { ER_TEMPLATE_NAME_MATCH , "xsl:template 必须具有名称或匹配的属性（或同时具有两者） " } , { ER_INVALID_PREFIX , "exclude-result-prefixes 中的前缀无效： {0}" } , { ER_NO_ATTRIB_SET , "不存在名为  {0} 的  attribute-set" } , { WG_FOUND_CURLYBRACE , "已找到  '}'，但未打开属性模板！ " } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "警告： ''count'' 属性与  xsl:number! Target = {0} 中的祖先不匹配 " } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "旧语法： 'expr' 属性的名称已经变为  'select'。 " } , { WG_NO_LOCALE_IN_FORMATNUMBER , " Xalan 仍然无法处理  format-number 函数中的语言环境名称。 " } , { WG_LOCALE_NOT_FOUND , "警告：无法找到  xml:lang={0} 中的语言环境  " } , { WG_CANNOT_MAKE_URL_FROM , "从  {0} 中无法产生  URL：  " } , { WG_CANNOT_LOAD_REQUESTED_DOC , "无法装入请求文档： {0}" } , { WG_CANNOT_FIND_COLLATOR , "在  <sort xml:lang={0} 中无法找到整理机  " } , { WG_FUNCTIONS_SHOULD_USE_URL , "旧语法：函数指令应当使用  {0} 的一个  URL " } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "不受支持的编码： {0}，正在使用  UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "不受支持的编码： {0}，正在  Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "发现专一性冲突： {0} 将使用上次在式样表单中找到的编码。 " } , { WG_PARSING_AND_PREPARING , "========= 分析和准备  {0} ==========" } , { WG_ATTR_TEMPLATE , "属性模板， {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "在  xsl:strip-space 和  xsl:preserve-space 之间出现匹配冲突  " } , { WG_ATTRIB_NOT_HANDLED , "Xalan 仍不处理  {0} 属性！ " } , { WG_NO_DECIMALFORMAT_DECLARATION , "未找到十进制格式的声明： {0}" } , { WG_OLD_XSLT_NS , "缺少或不正确的  XSLT Namespace。  " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "仅允许声明一个缺省  xsl:decimal-format。  " } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 的名称必须是唯一的。名称  \"{0}\" 已复制。 " } , { WG_ILLEGAL_ATTRIBUTE , "{0} 存在一个非法属性： {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "无法解析名称空间前缀： {0}。忽略节点。 " } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要  'version' 属性！ " } , { WG_ILLEGAL_ATTRIBUTE_NAME , "非法属性名称： {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "在属性中使用非法数值  {0}： {1}" } , { WG_EMPTY_SECOND_ARG , "来自文档属性第二个参数的结果节点集为空。将使用第一个参数。 " } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction 名称的  'name' 属性值不能为  'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction 的  ''name'' 属性值必须是一个有效的  NCName:a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "无法在已经生成子节点之后或在尚未生成元素之前添加属性  {0}。属性将被忽略。 " } , { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "BAD_CODE" , "createMessage 参数超过范围 " } , { "FORMAT_FAILED" , "调用  messageFormat 时出现意外情况   " } , { "version" , ">>>>>>> Xalan 版本  " } , { "version2" , "<<<<<<<" } , { "yes" , "是 " } , { "line" , "行  #" } , { "column" , "列  #" } , { "xsldone" , "XSLProcessor: done" } , { "xslProc_option" , "Xalan-J 命令行运行类选项： " } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER 完全符合分析联络的类名称 ]" } , { "optionE" , "   [-E（不扩展实体引用） ]" } , { "optionV" , "   [-E（不扩展实体引用） ]" } , { "optionQC" , "   [-QC（静止模式冲突警告） ]" } , { "optionQ" , "   [-Q（静止模式） ]" } , { "optionLF" , "   [-LF（仅在输出时使用换行  {缺省为  CR/LF}） ]" } , { "optionCR" , "   [-CR（仅在输出时使用换行  {缺省为  CR/LF}） ]" } , { "optionESCAPE" , "   [-ESCAPE（避免使用的字符  {缺省是  <>&\"\'\\r\\n}） ]" } , { "optionINDENT" , "   [-INDENT（控制缩进空格的数量  {缺省是  0}） ]" } , { "optionTT" , "   [-TT（跟踪调用的模板。） ]" } , { "optionTG" , "   [-TG（跟踪发生事件。） ]" } , { "optionTS" , "   [-TS（跟踪每个选中事件。） ]" } , { "optionTTC" , "   [-TTC（跟踪运行的子模板。） ]" } , { "optionTCLASS" , "   [-TCLASS（用于跟踪扩展名的  TraceListener 类。） ]" } , { "optionVALIDATE" , "   [-VALIDATE（设置是否“确认”。缺省情况下关闭“确认”。） ]" } , { "optionEDUMP" , "   [-EDUMP {可选文件名 }（出现错误时确保栈转储。） ]" } , { "optionXML" , "   [-XML (使用  XML 格式标识符并添加  XML 头。） ]" } , { "optionTEXT" , "   [-TEXT（使用简单的  Text 格式标识符。） ]" } , { "optionHTML" , "   [-HTML（使用  HTML 格式标识符。） ]" } , { "optionPARAM" , "   [-PARAM 名称扩展（设置一个  stylesheet 参数） ]" } , { "noParsermsg1" , "XSL 运行不成功。  " } , { "noParsermsg2" , "** 未找到分析器  **" } , { "noParsermsg3" , "请检查您的类路径。 " } , { "noParsermsg4" , "如果您没有  IBM 用于  Java 的  XML 分析器，您可从 " } , { "noParsermsg5" , "IBM AlphaWorks： http://www.alphaworks.ibm.com/formula/xml 下载。 " } , { "optionURIRESOLVER" , "   [-URIRESOLVER 全类名（ URIResolver 用于分析  URI） ]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER 全类名（ EntityResolver 用于分析实体） ] " } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER 全类名（ ContentHandler 用于串行化输出） ]" } , { "optionLINENUMBERS" , "   [-L 使用源文档的行号 ]" } , { "optionMEDIA" , " [-MEDIA 媒体类型（使用媒体属性查找与某个文档关联的样式表。） ]" } , { "optionFLAVOR" , " [-FLAVOR 风格名称（明确使用  s2s=SAX 或  d2d=DOM 进行变换。） ] " } , { "optionDIAG" , " [-DIAG（打印变换所花的总毫秒数。） ]" } , { "optionINCREMENTAL" , " [-INCREMENTAL（通过将  http://xml.apache.org/xalan/features/incremental 设置为  true 来请求增量式  DTM 构造。） ]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE（通过将  http://xml.apache.org/xalan/features/optimize 设置为  false 来请求无样式表优化处理。） ]" } , { "optionRL" , " [-RL 递归限制（声明样式表递归深度的数字限制。） ]" } , { "optionXO" , " [-XO [translet 名 ]（指定生成的  translet 的名称） ]" } , { "optionXD" , " [-XD 目标目录（指定  translet 的目标目录） ]" } , { "optionXJ" , " [-XJ jar 文件（将  translet 类封装成名称为  <jarfile> 的  jar 文件） ]" } , { "optionXP" , " [-XP 软件包（为所有生成的  translet 类指定软件包名称前缀） ]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "错误：  " ; public static final String WARNING_HEADER = "警告：  " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0
package org . apache . xalan . xsltc . dom ; import java . io . File ; import java . io . FileNotFoundException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . sax . SAXSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public final class LoadDocument { private static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static DTMAxisIterator document ( String uri , String base , AbstractTranslet translet , DOM dom ) throws Exception { final String originalUri = uri ; MultiDOM multiplexer = ( MultiDOM ) dom ; if ( uri == null || uri . equals ( "" ) ) { return ( new SingletonIterator ( DTM . NULL , true ) ) ; } if ( base != null && ! base . equals ( "" ) ) { if ( ! uri . startsWith ( base ) && ! uri . startsWith ( "/" ) && ! uri . startsWith ( "http:/" ) && ! uri . startsWith ( "file:/" ) ) { uri = base + uri ; } } final File file = new File ( uri ) ; if ( file . exists ( ) ) { uri = file . toURL ( ) . toExternalForm ( ) ; } int mask = multiplexer . getDocumentMask ( uri ) ; if ( mask != - 1 ) { DOM newDom = ( ( DOMAdapter ) multiplexer . getDOMAdapter ( uri ) ) . getDOMImpl ( ) ; if ( newDom instanceof SAXImpl ) { return new SingletonIterator ( ( ( SAXImpl ) newDom ) . getDocument ( ) , true ) ; } } DOMCache cache = translet . getDOMCache ( ) ; DOM newdom ; mask = multiplexer . nextMask ( ) ; if ( cache != null ) { newdom = cache . retrieveDocument ( uri , mask , translet ) ; if ( newdom == null ) { final Exception e = new FileNotFoundException ( originalUri ) ; throw new TransletException ( e ) ; } } else { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; try { reader . setFeature ( NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } XSLTCDTMManager dtmManager = ( XSLTCDTMManager ) ( ( DTMDefaultBase ) ( ( DOMAdapter ) multiplexer . getMain ( ) ) . getDOMImpl ( ) ) . m_mgr ; newdom = ( SAXImpl ) dtmManager . getDTM ( new SAXSource ( reader , new InputSource ( uri ) ) , false , null , true , false , translet . hasIdCall ( ) ) ; translet . prepassDocument ( newdom ) ; ( ( SAXImpl ) newdom ) . setDocumentURI ( uri ) ; } final DOMAdapter domAdapter = translet . makeDOMAdapter ( newdom ) ; multiplexer . addDOMAdapter ( domAdapter ) ; translet . buildKeys ( domAdapter , null , null , ( ( SAXImpl ) newdom ) . getDocument ( ) ) ; return new SingletonIterator ( ( ( SAXImpl ) newdom ) . getDocument ( ) , true ) ; } public static DTMAxisIterator document ( Object arg , String xmlURI , String xslURI , AbstractTranslet translet , DOM dom ) throws TransletException { try { if ( xmlURI != null ) { int sep = xmlURI . lastIndexOf ( '\\' ) + 1 ; if ( sep <= 0 ) { sep = xmlURI . lastIndexOf ( '/' ) + 1 ; } xmlURI = xmlURI . substring ( 0 , sep ) ; } else { xmlURI = "" ; } if ( xslURI != null ) { int sep = xslURI . lastIndexOf ( '\\' ) + 1 ; if ( sep <= 0 ) { sep = xslURI . lastIndexOf ( '/' ) + 1 ; } xslURI = xslURI . substring ( 0 , sep ) ; } else { xslURI = "" ; } if ( arg instanceof String ) { try { return document ( ( String ) arg , xmlURI , translet , dom ) ; } catch ( java . io . FileNotFoundException e ) { return document ( ( String ) arg , xslURI , translet , dom ) ; } catch ( org . xml . sax . SAXParseException e ) { return document ( ( String ) arg , xslURI , translet , dom ) ; } } else if ( arg instanceof DTMAxisIterator ) { UnionIterator union = new UnionIterator ( dom ) ; DTMAxisIterator iterator = ( DTMAxisIterator ) arg ; int node ; while ( ( node = iterator . next ( ) ) != DTM . NULL ) { String uri = dom . getStringValueX ( node ) ; if ( ( xmlURI == null ) || xmlURI . equals ( "" ) ) { xmlURI = dom . getDocumentURI ( node ) ; int sep = xmlURI . lastIndexOf ( '\\' ) + 1 ; if ( sep <= 0 ) { sep = xmlURI . lastIndexOf ( '/' ) + 1 ; } xmlURI = xmlURI . substring ( 0 , sep ) ; } try { union . addIterator ( document ( uri , xmlURI , translet , dom ) ) ; } catch ( java . io . FileNotFoundException e ) { union . addIterator ( document ( uri , xslURI , translet , dom ) ) ; } } return ( union ) ; } else { final String err = "document(" + arg . toString ( ) + ")" ; throw new IllegalArgumentException ( err ) ; } } catch ( TransletException e ) { throw e ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } } 	1
package org . apache . xalan . xsltc . compiler ; abstract class AttributeValue extends Expression { public static final AttributeValue create ( SyntaxTreeNode parent , String text , Parser parser ) { AttributeValue result ; if ( text . indexOf ( '{' ) != - 1 ) { result = new AttributeValueTemplate ( text , parser , parent ) ; } else if ( text . indexOf ( '}' ) != - 1 ) { result = new AttributeValueTemplate ( text , parser , parent ) ; } else { result = new SimpleAttributeValue ( text ) ; result . setParser ( parser ) ; result . setParent ( parent ) ; } return result ; } } 	0
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; public final class FilteredStepIterator extends StepIterator { private Filter _filter ; public FilteredStepIterator ( DTMAxisIterator source , DTMAxisIterator iterator , Filter filter ) { super ( source , iterator ) ; _filter = filter ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != END ) { if ( _filter . test ( node ) ) { return returnNode ( node ) ; } } return node ; } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class NamespaceAlias extends TopLevelElement { private String sPrefix ; private String rPrefix ; public void parseContents ( Parser parser ) { sPrefix = getAttribute ( "stylesheet-prefix" ) ; rPrefix = getAttribute ( "result-prefix" ) ; parser . getSymbolTable ( ) . addPrefixAlias ( sPrefix , rPrefix ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	0
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToTextSAXHandler extends ToSAXHandler { public void endElement ( String elemName ) throws SAXException { super . fireEndElem ( elemName ) ; } public void endElement ( String arg0 , String arg1 , String arg2 ) throws SAXException { super . fireEndElem ( arg2 ) ; } public ToTextSAXHandler ( ContentHandler hdlr , LexicalHandler lex , String encoding ) { super ( hdlr , lex , encoding ) ; } public ToTextSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { super . fireCommentEvent ( ch , start , length ) ; } public void comment ( String data ) throws org . xml . sax . SAXException { comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public boolean reset ( ) { return false ; } public void serialize ( Node node ) throws IOException { } public boolean setEscaping ( boolean escape ) { return false ; } public void setIndent ( boolean indent ) { } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) { } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { } public void endPrefixMapping ( String arg0 ) throws SAXException { } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { super . fireEscapingEvent ( arg0 , arg1 ) ; } public void setDocumentLocator ( Locator arg0 ) { } public void skippedEntity ( String arg0 ) throws SAXException { } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { flushPending ( ) ; super . startElement ( arg0 , arg1 , arg2 , arg3 ) ; } public void endCDATA ( ) throws SAXException { } public void endDTD ( ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void startEntity ( String arg0 ) throws SAXException { } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { super . startElement ( elementNamespaceURI , elementLocalName , elementName ) ; } public void startElement ( String elementName ) throws SAXException { super . startElement ( elementName ) ; } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; super . fireEndDoc ( ) ; } public void characters ( String characters ) throws SAXException { m_saxHandler . characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public void characters ( char [ ] characters , int offset , int length ) throws SAXException { m_saxHandler . characters ( characters , offset , length ) ; super . fireCharEvent ( characters , offset , length ) ; } public void addAttribute ( String name , String value ) { } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { } } 	0
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . StringVector ; import org . apache . xpath . XPathContext ; public class ElemLiteralResult extends ElemUse { private boolean isLiteralResultAsStylesheet = false ; public void setIsLiteralResultAsStylesheet ( boolean b ) { isLiteralResultAsStylesheet = b ; } public boolean getIsLiteralResultAsStylesheet ( ) { return isLiteralResultAsStylesheet ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } } } private Vector m_avts = null ; private Vector m_xslAttr = null ; public void addLiteralResultAttribute ( AVT avt ) { if ( null == m_avts ) m_avts = new Vector ( ) ; m_avts . addElement ( avt ) ; } public void addLiteralResultAttribute ( String att ) { if ( null == m_xslAttr ) m_xslAttr = new Vector ( ) ; m_xslAttr . addElement ( att ) ; } public void setXmlSpace ( AVT avt ) { addLiteralResultAttribute ( avt ) ; String val = avt . getSimpleString ( ) ; if ( val . equals ( "default" ) ) { super . setXmlSpace ( Constants . ATTRVAL_STRIP ) ; } else if ( val . equals ( "preserve" ) ) { super . setXmlSpace ( Constants . ATTRVAL_PRESERVE ) ; } } public AVT getLiteralResultAttribute ( String name ) { if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; if ( avt . getRawName ( ) . equals ( name ) ) { return avt ; } } } return null ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { if ( uri == null || ( null == m_excludeResultPrefixes && null == m_ExtensionElementURIs ) ) return super . containsExcludeResultPrefix ( prefix , uri ) ; if ( prefix . length ( ) == 0 ) prefix = Constants . ATTRVAL_DEFAULT_PREFIX ; if ( m_excludeResultPrefixes != null ) for ( int i = 0 ; i < m_excludeResultPrefixes . size ( ) ; i ++ ) { if ( uri . equals ( getNamespaceForPrefix ( m_excludeResultPrefixes . elementAt ( i ) ) ) ) return true ; } if ( m_ExtensionElementURIs != null && m_ExtensionElementURIs . contains ( uri ) ) return true ; return super . containsExcludeResultPrefix ( prefix , uri ) ; } public void resolvePrefixTables ( ) throws TransformerException { super . resolvePrefixTables ( ) ; StylesheetRoot stylesheet = getStylesheetRoot ( ) ; if ( ( null != m_namespace ) && ( m_namespace . length ( ) > 0 ) ) { NamespaceAlias nsa = stylesheet . getNamespaceAliasComposed ( m_namespace ) ; if ( null != nsa ) { m_namespace = nsa . getResultNamespace ( ) ; String resultPrefix = nsa . getStylesheetPrefix ( ) ; if ( ( null != resultPrefix ) && ( resultPrefix . length ( ) > 0 ) ) m_rawName = resultPrefix + ":" + m_localName ; else m_rawName = m_localName ; } } if ( null != m_avts ) { int n = m_avts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; String ns = avt . getURI ( ) ; if ( ( null != ns ) && ( ns . length ( ) > 0 ) ) { NamespaceAlias nsa = stylesheet . getNamespaceAliasComposed ( m_namespace ) ; if ( null != nsa ) { String namespace = nsa . getResultNamespace ( ) ; String resultPrefix = nsa . getStylesheetPrefix ( ) ; String rawName = avt . getName ( ) ; if ( ( null != resultPrefix ) && ( resultPrefix . length ( ) > 0 ) ) rawName = resultPrefix + ":" + rawName ; avt . setURI ( namespace ) ; avt . setRawName ( rawName ) ; } } } } } boolean needToCheckExclude ( ) { if ( null == m_excludeResultPrefixes && null == m_prefixTable && m_ExtensionElementURIs == null ) return false ; else { if ( null == m_prefixTable ) m_prefixTable = new Vector ( ) ; return true ; } } private String m_namespace ; public void setNamespace ( String ns ) { if ( null == ns ) ns = "" ; m_namespace = ns ; } public String getNamespace ( ) { return m_namespace ; } private String m_localName ; public void setLocalName ( String localName ) { m_localName = localName ; } public String getLocalName ( ) { return m_localName ; } private String m_rawName ; public void setRawName ( String rawName ) { m_rawName = rawName ; } public String getRawName ( ) { return m_rawName ; } public String getPrefix ( ) { int len = m_rawName . length ( ) - m_localName . length ( ) - 1 ; return ( len > 0 ) ? m_rawName . substring ( 0 , len ) : "" ; } private StringVector m_ExtensionElementURIs ; public void setExtensionElementPrefixes ( StringVector v ) { m_ExtensionElementURIs = v ; } public String getExtensionElementPrefix ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_ExtensionElementURIs ) throw new ArrayIndexOutOfBoundsException ( ) ; return m_ExtensionElementURIs . elementAt ( i ) ; } public int getExtensionElementPrefixCount ( ) { return ( null != m_ExtensionElementURIs ) ? m_ExtensionElementURIs . size ( ) : 0 ; } public boolean containsExtensionElementURI ( String uri ) { if ( null == m_ExtensionElementURIs ) return false ; return m_ExtensionElementURIs . contains ( uri ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_LITERALRESULT ; } public String getNodeName ( ) { return m_rawName ; } private String m_version ; public void setVersion ( String v ) { m_version = v ; } public String getVersion ( ) { return m_version ; } private StringVector m_excludeResultPrefixes ; public void setExcludeResultPrefixes ( StringVector v ) { m_excludeResultPrefixes = v ; } private boolean excludeResultNSDecl ( String prefix , String uri ) throws TransformerException { if ( null != m_excludeResultPrefixes ) { return containsExcludeResultPrefix ( prefix , uri ) ; } return false ; } public void execute ( TransformerImpl transformer ) throws TransformerException { try { SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; rhandler . startPrefixMapping ( getPrefix ( ) , getNamespace ( ) ) ; executeNSDecls ( transformer ) ; rhandler . startElement ( getNamespace ( ) , getLocalName ( ) , getRawName ( ) ) ; try { super . execute ( transformer ) ; if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String stringedValue = avt . evaluate ( xctxt , sourceNode , this ) ; if ( null != stringedValue ) { rhandler . addAttribute ( avt . getURI ( ) , avt . getName ( ) , avt . getRawName ( ) , "CDATA" , stringedValue ) ; } } } transformer . executeChildTemplates ( this , true ) ; } finally { rhandler . endElement ( getNamespace ( ) , getLocalName ( ) , getRawName ( ) ) ; unexecuteNSDecls ( transformer ) ; rhandler . endPrefixMapping ( getPrefix ( ) ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } public Enumeration enumerateLiteralResultAttributes ( ) { return ( null == m_avts ) ? null : m_avts . elements ( ) ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitLiteralResultElement ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs && null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; avt . callVisitors ( visitor ) ; } } super . callChildVisitors ( visitor , callAttrs ) ; } } 	1
package org . apache . xml . utils ; import java . io . Serializable ; import javax . xml . transform . SourceLocator ; import org . xml . sax . Locator ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; public class SAXSourceLocator extends LocatorImpl implements SourceLocator , Serializable { Locator m_locator ; public SAXSourceLocator ( ) { } public SAXSourceLocator ( Locator locator ) { m_locator = locator ; this . setColumnNumber ( locator . getColumnNumber ( ) ) ; this . setLineNumber ( locator . getLineNumber ( ) ) ; this . setPublicId ( locator . getPublicId ( ) ) ; this . setSystemId ( locator . getSystemId ( ) ) ; } public SAXSourceLocator ( javax . xml . transform . SourceLocator locator ) { m_locator = null ; this . setColumnNumber ( locator . getColumnNumber ( ) ) ; this . setLineNumber ( locator . getLineNumber ( ) ) ; this . setPublicId ( locator . getPublicId ( ) ) ; this . setSystemId ( locator . getSystemId ( ) ) ; } public SAXSourceLocator ( SAXParseException spe ) { this . setLineNumber ( spe . getLineNumber ( ) ) ; this . setColumnNumber ( spe . getColumnNumber ( ) ) ; this . setPublicId ( spe . getPublicId ( ) ) ; this . setSystemId ( spe . getSystemId ( ) ) ; } public String getPublicId ( ) { return ( null == m_locator ) ? super . getPublicId ( ) : m_locator . getPublicId ( ) ; } public String getSystemId ( ) { return ( null == m_locator ) ? super . getSystemId ( ) : m_locator . getSystemId ( ) ; } public int getLineNumber ( ) { return ( null == m_locator ) ? super . getLineNumber ( ) : m_locator . getLineNumber ( ) ; } public int getColumnNumber ( ) { return ( null == m_locator ) ? super . getColumnNumber ( ) : m_locator . getColumnNumber ( ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . runtime . TransletLoader ; final class FunctionAvailableCall extends FunctionCall { private Expression _arg ; private String _nameOfFunct = null ; private String _namespaceOfFunct = null ; private boolean _isFunctionAvailable = false ; public FunctionAvailableCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _arg = ( Expression ) arguments . elementAt ( 0 ) ; _type = null ; if ( _arg instanceof LiteralExpr ) { LiteralExpr arg = ( LiteralExpr ) _arg ; _namespaceOfFunct = arg . getNamespace ( ) ; _nameOfFunct = arg . getValue ( ) ; if ( ! isInternalNamespace ( ) ) { _isFunctionAvailable = hasMethods ( ) ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) { return _type ; } if ( _arg instanceof LiteralExpr ) { return _type = Type . Boolean ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . NEED_LITERAL_ERR , "function-available" , this ) ; throw new TypeCheckError ( err ) ; } public Object evaluateAtCompileTime ( ) { return getResult ( ) ? Boolean . TRUE : Boolean . FALSE ; } private boolean hasMethods ( ) { LiteralExpr arg = ( LiteralExpr ) _arg ; String className = getClassNameFromUri ( _namespaceOfFunct ) ; String methodName = null ; int colonIndex = _nameOfFunct . indexOf ( ":" ) ; if ( colonIndex > 0 ) { String functionName = _nameOfFunct . substring ( colonIndex + 1 ) ; int lastDotIndex = functionName . lastIndexOf ( '.' ) ; if ( lastDotIndex > 0 ) { methodName = functionName . substring ( lastDotIndex + 1 ) ; if ( className != null && ! className . equals ( "" ) ) className = className + "." + functionName . substring ( 0 , lastDotIndex ) ; else className = functionName . substring ( 0 , lastDotIndex ) ; } else methodName = functionName ; } else methodName = _nameOfFunct ; if ( className == null || methodName == null ) { return false ; } if ( methodName . indexOf ( '-' ) > 0 ) methodName = replaceDash ( methodName ) ; try { TransletLoader loader = new TransletLoader ( ) ; final Class clazz = loader . loadClass ( className ) ; if ( clazz == null ) { return false ; } else { final Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final int mods = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && Modifier . isStatic ( mods ) && methods [ i ] . getName ( ) . equals ( methodName ) ) { return true ; } } } } catch ( ClassNotFoundException e ) { return false ; } return false ; } public boolean getResult ( ) { if ( _nameOfFunct == null ) { return false ; } if ( isInternalNamespace ( ) ) { final Parser parser = getParser ( ) ; _isFunctionAvailable = parser . functionSupported ( Util . getLocalName ( _nameOfFunct ) ) ; } return _isFunctionAvailable ; } private boolean isInternalNamespace ( ) { return ( _namespaceOfFunct == null || _namespaceOfFunct . equals ( EMPTYSTRING ) || _namespaceOfFunct . equals ( TRANSLET_URI ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; methodGen . getInstructionList ( ) . append ( new PUSH ( cpg , getResult ( ) ) ) ; } } 	0
package org . apache . xalan . templates ; import java . text . DecimalFormatSymbols ; import org . apache . xml . utils . QName ; public class DecimalFormatProperties extends ElemTemplateElement { DecimalFormatSymbols m_dfs ; public DecimalFormatProperties ( int docOrderNumber ) { m_dfs = new java . text . DecimalFormatSymbols ( ) ; m_dfs . setInfinity ( Constants . ATTRVAL_INFINITY ) ; m_dfs . setNaN ( Constants . ATTRVAL_NAN ) ; m_docOrderNumber = docOrderNumber ; } public DecimalFormatSymbols getDecimalFormatSymbols ( ) { return m_dfs ; } private QName m_qname = null ; public void setName ( QName qname ) { m_qname = qname ; } public QName getName ( ) { if ( m_qname == null ) return new QName ( "" ) ; else return m_qname ; } public void setDecimalSeparator ( char ds ) { m_dfs . setDecimalSeparator ( ds ) ; } public char getDecimalSeparator ( ) { return m_dfs . getDecimalSeparator ( ) ; } public void setGroupingSeparator ( char gs ) { m_dfs . setGroupingSeparator ( gs ) ; } public char getGroupingSeparator ( ) { return m_dfs . getGroupingSeparator ( ) ; } public void setInfinity ( String inf ) { m_dfs . setInfinity ( inf ) ; } public String getInfinity ( ) { return m_dfs . getInfinity ( ) ; } public void setMinusSign ( char v ) { m_dfs . setMinusSign ( v ) ; } public char getMinusSign ( ) { return m_dfs . getMinusSign ( ) ; } public void setNaN ( String v ) { m_dfs . setNaN ( v ) ; } public String getNaN ( ) { return m_dfs . getNaN ( ) ; } public void setPercent ( char v ) { m_dfs . setPercent ( v ) ; } public char getPercent ( ) { return m_dfs . getPercent ( ) ; } public void setPerMille ( char v ) { m_dfs . setPerMill ( v ) ; } public char getPerMille ( ) { return m_dfs . getPerMill ( ) ; } public void setZeroDigit ( char v ) { m_dfs . setZeroDigit ( v ) ; } public char getZeroDigit ( ) { return m_dfs . getZeroDigit ( ) ; } public void setDigit ( char v ) { m_dfs . setDigit ( v ) ; } public char getDigit ( ) { return m_dfs . getDigit ( ) ; } public void setPatternSeparator ( char v ) { m_dfs . setPatternSeparator ( v ) ; } public char getPatternSeparator ( ) { return m_dfs . getPatternSeparator ( ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeDecimalFormats ( this ) ; } } 	1
package org . apache . xalan . transformer ; import java . util . Enumeration ; import java . util . Stack ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . NamespaceSupport2 ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectStack ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . xml . sax . helpers . NamespaceSupport ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; class TransformSnapshotImpl implements TransformSnapshot { private VariableStack m_variableStacks ; private IntStack m_currentNodes ; private IntStack m_currentExpressionNodes ; private Stack m_contextNodeLists ; private DTMIterator m_contextNodeList ; private Stack m_axesIteratorStack ; private BoolStack m_currentTemplateRuleIsNull ; private ObjectStack m_currentTemplateElements ; private Stack m_currentMatchTemplates ; private NodeVector m_currentMatchNodes ; private CountersTable m_countersTable ; private Stack m_attrSetStack ; boolean m_nsContextPushed ; private NamespaceMappings m_nsSupport ; TransformSnapshotImpl ( TransformerImpl transformer ) { try { SerializationHandler rtf = transformer . getResultTreeHandler ( ) ; { m_nsSupport = ( NamespaceMappings ) rtf . getNamespaceMappings ( ) . clone ( ) ; } XPathContext xpc = transformer . getXPathContext ( ) ; m_variableStacks = ( VariableStack ) xpc . getVarStack ( ) . clone ( ) ; m_currentNodes = ( IntStack ) xpc . getCurrentNodeStack ( ) . clone ( ) ; m_currentExpressionNodes = ( IntStack ) xpc . getCurrentExpressionNodeStack ( ) . clone ( ) ; m_contextNodeLists = ( Stack ) xpc . getContextNodeListsStack ( ) . clone ( ) ; if ( ! m_contextNodeLists . empty ( ) ) m_contextNodeList = ( DTMIterator ) xpc . getContextNodeList ( ) . clone ( ) ; m_axesIteratorStack = ( Stack ) xpc . getAxesIteratorStackStacks ( ) . clone ( ) ; m_currentTemplateRuleIsNull = ( BoolStack ) transformer . m_currentTemplateRuleIsNull . clone ( ) ; m_currentTemplateElements = ( ObjectStack ) transformer . m_currentTemplateElements . clone ( ) ; m_currentMatchTemplates = ( Stack ) transformer . m_currentMatchTemplates . clone ( ) ; m_currentMatchNodes = ( NodeVector ) transformer . m_currentMatchedNodes . clone ( ) ; m_countersTable = ( CountersTable ) transformer . getCountersTable ( ) . clone ( ) ; if ( transformer . m_attrSetStack != null ) m_attrSetStack = ( Stack ) transformer . m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } void apply ( TransformerImpl transformer ) { try { SerializationHandler rtf = transformer . getResultTreeHandler ( ) ; if ( rtf != null ) { rtf . setNamespaceMappings ( ( NamespaceMappings ) m_nsSupport . clone ( ) ) ; } XPathContext xpc = transformer . getXPathContext ( ) ; xpc . setVarStack ( ( VariableStack ) m_variableStacks . clone ( ) ) ; xpc . setCurrentNodeStack ( ( IntStack ) m_currentNodes . clone ( ) ) ; xpc . setCurrentExpressionNodeStack ( ( IntStack ) m_currentExpressionNodes . clone ( ) ) ; xpc . setContextNodeListsStack ( ( Stack ) m_contextNodeLists . clone ( ) ) ; if ( m_contextNodeList != null ) xpc . pushContextNodeList ( ( DTMIterator ) m_contextNodeList . clone ( ) ) ; xpc . setAxesIteratorStackStacks ( ( Stack ) m_axesIteratorStack . clone ( ) ) ; transformer . m_currentTemplateRuleIsNull = ( BoolStack ) m_currentTemplateRuleIsNull . clone ( ) ; transformer . m_currentTemplateElements = ( ObjectStack ) m_currentTemplateElements . clone ( ) ; transformer . m_currentMatchTemplates = ( Stack ) m_currentMatchTemplates . clone ( ) ; transformer . m_currentMatchedNodes = ( NodeVector ) m_currentMatchNodes . clone ( ) ; transformer . m_countersTable = ( CountersTable ) m_countersTable . clone ( ) ; if ( m_attrSetStack != null ) transformer . m_attrSetStack = ( Stack ) m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } } 	0
package org . apache . xpath . compiler ; public class OpMapVector { protected int m_blocksize ; protected int m_map [ ] ; protected int m_lengthPos = 0 ; protected int m_mapSize ; public OpMapVector ( int blocksize , int increaseSize , int lengthPos ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_lengthPos = lengthPos ; m_map = new int [ blocksize ] ; } public final int elementAt ( int i ) { return m_map [ i ] ; } public final void setElementAt ( int value , int index ) { if ( index >= m_mapSize ) { int oldSize = m_mapSize ; m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , oldSize ) ; m_map = newMap ; } m_map [ index ] = value ; } public final void setToSize ( int size ) { int newMap [ ] = new int [ size ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map [ m_lengthPos ] ) ; m_mapSize = size ; m_map = newMap ; } } 	1
package org . apache . xml . utils ; import java . io . PrintStream ; import java . io . PrintWriter ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class DefaultErrorHandler implements ErrorHandler , ErrorListener { PrintWriter m_pw ; public DefaultErrorHandler ( PrintWriter pw ) { m_pw = pw ; } public DefaultErrorHandler ( PrintStream pw ) { m_pw = new PrintWriter ( pw , true ) ; } public DefaultErrorHandler ( ) { m_pw = new PrintWriter ( System . err , true ) ; } public void warning ( SAXParseException exception ) throws SAXException { printLocation ( m_pw , exception ) ; m_pw . println ( "Parser warning: " + exception . getMessage ( ) ) ; } public void error ( SAXParseException exception ) throws SAXException { throw exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { throw exception ; } public void warning ( TransformerException exception ) throws TransformerException { printLocation ( m_pw , exception ) ; m_pw . println ( exception . getMessage ( ) ) ; } public void error ( TransformerException exception ) throws TransformerException { throw exception ; } public void fatalError ( TransformerException exception ) throws TransformerException { throw exception ; } public static void ensureLocationSet ( TransformerException exception ) { SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) locator = causeLocator ; } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; exception . setLocator ( locator ) ; } public static void printLocation ( PrintStream pw , TransformerException exception ) { printLocation ( new PrintWriter ( pw ) , exception ) ; } public static void printLocation ( java . io . PrintStream pw , org . xml . sax . SAXParseException exception ) { printLocation ( new PrintWriter ( pw ) , exception ) ; } public static void printLocation ( PrintWriter pw , Throwable exception ) { SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) locator = causeLocator ; } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof WrappedRuntimeException ) cause = ( ( WrappedRuntimeException ) cause ) . getException ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; if ( null != locator ) { String id = ( null != locator . getPublicId ( ) ) ? locator . getPublicId ( ) : ( null != locator . getSystemId ( ) ) ? locator . getSystemId ( ) : XMLMessages . createXMLMessage ( XMLErrorResources . ER_SYSTEMID_UNKNOWN , null ) ; pw . print ( id + "; " + XMLMessages . createXMLMessage ( "line" , null ) + locator . getLineNumber ( ) + "; " + XMLMessages . createXMLMessage ( "column" , null ) + locator . getColumnNumber ( ) + "; " ) ; } else pw . print ( "(" + XMLMessages . createXMLMessage ( XMLErrorResources . ER_LOCATION_UNKNOWN , null ) + ")" ) ; } } 	1
package org . apache . xml . utils ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public class UnImplNode implements Node , Element , NodeList , Document { public UnImplNode ( ) { } public void error ( String msg ) { System . out . println ( "DOM ERROR! class: " + this . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( XMLMessages . createXMLMessage ( msg , null ) ) ; } public void error ( String msg , Object [ ] args ) { System . out . println ( "DOM ERROR! class: " + this . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( XMLMessages . createXMLMessage ( msg , args ) ) ; } public Node appendChild ( Node newChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasChildNodes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public short getNodeType ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return 0 ; } public Node getParentNode ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public NodeList getChildNodes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getFirstChild ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getLastChild ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getNextSibling ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public int getLength ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return 0 ; } public Node item ( int index ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Document getOwnerDocument ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getTagName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getNodeName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void normalize ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public NodeList getElementsByTagName ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasAttribute ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public boolean hasAttributeNS ( String name , String x ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public Attr getAttributeNode ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void removeAttribute ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setAttribute ( String name , String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getAttribute ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasAttributes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getPreviousSibling ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node cloneNode ( boolean deep ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getNodeValue ( ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setNodeValue ( String nodeValue ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setValue ( String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public Element getOwnerElement ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean getSpecified ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public NamedNodeMap getAttributes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node removeChild ( Node oldChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getNamespaceURI ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getPrefix ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setPrefix ( String prefix ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getLocalName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DocumentType getDoctype ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DOMImplementation getImplementation ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element getDocumentElement ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element createElement ( String tagName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DocumentFragment createDocumentFragment ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Text createTextNode ( String data ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Comment createComment ( String data ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public CDATASection createCDATASection ( String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr createAttribute ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public EntityReference createEntityReference ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node importNode ( Node importedNode , boolean deep ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element getElementById ( String elementId ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setData ( String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String substringData ( int offset , int count ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void appendData ( String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void insertData ( int offset , String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void deleteData ( int offset , int count ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void replaceData ( int offset , int count , String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public Text splitText ( int offset ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node adoptNode ( Node source ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getEncoding ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setEncoding ( String encoding ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public boolean getStandalone ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public void setStandalone ( boolean standalone ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public boolean getStrictErrorChecking ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public void setStrictErrorChecking ( boolean strictErrorChecking ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getVersion ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setVersion ( String version ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } } 	1
package org . apache . xml . res ; public class XMLErrorResources_ko extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "기능이 지원되지 않습니다!" } , { ER_CANNOT_OVERWRITE_CAUSE , "겹쳐쓸 수 없습니다" } , { ER_NO_DEFAULT_IMPL , "기본 구현을 찾을 수 없습니다" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0})는 현재 지원되지 않습니다." } , { ER_OFFSET_BIGGER_THAN_SLOT , "오프셋이 슬롯보다 큽니다" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine은 사용할 수 없습니다, ID={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager가 co_exit() 요청을 수신했습니다" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet()이 실패했습니다" } , { ER_COROUTINE_PARAM , "Coroutine 매개변수 오류({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\n예상치 못한 문제: doTerminate 구문 분석기가 {0}에 응답했습니다. " } , { ER_NO_PARSE_CALL_WHILE_PARSING , "구문 분석하는 동안에는 구문 분석을 호출할 수 없습니다" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "오류: {0} 축에 대해 입력된 반복기가 구현되지 않습니다." } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "오류: {0} 축에 대한 반복기가 구현되지 않습니다. " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "반복기 복제가 지원되지 않습니다" } , { ER_UNKNOWN_AXIS_TYPE , "알 수 없는 축 순회 유형: {0}" } , { ER_AXIS_NOT_SUPPORTED , "축 순회기가 지원되지 않습니다: {0}" } , { ER_NO_DTMIDS_AVAIL , "더 이상 DTM ID를 사용할 수 없습니다." } , { ER_NOT_SUPPORTED , "지원되지 않습니다: {0}" } , { ER_NODE_NON_NULL , "노드는 getDTMHandleFromNode에 대해 널이 아니어야 합니다" } , { ER_COULD_NOT_RESOLVE_NODE , "노드를 핸들로 변환할 수 없습니다" } , { ER_STARTPARSE_WHILE_PARSING , "startParse는 구문 분석 중에 호출될 수 없습니다" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse에는 널이 아닌 SAXParser가 필요합니다" } , { ER_COULD_NOT_INIT_PARSER , "다음으로 구문 분석기를 초기화할 수 없습니다: " } , { ER_EXCEPTION_CREATING_POOL , "풀에 대한 새 인스턴스 작성 중 예외가 발생했습니다" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "경로에 잘못된 제어 문자열이 포함되어 있습니다" } , { ER_SCHEME_REQUIRED , "체계가 필요합니다!" } , { ER_NO_SCHEME_IN_URI , "URI에  체계가 없습니다: {0}" } , { ER_NO_SCHEME_INURI , "URI에 체계가 없습니다" } , { ER_PATH_INVALID_CHAR , "경로에 잘못된 문자 {0}이(가) 포함되어 있습니다." } , { ER_SCHEME_FROM_NULL_STRING , "널 문자열에서 체계를 설정할 수 없습니다" } , { ER_SCHEME_NOT_CONFORMANT , "체계가 일치하지 않습니다." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "호스트 주소가 올바른 형식이 아닙니다" } , { ER_PORT_WHEN_HOST_NULL , "호스트가 널이면 포트를 설정할 수 없습니다" } , { ER_INVALID_PORT , "잘못된 포트 번호입니다" } , { ER_FRAG_FOR_GENERIC_URI , "단편은 일반 URI에 대해서만 설정될 수 있습니다" } , { ER_FRAG_WHEN_PATH_NULL , "경로가 널이면 단편을 설정할 수 없습니다" } , { ER_FRAG_INVALID_CHAR , "단편에 잘못된 문자가 포함되어 있습니다" } , { ER_PARSER_IN_USE , "구문 분석기가 이미 사용 중입니다" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "구문 분석 중에는 {0} {1}을(를) 변경할 수 없습니다" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "자체 원인 제공은 허용되지 않습니다" } , { ER_NO_USERINFO_IF_NO_HOST , "호스트가 지정되어 있지 않으면 Userinfo를 지정할 수 없습니다" } , { ER_NO_PORT_IF_NO_HOST , "호스트가 지정되어 있지 않으면 포트를 지정할 수 없습니다" } , { ER_NO_QUERY_STRING_IN_PATH , "질의 문자열을 경로 또는 질의 문자열 내에 지정할 수 없습니다" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "단편을 경로와 단편 모두에 지정할 수는 없습니다" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "빈 매개변수로는 URI를 초기화할 수 없습니다" } , { ER_METHOD_NOT_SUPPORTED , "지원되지 않는 메소드입니다 " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter를 다시 시작할 수 없습니다" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "startParse 요청 전에 XMLReader를 수행할 수 없습니다" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "축 트래버서가 지원되지 않음: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler가 널 PrintWriter로 작성됨!" } , { ER_SYSTEMID_UNKNOWN , "시스템 ID를 알 수 없음" } , { ER_LOCATION_UNKNOWN , "오류 위치를 알 수 없음" } , { ER_PREFIX_MUST_RESOLVE , "접두어가 이름 공간 {0}으로(로) 결정되어야 합니다." } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument()는 XPathContext에서 지원되지 않습니다!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "자식 속성에 소유자 문서가 없습니다!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "자식 속성에 소유자 문서 요소가 없습니다!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "경고: 문서 요소 전에 텍스트를 출력할 수 없습니다! 무시됩니다..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM에 두 개 이상의 루트를 가질 수 없습니다!" } , { ER_ARG_LOCALNAME_NULL , "'localName' 인자가 널입니다" } , { ER_ARG_LOCALNAME_INVALID , "QNAME의 로컬 이름은 유효한 NCName이어야 합니다." } , { ER_ARG_PREFIX_INVALID , "QNAME의 접두어는 유효한 NCName이어야 합니다." } , { "BAD_CODE" , "createMessage의 매개변수가 바운드를 벗어났습니다." } , { "FORMAT_FAILED" , "messageFormat 호출 시 예외 발생" } , { "line" , "행 #" } , { "column" , "열 #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0
package org . apache . xpath ; import javax . xml . transform . SourceLocator ; import org . apache . xml . utils . PrefixResolver ; public interface XPathFactory { XPath create ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) ; } 	1
package org . apache . xml . dtm . ref ; public final class ExtendedType { private int nodetype ; private String namespace ; private String localName ; private int hash ; public ExtendedType ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } public ExtendedType ( int nodetype , String namespace , String localName , int hash ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = hash ; } protected void redefine ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } protected void redefine ( int nodetype , String namespace , String localName , int hash ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = hash ; } public int hashCode ( ) { return hash ; } public boolean equals ( ExtendedType other ) { try { return other . nodetype == this . nodetype && other . localName . equals ( this . localName ) && other . namespace . equals ( this . namespace ) ; } catch ( NullPointerException e ) { return false ; } } public int getNodeType ( ) { return nodetype ; } public String getLocalName ( ) { return localName ; } public String getNamespace ( ) { return namespace ; } } 	0
package org . apache . xml . utils . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XResourceBundle extends ListResourceBundle { public static final String ERROR_RESOURCES = "org.apache.xalan.res.XSLTErrorResources" , XSLT_RESOURCE = "org.apache.xml.utils.res.XResourceBundle" , LANG_BUNDLE_NAME = "org.apache.xml.utils.res.XResources" , MULT_ORDER = "multiplierOrder" , MULT_PRECEDES = "precedes" , MULT_FOLLOWS = "follows" , LANG_ORIENTATION = "orientation" , LANG_RIGHTTOLEFT = "rightToLeft" , LANG_LEFTTORIGHT = "leftToRight" , LANG_NUMBERING = "numbering" , LANG_ADDITIVE = "additive" , LANG_MULT_ADD = "multiplicative-additive" , LANG_MULTIPLIER = "multiplier" , LANG_MULTIPLIER_CHAR = "multiplierChar" , LANG_NUMBERGROUPS = "numberGroups" , LANG_NUM_TABLES = "tables" , LANG_ALPHABET = "alphabet" , LANG_TRAD_ALPHABET = "tradAlphabet" ; public static final XResourceBundle loadResourceBundle ( String className , Locale locale ) throws MissingResourceException { String suffix = getResourceSuffix ( locale ) ; try { String resourceName = className + suffix ; return ( XResourceBundle ) ResourceBundle . getBundle ( resourceName , locale ) ; } catch ( MissingResourceException e ) { try { return ( XResourceBundle ) ResourceBundle . getBundle ( XSLT_RESOURCE , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String lang = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; String suffix = "_" + locale . getLanguage ( ) ; if ( lang . equals ( "zh" ) ) suffix += "_" + country ; if ( country . equals ( "JP" ) ) suffix += "_" + country + "_" + variant ; return suffix ; } public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class WithParam extends Instruction { private QName _name ; private Expression _select ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "with-param " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( name . length ( ) > 0 ) { _name = parser . getQName ( name ) ; } else { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; } final String select = getAttribute ( "select" ) ; if ( select . length ( ) > 0 ) { _select = parser . parseExpression ( this , "select" , null ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { final Type tselect = _select . typeCheck ( stable ) ; if ( tselect instanceof ReferenceType == false ) { _select = new CastExpr ( _select , Type . Reference ) ; } } else { typeCheckContents ( stable ) ; } return Type . Void ; } public void translateValue ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _select != null ) { _select . translate ( classGen , methodGen ) ; _select . startResetIterator ( classGen , methodGen ) ; } else if ( hasContents ( ) ) { compileResultTree ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; String name = Util . escape ( _name . getLocalPart ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; il . append ( POP ) ; } } 	1
package org . apache . xalan . lib ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . extensions . XSLProcessorContext ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xpath . XPathContext ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; public class PipeDocument { public void pipeDocument ( XSLProcessorContext context , ElemExtensionCall elem ) throws TransformerException , TransformerConfigurationException , SAXException , IOException , FileNotFoundException { try { SAXTransformerFactory saxTFactory = ( SAXTransformerFactory ) TransformerFactory . newInstance ( ) ; String source = elem . getAttribute ( "source" , context . getContextNode ( ) , context . getTransformer ( ) ) ; TransformerImpl transImpl = context . getTransformer ( ) ; String baseURLOfSource = transImpl . getBaseURLOfSource ( ) ; String absSourceURL = SystemIDResolver . getAbsoluteURI ( source , baseURLOfSource ) ; String target = elem . getAttribute ( "target" , context . getContextNode ( ) , context . getTransformer ( ) ) ; XPathContext xctxt = context . getTransformer ( ) . getXPathContext ( ) ; int xt = xctxt . getDTMHandleFromNode ( context . getContextNode ( ) ) ; String sysId = elem . getSystemId ( ) ; NodeList ssNodes = null ; NodeList paramNodes = null ; Node ssNode = null ; Node paramNode = null ; if ( elem . hasChildNodes ( ) ) { ssNodes = elem . getChildNodes ( ) ; Vector vTHandler = new Vector ( ssNodes . getLength ( ) ) ; for ( int i = 0 ; i < ssNodes . getLength ( ) ; i ++ ) { ssNode = ssNodes . item ( i ) ; if ( ssNode . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) ssNode ) . getTagName ( ) . equals ( "stylesheet" ) && ssNode instanceof ElemLiteralResult ) { AVT avt = ( ( ElemLiteralResult ) ssNode ) . getLiteralResultAttribute ( "href" ) ; String href = avt . evaluate ( xctxt , xt , elem ) ; String absURI = SystemIDResolver . getAbsoluteURI ( href , sysId ) ; Templates tmpl = saxTFactory . newTemplates ( new StreamSource ( absURI ) ) ; TransformerHandler tHandler = saxTFactory . newTransformerHandler ( tmpl ) ; Transformer trans = tHandler . getTransformer ( ) ; vTHandler . addElement ( tHandler ) ; paramNodes = ssNode . getChildNodes ( ) ; for ( int j = 0 ; j < paramNodes . getLength ( ) ; j ++ ) { paramNode = paramNodes . item ( j ) ; if ( paramNode . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) paramNode ) . getTagName ( ) . equals ( "param" ) && paramNode instanceof ElemLiteralResult ) { avt = ( ( ElemLiteralResult ) paramNode ) . getLiteralResultAttribute ( "name" ) ; String pName = avt . evaluate ( xctxt , xt , elem ) ; avt = ( ( ElemLiteralResult ) paramNode ) . getLiteralResultAttribute ( "value" ) ; String pValue = avt . evaluate ( xctxt , xt , elem ) ; trans . setParameter ( pName , pValue ) ; } } } } usePipe ( vTHandler , absSourceURL , target ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void usePipe ( Vector vTHandler , String source , String target ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , IOException , SAXException , SAXNotRecognizedException { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; TransformerHandler tHFirst = ( TransformerHandler ) vTHandler . firstElement ( ) ; reader . setContentHandler ( tHFirst ) ; reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , tHFirst ) ; for ( int i = 1 ; i < vTHandler . size ( ) ; i ++ ) { TransformerHandler tHFrom = ( TransformerHandler ) vTHandler . elementAt ( i - 1 ) ; TransformerHandler tHTo = ( TransformerHandler ) vTHandler . elementAt ( i ) ; tHFrom . setResult ( new SAXResult ( tHTo ) ) ; } TransformerHandler tHLast = ( TransformerHandler ) vTHandler . lastElement ( ) ; Transformer trans = tHLast . getTransformer ( ) ; Properties outputProps = trans . getOutputProperties ( ) ; Serializer serializer = SerializerFactory . getSerializer ( outputProps ) ; serializer . setOutputStream ( new FileOutputStream ( target ) ) ; tHLast . setResult ( new SAXResult ( serializer . asContentHandler ( ) ) ) ; reader . parse ( source ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ACONST_NULL ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DCONST ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Variable extends VariableBase { public int getIndex ( ) { return ( _local != null ) ? _local . getIndex ( ) : - 1 ; } public void parseContents ( Parser parser ) { super . parseContents ( parser ) ; SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof Stylesheet ) { _isLocal = false ; Variable var = parser . getSymbolTable ( ) . lookupVariable ( _name ) ; if ( var != null ) { final int us = this . getImportPrecedence ( ) ; final int them = var . getImportPrecedence ( ) ; if ( us == them ) { final String name = _name . toString ( ) ; reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } else if ( them > us ) { _ignore = true ; return ; } else { var . disable ( ) ; } } ( ( Stylesheet ) parent ) . addVariable ( this ) ; parser . getSymbolTable ( ) . addVariable ( this ) ; } else { _isLocal = true ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; } else if ( hasContents ( ) ) { typeCheckContents ( stable ) ; _type = Type . ResultTree ; } else { _type = Type . Reference ; } return Type . Void ; } public void initialize ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( isLocal ( ) && ! _refs . isEmpty ( ) ) { if ( _local == null ) { _local = methodGen . addLocalVariable2 ( _name . getLocalPart ( ) , _type . toJCType ( ) , il . getEnd ( ) ) ; } if ( ( _type instanceof IntType ) || ( _type instanceof NodeType ) || ( _type instanceof BooleanType ) ) il . append ( new ICONST ( 0 ) ) ; else if ( _type instanceof RealType ) il . append ( new DCONST ( 0 ) ) ; else il . append ( new ACONST_NULL ( ) ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String name = getVariable ( ) ; if ( _ignore ) return ; _ignore = true ; if ( isLocal ( ) ) { translateValue ( classGen , methodGen ) ; if ( _refs . isEmpty ( ) ) { il . append ( _type . POP ( ) ) ; _local = null ; } else { if ( _local == null ) mapRegister ( methodGen ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } else { String signature = _type . toSignature ( ) ; if ( classGen . containsField ( name ) == null ) { classGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( name ) , cpg . addUtf8 ( signature ) , null , cpg . getConstantPool ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( classGen . getClassName ( ) , name , signature ) ) ) ; } } } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DUP_X1 ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . DOM ; import org . xml . sax . Attributes ; public abstract class SyntaxTreeNode implements Constants { private Parser _parser ; protected SyntaxTreeNode _parent ; private Stylesheet _stylesheet ; private Template _template ; private final Vector _contents = new Vector ( 2 ) ; protected QName _qname ; private int _line ; protected Attributes _attributes = null ; private Hashtable _prefixMapping = null ; protected static final SyntaxTreeNode Dummy = new AbsolutePathPattern ( null ) ; protected static final int IndentIncrement = 4 ; private static final char [ ] _spaces = "                                                       " . toCharArray ( ) ; public SyntaxTreeNode ( ) { _line = 0 ; _qname = null ; } public SyntaxTreeNode ( int line ) { _line = line ; _qname = null ; } public SyntaxTreeNode ( String uri , String prefix , String local ) { _line = 0 ; setQName ( uri , prefix , local ) ; } protected final void setLineNumber ( int line ) { _line = line ; } public final int getLineNumber ( ) { return _line ; } protected void setQName ( QName qname ) { _qname = qname ; } protected void setQName ( String uri , String prefix , String localname ) { _qname = new QName ( uri , prefix , localname ) ; } protected QName getQName ( ) { return ( _qname ) ; } protected void setAttributes ( Attributes attributes ) { _attributes = attributes ; } protected String getAttribute ( String qname ) { if ( _attributes == null ) { return EMPTYSTRING ; } final String value = _attributes . getValue ( qname ) ; return ( value == null || value . equals ( EMPTYSTRING ) ) ? EMPTYSTRING : value ; } protected boolean hasAttribute ( String qname ) { return ( _attributes != null && _attributes . getValue ( qname ) != null ) ; } protected Attributes getAttributes ( ) { return ( _attributes ) ; } protected void setPrefixMapping ( Hashtable mapping ) { _prefixMapping = mapping ; } protected Hashtable getPrefixMapping ( ) { return _prefixMapping ; } protected void addPrefixMapping ( String prefix , String uri ) { if ( _prefixMapping == null ) _prefixMapping = new Hashtable ( ) ; _prefixMapping . put ( prefix , uri ) ; } protected String lookupNamespace ( String prefix ) { String uri = null ; if ( _prefixMapping != null ) uri = ( String ) _prefixMapping . get ( prefix ) ; if ( ( uri == null ) && ( _parent != null ) ) { uri = _parent . lookupNamespace ( prefix ) ; if ( ( prefix == Constants . EMPTYSTRING ) && ( uri == null ) ) uri = Constants . EMPTYSTRING ; } return ( uri ) ; } protected String lookupPrefix ( String uri ) { String prefix = null ; if ( ( _prefixMapping != null ) && ( _prefixMapping . contains ( uri ) ) ) { Enumeration prefixes = _prefixMapping . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { prefix = ( String ) prefixes . nextElement ( ) ; String mapsTo = ( String ) _prefixMapping . get ( prefix ) ; if ( mapsTo . equals ( uri ) ) return ( prefix ) ; } } else if ( _parent != null ) { prefix = _parent . lookupPrefix ( uri ) ; if ( ( uri == Constants . EMPTYSTRING ) && ( prefix == null ) ) prefix = Constants . EMPTYSTRING ; } return ( prefix ) ; } protected void setParser ( Parser parser ) { _parser = parser ; } public final Parser getParser ( ) { return _parser ; } protected void setParent ( SyntaxTreeNode parent ) { if ( _parent == null ) _parent = parent ; } protected final SyntaxTreeNode getParent ( ) { return _parent ; } protected final boolean isDummy ( ) { return this == Dummy ; } protected int getImportPrecedence ( ) { Stylesheet stylesheet = getStylesheet ( ) ; if ( stylesheet == null ) return Integer . MIN_VALUE ; return stylesheet . getImportPrecedence ( ) ; } public Stylesheet getStylesheet ( ) { if ( _stylesheet == null ) { SyntaxTreeNode parent = this ; while ( parent != null ) { if ( parent instanceof Stylesheet ) return ( ( Stylesheet ) parent ) ; parent = parent . getParent ( ) ; } _stylesheet = ( Stylesheet ) parent ; } return ( _stylesheet ) ; } protected Template getTemplate ( ) { if ( _template == null ) { SyntaxTreeNode parent = this ; while ( ( parent != null ) && ( ! ( parent instanceof Template ) ) ) parent = parent . getParent ( ) ; _template = ( Template ) parent ; } return ( _template ) ; } protected final XSLTC getXSLTC ( ) { return _parser . getXSLTC ( ) ; } protected final SymbolTable getSymbolTable ( ) { return ( _parser == null ) ? null : _parser . getSymbolTable ( ) ; } public void parseContents ( Parser parser ) { parseChildren ( parser ) ; } protected final void parseChildren ( Parser parser ) { Vector locals = null ; final int count = _contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; final QName varOrParamName = updateScope ( parser , child ) ; if ( varOrParamName != null ) { if ( locals == null ) { locals = new Vector ( 2 ) ; } locals . addElement ( varOrParamName ) ; } } parser . getSymbolTable ( ) . setCurrentNode ( this ) ; if ( locals != null ) { final int nLocals = locals . size ( ) ; for ( int i = 0 ; i < nLocals ; i ++ ) { parser . removeVariable ( ( QName ) locals . elementAt ( i ) ) ; } } } protected QName updateScope ( Parser parser , SyntaxTreeNode node ) { if ( node instanceof Variable ) { final Variable var = ( Variable ) node ; parser . addVariable ( var ) ; return var . getName ( ) ; } else if ( node instanceof Param ) { final Param param = ( Param ) node ; parser . addParameter ( param ) ; return param . getName ( ) ; } else { return null ; } } public abstract Type typeCheck ( SymbolTable stable ) throws TypeCheckError ; protected Type typeCheckContents ( SymbolTable stable ) throws TypeCheckError { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . typeCheck ( stable ) ; } return Type . Void ; } public abstract void translate ( ClassGenerator classGen , MethodGenerator methodGen ) ; protected void translateContents ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . translate ( classGen , methodGen ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( _contents . elementAt ( i ) instanceof VariableBase ) { final VariableBase var = ( VariableBase ) _contents . elementAt ( i ) ; var . unmapRegister ( methodGen ) ; } } } private boolean isSimpleRTF ( SyntaxTreeNode node ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! isTextElement ( item , false ) ) return false ; } return true ; } private boolean isAdaptiveRTF ( SyntaxTreeNode node ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! isTextElement ( item , true ) ) return false ; } return true ; } private boolean isTextElement ( SyntaxTreeNode node , boolean doExtendedCheck ) { if ( node instanceof ValueOf || node instanceof Number || node instanceof Text ) { return true ; } else if ( node instanceof If ) { return doExtendedCheck ? isAdaptiveRTF ( node ) : isSimpleRTF ( node ) ; } else if ( node instanceof Choose ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( item instanceof Text || ( ( item instanceof When || item instanceof Otherwise ) && ( ( doExtendedCheck && isAdaptiveRTF ( item ) ) || ( ! doExtendedCheck && isSimpleRTF ( item ) ) ) ) ) continue ; else return false ; } return true ; } else if ( doExtendedCheck && ( node instanceof CallTemplate || node instanceof ApplyTemplates ) ) return true ; else return false ; } protected void compileResultTree ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final Stylesheet stylesheet = classGen . getStylesheet ( ) ; boolean isSimple = isSimpleRTF ( this ) ; boolean isAdaptive = false ; if ( ! isSimple ) { isAdaptive = isAdaptiveRTF ( this ) ; } int rtfType = isSimple ? DOM . SIMPLE_RTF : ( isAdaptive ? DOM . ADAPTIVE_RTF : DOM . TREE_RTF ) ; il . append ( methodGen . loadHandler ( ) ) ; final String DOM_CLASS = classGen . getDOMClass ( ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , "getResultTreeFrag" , "(II)" + DOM_INTF_SIG ) ; il . append ( new PUSH ( cpg , RTF_INITIAL_SIZE ) ) ; il . append ( new PUSH ( cpg , rtfType ) ) ; il . append ( new INVOKEINTERFACE ( index , 3 ) ) ; il . append ( DUP ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , "getOutputDomBuilder" , "()" + TRANSLET_OUTPUT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; il . append ( methodGen . startDocument ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . endDocument ( ) ) ; if ( ( ! isSimple || stylesheet . callsNodeset ( ) ) && ! DOM_CLASS . equals ( DOM_IMPL_CLASS ) ) { index = cpg . addMethodref ( DOM_ADAPTER_CLASS , "<init>" , "(" + DOM_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DOM_ADAPTER_CLASS ) ) ) ; il . append ( new DUP_X1 ( ) ) ; il . append ( SWAP ) ; if ( ! stylesheet . callsNodeset ( ) ) { il . append ( new ICONST ( 0 ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( index ) ) ; } else { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( classGen . getDOMClass ( ) ) ) ) ; il . append ( SWAP ) ; index = cpg . addMethodref ( MULTI_DOM_CLASS , "addDOMAdapter" , "(" + DOM_ADAPTER_SIG + ")I" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( POP ) ; } } il . append ( SWAP ) ; il . append ( methodGen . storeHandler ( ) ) ; } protected boolean contextDependent ( ) { return true ; } protected boolean dependentContents ( ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; if ( item . contextDependent ( ) ) { return true ; } } return false ; } protected final void addElement ( SyntaxTreeNode element ) { _contents . addElement ( element ) ; element . setParent ( this ) ; } protected final void setFirstElement ( SyntaxTreeNode element ) { _contents . insertElementAt ( element , 0 ) ; element . setParent ( this ) ; } protected final void removeElement ( SyntaxTreeNode element ) { _contents . remove ( element ) ; element . setParent ( null ) ; } protected final Vector getContents ( ) { return _contents ; } protected final boolean hasContents ( ) { return elementCount ( ) > 0 ; } protected final int elementCount ( ) { return _contents . size ( ) ; } protected final Enumeration elements ( ) { return _contents . elements ( ) ; } protected final Object elementAt ( int pos ) { return _contents . elementAt ( pos ) ; } protected final SyntaxTreeNode lastChild ( ) { if ( _contents . size ( ) == 0 ) return null ; return ( SyntaxTreeNode ) _contents . lastElement ( ) ; } public void display ( int indent ) { displayContents ( indent ) ; } protected void displayContents ( int indent ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . display ( indent ) ; } } protected final void indent ( int indent ) { System . out . print ( new String ( _spaces , 0 , indent ) ) ; } protected void reportError ( SyntaxTreeNode element , Parser parser , String errorCode , String message ) { final ErrorMsg error = new ErrorMsg ( errorCode , message , element ) ; parser . reportError ( Constants . ERROR , error ) ; } protected void reportWarning ( SyntaxTreeNode element , Parser parser , String errorCode , String message ) { final ErrorMsg error = new ErrorMsg ( errorCode , message , element ) ; parser . reportError ( Constants . WARNING , error ) ; } } 	0
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DLOAD ; import org . apache . bcel . generic . DSTORE ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class RealType extends NumberType { protected RealType ( ) { } public String toString ( ) { return "real" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "D" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . DOUBLE ; } public int distanceTo ( Type type ) { if ( type == this ) { return 0 ; } else if ( type == Type . Int ) { return 1 ; } else { return Integer . MAX_VALUE ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Int ) { translateTo ( classGen , methodGen , ( IntType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "realToString" , "(D)" + STRING_SIG ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , IntType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "realToInt" , "(D)I" ) ) ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { LocalVariableGen local ; final FlowList flowlist = new FlowList ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP2 ) ; local = methodGen . addLocalVariable ( "real_to_boolean_tmp" , org . apache . bcel . generic . Type . DOUBLE , il . getEnd ( ) , null ) ; il . append ( new DSTORE ( local . getIndex ( ) ) ) ; il . append ( DCONST_0 ) ; il . append ( DCMPG ) ; flowlist . add ( il . append ( new IFEQ ( null ) ) ) ; il . append ( new DLOAD ( local . getIndex ( ) ) ) ; il . append ( new DLOAD ( local . getIndex ( ) ) ) ; il . append ( DCMPG ) ; flowlist . add ( il . append ( new IFNE ( null ) ) ) ; return flowlist ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( DUP_X2 ) ; il . append ( DUP_X2 ) ; il . append ( POP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( DOUBLE_CLASS , "<init>" , "(D)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , final Class clazz ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE ) { il . append ( D2I ) ; il . append ( I2C ) ; } else if ( clazz == Byte . TYPE ) { il . append ( D2I ) ; il . append ( I2B ) ; } else if ( clazz == Short . TYPE ) { il . append ( D2I ) ; il . append ( I2S ) ; } else if ( clazz == Integer . TYPE ) { il . append ( D2I ) ; } else if ( clazz == Long . TYPE ) { il . append ( D2L ) ; } else if ( clazz == Float . TYPE ) { il . append ( D2F ) ; } else if ( clazz == Double . TYPE ) { il . append ( NOP ) ; } else if ( clazz . isAssignableFrom ( java . lang . Double . class ) ) { translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE || clazz == Byte . TYPE || clazz == Short . TYPE || clazz == Integer . TYPE ) { il . append ( I2D ) ; } else if ( clazz == Long . TYPE ) { il . append ( L2D ) ; } else if ( clazz == Float . TYPE ) { il . append ( F2D ) ; } else if ( clazz == Double . TYPE ) { il . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( DOUBLE_CLASS , DOUBLE_VALUE , DOUBLE_VALUE_SIG ) ) ) ; } public Instruction ADD ( ) { return InstructionConstants . DADD ; } public Instruction SUB ( ) { return InstructionConstants . DSUB ; } public Instruction MUL ( ) { return InstructionConstants . DMUL ; } public Instruction DIV ( ) { return InstructionConstants . DDIV ; } public Instruction REM ( ) { return InstructionConstants . DREM ; } public Instruction NEG ( ) { return InstructionConstants . DNEG ; } public Instruction LOAD ( int slot ) { return new DLOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new DSTORE ( slot ) ; } public Instruction POP ( ) { return POP2 ; } public Instruction CMP ( boolean less ) { return less ? InstructionConstants . DCMPG : InstructionConstants . DCMPL ; } public Instruction DUP ( ) { return DUP2 ; } } 	0
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Or extends Operation { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject expr1 = m_left . execute ( xctxt ) ; if ( ! expr1 . bool ( ) ) { XObject expr2 = m_right . execute ( xctxt ) ; return expr2 . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } else return XBoolean . S_TRUE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . bool ( xctxt ) || m_right . bool ( xctxt ) ) ; } } 	0
package org . apache . xalan . xsltc ; import org . xml . sax . SAXException ; public final class TransletException extends SAXException { public TransletException ( ) { super ( "Translet error" ) ; } public TransletException ( Exception e ) { super ( e . toString ( ) ) ; } public TransletException ( String message ) { super ( message ) ; } } 	0
package org . apache . xalan . xsltc . runtime ; import java . util . Enumeration ; class HashtableEntry { int hash ; Object key ; Object value ; HashtableEntry next ; protected Object clone ( ) { HashtableEntry entry = new HashtableEntry ( ) ; entry . hash = hash ; entry . key = key ; entry . value = value ; entry . next = ( next != null ) ? ( HashtableEntry ) next . clone ( ) : null ; return entry ; } } public class Hashtable { private transient HashtableEntry table [ ] ; private transient int count ; private int threshold ; private float loadFactor ; public Hashtable ( int initialCapacity , float loadFactor ) { if ( initialCapacity <= 0 ) initialCapacity = 11 ; if ( loadFactor <= 0.0 ) loadFactor = 0.75f ; this . loadFactor = loadFactor ; table = new HashtableEntry [ initialCapacity ] ; threshold = ( int ) ( initialCapacity * loadFactor ) ; } public Hashtable ( int initialCapacity ) { this ( initialCapacity , 0.75f ) ; } public Hashtable ( ) { this ( 101 , 0.75f ) ; } public int size ( ) { return count ; } public boolean isEmpty ( ) { return count == 0 ; } public Enumeration keys ( ) { return new HashtableEnumerator ( table , true ) ; } public Enumeration elements ( ) { return new HashtableEnumerator ( table , false ) ; } public boolean contains ( Object value ) { if ( value == null ) throw new NullPointerException ( ) ; int i ; HashtableEntry e ; HashtableEntry tab [ ] = table ; for ( i = tab . length ; i -- > 0 ; ) { for ( e = tab [ i ] ; e != null ; e = e . next ) { if ( e . value . equals ( value ) ) { return true ; } } } return false ; } public boolean containsKey ( Object key ) { HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) if ( ( e . hash == hash ) && e . key . equals ( key ) ) return true ; return false ; } public Object get ( Object key ) { HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) if ( ( e . hash == hash ) && e . key . equals ( key ) ) return e . value ; return null ; } protected void rehash ( ) { HashtableEntry e , old ; int i , index ; int oldCapacity = table . length ; HashtableEntry oldTable [ ] = table ; int newCapacity = oldCapacity * 2 + 1 ; HashtableEntry newTable [ ] = new HashtableEntry [ newCapacity ] ; threshold = ( int ) ( newCapacity * loadFactor ) ; table = newTable ; for ( i = oldCapacity ; i -- > 0 ; ) { for ( old = oldTable [ i ] ; old != null ; ) { e = old ; old = old . next ; index = ( e . hash & 0x7FFFFFFF ) % newCapacity ; e . next = newTable [ index ] ; newTable [ index ] = e ; } } } public Object put ( Object key , Object value ) { if ( value == null ) throw new NullPointerException ( ) ; HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) { if ( ( e . hash == hash ) && e . key . equals ( key ) ) { Object old = e . value ; e . value = value ; return old ; } } if ( count >= threshold ) { rehash ( ) ; return put ( key , value ) ; } e = new HashtableEntry ( ) ; e . hash = hash ; e . key = key ; e . value = value ; e . next = tab [ index ] ; tab [ index ] = e ; count ++ ; return null ; } public Object remove ( Object key ) { HashtableEntry e , prev ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( ( e . hash == hash ) && e . key . equals ( key ) ) { if ( prev != null ) prev . next = e . next ; else tab [ index ] = e . next ; count -- ; return e . value ; } } return null ; } public void clear ( ) { HashtableEntry tab [ ] = table ; for ( int index = tab . length ; -- index >= 0 ; ) tab [ index ] = null ; count = 0 ; } public String toString ( ) { int i ; int max = size ( ) - 1 ; StringBuffer buf = new StringBuffer ( ) ; Enumeration k = keys ( ) ; Enumeration e = elements ( ) ; buf . append ( "{" ) ; for ( i = 0 ; i <= max ; i ++ ) { String s1 = k . nextElement ( ) . toString ( ) ; String s2 = e . nextElement ( ) . toString ( ) ; buf . append ( s1 + "=" + s2 ) ; if ( i < max ) buf . append ( ", " ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } class HashtableEnumerator implements Enumeration { boolean keys ; int index ; HashtableEntry table [ ] ; HashtableEntry entry ; HashtableEnumerator ( HashtableEntry table [ ] , boolean keys ) { this . table = table ; this . keys = keys ; this . index = table . length ; } public boolean hasMoreElements ( ) { if ( entry != null ) { return true ; } while ( index -- > 0 ) { if ( ( entry = table [ index ] ) != null ) { return true ; } } return false ; } public Object nextElement ( ) { if ( entry == null ) { while ( ( index -- > 0 ) && ( ( entry = table [ index ] ) == null ) ) ; } if ( entry != null ) { HashtableEntry e = entry ; entry = e . next ; return keys ? e . key : e . value ; } return null ; } } } 	0
package org . apache . xml . utils ; import java . io . IOException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; public class DOM2Helper extends DOMHelper { public DOM2Helper ( ) { } public void checkNode ( Node node ) throws TransformerException { } public boolean supportsSAX ( ) { return true ; } private Document m_doc ; public void setDocument ( Document doc ) { m_doc = doc ; } public Document getDocument ( ) { return m_doc ; } public void parse ( InputSource source ) throws TransformerException { try { DocumentBuilderFactory builderFactory = DocumentBuilderFactory . newInstance ( ) ; builderFactory . setNamespaceAware ( true ) ; builderFactory . setValidating ( true ) ; DocumentBuilder parser = builderFactory . newDocumentBuilder ( ) ; parser . setErrorHandler ( new org . apache . xml . utils . DefaultErrorHandler ( ) ) ; setDocument ( parser . parse ( source ) ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } catch ( ParserConfigurationException pce ) { throw new TransformerException ( pce ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } public Element getElementByID ( String id , Document doc ) { return doc . getElementById ( id ) ; } public static boolean isNodeAfter ( Node node1 , Node node2 ) { if ( node1 instanceof DOMOrder && node2 instanceof DOMOrder ) { int index1 = ( ( DOMOrder ) node1 ) . getUid ( ) ; int index2 = ( ( DOMOrder ) node2 ) . getUid ( ) ; return index1 <= index2 ; } else { return DOMHelper . isNodeAfter ( node1 , node2 ) ; } } public static Node getParentOfNode ( Node node ) { Node parent = node . getParentNode ( ) ; if ( parent == null && ( Node . ATTRIBUTE_NODE == node . getNodeType ( ) ) ) parent = ( ( Attr ) node ) . getOwnerElement ( ) ; return parent ; } public String getLocalNameOfNode ( Node n ) { String name = n . getLocalName ( ) ; return ( null == name ) ? super . getLocalNameOfNode ( n ) : name ; } public String getNamespaceOfNode ( Node n ) { return n . getNamespaceURI ( ) ; } } 	1
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . xml . sax . Attributes ; class ProcessorKey extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { KeyDeclaration kd = new KeyDeclaration ( handler . getStylesheet ( ) , handler . nextUid ( ) ) ; kd . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; kd . setLocaterInfo ( handler . getLocator ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , kd ) ; handler . getStylesheet ( ) . setKey ( kd ) ; } void setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , org . apache . xalan . templates . ElemTemplateElement target ) throws org . xml . sax . SAXException { XSLTElementDef def = getElemDef ( ) ; Vector processedDefs = new Vector ( ) ; int nAttrs = attributes . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrLocalName = attributes . getLocalName ( i ) ; XSLTAttributeDef attrDef = def . getAttributeDef ( attrUri , attrLocalName ) ; if ( null == attrDef ) { handler . error ( attributes . getQName ( i ) + "attribute is not allowed on the " + rawName + " element!" , null ) ; } else { String valueString = attributes . getValue ( i ) ; if ( valueString . indexOf ( org . apache . xpath . compiler . Keywords . FUNC_KEY_STRING + "(" ) >= 0 ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_KEY_CALL , null ) , null ) ; processedDefs . addElement ( attrDef ) ; attrDef . setAttrValue ( handler , attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getValue ( i ) , target ) ; } } XSLTAttributeDef [ ] attrDefs = def . getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int i = 0 ; i < nAttrDefs ; i ++ ) { XSLTAttributeDef attrDef = attrDefs [ i ] ; String defVal = attrDef . getDefault ( ) ; if ( null != defVal ) { if ( ! processedDefs . contains ( attrDef ) ) { attrDef . setDefAttrValue ( handler , target ) ; } } if ( attrDef . getRequired ( ) ) { if ( ! processedDefs . contains ( attrDef ) ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_REQUIRES_ATTRIB , new Object [ ] { rawName , attrDef . getName ( ) } ) , null ) ; } } } } 	0
package org . apache . xml . res ; public class XMLErrorResources_en extends XMLErrorResources { } 	1
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . res . XPATHErrorResources ; public class XRTreeFragSelectWrapper extends XRTreeFrag implements Cloneable { XObject m_selected ; public XRTreeFragSelectWrapper ( Expression expr ) { super ( expr ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { ( ( Expression ) m_obj ) . fixupVariables ( vars , globalsSize ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { m_selected = ( ( Expression ) m_obj ) . execute ( xctxt ) ; m_selected . allowDetachToRelease ( m_allowRelease ) ; if ( m_selected . getType ( ) == CLASS_STRING ) return m_selected ; else return new XString ( m_selected . str ( ) ) ; } public void detach ( ) { if ( m_allowRelease ) { m_selected . detach ( ) ; m_selected = null ; } super . detach ( ) ; } public double num ( ) throws javax . xml . transform . TransformerException { return m_selected . num ( ) ; } public XMLString xstr ( ) { return m_selected . xstr ( ) ; } public String str ( ) { return m_selected . str ( ) ; } public int getType ( ) { return CLASS_STRING ; } public int rtf ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } public DTMIterator asNodeIterator ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } } 	0
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class KeyRefIterator extends org . apache . xpath . axes . ChildTestIterator { public KeyRefIterator ( QName name , XMLString ref , Vector keyDecls , DTMIterator ki ) { super ( null ) ; m_name = name ; m_ref = ref ; m_keyDeclarations = keyDecls ; m_keysNodes = ki ; setWhatToShow ( org . apache . xml . dtm . DTMFilter . SHOW_ALL ) ; } DTMIterator m_keysNodes ; protected int getNextNode ( ) { int next ; while ( DTM . NULL != ( next = m_keysNodes . nextNode ( ) ) ) { if ( DTMIterator . FILTER_ACCEPT == filterNode ( next ) ) break ; } m_lastFetched = next ; return next ; } public short filterNode ( int testNode ) { boolean foundKey = false ; Vector keys = m_keyDeclarations ; QName name = m_name ; KeyIterator ki = ( KeyIterator ) ( ( ( XNodeSet ) m_keysNodes ) . getContainedIter ( ) ) ; org . apache . xpath . XPathContext xctxt = ki . getXPathContext ( ) ; if ( null == xctxt ) assertion ( false , "xctxt can not be null here!" ) ; try { XMLString lookupKey = m_ref ; int nDeclarations = keys . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) keys . elementAt ( i ) ; if ( ! kd . getName ( ) . equals ( name ) ) continue ; foundKey = true ; XObject xuse = kd . getUse ( ) . execute ( xctxt , testNode , ki . getPrefixResolver ( ) ) ; if ( xuse . getType ( ) != xuse . CLASS_NODESET ) { XMLString exprResult = xuse . xstr ( ) ; if ( lookupKey . equals ( exprResult ) ) return DTMIterator . FILTER_ACCEPT ; } else { DTMIterator nl = ( ( XNodeSet ) xuse ) . iterRaw ( ) ; int useNode ; while ( DTM . NULL != ( useNode = nl . nextNode ( ) ) ) { DTM dtm = getDTM ( useNode ) ; XMLString exprResult = dtm . getStringValue ( useNode ) ; if ( ( null != exprResult ) && lookupKey . equals ( exprResult ) ) return DTMIterator . FILTER_ACCEPT ; } } } } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } if ( ! foundKey ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_XSLKEY_DECLARATION , new Object [ ] { name . getLocalName ( ) } ) ) ; return DTMIterator . FILTER_REJECT ; } protected XMLString m_ref ; protected QName m_name ; protected Vector m_keyDeclarations ; } 	1
package org . apache . xpath . compiler ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . Expression ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . Function ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XString ; import org . apache . xpath . operations . And ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Equals ; import org . apache . xpath . operations . Gt ; import org . apache . xpath . operations . Gte ; import org . apache . xpath . operations . Lt ; import org . apache . xpath . operations . Lte ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Neg ; import org . apache . xpath . operations . NotEquals ; import org . apache . xpath . operations . Operation ; import org . apache . xpath . operations . Or ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . UnaryOperation ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . patterns . FunctionPattern ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; import org . apache . xpath . res . XPATHErrorResources ; public class Compiler extends OpMap { public Compiler ( ErrorListener errorHandler , SourceLocator locator ) { m_errorHandler = errorHandler ; m_locator = locator ; } public Compiler ( ) { m_errorHandler = null ; m_locator = null ; } public Expression compile ( int opPos ) throws TransformerException { int op = getOp ( opPos ) ; Expression expr = null ; switch ( op ) { case OpCodes . OP_XPATH : expr = compile ( opPos + 2 ) ; break ; case OpCodes . OP_OR : expr = or ( opPos ) ; break ; case OpCodes . OP_AND : expr = and ( opPos ) ; break ; case OpCodes . OP_NOTEQUALS : expr = notequals ( opPos ) ; break ; case OpCodes . OP_EQUALS : expr = equals ( opPos ) ; break ; case OpCodes . OP_LTE : expr = lte ( opPos ) ; break ; case OpCodes . OP_LT : expr = lt ( opPos ) ; break ; case OpCodes . OP_GTE : expr = gte ( opPos ) ; break ; case OpCodes . OP_GT : expr = gt ( opPos ) ; break ; case OpCodes . OP_PLUS : expr = plus ( opPos ) ; break ; case OpCodes . OP_MINUS : expr = minus ( opPos ) ; break ; case OpCodes . OP_MULT : expr = mult ( opPos ) ; break ; case OpCodes . OP_DIV : expr = div ( opPos ) ; break ; case OpCodes . OP_MOD : expr = mod ( opPos ) ; break ; case OpCodes . OP_NEG : expr = neg ( opPos ) ; break ; case OpCodes . OP_STRING : expr = string ( opPos ) ; break ; case OpCodes . OP_BOOL : expr = bool ( opPos ) ; break ; case OpCodes . OP_NUMBER : expr = number ( opPos ) ; break ; case OpCodes . OP_UNION : expr = union ( opPos ) ; break ; case OpCodes . OP_LITERAL : expr = literal ( opPos ) ; break ; case OpCodes . OP_VARIABLE : expr = variable ( opPos ) ; break ; case OpCodes . OP_GROUP : expr = group ( opPos ) ; break ; case OpCodes . OP_NUMBERLIT : expr = numberlit ( opPos ) ; break ; case OpCodes . OP_ARGUMENT : expr = arg ( opPos ) ; break ; case OpCodes . OP_EXTFUNCTION : expr = compileExtension ( opPos ) ; break ; case OpCodes . OP_FUNCTION : expr = compileFunction ( opPos ) ; break ; case OpCodes . OP_LOCATIONPATH : expr = locationPath ( opPos ) ; break ; case OpCodes . OP_PREDICATE : expr = null ; break ; case OpCodes . OP_MATCHPATTERN : expr = matchPattern ( opPos + 2 ) ; break ; case OpCodes . OP_LOCATIONPATHPATTERN : expr = locationPathPattern ( opPos ) ; break ; case OpCodes . OP_QUO : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { "quo" } ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { Integer . toString ( getOp ( opPos ) ) } ) ; } return expr ; } private Expression compileOperation ( Operation operation , int opPos ) throws TransformerException { int leftPos = getFirstChildPos ( opPos ) ; int rightPos = getNextOpPos ( leftPos ) ; operation . setLeftRight ( compile ( leftPos ) , compile ( rightPos ) ) ; return operation ; } private Expression compileUnary ( UnaryOperation unary , int opPos ) throws TransformerException { int rightPos = getFirstChildPos ( opPos ) ; unary . setRight ( compile ( rightPos ) ) ; return unary ; } protected Expression or ( int opPos ) throws TransformerException { return compileOperation ( new Or ( ) , opPos ) ; } protected Expression and ( int opPos ) throws TransformerException { return compileOperation ( new And ( ) , opPos ) ; } protected Expression notequals ( int opPos ) throws TransformerException { return compileOperation ( new NotEquals ( ) , opPos ) ; } protected Expression equals ( int opPos ) throws TransformerException { return compileOperation ( new Equals ( ) , opPos ) ; } protected Expression lte ( int opPos ) throws TransformerException { return compileOperation ( new Lte ( ) , opPos ) ; } protected Expression lt ( int opPos ) throws TransformerException { return compileOperation ( new Lt ( ) , opPos ) ; } protected Expression gte ( int opPos ) throws TransformerException { return compileOperation ( new Gte ( ) , opPos ) ; } protected Expression gt ( int opPos ) throws TransformerException { return compileOperation ( new Gt ( ) , opPos ) ; } protected Expression plus ( int opPos ) throws TransformerException { return compileOperation ( new Plus ( ) , opPos ) ; } protected Expression minus ( int opPos ) throws TransformerException { return compileOperation ( new Minus ( ) , opPos ) ; } protected Expression mult ( int opPos ) throws TransformerException { return compileOperation ( new Mult ( ) , opPos ) ; } protected Expression div ( int opPos ) throws TransformerException { return compileOperation ( new Div ( ) , opPos ) ; } protected Expression mod ( int opPos ) throws TransformerException { return compileOperation ( new Mod ( ) , opPos ) ; } protected Expression neg ( int opPos ) throws TransformerException { return compileUnary ( new Neg ( ) , opPos ) ; } protected Expression string ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . String ( ) , opPos ) ; } protected Expression bool ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Bool ( ) , opPos ) ; } protected Expression number ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Number ( ) , opPos ) ; } protected Expression literal ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XString ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; } protected Expression numberlit ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XNumber ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; } protected Expression variable ( int opPos ) throws TransformerException { Variable var = new Variable ( ) ; opPos = getFirstChildPos ( opPos ) ; int nsPos = getOp ( opPos ) ; java . lang . String namespace = ( OpCodes . EMPTY == nsPos ) ? null : ( java . lang . String ) getTokenQueue ( ) . elementAt ( nsPos ) ; java . lang . String localname = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos + 1 ) ) ; QName qname = new QName ( namespace , localname ) ; var . setQName ( qname ) ; return var ; } protected Expression group ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression arg ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression union ( int opPos ) throws TransformerException { locPathDepth ++ ; try { return UnionPathIterator . createUnionIterator ( this , opPos ) ; } finally { locPathDepth -- ; } } private int locPathDepth = - 1 ; public int getLocationPathDepth ( ) { return locPathDepth ; } public Expression locationPath ( int opPos ) throws TransformerException { locPathDepth ++ ; try { DTMIterator iter = WalkerFactory . newDTMIterator ( this , opPos , ( locPathDepth == 0 ) ) ; return ( Expression ) iter ; } finally { locPathDepth -- ; } } public Expression predicate ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression matchPattern ( int opPos ) throws TransformerException { locPathDepth ++ ; try { int nextOpPos = opPos ; int i ; for ( i = 0 ; getOp ( nextOpPos ) == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( nextOpPos ) ; } if ( i == 1 ) return compile ( opPos ) ; UnionPattern up = new UnionPattern ( ) ; StepPattern [ ] patterns = new StepPattern [ i ] ; for ( i = 0 ; getOp ( opPos ) == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( opPos ) ; patterns [ i ] = ( StepPattern ) compile ( opPos ) ; opPos = nextOpPos ; } up . setPatterns ( patterns ) ; return up ; } finally { locPathDepth -- ; } } public Expression locationPathPattern ( int opPos ) throws TransformerException { opPos = getFirstChildPos ( opPos ) ; return stepPattern ( opPos , 0 , null ) ; } public int getWhatToShow ( int opPos ) { int axesType = getOp ( opPos ) ; int testType = getOp ( opPos + 3 ) ; switch ( testType ) { case OpCodes . NODETYPE_COMMENT : return DTMFilter . SHOW_COMMENT ; case OpCodes . NODETYPE_TEXT : return DTMFilter . SHOW_TEXT | DTMFilter . SHOW_CDATA_SECTION ; case OpCodes . NODETYPE_PI : return DTMFilter . SHOW_PROCESSING_INSTRUCTION ; case OpCodes . NODETYPE_NODE : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . FROM_SELF : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_DESCENDANTS_OR_SELF : return DTMFilter . SHOW_ALL ; default : if ( getOp ( 0 ) == OpCodes . OP_MATCHPATTERN ) return ~ DTMFilter . SHOW_ATTRIBUTE & ~ DTMFilter . SHOW_DOCUMENT & ~ DTMFilter . SHOW_DOCUMENT_FRAGMENT ; else return ~ DTMFilter . SHOW_ATTRIBUTE ; } case OpCodes . NODETYPE_ROOT : return DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ; case OpCodes . NODETYPE_FUNCTEST : return NodeTest . SHOW_BYFUNCTION ; case OpCodes . NODENAME : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return DTMFilter . SHOW_ELEMENT ; default : return DTMFilter . SHOW_ELEMENT ; } default : return DTMFilter . SHOW_ALL ; } } private static final boolean DEBUG = false ; protected StepPattern stepPattern ( int opPos , int stepCount , StepPattern ancestorPattern ) throws TransformerException { int startOpPos = opPos ; int stepType = getOp ( opPos ) ; if ( OpCodes . ENDOP == stepType ) { return null ; } boolean addMagicSelf = true ; int endStep = getNextOpPos ( opPos ) ; StepPattern pattern ; int argLen ; switch ( stepType ) { case OpCodes . OP_FUNCTION : if ( DEBUG ) System . out . println ( "MATCH_FUNCTION: " + m_currentPattern ) ; addMagicSelf = false ; argLen = getOp ( opPos + OpMap . MAPINDEX_LENGTH ) ; pattern = new FunctionPattern ( compileFunction ( opPos ) , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . FROM_ROOT : if ( DEBUG ) System . out . println ( "FROM_ROOT, " + m_currentPattern ) ; addMagicSelf = false ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . MATCH_ATTRIBUTE : if ( DEBUG ) System . out . println ( "MATCH_ATTRIBUTE: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_ATTRIBUTE , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_ANY_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; int what = getWhatToShow ( startOpPos ) ; if ( 0x00000500 == what ) addMagicSelf = false ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . ANCESTOR , Axis . CHILD ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_IMMEDIATE_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . CHILD ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_MATCH_OPERATION , null ) ; return null ; } pattern . setPredicates ( getCompiledPredicates ( opPos + argLen ) ) ; if ( null == ancestorPattern ) { } else { pattern . setRelativePathPattern ( ancestorPattern ) ; } StepPattern relativePathPattern = stepPattern ( endStep , stepCount + 1 , pattern ) ; return ( null != relativePathPattern ) ? relativePathPattern : pattern ; } public Expression [ ] getCompiledPredicates ( int opPos ) throws TransformerException { int count = countPredicates ( opPos ) ; if ( count > 0 ) { Expression [ ] predicates = new Expression [ count ] ; compilePredicates ( opPos , predicates ) ; return predicates ; } return null ; } public int countPredicates ( int opPos ) throws TransformerException { int count = 0 ; while ( OpCodes . OP_PREDICATE == getOp ( opPos ) ) { count ++ ; opPos = getNextOpPos ( opPos ) ; } return count ; } private void compilePredicates ( int opPos , Expression [ ] predicates ) throws TransformerException { for ( int i = 0 ; OpCodes . OP_PREDICATE == getOp ( opPos ) ; i ++ ) { predicates [ i ] = predicate ( opPos ) ; opPos = getNextOpPos ( opPos ) ; } } Expression compileFunction ( int opPos ) throws TransformerException { int endFunc = opPos + getOp ( opPos + 1 ) - 1 ; opPos = getFirstChildPos ( opPos ) ; int funcID = getOp ( opPos ) ; opPos ++ ; if ( - 1 != funcID ) { Function func = FunctionTable . getFunction ( funcID ) ; func . postCompileStep ( this ) ; try { int i = 0 ; for ( int p = opPos ; p < endFunc ; p = getNextOpPos ( p ) , i ++ ) { func . setArg ( compile ( p ) , i ) ; } func . checkNumberArgs ( i ) ; } catch ( WrongNumberArgsException wnae ) { java . lang . String name = FunctionTable . m_functions [ funcID ] . getName ( ) ; m_errorHandler . fatalError ( new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ONLY_ALLOWS , new Object [ ] { name , wnae . getMessage ( ) } ) , m_locator ) ) ; } return func ; } else { error ( XPATHErrorResources . ER_FUNCTION_TOKEN_NOT_FOUND , null ) ; return null ; } } private Expression compileExtension ( int opPos ) throws TransformerException { int endExtFunc = opPos + getOp ( opPos + 1 ) - 1 ; opPos = getFirstChildPos ( opPos ) ; java . lang . String ns = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; opPos ++ ; java . lang . String funcName = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; opPos ++ ; Function extension = new FuncExtFunction ( ns , funcName , String . valueOf ( opPos ) + String . valueOf ( hashCode ( ) ) + String . valueOf ( System . currentTimeMillis ( ) ) ) ; try { int i = 0 ; while ( opPos < endExtFunc ) { int nextOpPos = getNextOpPos ( opPos ) ; extension . setArg ( this . compile ( opPos ) , i ) ; opPos = nextOpPos ; i ++ ; } } catch ( WrongNumberArgsException wnae ) { ; } return extension ; } public void warn ( String msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . warning ( new TransformerException ( fmsg , m_locator ) ) ; } else { System . out . println ( fmsg + "; file " + m_locator . getSystemId ( ) + "; line " + m_locator . getLineNumber ( ) + "; column " + m_locator . getColumnNumber ( ) ) ; } } public void assertion ( boolean b , java . lang . String msg ) { if ( ! b ) { java . lang . String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( String msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . fatalError ( new TransformerException ( fmsg , m_locator ) ) ; } else { throw new TransformerException ( fmsg , ( SAXSourceLocator ) m_locator ) ; } } private PrefixResolver m_currentPrefixResolver = null ; public PrefixResolver getNamespaceContext ( ) { return m_currentPrefixResolver ; } public void setNamespaceContext ( PrefixResolver pr ) { m_currentPrefixResolver = pr ; } ErrorListener m_errorHandler ; SourceLocator m_locator ; } 	1
package org . apache . xalan . xsltc . util ; public final class IntegerArray { private static final int InitialSize = 32 ; private int [ ] _array ; private int _size ; private int _free = 0 ; public IntegerArray ( ) { this ( InitialSize ) ; } public IntegerArray ( int size ) { _array = new int [ _size = size ] ; } public IntegerArray ( int [ ] array ) { this ( array . length ) ; System . arraycopy ( array , 0 , _array , 0 , _free = _size ) ; } public void clear ( ) { _free = 0 ; } public Object clone ( ) { final IntegerArray clone = new IntegerArray ( _free ) ; System . arraycopy ( _array , 0 , clone . _array , 0 , _free ) ; clone . _free = _free ; return clone ; } public int [ ] toIntArray ( ) { final int [ ] result = new int [ cardinality ( ) ] ; System . arraycopy ( _array , 0 , result , 0 , cardinality ( ) ) ; return result ; } public final int at ( int index ) { return _array [ index ] ; } public final void set ( int index , int value ) { _array [ index ] = value ; } public int indexOf ( int n ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( n == _array [ i ] ) return i ; } return - 1 ; } public final void add ( int value ) { if ( _free == _size ) { growArray ( _size * 2 ) ; } _array [ _free ++ ] = value ; } public void addNew ( int value ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( _array [ i ] == value ) return ; } add ( value ) ; } public void reverse ( ) { int left = 0 ; int right = _free - 1 ; while ( left < right ) { int temp = _array [ left ] ; _array [ left ++ ] = _array [ right ] ; _array [ right -- ] = temp ; } } public void merge ( IntegerArray other ) { final int newSize = _free + other . _free ; int [ ] newArray = new int [ newSize ] ; int i = 0 , j = 0 , k ; for ( k = 0 ; i < _free && j < other . _free ; k ++ ) { int x = _array [ i ] ; int y = other . _array [ j ] ; if ( x < y ) { newArray [ k ] = x ; i ++ ; } else if ( x > y ) { newArray [ k ] = y ; j ++ ; } else { newArray [ k ] = x ; i ++ ; j ++ ; } } if ( i >= _free ) { while ( j < other . _free ) { newArray [ k ++ ] = other . _array [ j ++ ] ; } } else { while ( i < _free ) { newArray [ k ++ ] = _array [ i ++ ] ; } } _array = newArray ; _free = _size = newSize ; } public void sort ( ) { quicksort ( _array , 0 , _free - 1 ) ; } private static void quicksort ( int [ ] array , int p , int r ) { if ( p < r ) { final int q = partition ( array , p , r ) ; quicksort ( array , p , q ) ; quicksort ( array , q + 1 , r ) ; } } private static int partition ( int [ ] array , int p , int r ) { final int x = array [ ( p + r ) > > > 1 ] ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x < array [ -- j ] ) ; while ( x > array [ ++ i ] ) ; if ( i < j ) { int temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } else { return j ; } } } private void growArray ( int size ) { final int [ ] newArray = new int [ _size = size ] ; System . arraycopy ( _array , 0 , newArray , 0 , _free ) ; _array = newArray ; } public int popLast ( ) { return _array [ -- _free ] ; } public int last ( ) { return _array [ _free - 1 ] ; } public void setLast ( int n ) { _array [ _free - 1 ] = n ; } public void pop ( ) { _free -- ; } public void pop ( int n ) { _free -= n ; } public final int cardinality ( ) { return _free ; } public void print ( java . io . PrintStream out ) { if ( _free > 0 ) { for ( int i = 0 ; i < _free - 1 ; i ++ ) { out . print ( _array [ i ] ) ; out . print ( ' ' ) ; } out . println ( _array [ _free - 1 ] ) ; } else { out . println ( "IntegerArray: empty" ) ; } } } 	1
package org . apache . xml . res ; public class XMLErrorResources_es extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Función no admitida" } , { ER_CANNOT_OVERWRITE_CAUSE , "No se puede sobrescribir la causa" } , { ER_NO_DEFAULT_IMPL , "No se ha encontrado ninguna implementación predeterminada " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) no se utiliza actualmente" } , { ER_OFFSET_BIGGER_THAN_SLOT , "La desviación es mayor que el intervalo" } , { ER_COROUTINE_NOT_AVAIL , "Corrutina no disponible, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager ha recibido una solicitud co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Fallo co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Error de parámetro de corrutina({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: el analizador sintáctico doTerminate responde {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "no puede invocarse el analizador sintáctico con un análisis sintáctico en curso" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: El iterador introducido para el eje  {0} no está implementado" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: el iterador para el eje {0} no está implementado " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "no se admite clon del iterador" } , { ER_UNKNOWN_AXIS_TYPE , "El tipo de eje transversal es desconocido: {0}" } , { ER_AXIS_NOT_SUPPORTED , "No se admite traverser de eje: {0}" } , { ER_NO_DTMIDS_AVAIL , "No hay más Id de DTM disponibles" } , { ER_NOT_SUPPORTED , "No se admite: {0}" } , { ER_NODE_NON_NULL , "El nodo no puede ser nulo para getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "No se ha podido convertir el nodo en un manejador" } , { ER_STARTPARSE_WHILE_PARSING , "no se puede invocar startParse con un análisis sintáctico en curso" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse no admite SAXParser nulo" } , { ER_COULD_NOT_INIT_PARSER , "No se ha podido inicializar el analizador sintáctico con" } , { ER_EXCEPTION_CREATING_POOL , "se ha producido una excepción al crear una nueva instancia para pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "El trayecto contiene una secuencia de escape no válida" } , { ER_SCHEME_REQUIRED , "Se necesita un esquema." } , { ER_NO_SCHEME_IN_URI , "No se ha encontrado ningún esquema en el URI: {0}" } , { ER_NO_SCHEME_INURI , "No se ha encontrado ningún esquema en el URI" } , { ER_PATH_INVALID_CHAR , "El trayecto contiene un carácter no válido: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "No se puede establecer un esquema a partir de una cadena nula" } , { ER_SCHEME_NOT_CONFORMANT , "El esquema no es aceptable." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "El sistema central no es una dirección bien construida" } , { ER_PORT_WHEN_HOST_NULL , "No puede establecerse el puerto cuando el sistema central es nulo" } , { ER_INVALID_PORT , "Número de puerto no válido" } , { ER_FRAG_FOR_GENERIC_URI , "Sólo puede establecerse el fragmento para un URI genérico" } , { ER_FRAG_WHEN_PATH_NULL , "No puede establecerse el fragmento cuando el trayecto es nulo" } , { ER_FRAG_INVALID_CHAR , "El fragmento contiene un carácter no válido" } , { ER_PARSER_IN_USE , "El analizador sintáctico está en uso" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "No se puede cambiar {0} {1} mientras el análisis sintáctico está en curso" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "No se permite la autocausalidad" } , { ER_NO_USERINFO_IF_NO_HOST , "La información de usuario no puede especificarse si no se especifica el sistema central" } , { ER_NO_PORT_IF_NO_HOST , "El puerto no puede especificarse si no está especificado el sistema central" } , { ER_NO_QUERY_STRING_IN_PATH , "La cadena de consulta no puede especificarse a la vez en el trayecto y en la cadena de consulta" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "El fragmento no puede especificarse a la vez en el trayecto y en el fragmento" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "No se puede inicializar el URI con parámetros vacíos" } , { ER_METHOD_NOT_SUPPORTED , "Método todavía no utilizado" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter no puede reiniciarse actualmente" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader no antes de una solicitud startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "No se admite el eje transversal: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler creado con PrintWriter nulo" } , { ER_SYSTEMID_UNKNOWN , "Id de sistema desconocido" } , { ER_LOCATION_UNKNOWN , "Ubicación del error desconocida" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe convertirse en un espacio de nombre: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument no admitido en XPathContext." } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "El atributo hijo no tiene documento propietario!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "El atributo hijo no tiene elemento de documento propietario!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Advertencia: no puede enviar el texto antes del elemento de documento. Se ignora..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "No puede haber más de una raíz en un DOM." } , { ER_ARG_LOCALNAME_NULL , "El argumentoArgument 'localName' es nulo." } , { ER_ARG_LOCALNAME_INVALID , "El nombre local especificado en QNAME debe ser un nombre NCName válido" } , { ER_ARG_PREFIX_INVALID , "El prefijo especificado en QNAME debe ser un nombre NCName válido" } , { "BAD_CODE" , "El parámetro para crear el mensaje estaba fuera de los límites" } , { "FORMAT_FAILED" , "Excepción generada durante la llamada messageFormat" } , { "line" , "Línea #" } , { "column" , "Columna #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0
package org . apache . xml . utils . synthetic ; import java . lang . reflect . Modifier ; import org . apache . xml . utils . synthetic . reflection . Constructor ; import org . apache . xml . utils . synthetic . reflection . Field ; import org . apache . xml . utils . synthetic . reflection . Method ; public class Class extends Object implements java . io . Serializable { private static java . util . Hashtable global_classtable = new java . util . Hashtable ( ) ; private java . lang . String name ; private java . lang . Class realclass = null ; private int modifiers ; private boolean isInterface = false ; private Class superclass = null ; private Class declaringclass = null ; private Class [ ] interfaces = new Class [ 0 ] ; private Class [ ] allclasses = new Class [ 0 ] ; private Class [ ] declaredclasses = new Class [ 0 ] ; private Constructor [ ] allconstructors = new Constructor [ 0 ] ; private Constructor [ ] declaredconstructors = new Constructor [ 0 ] ; private Method [ ] allmethods = new Method [ 0 ] ; private Method [ ] declaredmethods = new Method [ 0 ] ; private Field [ ] allfields = new Field [ 0 ] ; private Field [ ] declaredfields = new Field [ 0 ] ; private Class [ ] innerclasses = new Class [ 0 ] ; Class ( java . lang . Class realclass ) { this ( realclass . getName ( ) ) ; try { setRealClass ( realclass ) ; } catch ( SynthesisException e ) { e . printStackTrace ( ) ; } } Class ( String fullname ) { this . name = fullname ; global_classtable . put ( fullname , this ) ; } public static Class forClass ( java . lang . Class cls ) { if ( cls == null ) return null ; Class ret = ( Class ) ( global_classtable . get ( cls . getName ( ) ) ) ; if ( null == ret ) ret = new Class ( cls ) ; return ret ; } public Class forNameInContext ( String classname ) throws ClassNotFoundException { for ( int i = innerclasses . length - 1 ; i >= 0 ; -- i ) { if ( classname . equals ( innerclasses [ i ] . getShortName ( ) ) ) return innerclasses [ i ] ; } return forName ( classname ) ; } public static Class forName ( String className ) throws ClassNotFoundException { if ( className . endsWith ( "]" ) ) { StringBuffer arrayname = new StringBuffer ( ) ; for ( int i = className . indexOf ( '[' ) ; i != - 1 ; i = className . indexOf ( '[' , i + 1 ) ) { arrayname . append ( '[' ) ; } String classname = className . substring ( 0 , className . indexOf ( '[' ) ) ; if ( "byte" . equals ( classname ) ) arrayname . append ( 'B' ) ; else if ( "char" . equals ( classname ) ) arrayname . append ( 'C' ) ; else if ( "double" . equals ( classname ) ) arrayname . append ( 'D' ) ; else if ( "float" . equals ( classname ) ) arrayname . append ( 'F' ) ; else if ( "int" . equals ( classname ) ) arrayname . append ( 'I' ) ; else if ( "long" . equals ( classname ) ) arrayname . append ( 'J' ) ; else if ( "short" . equals ( classname ) ) arrayname . append ( 'S' ) ; else if ( "boolean" . equals ( classname ) ) arrayname . append ( 'Z' ) ; else arrayname . append ( 'L' ) . append ( classname ) . append ( ';' ) ; return forName ( arrayname . toString ( ) ) ; } Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null == ret ) { if ( "boolean" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Boolean . TYPE ; } else if ( "byte" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Byte . TYPE ; } else if ( "char" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Character . TYPE ; } else if ( "short" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Short . TYPE ; } else if ( "int" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Integer . TYPE ; } else if ( "long" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Long . TYPE ; } else if ( "float" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Float . TYPE ; } else if ( "double" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Double . TYPE ; } else if ( "void" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Class . forName ( "java.lang.Object" ) ; } else ret = new Class ( java . lang . Class . forName ( className ) ) ; } return ret ; } public static Class declareClass ( String className ) throws SynthesisException { Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null == ret ) ret = new Class ( className ) ; if ( ret . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; return ret ; } public static Class reallyDeclareClass ( String className ) { Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null != ret ) global_classtable . remove ( ret ) ; ret = new Class ( className ) ; return ret ; } public Class [ ] getClasses ( ) { if ( realclass != null && allclasses == null ) { java . lang . Class [ ] realDE = realclass . getClasses ( ) ; allclasses = new Class [ realDE . length ] ; for ( int i = 0 ; i < realDE . length ; ++ i ) { allclasses [ i ] = forClass ( realDE [ i ] ) ; } } return allclasses ; } public ClassLoader getClassLoader ( ) { return ( realclass == null ) ? null : realclass . getClassLoader ( ) ; } public Class getComponentType ( ) { return realclass == null ? null : new Class ( realclass . getComponentType ( ) ) ; } public Constructor getConstructor ( Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException , SynthesisException { if ( realclass == null ) throw new SynthesisException ( SynthesisException . UNREIFIED ) ; java . lang . Class [ ] real = new java . lang . Class [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) { if ( ( real [ i ] = parameterTypes [ i ] . getRealClass ( ) ) == null ) throw new SynthesisException ( SynthesisException . UNREIFIED ) ; } return new Constructor ( realclass . getConstructor ( real ) , this ) ; } public Constructor [ ] getConstructors ( ) throws SecurityException { if ( realclass != null && allconstructors == null ) { java . lang . reflect . Constructor [ ] realDC = realclass . getConstructors ( ) ; allconstructors = new Constructor [ realDC . length ] ; for ( int i = 0 ; i < realDC . length ; ++ i ) { allconstructors [ i ] = new Constructor ( realDC [ i ] , this ) ; } } return allconstructors ; } public Class [ ] getDeclaredClasses ( ) throws SecurityException { if ( realclass != null && declaredclasses == null ) { java . lang . Class [ ] realDE = realclass . getDeclaredClasses ( ) ; declaredclasses = new Class [ realDE . length ] ; for ( int i = 0 ; i < realDE . length ; ++ i ) { declaredclasses [ i ] = forClass ( realDE [ i ] ) ; if ( ! realDE [ i ] . isInterface ( ) ) superclass = declaredclasses [ i ] ; } } return declaredclasses ; } public void addExtends ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Class [ ] scratch = new Class [ declaredclasses . length + 1 ] ; System . arraycopy ( declaredclasses , 0 , scratch , 0 , declaredclasses . length ) ; scratch [ declaredclasses . length ] = newclass ; declaredclasses = scratch ; } public Constructor getDeclaredConstructor ( Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Constructor declareConstructor ( ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Constructor newctor = new Constructor ( this ) ; Constructor [ ] scratch = new Constructor [ declaredconstructors . length + 1 ] ; System . arraycopy ( declaredconstructors , 0 , scratch , 0 , declaredconstructors . length ) ; scratch [ declaredconstructors . length ] = newctor ; declaredconstructors = scratch ; scratch = new Constructor [ allconstructors . length + 1 ] ; System . arraycopy ( allconstructors , 0 , scratch , 0 , allconstructors . length ) ; scratch [ allconstructors . length ] = newctor ; allconstructors = scratch ; return newctor ; } public Class declareInterface ( Class newifce ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; if ( ! newifce . isInterface ( ) ) throw new SynthesisException ( SynthesisException . SYNTAX , newifce . getName ( ) + " isn't an interface" ) ; Class [ ] scratch = new Class [ interfaces . length + 1 ] ; System . arraycopy ( interfaces , 0 , scratch , 0 , interfaces . length ) ; scratch [ interfaces . length ] = newifce ; interfaces = scratch ; scratch = new Class [ allclasses . length + 1 ] ; System . arraycopy ( allclasses , 0 , scratch , 0 , allclasses . length ) ; scratch [ allclasses . length ] = newifce ; allclasses = scratch ; return newifce ; } public Constructor [ ] getDeclaredConstructors ( ) throws SecurityException { if ( realclass != null && declaredconstructors == null ) { java . lang . reflect . Constructor [ ] realDC = realclass . getDeclaredConstructors ( ) ; declaredconstructors = new Constructor [ realDC . length ] ; for ( int i = 0 ; i < realDC . length ; ++ i ) { declaredconstructors [ i ] = new Constructor ( realDC [ i ] , this ) ; } } return declaredconstructors ; } public Field getDeclaredField ( String name ) throws NoSuchFieldException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Field declareField ( String name ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Field newfield = new Field ( name , this ) ; Field [ ] scratch = new Field [ declaredfields . length + 1 ] ; System . arraycopy ( declaredfields , 0 , scratch , 0 , declaredfields . length ) ; scratch [ declaredfields . length ] = newfield ; declaredfields = scratch ; scratch = new Field [ allfields . length + 1 ] ; System . arraycopy ( allfields , 0 , scratch , 0 , allfields . length ) ; scratch [ allfields . length ] = newfield ; allfields = scratch ; return newfield ; } public Field [ ] getDeclaredFields ( ) throws SecurityException { if ( realclass != null && declaredfields == null ) { java . lang . reflect . Field [ ] realDF = realclass . getDeclaredFields ( ) ; declaredfields = new Field [ realDF . length ] ; for ( int i = 0 ; i < realDF . length ; ++ i ) { declaredfields [ i ] = new Field ( realDF [ i ] , this ) ; } } return declaredfields ; } public Method getDeclaredMethod ( String name , Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Method declareMethod ( String name ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Method newMethod = new Method ( name , this ) ; Method [ ] scratch = new Method [ declaredmethods . length + 1 ] ; System . arraycopy ( declaredmethods , 0 , scratch , 0 , declaredmethods . length ) ; scratch [ declaredmethods . length ] = newMethod ; declaredmethods = scratch ; scratch = new Method [ allmethods . length + 1 ] ; System . arraycopy ( allmethods , 0 , scratch , 0 , allmethods . length ) ; scratch [ allmethods . length ] = newMethod ; allmethods = scratch ; return newMethod ; } public Method [ ] getDeclaredMethods ( ) throws SecurityException { if ( realclass != null && declaredmethods == null ) { java . lang . reflect . Method [ ] realDM = realclass . getDeclaredMethods ( ) ; declaredmethods = new Method [ realDM . length ] ; for ( int i = 0 ; i < realDM . length ; ++ i ) { declaredmethods [ i ] = new Method ( realDM [ i ] , this ) ; } } return declaredmethods ; } public Class getDeclaringClass ( ) { if ( realclass != null && declaringclass == null ) { java . lang . Class dc = realclass . getDeclaringClass ( ) ; if ( dc == null ) declaringclass = null ; else declaringclass = forClass ( dc ) ; } return declaringclass ; } private void addInnerClass ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; if ( newclass . getDeclaringClass ( ) != this ) throw new SynthesisException ( SynthesisException . WRONG_OWNER ) ; Class [ ] scratch = new Class [ innerclasses . length + 1 ] ; System . arraycopy ( innerclasses , 0 , scratch , 0 , innerclasses . length ) ; scratch [ innerclasses . length ] = newclass ; innerclasses = scratch ; } public Class declareInnerClass ( String className ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; String relativeName = getName ( ) + "$" + className ; Class newclass = ( Class ) ( global_classtable . get ( relativeName ) ) ; if ( newclass != null ) throw new SynthesisException ( SynthesisException . SYNTAX , "Inner class " + name + " already exists" ) ; newclass = new Class ( className ) ; newclass . declaringclass = this ; Class [ ] scratch = new Class [ innerclasses . length + 1 ] ; System . arraycopy ( innerclasses , 0 , scratch , 0 , innerclasses . length ) ; scratch [ innerclasses . length ] = newclass ; innerclasses = scratch ; return newclass ; } public Class [ ] getInnerClasses ( ) { return innerclasses ; } public Field getField ( String name ) throws NoSuchFieldException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Field [ ] getFields ( ) throws SecurityException { if ( realclass != null && allfields == null ) { java . lang . reflect . Field [ ] realDF = realclass . getFields ( ) ; allfields = new Field [ realDF . length ] ; for ( int i = 0 ; i < realDF . length ; ++ i ) { allfields [ i ] = new Field ( realDF [ i ] , this ) ; } } return allfields ; } public Class [ ] getInterfaces ( ) { if ( realclass != null && interfaces == null ) { java . lang . Class [ ] realI = realclass . getInterfaces ( ) ; interfaces = new Class [ realI . length ] ; for ( int i = 0 ; i < realI . length ; ++ i ) { interfaces [ i ] = forClass ( realI [ i ] ) ; } } return interfaces ; } public void addImplements ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Class [ ] scratch = new Class [ interfaces . length + 1 ] ; System . arraycopy ( interfaces , 0 , scratch , 0 , interfaces . length ) ; scratch [ interfaces . length ] = newclass ; interfaces = scratch ; } public Method getMethod ( String name , Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Method [ ] getMethods ( ) throws SecurityException { if ( realclass != null && allmethods == null ) { java . lang . reflect . Method [ ] realDM = realclass . getMethods ( ) ; allmethods = new Method [ realDM . length ] ; for ( int i = 0 ; i < realDM . length ; ++ i ) { allmethods [ i ] = new Method ( realDM [ i ] , this ) ; } } return allmethods ; } public int getModifiers ( ) { return modifiers ; } public void setModifiers ( int modifiers ) throws SynthesisException { if ( this . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . modifiers = modifiers ; } public java . lang . String getName ( ) { return name ; } public java . lang . String getJavaName ( ) { if ( name . charAt ( 0 ) != '[' ) return name ; int count = name . lastIndexOf ( '[' ) ; StringBuffer jname = new StringBuffer ( name . substring ( count + 2 ) ) ; jname . setLength ( jname . length ( ) - 1 ) ; while ( count -- >= 0 ) { jname . append ( "[]" ) ; } return jname . toString ( ) ; } public java . lang . String getShortName ( ) { int start = name . lastIndexOf ( "." ) ; if ( start != 0 || name . charAt ( 0 ) == '.' ) ++ start ; if ( declaringclass != null ) { int d = name . lastIndexOf ( '$' , start ) ; if ( d != 0 ) start = d + 1 ; } return name . substring ( start ) ; } public java . lang . String getJavaShortName ( ) { String shortname = getShortName ( ) ; if ( shortname . charAt ( 0 ) != '[' ) return shortname ; int count = shortname . lastIndexOf ( '[' ) ; StringBuffer jname = new StringBuffer ( shortname . substring ( count + 2 ) ) ; jname . setLength ( jname . length ( ) - 1 ) ; while ( count -- >= 0 ) { jname . append ( "[]" ) ; } return jname . toString ( ) ; } public java . lang . String getPackageName ( ) { int start = name . lastIndexOf ( "." ) ; return name . substring ( 0 , start ) ; } public java . lang . Class getRealClass ( ) { return realclass ; } public void setRealClass ( java . lang . Class realclass ) throws SynthesisException { if ( this . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . realclass = realclass ; this . modifiers = realclass . getModifiers ( ) ; this . isInterface = realclass . isInterface ( ) ; this . declaringclass = null ; this . interfaces = null ; this . declaredconstructors = null ; this . allconstructors = null ; this . declaredmethods = null ; this . allmethods = null ; this . declaredfields = null ; this . allfields = null ; this . declaredclasses = null ; this . allclasses = null ; this . superclass = null ; } public void setSuperClass ( Class superclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . superclass = superclass ; } public void setSuperClass ( java . lang . Class superclass ) throws ClassNotFoundException , SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . superclass = Class . forClass ( superclass ) ; } public java . net . URL getResource ( String name ) { throw new java . lang . IllegalStateException ( ) ; } public java . io . InputStream getResourceAsStream ( String name ) { throw new java . lang . IllegalStateException ( ) ; } public Object [ ] getSigners ( ) { throw new java . lang . IllegalStateException ( ) ; } public Class getSuperclass ( ) { if ( realclass != null && superclass == null ) { superclass = forClass ( realclass . getSuperclass ( ) ) ; } if ( superclass == null ) superclass = forClass ( Object . class ) ; return superclass ; } public boolean isArray ( ) { return realclass != null && realclass . isArray ( ) ; } public boolean isAssignableFrom ( Class cls ) { if ( realclass != null && cls . realclass != null ) return realclass . isAssignableFrom ( cls . realclass ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isAssignableFrom ( java . lang . Class cls ) { if ( realclass != null ) return realclass . isAssignableFrom ( ( java . lang . Class ) cls ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isInstance ( Object obj ) { if ( realclass != null ) return realclass . isInstance ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isInterface ( ) { return ( realclass != null ) ? realclass . isInterface ( ) : isInterface ; } public void isInterface ( boolean isInterface ) throws SynthesisException { if ( realclass == null ) this . isInterface = isInterface ; else if ( realclass . isInterface ( ) != isInterface ) throw new SynthesisException ( SynthesisException . REIFIED ) ; } public boolean isPrimitive ( ) { return realclass != null && realclass . isPrimitive ( ) ; } public Object newInstance ( ) throws InstantiationException , IllegalAccessException { throw new java . lang . IllegalStateException ( ) ; } public String toString ( ) { if ( realclass != null ) return realclass . toString ( ) ; else if ( isInterface ( ) ) return "interface " + name ; else return "class " + name ; } public void toSource ( java . io . OutputStream out , int depth ) { java . io . PrintWriter writer = new java . io . PrintWriter ( out ) ; toSource ( writer , depth ) ; } public void toSource ( java . io . PrintWriter out , int depth ) { String tab = tabset ( depth ) ; if ( realclass != null ) out . println ( tab + "/** Code back-generated from a \"real\" Class; accuracy limited by reflection APIs. */" ) ; else out . println ( tab + "/** Code generated via org.apache.xml.utils.synthetic.Class */" ) ; if ( getDeclaringClass ( ) == null ) out . println ( tab + "package " + getPackageName ( ) + ";" ) ; out . print ( tab + Modifier . toString ( getModifiers ( ) ) ) ; if ( isInterface ( ) ) out . print ( " interface " ) ; else out . print ( " class " ) ; out . println ( getJavaShortName ( ) ) ; if ( superclass != null ) { out . print ( '\n' + tab + " extends " + superclass . getJavaName ( ) ) ; } Class [ ] ext = getInterfaces ( ) ; if ( ext != null & ext . length > 0 ) { out . print ( '\n' + tab + ( isInterface ? " extends " : " implements " ) + ext [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < ext . length ; ++ i ) { out . print ( ", " + ext [ i ] . getJavaName ( ) ) ; } out . print ( "\n" ) ; } out . print ( tab + "{\n" ) ; tab = tabset ( ++ depth ) ; Field [ ] fields = null ; try { fields = getDeclaredFields ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving fields" ) ; } if ( fields != null ) { for ( int i = 0 ; i < fields . length ; ++ i ) { out . println ( tab + fields [ i ] . toSource ( ) ) ; } } Constructor [ ] ctors = null ; try { ctors = getDeclaredConstructors ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving ctors" ) ; } if ( ctors != null ) { for ( int i = 0 ; i < ctors . length ; ++ i ) { out . print ( ctors [ i ] . toSource ( tab ) ) ; } } Method [ ] methods = null ; try { methods = getDeclaredMethods ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving methods" ) ; } if ( methods != null ) { for ( int i = 0 ; i < methods . length ; ++ i ) { out . print ( '\n' ) ; out . print ( methods [ i ] . toSource ( tab ) ) ; } } Class [ ] inners = getInnerClasses ( ) ; if ( inners != null ) { for ( int i = 0 ; i < inners . length ; ++ i ) { out . print ( '\n' ) ; inners [ i ] . toSource ( out , depth ) ; } } tab = tabset ( -- depth ) ; out . print ( tab + "}\n" ) ; out . flush ( ) ; } private String tabset ( int depth ) { StringBuffer t = new StringBuffer ( ) ; while ( depth -- > 0 ) { t . append ( "    " ) ; } return t . toString ( ) ; } static final int [ ] val = { Modifier . ABSTRACT , Modifier . FINAL , Modifier . INTERFACE , Modifier . NATIVE , Modifier . PRIVATE , Modifier . PROTECTED , Modifier . PUBLIC , Modifier . STATIC , Modifier . SYNCHRONIZED , Modifier . TRANSIENT , Modifier . VOLATILE } ; static final String [ ] kwd = { "abstract" , "final" , "interface" , "native" , "private" , "protected" , "public" , "static" , "synchronized" , "transient" , "volatile" } ; static public int modifierFromString ( String t ) { for ( int i = 0 ; i < kwd . length ; ++ i ) { if ( kwd [ i ] . equals ( t ) ) return val [ i ] ; } return 0 ; } static public int modifiersFromString ( String s ) { int mods = 0 ; java . util . StringTokenizer parts = new java . util . StringTokenizer ( s ) ; while ( parts . hasMoreTokens ( ) ) { String t = parts . nextToken ( ) ; mods |= modifierFromString ( t ) ; } return mods ; } } 	1
package org . apache . xalan . processor ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . templates . ElemApplyImport ; import org . apache . xalan . templates . ElemApplyTemplates ; import org . apache . xalan . templates . ElemAttribute ; import org . apache . xalan . templates . ElemCallTemplate ; import org . apache . xalan . templates . ElemComment ; import org . apache . xalan . templates . ElemCopy ; import org . apache . xalan . templates . ElemCopyOf ; import org . apache . xalan . templates . ElemElement ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemFallback ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xalan . templates . ElemPI ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemValueOf ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . Stylesheet ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ProcessorExsltFunction extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = "" ; if ( ! ( handler . getElemTemplateElement ( ) instanceof Stylesheet ) ) { msg = "func:function element must be top level." ; handler . error ( msg , new SAXException ( msg ) ) ; } super . startElement ( handler , uri , localName , rawName , attributes ) ; String val = attributes . getValue ( "name" ) ; int indexOfColon = val . indexOf ( ":" ) ; if ( indexOfColon > 0 ) { String prefix = val . substring ( 0 , indexOfColon ) ; String localVal = val . substring ( indexOfColon + 1 ) ; String ns = handler . getNamespaceSupport ( ) . getURI ( prefix ) ; } else { msg = "func:function name must have namespace" ; handler . error ( msg , new SAXException ( msg ) ) ; } } protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws SAXException { ElemTemplateElement function = handler . getElemTemplateElement ( ) ; SourceLocator locator = handler . getLocator ( ) ; validate ( function , handler ) ; super . endElement ( handler , uri , localName , rawName ) ; } public void validate ( ElemTemplateElement elem , StylesheetHandler handler ) throws SAXException { String msg = "" ; while ( elem != null ) { if ( elem instanceof ElemExsltFuncResult && elem . getNextSiblingElem ( ) != null && ! ( elem . getNextSiblingElem ( ) instanceof ElemFallback ) ) { msg = "func:result has an illegal following sibling (only xsl:fallback allowed)" ; handler . error ( msg , new SAXException ( msg ) ) ; } if ( ( elem instanceof ElemApplyImport || elem instanceof ElemApplyTemplates || elem instanceof ElemAttribute || elem instanceof ElemCallTemplate || elem instanceof ElemComment || elem instanceof ElemCopy || elem instanceof ElemCopyOf || elem instanceof ElemElement || elem instanceof ElemLiteralResult || elem instanceof ElemNumber || elem instanceof ElemPI || elem instanceof ElemText || elem instanceof ElemTextLiteral || elem instanceof ElemValueOf ) && ! ( ancestorIsOk ( elem ) ) ) { msg = "misplaced literal result in a func:function container." ; handler . error ( msg , new SAXException ( msg ) ) ; } ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; while ( nextElem == null ) { nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) elem = elem . getParentElem ( ) ; if ( elem == null || elem instanceof ElemExsltFunction ) return ; } elem = nextElem ; } } boolean ancestorIsOk ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof ElemExsltFunction ) ) { ElemTemplateElement parent = child . getParentElem ( ) ; if ( parent instanceof ElemExsltFuncResult || parent instanceof ElemVariable || parent instanceof ElemParam ) return true ; child = parent ; } return false ; } } 	1
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemChoose extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_CHOOSE ; } public String getNodeName ( ) { return Constants . ELEMNAME_CHOOSE_STRING ; } public ElemChoose ( ) { } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; boolean found = false ; for ( ElemTemplateElement childElem = getFirstChildElem ( ) ; childElem != null ; childElem = childElem . getNextSiblingElem ( ) ) { int type = childElem . getXSLToken ( ) ; if ( Constants . ELEMNAME_WHEN == type ) { found = true ; ElemWhen when = ( ElemWhen ) childElem ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject test = when . getTest ( ) . execute ( xctxt , sourceNode , when ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , when , "test" , when . getTest ( ) , test ) ; if ( test . bool ( ) ) { transformer . getTraceManager ( ) . fireTraceEvent ( when ) ; transformer . executeChildTemplates ( when , true ) ; transformer . getTraceManager ( ) . fireTraceEndEvent ( when ) ; return ; } } else if ( when . getTest ( ) . bool ( xctxt , sourceNode , when ) ) { transformer . executeChildTemplates ( when , true ) ; return ; } } else if ( Constants . ELEMNAME_OTHERWISE == type ) { found = true ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( childElem ) ; transformer . executeChildTemplates ( childElem , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( childElem ) ; return ; } } if ( ! found ) transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_CHOOSE_REQUIRES_WHEN ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_WHEN : case Constants . ELEMNAME_OTHERWISE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public boolean canAcceptVariables ( ) { return false ; } } 	1
package org . apache . xalan . xsltc ; import java . text . Collator ; import java . util . Locale ; public interface CollatorFactory { public Collator getCollator ( String lang , String country ) ; public Collator getCollator ( Locale locale ) ; } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; final class ParameterRef extends VariableRefBase { public ParameterRef ( Param param ) { super ( param ) ; } public String toString ( ) { return "parameter-ref(" + _variable . getName ( ) + '/' + _variable . getType ( ) + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String name = _variable . getVariable ( ) ; final String signature = _type . toSignature ( ) ; if ( _variable . isLocal ( ) ) { if ( classGen . isExternal ( ) ) { Closure variableClosure = _closure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , name , signature ) ) ) ; } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { final String className = classGen . getClassName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new GETFIELD ( cpg . addFieldref ( className , name , signature ) ) ) ; } if ( _variable . getType ( ) instanceof NodeSetType ) { final int clone = cpg . addInterfaceMethodref ( NODE_ITERATOR , "cloneIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( clone , 1 ) ) ; } } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FilterParentPath extends Expression { private Expression _filterExpr ; private Expression _path ; private boolean _hasDescendantAxis = false ; public FilterParentPath ( Expression filterExpr , Expression path ) { ( _path = path ) . setParent ( this ) ; ( _filterExpr = filterExpr ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _filterExpr . setParser ( parser ) ; _path . setParser ( parser ) ; } public String toString ( ) { return "FilterParentPath(" + _filterExpr + ", " + _path + ')' ; } public void setDescendantAxis ( ) { _hasDescendantAxis = true ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type ftype = _filterExpr . typeCheck ( stable ) ; if ( ftype instanceof NodeSetType == false ) { if ( ftype instanceof ReferenceType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else if ( ftype instanceof NodeType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else { throw new TypeCheckError ( this ) ; } } final Type ptype = _path . typeCheck ( stable ) ; if ( ! ( ptype instanceof NodeSetType ) ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initSI = cpg . addMethodref ( STEP_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( STEP_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; _filterExpr . translate ( classGen , methodGen ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initSI ) ) ; if ( _hasDescendantAxis ) { final int incl = cpg . addMethodref ( NODE_ITERATOR_BASE , "includeSelf" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEVIRTUAL ( incl ) ) ; } if ( ! ( getParent ( ) instanceof RelativeLocationPath ) && ! ( getParent ( ) instanceof FilterParentPath ) ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	0
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import javax . xml . transform . Result ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToHTMLSAXHandler extends ToSAXHandler { protected boolean m_escapeSetting = false ; public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public boolean reset ( ) { return false ; } public void serialize ( Node node ) throws IOException { return ; } public boolean setEscaping ( boolean escape ) throws SAXException { boolean oldEscapeSetting = m_escapeSetting ; m_escapeSetting = escape ; if ( escape ) { processingInstruction ( Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { processingInstruction ( Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; } return oldEscapeSetting ; } public void setIndent ( boolean indent ) { } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void elementDecl ( String name , String model ) throws SAXException { return ; } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void endElement ( String uri , String localName , String qName ) throws SAXException { flushPending ( ) ; m_saxHandler . endElement ( uri , localName , qName ) ; super . fireEndElem ( qName ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { flushPending ( ) ; m_saxHandler . processingInstruction ( arg0 , arg1 ) ; super . fireEscapingEvent ( arg0 , arg1 ) ; } public void setDocumentLocator ( Locator arg0 ) { } public void skippedEntity ( String arg0 ) throws SAXException { } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { flushPending ( ) ; super . startElement ( namespaceURI , localName , qName , atts ) ; m_saxHandler . startElement ( namespaceURI , localName , qName , atts ) ; m_startTagOpen = false ; } public void comment ( char [ ] ch , int start , int length ) throws SAXException { flushPending ( ) ; m_lexHandler . comment ( ch , start , length ) ; super . fireCommentEvent ( ch , start , length ) ; return ; } public void endCDATA ( ) throws SAXException { return ; } public void endDTD ( ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void startEntity ( String arg0 ) throws SAXException { } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; super . fireEndDoc ( ) ; } protected void closeStartTag ( ) throws SAXException { m_startTagOpen = false ; m_saxHandler . startElement ( EMPTYSTRING , m_elementName , m_elementName , m_attributes ) ; m_attributes . clear ( ) ; } public void close ( ) { return ; } public void characters ( String chars ) throws SAXException { this . characters ( chars . toCharArray ( ) , 0 , chars . length ( ) ) ; return ; } public ToHTMLSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; } public ToHTMLSAXHandler ( ContentHandler handler , LexicalHandler lex , String encoding ) { super ( handler , lex , encoding ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { super . startElement ( elementNamespaceURI , elementLocalName , elementName ) ; flushPending ( ) ; if ( m_lexHandler != null ) { String doctypeSystem = getDoctypeSystem ( ) ; String doctypePublic = getDoctypePublic ( ) ; if ( ( doctypeSystem != null ) || ( doctypePublic != null ) ) m_lexHandler . startDTD ( elementName , doctypePublic , doctypeSystem ) ; m_lexHandler = null ; } m_currentElemDepth ++ ; m_elementName = elementName ; m_elementLocalName = elementLocalName ; m_elementURI = elementNamespaceURI ; m_startTagOpen = true ; } public void startElement ( String elementName ) throws SAXException { this . startElement ( null , null , elementName ) ; } public void endElement ( String elementName ) throws SAXException { flushPending ( ) ; m_saxHandler . endElement ( EMPTYSTRING , elementName , elementName ) ; super . fireEndElem ( elementName ) ; } public void characters ( char [ ] ch , int off , int len ) throws SAXException { flushPending ( ) ; m_saxHandler . characters ( ch , off , len ) ; super . fireCharEvent ( ch , off , len ) ; } public void flushPending ( ) { if ( m_needToCallStartDocument ) { try { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } catch ( SAXException e ) { } } if ( m_startTagOpen ) { try { closeStartTag ( ) ; } catch ( SAXException se ) { } m_startTagOpen = false ; } } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { if ( shouldFlush ) flushPending ( ) ; m_saxHandler . startPrefixMapping ( prefix , uri ) ; return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { if ( m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } } 	0
package org . apache . xml . utils ; import org . w3c . dom . Attr ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; public class AttList implements Attributes { NamedNodeMap m_attrs ; int m_lastIndex ; DOMHelper m_dh ; public AttList ( NamedNodeMap attrs , DOMHelper dh ) { m_attrs = attrs ; m_lastIndex = m_attrs . getLength ( ) - 1 ; m_dh = dh ; } public int getLength ( ) { return m_attrs . getLength ( ) ; } public String getURI ( int index ) { String ns = m_dh . getNamespaceOfNode ( ( ( Attr ) m_attrs . item ( index ) ) ) ; if ( null == ns ) ns = "" ; return ns ; } public String getLocalName ( int index ) { return m_dh . getLocalNameOfNode ( ( ( Attr ) m_attrs . item ( index ) ) ) ; } public String getQName ( int i ) { return ( ( Attr ) m_attrs . item ( i ) ) . getName ( ) ; } public String getType ( int i ) { return "CDATA" ; } public String getValue ( int i ) { return ( ( Attr ) m_attrs . item ( i ) ) . getValue ( ) ; } public String getType ( String name ) { return "CDATA" ; } public String getType ( String uri , String localName ) { return "CDATA" ; } public String getValue ( String name ) { Attr attr = ( ( Attr ) m_attrs . getNamedItem ( name ) ) ; return ( null != attr ) ? attr . getValue ( ) : null ; } public String getValue ( String uri , String localName ) { Node a = m_attrs . getNamedItemNS ( uri , localName ) ; return ( a == null ) ? null : a . getNodeValue ( ) ; } public int getIndex ( String uri , String localPart ) { for ( int i = m_attrs . getLength ( ) - 1 ; i >= 0 ; -- i ) { Node a = m_attrs . item ( i ) ; String u = a . getNamespaceURI ( ) ; if ( ( u == null ? uri == null : u . equals ( uri ) ) && a . getLocalName ( ) . equals ( localPart ) ) return i ; } return - 1 ; } public int getIndex ( String qName ) { for ( int i = m_attrs . getLength ( ) - 1 ; i >= 0 ; -- i ) { Node a = m_attrs . item ( i ) ; if ( a . getNodeName ( ) . equals ( qName ) ) return i ; } return - 1 ; } } 	1
package org . apache . xml . serializer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; public class NamespaceMappings { private int count = 0 ; private java . util . Stack m_prefixStack ; private Hashtable m_namespaces ; private Stack m_nodeStack ; private static final String EMPTYSTRING = "" ; private static final String XML_PREFIX = "xml" ; public NamespaceMappings ( ) { initNamespaces ( ) ; } private void initNamespaces ( ) { m_namespaces = new Hashtable ( ) ; m_nodeStack = new Stack ( ) ; m_prefixStack = new Stack ( ) ; Stack stack ; m_namespaces . put ( EMPTYSTRING , stack = new Stack ( ) ) ; stack . push ( EMPTYSTRING ) ; m_prefixStack . push ( EMPTYSTRING ) ; m_namespaces . put ( XML_PREFIX , stack = new Stack ( ) ) ; stack . push ( "http://www.w3.org/XML/1998/namespace" ) ; m_prefixStack . push ( XML_PREFIX ) ; m_nodeStack . push ( new Integer ( - 1 ) ) ; } public String lookupNamespace ( String prefix ) { final Stack stack = ( Stack ) m_namespaces . get ( prefix ) ; return stack != null && ! stack . isEmpty ( ) ? ( String ) stack . peek ( ) : null ; } public String lookupPrefix ( String uri ) { String foundPrefix = null ; Enumeration prefixes = m_namespaces . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; String uri2 = lookupNamespace ( prefix ) ; if ( uri2 != null && uri2 . equals ( uri ) ) { foundPrefix = prefix ; break ; } } return foundPrefix ; } public boolean popNamespace ( String prefix ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) m_namespaces . get ( prefix ) ) != null ) { stack . pop ( ) ; return true ; } return false ; } public boolean pushNamespace ( String prefix , String uri , int elemDepth ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) m_namespaces . get ( prefix ) ) == null ) { m_namespaces . put ( prefix , stack = new Stack ( ) ) ; } if ( ! stack . empty ( ) && uri . equals ( stack . peek ( ) ) ) { return false ; } stack . push ( uri ) ; m_prefixStack . push ( prefix ) ; m_nodeStack . push ( new Integer ( elemDepth ) ) ; return true ; } public void popNamespaces ( int elemDepth ) { while ( true ) { if ( m_nodeStack . isEmpty ( ) ) return ; Integer i = ( Integer ) ( m_nodeStack . peek ( ) ) ; if ( i . intValue ( ) < elemDepth ) return ; m_nodeStack . pop ( ) ; popNamespace ( ( String ) m_prefixStack . pop ( ) ) ; } } public String generateNextPrefix ( ) { return "ns" + ( count ++ ) ; } public Object clone ( ) throws CloneNotSupportedException { NamespaceMappings clone = new NamespaceMappings ( ) ; clone . m_prefixStack = ( Stack ) m_prefixStack . clone ( ) ; clone . m_nodeStack = ( Stack ) m_nodeStack . clone ( ) ; clone . m_namespaces = ( Hashtable ) m_namespaces . clone ( ) ; clone . count = count ; return clone ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class XslElement extends Instruction { private String _prefix ; private boolean _ignore = false ; private boolean _isLiteralName = true ; private AttributeValueTemplate _name ; private AttributeValueTemplate _namespace ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Element " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public boolean declaresDefaultNS ( ) { return false ; } private boolean isLiteral ( String str ) { final int length = str . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( str . charAt ( i ) == '{' && str . charAt ( i + 1 ) != '{' ) { return false ; } } return true ; } private boolean isLegalName ( String str ) { if ( str . indexOf ( ' ' ) > - 1 ) { return false ; } final int colon = str . indexOf ( ':' ) ; if ( colon == 0 || colon == str . length ( ) - 1 ) { return false ; } final char first = str . charAt ( 0 ) ; if ( ! Character . isLetter ( first ) && first != '_' ) { return false ; } return true ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; String name = getAttribute ( "name" ) ; if ( name == EMPTYSTRING ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ELEM_NAME_ERR , name , this ) ; parser . reportError ( WARNING , msg ) ; parseChildren ( parser ) ; _ignore = true ; return ; } String namespace = getAttribute ( "namespace" ) ; _isLiteralName = isLiteral ( name ) ; if ( _isLiteralName ) { if ( ! isLegalName ( name ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ELEM_NAME_ERR , name , this ) ; parser . reportError ( WARNING , msg ) ; parseChildren ( parser ) ; _ignore = true ; return ; } final QName qname = parser . getQNameSafe ( name ) ; String prefix = qname . getPrefix ( ) ; String local = qname . getLocalPart ( ) ; if ( prefix == null ) { prefix = EMPTYSTRING ; } if ( ! hasAttribute ( "namespace" ) ) { namespace = lookupNamespace ( prefix ) ; if ( namespace == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NAMESPACE_UNDEF_ERR , prefix , this ) ; parser . reportError ( WARNING , err ) ; parseChildren ( parser ) ; _ignore = true ; return ; } _prefix = prefix ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } else { if ( prefix == EMPTYSTRING ) { if ( isLiteral ( namespace ) ) { prefix = lookupPrefix ( namespace ) ; if ( prefix == null ) { prefix = stable . generateNamespacePrefix ( ) ; } } final StringBuffer newName = new StringBuffer ( prefix ) ; if ( prefix != EMPTYSTRING ) { newName . append ( ':' ) ; } name = newName . append ( local ) . toString ( ) ; } _prefix = prefix ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } } else { _namespace = ( namespace == EMPTYSTRING ) ? null : new AttributeValueTemplate ( namespace , parser , this ) ; } _name = new AttributeValueTemplate ( name , parser , this ) ; final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { setFirstElement ( new UseAttributeSets ( useSets , parser ) ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( ! _ignore ) { _name . typeCheck ( stable ) ; if ( _namespace != null ) { _namespace . typeCheck ( stable ) ; } } typeCheckContents ( stable ) ; return Type . Void ; } public void translateLiteral ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( ! _ignore ) { il . append ( methodGen . loadHandler ( ) ) ; _name . translate ( classGen , methodGen ) ; il . append ( DUP2 ) ; il . append ( methodGen . startElement ( ) ) ; if ( _namespace != null ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _prefix ) ) ; _namespace . translate ( classGen , methodGen ) ; il . append ( methodGen . namespace ( ) ) ; } } translateContents ( classGen , methodGen ) ; if ( ! _ignore ) { il . append ( methodGen . endElement ( ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { LocalVariableGen local = null ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _isLiteralName ) { translateLiteral ( classGen , methodGen ) ; return ; } if ( ! _ignore ) { il . append ( methodGen . loadHandler ( ) ) ; _name . translate ( classGen , methodGen ) ; if ( _namespace != null ) { _namespace . translate ( classGen , methodGen ) ; } else { il . append ( ACONST_NULL ) ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "startXslElement" , "(" + STRING_SIG + STRING_SIG + TRANSLET_OUTPUT_SIG + DOM_INTF_SIG + "I)" + STRING_SIG ) ) ) ; } translateContents ( classGen , methodGen ) ; if ( ! _ignore ) { il . append ( methodGen . endElement ( ) ) ; } } public void translateContents ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) getContents ( ) . elementAt ( i ) ; if ( _ignore && item instanceof XslAttribute ) continue ; item . translate ( classGen , methodGen ) ; } } } 	1
package org . apache . xml . dtm . ref ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public interface IncrementalSAXSource { public void setContentHandler ( ContentHandler handler ) ; public void setLexicalHandler ( org . xml . sax . ext . LexicalHandler handler ) ; public void setDTDHandler ( org . xml . sax . DTDHandler handler ) ; public Object deliverMoreNodes ( boolean parsemore ) ; public void startParse ( InputSource source ) throws SAXException ; } 	0
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; public class ToUnknownStream extends SerializerBase { private SerializationHandler m_handler ; private static final String EMPTYSTRING = "" ; private boolean m_wrapped_handler_not_initialized = false ; private String m_firstElementPrefix ; private String m_firstElementName ; private String m_firstElementURI ; private String m_firstElementLocalName = null ; private boolean m_firstTagNotEmitted = true ; private Vector m_namespaceURI = null ; private Vector m_namespacePrefix = null ; private boolean m_needToCallStartDocument = false ; private boolean m_setVersion_called = false ; private boolean m_setDoctypeSystem_called = false ; private boolean m_setDoctypePublic_called = false ; private boolean m_setMediaType_called = false ; public ToUnknownStream ( ) { m_handler = new ToXMLStream ( ) ; } public ContentHandler asContentHandler ( ) throws IOException { return this ; } public void close ( ) { m_handler . close ( ) ; } public Properties getOutputFormat ( ) { return m_handler . getOutputFormat ( ) ; } public OutputStream getOutputStream ( ) { return m_handler . getOutputStream ( ) ; } public Writer getWriter ( ) { return m_handler . getWriter ( ) ; } public boolean reset ( ) { return m_handler . reset ( ) ; } public void serialize ( Node node ) throws IOException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . serialize ( node ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { return m_handler . setEscaping ( escape ) ; } public void setOutputFormat ( Properties format ) { m_handler . setOutputFormat ( format ) ; } public void setOutputStream ( OutputStream output ) { m_handler . setOutputStream ( output ) ; } public void setWriter ( Writer writer ) { m_handler . setWriter ( writer ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . addAttribute ( uri , localName , rawName , type , value ) ; } public void addAttribute ( String rawName , String value ) { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . addAttribute ( rawName , value ) ; } public void characters ( String chars ) throws SAXException { final char [ ] arr = chars . toCharArray ( ) ; this . characters ( arr , 0 , arr . length ) ; } public void endElement ( String elementName ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . endElement ( elementName ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { this . startPrefixMapping ( prefix , uri , true ) ; } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( m_firstTagNotEmitted && m_firstElementURI == null && m_firstElementName != null ) { String prefix1 = getPrefixPart ( m_firstElementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_firstElementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { boolean pushed = false ; if ( m_firstTagNotEmitted ) { if ( m_firstElementName != null && shouldFlush ) { flush ( ) ; pushed = m_handler . startPrefixMapping ( prefix , uri , shouldFlush ) ; } else { if ( m_namespacePrefix == null ) { m_namespacePrefix = new Vector ( ) ; m_namespaceURI = new Vector ( ) ; } m_namespacePrefix . addElement ( prefix ) ; m_namespaceURI . addElement ( uri ) ; if ( m_firstElementURI == null ) { if ( prefix . equals ( m_firstElementPrefix ) ) m_firstElementURI = uri ; } } } else { pushed = m_handler . startPrefixMapping ( prefix , uri , shouldFlush ) ; } return pushed ; } public void setVersion ( String version ) { m_handler . setVersion ( version ) ; m_setVersion_called = true ; } public void startDocument ( ) throws SAXException { m_needToCallStartDocument = true ; } public void startElement ( String qName ) throws SAXException { this . startElement ( null , null , qName , null ) ; } public void startElement ( String namespaceURI , String localName , String qName ) throws SAXException { this . startElement ( namespaceURI , localName , qName , null ) ; } public void startElement ( String namespaceURI , String localName , String elementName , Attributes atts ) throws SAXException { if ( m_firstTagNotEmitted ) { if ( m_firstElementName != null ) { flush ( ) ; m_handler . startElement ( namespaceURI , localName , elementName , atts ) ; } else { m_wrapped_handler_not_initialized = true ; m_firstElementName = elementName ; m_firstElementPrefix = getPrefixPartUnknown ( elementName ) ; m_firstElementURI = namespaceURI ; m_firstElementLocalName = localName ; if ( atts != null ) super . addAttributes ( atts ) ; if ( atts != null ) flush ( ) ; } } else { m_handler . startElement ( namespaceURI , localName , elementName , atts ) ; } } public void comment ( String comment ) throws SAXException { if ( m_firstTagNotEmitted && m_firstElementName != null ) { emitFirstTag ( ) ; } else if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } m_handler . comment ( comment ) ; } public String getDoctypePublic ( ) { return m_handler . getDoctypePublic ( ) ; } public String getDoctypeSystem ( ) { return m_handler . getDoctypeSystem ( ) ; } public String getEncoding ( ) { return m_handler . getEncoding ( ) ; } public boolean getIndent ( ) { return m_handler . getIndent ( ) ; } public int getIndentAmount ( ) { return m_handler . getIndentAmount ( ) ; } public String getMediaType ( ) { return m_handler . getMediaType ( ) ; } public boolean getOmitXMLDeclaration ( ) { return m_handler . getOmitXMLDeclaration ( ) ; } public String getStandalone ( ) { return m_handler . getStandalone ( ) ; } public String getVersion ( ) { return m_handler . getVersion ( ) ; } public void setDoctype ( String system , String pub ) { m_handler . setDoctypePublic ( pub ) ; m_handler . setDoctypeSystem ( system ) ; } public void setDoctypePublic ( String doctype ) { m_handler . setDoctypePublic ( doctype ) ; m_setDoctypePublic_called = true ; } public void setDoctypeSystem ( String doctype ) { m_handler . setDoctypeSystem ( doctype ) ; m_setDoctypeSystem_called = true ; } public void setEncoding ( String encoding ) { m_handler . setEncoding ( encoding ) ; } public void setIndent ( boolean indent ) { m_handler . setIndent ( indent ) ; } public void setIndentAmount ( int value ) { m_handler . setIndentAmount ( value ) ; } public void setMediaType ( String mediaType ) { m_handler . setMediaType ( mediaType ) ; m_setMediaType_called = true ; } public void setOmitXMLDeclaration ( boolean b ) { m_handler . setOmitXMLDeclaration ( b ) ; } public void setStandalone ( String standalone ) { m_handler . setStandalone ( standalone ) ; } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { m_handler . attributeDecl ( arg0 , arg1 , arg2 , arg3 , arg4 ) ; } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } m_handler . elementDecl ( arg0 , arg1 ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . externalEntityDecl ( name , publicId , systemId ) ; } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . internalEntityDecl ( arg0 , arg1 ) ; } public void characters ( char [ ] characters , int offset , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . characters ( characters , offset , length ) ; } public void endDocument ( ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . endDocument ( ) ; } public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; if ( namespaceURI == null && m_firstElementURI != null ) namespaceURI = m_firstElementURI ; if ( localName == null && m_firstElementLocalName != null ) localName = m_firstElementLocalName ; } m_handler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { m_handler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { m_handler . setDocumentLocator ( locator ) ; } public void skippedEntity ( String name ) throws SAXException { m_handler . skippedEntity ( name ) ; } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . comment ( ch , start , length ) ; } public void endCDATA ( ) throws SAXException { m_handler . endCDATA ( ) ; } public void endDTD ( ) throws SAXException { m_handler . endDTD ( ) ; } public void endEntity ( String name ) throws SAXException { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } m_handler . endEntity ( name ) ; } public void startCDATA ( ) throws SAXException { m_handler . startCDATA ( ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_handler . startDTD ( name , publicId , systemId ) ; } public void startEntity ( String name ) throws SAXException { m_handler . startEntity ( name ) ; } private void initStreamOutput ( ) throws SAXException { boolean firstElementIsHTML = isFirstElemHTML ( ) ; if ( firstElementIsHTML ) { SerializationHandler oldHandler = m_handler ; Properties htmlProperties = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; Serializer serializer = SerializerFactory . getSerializer ( htmlProperties ) ; m_handler = ( SerializationHandler ) serializer ; Writer writer = oldHandler . getWriter ( ) ; if ( null != writer ) m_handler . setWriter ( writer ) ; else { OutputStream os = oldHandler . getOutputStream ( ) ; if ( null != os ) m_handler . setOutputStream ( os ) ; } m_handler . setVersion ( oldHandler . getVersion ( ) ) ; m_handler . setDoctypeSystem ( oldHandler . getDoctypeSystem ( ) ) ; m_handler . setDoctypePublic ( oldHandler . getDoctypePublic ( ) ) ; m_handler . setMediaType ( oldHandler . getMediaType ( ) ) ; m_handler . setTransformer ( oldHandler . getTransformer ( ) ) ; } if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } m_wrapped_handler_not_initialized = false ; } private void emitFirstTag ( ) throws SAXException { if ( m_firstElementName != null ) { if ( m_wrapped_handler_not_initialized ) { initStreamOutput ( ) ; m_wrapped_handler_not_initialized = false ; } m_handler . startElement ( m_firstElementURI , null , m_firstElementName , m_attributes ) ; m_attributes = null ; if ( m_namespacePrefix != null ) { final int n = m_namespacePrefix . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final String prefix = ( String ) m_namespacePrefix . elementAt ( i ) ; final String uri = ( String ) m_namespaceURI . elementAt ( i ) ; m_handler . startPrefixMapping ( prefix , uri , false ) ; } m_namespacePrefix = null ; m_namespaceURI = null ; } m_firstTagNotEmitted = false ; } } private String getLocalNameUnknown ( String value ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . lastIndexOf ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; } private String getPrefixPartUnknown ( String qname ) { final int index = qname . indexOf ( ':' ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : EMPTYSTRING ; } private boolean isFirstElemHTML ( ) { boolean isHTML ; isHTML = getLocalNameUnknown ( m_firstElementName ) . equalsIgnoreCase ( "html" ) ; if ( isHTML && m_firstElementURI != null && ! EMPTYSTRING . equals ( m_firstElementURI ) ) { isHTML = false ; } if ( isHTML && m_namespacePrefix != null ) { final int max = m_namespacePrefix . size ( ) ; for ( int i = 0 ; i < max ; i ++ ) { final String prefix = ( String ) m_namespacePrefix . elementAt ( i ) ; final String uri = ( String ) m_namespaceURI . elementAt ( i ) ; if ( m_firstElementPrefix != null && m_firstElementPrefix . equals ( prefix ) && ! EMPTYSTRING . equals ( uri ) ) { isHTML = false ; break ; } } } return isHTML ; } public DOMSerializer asDOMSerializer ( ) throws IOException { return m_handler . asDOMSerializer ( ) ; } public void setCdataSectionElements ( Vector URI_and_localNames ) { m_handler . setCdataSectionElements ( URI_and_localNames ) ; } public void addAttributes ( Attributes atts ) throws SAXException { m_handler . addAttributes ( atts ) ; } public NamespaceMappings getNamespaceMappings ( ) { NamespaceMappings mappings = null ; if ( m_handler != null ) { mappings = m_handler . getNamespaceMappings ( ) ; } return mappings ; } public void flushPending ( ) { flush ( ) ; m_handler . flushPending ( ) ; } private void flush ( ) { try { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } } catch ( SAXException e ) { throw new RuntimeException ( e . toString ( ) ) ; } } public String getPrefix ( String namespaceURI ) { return m_handler . getPrefix ( namespaceURI ) ; } public void entityReference ( String entityName ) throws SAXException { m_handler . entityReference ( entityName ) ; } public String getNamespaceURI ( String qname , boolean isElement ) { return m_handler . getNamespaceURI ( qname , isElement ) ; } public String getNamespaceURIFromPrefix ( String prefix ) { return m_handler . getNamespaceURIFromPrefix ( prefix ) ; } public void setTransformer ( Transformer t ) { m_handler . setTransformer ( t ) ; } public Transformer getTransformer ( ) { return m_handler . getTransformer ( ) ; } public void setContentHandler ( ContentHandler ch ) { m_handler . setContentHandler ( ch ) ; } public void setSourceLocator ( SourceLocator locator ) { m_handler . setSourceLocator ( locator ) ; } } 	0
package org . apache . xml . utils . res ; public class XResources_it extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1
package org . apache . xml . utils . res ; public class XResources_ko extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ko" } , { "help_language" , "ko" } , { "language" , "ko" } , { "alphabet" , new char [ ] { 0x3131 , 0x3134 , 0x3137 , 0x3139 , 0x3141 , 0x3142 , 0x3145 , 0x3147 , 0x3148 , 0x314a , 0x314b , 0x314c , 0x314d , 0x314e , 0x314f , 0x3151 , 0x3153 , 0x3155 , 0x3157 , 0x315b , 0x315c , 0x3160 , 0x3161 , 0x3163 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ 0 ] } , { "multiplier" , new int [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0xc5b5 , 0xb9cc , 0xcc9c , 0xbc31 , 0xc2ed } } , { "digits" , new char [ ] { 0xc77c , 0xc774 , 0xc0bc , 0xc0ac , 0xc624 , 0xc721 , 0xce60 , 0xd314 , 0xad6c } } , { "tables" , new String [ ] { "digits" } } } ; } 	1
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . PrefixResolverDefault ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class CachedXPathAPI { protected XPathContext xpathSupport ; public CachedXPathAPI ( ) { xpathSupport = new XPathContext ( ) ; } public CachedXPathAPI ( CachedXPathAPI priorXPathAPI ) { xpathSupport = priorXPathAPI . xpathSupport ; } public XPathContext getXPathContext ( ) { return this . xpathSupport ; } public Node selectSingleNode ( Node contextNode , String str ) throws TransformerException { return selectSingleNode ( contextNode , str , contextNode ) ; } public Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } public NodeIterator selectNodeIterator ( Node contextNode , String str ) throws TransformerException { return selectNodeIterator ( contextNode , str , contextNode ) ; } public NodeIterator selectNodeIterator ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodeset ( ) ; } public NodeList selectNodeList ( Node contextNode , String str ) throws TransformerException { return selectNodeList ( contextNode , str , contextNode ) ; } public NodeList selectNodeList ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodelist ( ) ; } public XObject eval ( Node contextNode , String str ) throws TransformerException { return eval ( contextNode , str , contextNode ) ; } public XObject eval ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { PrefixResolverDefault prefixResolver = new PrefixResolverDefault ( ( namespaceNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) namespaceNode ) . getDocumentElement ( ) : namespaceNode ) ; XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } public XObject eval ( Node contextNode , String str , PrefixResolver prefixResolver ) throws TransformerException { XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; XPathContext xpathSupport = new XPathContext ( ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ForEach extends Instruction { private Expression _select ; private Type _type ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ForEach" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; parseChildren ( parser ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; } else { final Expression fpe = new ForwardPositionExpr ( _select ) ; _select . setParent ( fpe ) ; fpe . setParser ( _select . getParser ( ) ) ; _select = fpe ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _type = _select . typeCheck ( stable ) ; if ( _type instanceof ReferenceType || _type instanceof NodeType ) { _select = new CastExpr ( _select , Type . NodeSet ) ; typeCheckContents ( stable ) ; return Type . Void ; } if ( _type instanceof NodeSetType || _type instanceof ResultTreeType ) { typeCheckContents ( stable ) ; return Type . Void ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; final Vector sortObjects = new Vector ( ) ; Enumeration children = elements ( ) ; while ( children . hasMoreElements ( ) ) { final Object child = children . nextElement ( ) ; if ( child instanceof Sort ) { sortObjects . addElement ( child ) ; } } if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { il . append ( methodGen . loadDOM ( ) ) ; if ( sortObjects . size ( ) > 0 ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . RESULT_TREE_SORT_ERR , this ) ; getParser ( ) . reportError ( WARNING , msg ) ; } _select . translate ( classGen , methodGen ) ; _type . translateTo ( classGen , methodGen , Type . NodeSet ) ; il . append ( SWAP ) ; il . append ( methodGen . storeDOM ( ) ) ; } else { if ( sortObjects . size ( ) > 0 ) { Sort . translateSortIterator ( classGen , methodGen , _select , sortObjects ) ; } else { _select . translate ( classGen , methodGen ) ; } if ( _type instanceof ReferenceType == false ) { _select . startResetIterator ( classGen , methodGen ) ; } } il . append ( methodGen . storeIterator ( ) ) ; initializeVariables ( classGen , methodGen ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; translateContents ( classGen , methodGen ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { il . append ( methodGen . storeDOM ( ) ) ; } il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; } public void initializeVariables ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Object child = getContents ( ) . elementAt ( i ) ; if ( child instanceof Variable ) { Variable var = ( Variable ) child ; var . initialize ( classGen , methodGen ) ; } } } } 	0
package org . apache . xml . utils ; public class StringVector implements java . io . Serializable { protected int m_blocksize ; protected String m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public StringVector ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; } public StringVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; } public int getLength ( ) { return m_firstFree ; } public final int size ( ) { return m_firstFree ; } public final void addElement ( String value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final String elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( String s ) { if ( null == s ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( s ) ) return true ; } return false ; } public final boolean containsIgnoreCase ( String s ) { if ( null == s ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equalsIgnoreCase ( s ) ) return true ; } return false ; } public final void push ( String s ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = s ; m_firstFree ++ ; } public final String pop ( ) { if ( m_firstFree <= 0 ) return null ; m_firstFree -- ; String s = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = null ; return s ; } public final String peek ( ) { return ( m_firstFree <= 0 ) ? null : m_map [ m_firstFree - 1 ] ; } } 	1
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; public final class DupFilterIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private IntegerArray _nodes = new IntegerArray ( ) ; private int _current = 0 ; private int _nodesSize = 0 ; private int _lastNext = END ; public DupFilterIterator ( DTMAxisIterator source ) { _source = source ; if ( source instanceof KeyIndex ) { setStartNode ( DTMDefaultBase . ROOTNODE ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( _source instanceof KeyIndex && _startNode == DTMDefaultBase . ROOTNODE ) { return this ; } if ( node != _startNode ) { _source . setStartNode ( _startNode = node ) ; _nodes . clear ( ) ; while ( ( node = _source . next ( ) ) != END ) { _nodes . add ( node ) ; } _nodes . sort ( ) ; _nodesSize = _nodes . cardinality ( ) ; _current = 0 ; _lastNext = END ; resetPosition ( ) ; } } return this ; } public int next ( ) { while ( _current < _nodesSize ) { final int next = _nodes . at ( _current ++ ) ; if ( next != _lastNext ) { return returnNode ( _lastNext = next ) ; } } return END ; } public DTMAxisIterator cloneIterator ( ) { try { final DupFilterIterator clone = ( DupFilterIterator ) super . clone ( ) ; clone . _nodes = ( IntegerArray ) _nodes . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public void setMark ( ) { _markedNode = _current ; } public void gotoMark ( ) { _current = _markedNode ; } public DTMAxisIterator reset ( ) { _current = 0 ; _lastNext = END ; return resetPosition ( ) ; } } 	1
package org . apache . xalan . res ; public class XSLTErrorResources_sv extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Fel: Kan inte ha '{' inuti uttryck" } , { ER_ILLEGAL_ATTRIBUTE , "{0} har ett otillåtet attribut: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode är null i xsl:apply-imports!" } , { ER_CANNOT_ADD , "Kan inte lägga {0} till {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode är null i handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} måste ha ett namn-attribut." } , { ER_TEMPLATE_NOT_FOUND , "Hittade inte mallen med namn: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Kunde inte lösa namn-AVT i xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} kräver attribut: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} måste ha ett ''test''-attribut." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Dåligt värde på nivå-attribut: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Namn på behandlande instruktion får inte vara 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Namn på behandlande instruktion måste vara ett giltigt NCNamn: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} måste ha ett matchningsattribut om det har ett tillstånd." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} kräver antingen ett namn eller ett matchningsattribut." } , { ER_CANT_RESOLVE_NSPREFIX , "Kan inte lösa namnrymdsprefix: {0}" } , { ER_ILLEGAL_VALUE , "xml:space har ett otillåtet värde: {0}" } , { ER_NO_OWNERDOC , "Barnnod saknar ägardokument!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement-fel: {0}" } , { ER_NULL_CHILD , "Försöker lägga till ett null-barn!" } , { ER_NEED_SELECT_ATTRIB , "{0} kräver ett valattribut." } , { ER_NEED_TEST_ATTRIB , "xsl:when måste ha ett 'test'-attribut." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param måste ha ett 'namn'-attribut." } , { ER_NO_CONTEXT_OWNERDOC , "Kontext saknar ägardokument!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Kunde inte skapa XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Process misslyckades." } , { ER_NOT_SUCCESSFUL , "Xalan: misslyckades." } , { ER_ENCODING_NOT_SUPPORTED , "Kodning inte understödd: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Kunde inte skapa TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key måste ha ett 'namn'-attribut." } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key måste ha ett 'matcha'-attribut." } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key måste ha ett 'använd'-attribut." } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} kräver ett ''element''-attribut!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} ''prefix''-attribut saknas" } , { ER_BAD_STYLESHEET_URL , "Stylesheet URL är dålig: {0}" } , { ER_FILE_NOT_FOUND , "Stylesheet-fil saknas: {0}" } , { ER_IOEXCEPTION , "Fick IO-Undantag med stylesheet-fil: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Hittade inte href-attribute för {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} inkluderar, direkt eller indirekt, sig själv!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude-fel, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} ''lang''-attribut' saknas" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) felplacerade {0} element?? Saknar behållarelement  ''komponent''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Kan endast skicka utdata till ett Element, ett DocumentFragment, ett Document, eller en PrintWriter." } , { ER_PROCESS_ERROR , "StylesheetRoot.process-fel" } , { ER_UNIMPLNODE_ERROR , "UnImplNode-fel: {0}" } , { ER_NO_SELECT_EXPRESSION , "Fel! Hittade inte xpath select-uttryck (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Kan inte serialisera en XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Stylesheet-indata ej angiven!" } , { ER_FAILED_PROCESS_STYLESHEET , "Kunde inte behandla stylesheet!" } , { ER_COULDNT_PARSE_DOC , "Kunde inte tolka {0} dokument!" } , { ER_COULDNT_FIND_FRAGMENT , "Hittade inte fragment: {0}" } , { ER_NODE_NOT_ELEMENT , "Nod som pekades på av fragment-identifierare var inte ett element: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each kräver antingen en matchning eller ett namnattribut." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "mallar kräver antingen en matchning eller ett namnattribut." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Ingen klon av ett dokumentfragment!" } , { ER_CANT_CREATE_ITEM , "Kan inte skapa element i resultatträd: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space i käll-XML har ett otillåtet värde: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Det finns ingen xsl:key-deklaration för {0}!" } , { ER_CANT_CREATE_URL , "Fel! Kan inte skapa url för: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions är inte understödd" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory-Fel" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} är inte tillåten inne i ett stylesheet!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns inte längre understödd!  Använd xsl:output istället." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space inte längre understödd!  Använd xsl:strip-space eller xsl:preserve-space istället." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result inte längre understödd!  Använd xsl:output istället." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} har ett otillåtet attribut: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Okänt XSL-element: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort kan endast användas med xsl:apply-templates eller xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) felplacerade xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when härstammar inte från xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) felplacerade xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise härstammar inte från xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} är inte tillåten inne i en mall!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} utbyggnadsnamnrymdsprefix {1} okänt" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports kan endast förekomma som de första elementen i ett stylesheet!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} importerar, direkt eller indirekt, sig själv!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space har ett otillåtet värde: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet misslyckades!" } , { ER_SAX_EXCEPTION , "SAX-Undantag" } , { ER_XSLT_ERROR , "XSLT-fel" } , { ER_CURRENCY_SIGN_ILLEGAL , "valutatecken är inte tillåtet i formatmönstersträng" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Dokumentfunktion inte understödd i Stylesheet DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Kan inte lösa prefix i icke-Prefixlösare!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension: Hittade inte filnamn - fil eller valattribut måste returnera vald  sträng." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Kan inte bygga FormatterListener i Redirect extension!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Prefix i exkludera-resultat-prefix är inte giltig: {0}" } , { ER_MISSING_NS_URI , "Namnrymds-URI saknas för angivna prefix" } , { ER_MISSING_ARG_FOR_OPTION , "Argument saknas för alternativ: {0}" } , { ER_INVALID_OPTION , "Ogiltigt alternativ: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Fel format på formatsträng: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet måste ha ett 'version'-attribut!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attribut: {0} har ett otillåtet värde: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose kräver ett xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports inte tillåtet i ett xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Kan inte använda DTMLiaison till en DOM utdatanod... skicka en org.apache.xpath.DOM2Helper istället!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Kan inte använda DTMLiaison till en DOM indatanod... skicka en org.apache.xpath.DOM2Helper istället!" } , { ER_CALL_TO_EXT_FAILED , "Anrop till anslutningselement misslyckades: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Prefix måste lösa till en mamnrymd: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Ogiltigt UTF-16-surrogat upptäckt: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} använde sig självt, vilket kommer att orsaka en  oändlig loop." } , { ER_CANNOT_MIX_XERCESDOM , "Kan inte blanda icke-Xerces-DOM-indata med Xerces-DOM-utdata!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "I ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Hittade mer än en mall med namnet: {0}" } , { ER_INVALID_KEY_CALL , "Ogiltigt funktionsanrop: rekursiva key()-anrop är inte tillåtna" } , { ER_REFERENCING_ITSELF , "Variabel {0} hänvisar, direkt eller indirekt, till sig själv!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Indatanoden till en DOMSource för newTemplates får inte vara null!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Klassfil för alternativ {0} saknas" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Nödvändigt element saknas: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream får inte vara null" } , { ER_URI_CANNOT_BE_NULL , "URI får inte vara null" } , { ER_FILE_CANNOT_BE_NULL , "Fil får inte vara null" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource får inte vara null" } , { ER_CANNOT_INIT_BSFMGR , "Kan inte initialisera BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Kunde inte kompilera anslutning" } , { ER_CANNOT_CREATE_EXTENSN , "Kunde inte skapa anslutning: {0} på grund av: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Instansmetodanrop till metod {0} kräver en Objektinstans som första argument" } , { ER_INVALID_ELEMENT_NAME , "Ogiltigt elementnamn angivet {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Elementnamnmetod måste vara static {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Anslutningsfunktion {0} : {1} är okänd" } , { ER_MORE_MATCH_CONSTRUCTOR , "Fler än en bästa matchning för konstruktor för {0}" } , { ER_MORE_MATCH_METHOD , "Fler än en bästa matchning för metod {0}" } , { ER_MORE_MATCH_ELEMENT , "Fler än en bästa matchning för elementmetod {0}" } , { ER_INVALID_CONTEXT_PASSED , "Ogiltig kontext skickad för att utvärdera {0}" } , { ER_POOL_EXISTS , "Pool finns redan" } , { ER_NO_DRIVER_NAME , "Inget driver-namn angivet" } , { ER_NO_URL , "Ingen URL angiven" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Poolstorlek är mindre än ett!" } , { ER_INVALID_DRIVER , "Ogiltigt driver-namn angivet" } , { ER_NO_STYLESHEETROOT , "Hittade inte stylesheet-roten!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Ogiltigt värde för xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode misslyckades" } , { ER_RESOURCE_COULD_NOT_LOAD , "Resursen [ {0} ] kunde inte laddas: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Bufferstorlek <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Okänt fel vid anslutningsanrop" } , { ER_NO_NAMESPACE_DECL , "Prefix{0} har inte en motsvarande namnrymdsdeklaration" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Elementinnehåll är inte tillåtet för lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stylesheet-ledd avslutning" } , { ER_ONE_OR_TWO , "1 eller 2" } , { ER_TWO_OR_THREE , "2 eller 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Kunde inte ladda {0} (kontrollera CLASSPATH), använder nu enbart standard" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Kan inte initialisera standardmallar" } , { ER_RESULT_NULL , "Result borde inte vara null" } , { ER_RESULT_COULD_NOT_BE_SET , "Result kunde inte sättas" } , { ER_NO_OUTPUT_SPECIFIED , "Ingen utdata angiven" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Kan inte omvandla till en Result av typ {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Kan inte omvandla en Source av typ {0}" } , { ER_NULL_CONTENT_HANDLER , "Innehållshanterare med värde null" } , { ER_NULL_ERROR_HANDLER , "Felhanterare med värde null" } , { ER_CANNOT_CALL_PARSE , "parse kan inte anropas om ContentHandler inte har satts" } , { ER_NO_PARENT_FOR_FILTER , "Ingen förälder till filter" } , { ER_NO_STYLESHEET_IN_MEDIA , "Stylesheet saknas i: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "xml-stylesheet PI saknas i: {0}" } , { ER_NOT_SUPPORTED , "Understöds inte: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Värde på egenskap {0} borde vara en Boolesk instans" } , { "ER_SRC_ATTRIB_NOT_SUPPORTED" , "src-attributet understöds ännu inte för {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Resursen [ {0} ] saknas. \n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Utdata-egenskap känns inte igen: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Kunde inte skapa instans av ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "Värdet för {0} bör innehålla en siffra som inte kan tolkas" } , { ER_VALUE_SHOULD_EQUAL , "Värde på {0} borde motsvara ja eller nej" } , { ER_FAILED_CALLING_METHOD , " Kunde inte anropa metoden {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Kunde inte skapa instans av ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "Tecken är inte tillåtna i dokumentet vid den här tidpunkten" } , { ER_ATTR_NOT_ALLOWED , "Attributet \"{0}\" är inte tillåten i det {1} elementet!" } , { ER_BAD_VALUE , "{0} dåligt värde {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Attributet {0} saknas " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Attributvärdet {0} känns inte igen " } , { ER_NULL_URI_NAMESPACE , "Försöker generera ett namnområdesprefix med en null-URI" } , { ER_NUMBER_TOO_BIG , "Försöker formatera en siffra som är större än det största långa heltalet" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Det går inte att hitta SAX1-drivrutinen klass {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1-drivrutinen klass {0} hittades men kan inte laddas" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1-drivrutinen klass {0} hittades men kan inte instansieras" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1-drivrutinen klass {0} implementerar inte org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Systemegenskapen org.xml.sax.parser är inte angiven" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Tolkningsargumentet får inte vara null" } , { ER_FEATURE , "Funktion:a {0}" } , { ER_PROPERTY , "Egenskap:a {0}" } , { ER_NULL_ENTITY_RESOLVER , "Nullenhetslösare" } , { ER_NULL_DTD_HANDLER , "Null-DTD-hanterare" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Inget drivrutinsnamn är angett!" } , { ER_NO_URL_SPECIFIED , "Ingen URL har angetts!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Poolstorleken är mindre än 1!" } , { ER_INVALID_DRIVER_NAME , "Ett ogiltigt drivrutinsnamn har angetts!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programmerarfel! expr har inget överordnat ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programmerarkontroll i RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} är inte tillåten i denna position i formatmallen!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Text utan blanksteg är inte tillåten i denna position i formatmallen!" } , { INVALID_TCHAR , "Ogiltigt värde: {1} används för CHAR-attributet: {0}.  Ett attribut av CHAR-typ får bara ha 1 tecken!" } , { INVALID_QNAME , "Ogiltigt värde:a {1} används för QNAME-attributet:a {0}" } , { INVALID_ENUM , "Ogiltigt värde:a  {1} används för ENUM-attributet:a {0}.  Giltiga värden är:a {2}." } , { INVALID_NMTOKEN , "Ogiltigt värde:a {1} används för NMTOKEN-attributet:a {0} " } , { INVALID_NCNAME , "Ogiltigt värde:a {1} används för NCNAME-attributet:a {0} " } , { INVALID_BOOLEAN , "Ogiltigt värde:a {1} används som Booleskt attribut:a {0} " } , { INVALID_NUMBER , "Ogiltigt värde:a {1} används som sifferattribut:a {0} " } , { ER_ARG_LITERAL , "Argument för {0} i matchningsmönstret måste vara literalt." } , { ER_DUPLICATE_GLOBAL_VAR , "Dubbel deklaration av global variabel." } , { ER_DUPLICATE_VAR , "Dubbel variabeldeklaration." } , { ER_TEMPLATE_NAME_MATCH , "xsl: en mall måste ha ett namn och ett matchningsattribut (eller både och)" } , { ER_INVALID_PREFIX , "Prefix i exclude-result-prefixes är ogiltigt:a {0}" } , { ER_NO_ATTRIB_SET , "attributserien {0} finns inte" } , { WG_FOUND_CURLYBRACE , "Hittade '}' men ingen attributmall är öppen!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Varning: räknarattribut matchar inte en förfäder in xsl:number! Target = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Gammal syntax: Namnet på  'expr'-attributet har ändrats till 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan hanterar ännu inte locale-namnet i funktionen format-number." } , { WG_LOCALE_NOT_FOUND , "Varning: Hittade inte locale för xml:lang{0}" } , { WG_CANNOT_MAKE_URL_FROM , "Kan inte skapa URL från: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Kan inte ladda begärd doc: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Hittade inte Collator för <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Gammal syntax: Funktionsinstruktionen borde använda en url av {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "kodning understöds inte: {0}, använder UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "kodning understöds inte: {0}, använder Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Hittade specificitetskonflikter: {0} Senast hittade i stylesheet kommer att användas." } , { WG_PARSING_AND_PREPARING , "========= Tolkar och förbereder {0} ==========" } , { WG_ATTR_TEMPLATE , "Attributmall, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Matcha konflikter mellan xsl:strip-space och xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan hanterar ännu inte attributet {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Deklaration saknas för decimalformat: {0}" } , { WG_OLD_XSLT_NS , "XSLT-Namnrymd saknas eller är inkorrekt " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Endast en standarddeklaration av xsl:decimal-format är tillåten." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-formatnamn måste vara unika. Namnet \"{0}\" har blivit duplicerat." } , { WG_ILLEGAL_ATTRIBUTE , "{0} har ett otillåtet attribut: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Kan inte lösa namnrymdsprefix: {0}. Noden kommer att ignoreras." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet måste ha ett 'version'-attribut!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Otillåtet attributnamn: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Ogiltigt värde använt för attribut {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Den resulterande nodmängden från dokumentfunktions andra argument är tomt. Det första argumentet kommer att användas." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Värdet på attributet 'name' i xsl:processing-instruction får inte vara 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Värdet på attributet  ''name'' i xsl:processing-instruction måste vara ett giltigt NCName:a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Det går inte att lägga till attributet {0} efter undernoder eller innan ett element produceras. Attributet ignoreras." } , { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "version" , ">>>>>>> Xalan Version" } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Rad #" } , { "column" , "Kolumn #" } , { "xsldone" , "XSLProcessor: färdig" } , { "xslProc_option" , "Xalan-J kommando linje Process klass alternativ:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT utdataFilnamn]" } , { "optionLXCIN" , "   [-LXCIN kompileratStylesheetFilnameIn]" } , { "optionLXCOUT" , "   [-LXCOUT kompileratStylesheetFilenameUt]" } , { "optionPARSER" , "   [-PARSER fullt kvalificerat klassnamn eller tolkförbindelse]" } , { "optionE" , "   [-E (Utöka inte enhetsreferenser)]" } , { "optionV" , "   [-E (Utöka inte enhetsreferenser)]" } , { "optionQC" , "   [-QC (Tysta Mönsterkonfliktvarningar)]" } , { "optionQ" , "   [-Q  (Tyst Tillstånd)]" } , { "optionLF" , "   [-LF (Använd radframmatning enbart på utdata {standard är CR/LF})]" } , { "optionCR" , "   [-CR (Använd vagnretur enbart på utdata {standard är CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Vilka tecken är skiftningstecken {standard är <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Bestäm antal blanksteg för att tabulera {standard är 0})]" } , { "optionTT" , "   [-TT (Spåra mallarna allt eftersom de blir anropade.)]" } , { "optionTG" , "   [-TG (Spåra varje generationshändelse.)]" } , { "optionTS" , "   [-TS (Spåra varje valhändelse.)]" } , { "optionTTC" , "   [-TTC (Spåra mallbarnen allt eftersom de blir behandlade.)]" } , { "optionTCLASS" , "   [-TCLASS (TraceListener-klass för spårningsanslutningar.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Sätt om validering ska ske.  Standard är att validering är avstängd)]" } , { "optionEDUMP" , "   [-EDUMP {valfritt filnamn) (Gör stackdump vid fel.)]" } , { "optionXML" , "   [-XML (Använd XML-formaterare och lägg till XML-huvud.)]" } , { "optionTEXT" , "   [-XML (Använd enkel Text-formaterare.)]" } , { "optionHTML" , "   [-HTML (Använd HTML-formaterare)]" } , { "optionPARAM" , "   [-PARAM namn uttryck (Sätt en stylesheet-parameter)]" } , { "noParsermsg1" , "XSL-Process misslyckades." } , { "noParsermsg2" , "** Hittade inte tolk **" } , { "noParsermsg3" , "Vänligen kontrollera din classpath" } , { "noParsermsg4" , "Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER fullständigt klassnamn (URIResolver som ska användas för att lösa URI-er)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER fullständigt klassnamn (EntityResolver som ska användas för att lösa enheter)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTRESOLVER fullständigt klassnamn (ContentHandler som ska användas för att serialisera utdata)]" } , { "optionLINENUMBERS" , "   [-L använd radnummer i källdokument]" } , { "optionMEDIA" , " [-MEDIA mediaType (använd medieattribut för att hitta en formatmall som är associerad med ett dokument.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (Använd s2s=SAX eller d2d=DOM för transformationen.)] " } , { "optionDIAG" , " [-DIAG (Skriv ut totala transformationer, millisekunder.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (begär inkrementell DTM-konstruktion genom att ange http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (begär ingen formatmallsoptimering genom att ange http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , " [-RL recursionlimit (kontrollera numerisk gräns på formatmallens rekursionsdjup.)]" } , { "optionXO" , " [-XO [transletName] (tilldela namnet till genererad translet)]" } , { "optionXD" , " [-XD destinationDirectory (ange målkatalog för translet)]" } , { "optionXJ" , " [-XJ jarfile (paketerar transletklasserna i en jar-fil med namnet <jarfile>)]" } , { "optionXP" , " [-XP-paket (anger ett paketnamnsprefix för alla genererade transletklasser)]" } } ; public static final String BAD_CODE = "DÅLIG_KOD" ; public static final String FORMAT_FAILED = "FORMATERING_MISSLYCKADES" ; public static final String ERROR_STRING = "#fel" ; public static final String ERROR_HEADER = "Fel: " ; public static final String WARNING_HEADER = "Varning: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MÖNSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncQname extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = getArg0AsNode ( xctxt ) ; XObject val ; if ( DTM . NULL != context ) { DTM dtm = xctxt . getDTM ( context ) ; String qname = dtm . getNodeNameX ( context ) ; val = ( null == qname ) ? XString . EMPTYSTRING : new XString ( qname ) ; } else { val = XString . EMPTYSTRING ; } return val ; } } 	1
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . WrappedRuntimeException ; public class IteratorPool implements java . io . Serializable { private final DTMIterator m_orig ; private final Vector m_freeStack ; public IteratorPool ( DTMIterator original ) { m_orig = original ; m_freeStack = new Vector ( ) ; } public synchronized DTMIterator getInstanceOrThrow ( ) throws CloneNotSupportedException { if ( m_freeStack . isEmpty ( ) ) { return ( DTMIterator ) m_orig . clone ( ) ; } else { DTMIterator result = ( DTMIterator ) m_freeStack . lastElement ( ) ; m_freeStack . setSize ( m_freeStack . size ( ) - 1 ) ; return result ; } } public synchronized DTMIterator getInstance ( ) { if ( m_freeStack . isEmpty ( ) ) { try { return ( DTMIterator ) m_orig . clone ( ) ; } catch ( Exception ex ) { throw new WrappedRuntimeException ( ex ) ; } } else { DTMIterator result = ( DTMIterator ) m_freeStack . lastElement ( ) ; m_freeStack . setSize ( m_freeStack . size ( ) - 1 ) ; return result ; } } public synchronized void freeInstance ( DTMIterator obj ) { m_freeStack . addElement ( obj ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; abstract class RelativeLocationPath extends Expression { public abstract int getAxis ( ) ; public abstract void setAxis ( int axis ) ; } 	0
package org . apache . xalan . xsltc ; public interface DOMCache { public DOM retrieveDocument ( String uri , int mask , Translet translet ) ; } 	1
package org . apache . xpath ; import java . util . Vector ; import org . apache . xpath . functions . FuncExtFunction ; public interface ExtensionsProvider { public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException ; public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException ; public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey ) throws javax . xml . transform . TransformerException ; public Object extFunction ( FuncExtFunction extFunction , Vector argVec ) throws javax . xml . transform . TransformerException ; } 	0
package org . apache . xalan . templates ; public interface XSLTVisitable { public void callVisitors ( XSLTVisitor visitor ) ; } 	0
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; public class DOM2TO implements XMLReader , Locator { private final static String EMPTYSTRING = "" ; private static final String XMLNS_PREFIX = "xmlns" ; private Node _dom ; private SerializationHandler _handler ; public DOM2TO ( Node root , SerializationHandler handler ) { _dom = root ; _handler = handler ; } public ContentHandler getContentHandler ( ) { return null ; } public void setContentHandler ( ContentHandler handler ) { } public void parse ( InputSource unused ) throws IOException , SAXException { parse ( _dom ) ; } public void parse ( ) throws IOException , SAXException { if ( _dom != null ) { boolean isIncomplete = ( _dom . getNodeType ( ) != org . w3c . dom . Node . DOCUMENT_NODE ) ; if ( isIncomplete ) { _handler . startDocument ( ) ; parse ( _dom ) ; _handler . endDocument ( ) ; } else { parse ( _dom ) ; } } } private void parse ( Node node ) throws IOException , SAXException { if ( node == null ) return ; switch ( node . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . NOTATION_NODE : break ; case Node . CDATA_SECTION_NODE : _handler . startCDATA ( ) ; _handler . characters ( node . getNodeValue ( ) ) ; _handler . endCDATA ( ) ; break ; case Node . COMMENT_NODE : _handler . comment ( node . getNodeValue ( ) ) ; break ; case Node . DOCUMENT_NODE : _handler . startDocument ( ) ; Node next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endDocument ( ) ; break ; case Node . DOCUMENT_FRAGMENT_NODE : next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } break ; case Node . ELEMENT_NODE : final String qname = node . getNodeName ( ) ; _handler . startElement ( null , null , qname ) ; String prefix ; final NamedNodeMap map = node . getAttributes ( ) ; final int length = map . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int colon ; final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNodeValue ( ) ; colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( colon + 1 ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uriAttr ) ; } else { final String uriAttr = attr . getNamespaceURI ( ) ; if ( uriAttr != null && ! uriAttr . equals ( EMPTYSTRING ) ) { colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( 0 , colon ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uriAttr ) ; } _handler . addAttribute ( qnameAttr , attr . getNodeValue ( ) ) ; } } final String uri = node . getNamespaceURI ( ) ; if ( uri != null ) { final int colon = qname . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qname . substring ( 0 , colon ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uri ) ; } next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endElement ( qname ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : _handler . processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . TEXT_NODE : _handler . characters ( node . getNodeValue ( ) ) ; break ; } } public DTDHandler getDTDHandler ( ) { return null ; } public ErrorHandler getErrorHandler ( ) { return null ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return false ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public void parse ( String sysId ) throws IOException , SAXException { throw new IOException ( "This method is not yet implemented." ) ; } public void setDTDHandler ( DTDHandler handler ) throws NullPointerException { } public void setEntityResolver ( EntityResolver resolver ) throws NullPointerException { } public EntityResolver getEntityResolver ( ) { return null ; } public void setErrorHandler ( ErrorHandler handler ) throws NullPointerException { } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return null ; } public int getColumnNumber ( ) { return 0 ; } public int getLineNumber ( ) { return 0 ; } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { return null ; } private String getNodeTypeFromCode ( short code ) { String retval = null ; switch ( code ) { case Node . ATTRIBUTE_NODE : retval = "ATTRIBUTE_NODE" ; break ; case Node . CDATA_SECTION_NODE : retval = "CDATA_SECTION_NODE" ; break ; case Node . COMMENT_NODE : retval = "COMMENT_NODE" ; break ; case Node . DOCUMENT_FRAGMENT_NODE : retval = "DOCUMENT_FRAGMENT_NODE" ; break ; case Node . DOCUMENT_NODE : retval = "DOCUMENT_NODE" ; break ; case Node . DOCUMENT_TYPE_NODE : retval = "DOCUMENT_TYPE_NODE" ; break ; case Node . ELEMENT_NODE : retval = "ELEMENT_NODE" ; break ; case Node . ENTITY_NODE : retval = "ENTITY_NODE" ; break ; case Node . ENTITY_REFERENCE_NODE : retval = "ENTITY_REFERENCE_NODE" ; break ; case Node . NOTATION_NODE : retval = "NOTATION_NODE" ; break ; case Node . PROCESSING_INSTRUCTION_NODE : retval = "PROCESSING_INSTRUCTION_NODE" ; break ; case Node . TEXT_NODE : retval = "TEXT_NODE" ; break ; } return retval ; } } 	1
package org . apache . xalan . trace ; public interface TraceListener extends java . util . EventListener { public void trace ( TracerEvent ev ) ; public void selected ( SelectionEvent ev ) throws javax . xml . transform . TransformerException ; public void generated ( GenerateEvent ev ) ; } 	1
package org . apache . xml . utils . res ; public class XResources_en extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class VariableRefBase extends Expression { protected final VariableBase _variable ; protected Closure _closure = null ; public VariableRefBase ( VariableBase variable ) { _variable = variable ; variable . addReference ( this ) ; } public VariableRefBase ( ) { _variable = null ; } public VariableBase getVariable ( ) { return _variable ; } public VariableBase findParentVariable ( ) { SyntaxTreeNode node = this ; while ( node != null && ! ( node instanceof VariableBase ) ) { node = node . getParent ( ) ; } return ( VariableBase ) node ; } public boolean equals ( Object obj ) { try { return ( _variable == ( ( VariableRefBase ) obj ) . _variable ) ; } catch ( ClassCastException e ) { return false ; } } public String toString ( ) { return "variable-ref(" + _variable . getName ( ) + '/' + _variable . getType ( ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) return _type ; if ( _variable . isLocal ( ) ) { SyntaxTreeNode node = getParent ( ) ; do { if ( node instanceof Closure ) { _closure = ( Closure ) node ; break ; } if ( node instanceof TopLevelElement ) { break ; } node = node . getParent ( ) ; } while ( node != null ) ; if ( _closure != null ) { _closure . addVariable ( this ) ; } } VariableBase parent = findParentVariable ( ) ; if ( parent != null ) parent . addDependency ( _variable ) ; _type = _variable . getType ( ) ; if ( _type == null ) { _variable . typeCheck ( stable ) ; _type = _variable . getType ( ) ; } return _type ; } } 	0
package org . apache . xalan . templates ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemCallTemplate extends ElemForEach { public QName m_templateName = null ; public void setName ( QName name ) { m_templateName = name ; } public QName getName ( ) { return m_templateName ; } private ElemTemplate m_template = null ; public int getXSLToken ( ) { return Constants . ELEMNAME_CALLTEMPLATE ; } public String getNodeName ( ) { return Constants . ELEMNAME_CALLTEMPLATE_STRING ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; int length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . compose ( sroot ) ; } if ( ( null != m_templateName ) && ( null == m_template ) ) { m_template = this . getStylesheetRoot ( ) . getTemplateComposed ( m_templateName ) ; if ( null == m_template ) return ; length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . m_index = - 1 ; int etePos = 0 ; for ( ElemTemplateElement ete = m_template . getFirstChildElem ( ) ; null != ete ; ete = ete . getNextSiblingElem ( ) ) { if ( ete . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE ) { ElemParam ep = ( ElemParam ) ete ; if ( ep . getName ( ) . equals ( ewp . getName ( ) ) ) { ewp . m_index = etePos ; } } else break ; etePos ++ ; } } } } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { int length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . endCompose ( sroot ) ; } super . endCompose ( sroot ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( null != m_template ) { XPathContext xctxt = transformer . getXPathContext ( ) ; VariableStack vars = xctxt . getVarStack ( ) ; int thisframe = vars . getStackFrame ( ) ; int nextFrame = vars . link ( m_template . m_frameSize ) ; if ( m_template . m_inArgsSize > 0 ) { vars . clearLocalSlots ( 0 , m_template . m_inArgsSize ) ; if ( null != m_paramElems ) { int currentNode = xctxt . getCurrentNode ( ) ; vars . setStackFrame ( thisframe ) ; int size = m_paramElems . length ; for ( int i = 0 ; i < size ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; if ( ewp . m_index >= 0 ) { XObject obj = ewp . getValue ( transformer , currentNode ) ; vars . setLocalVariable ( ewp . m_index , obj , nextFrame ) ; } } vars . setStackFrame ( nextFrame ) ; } } SourceLocator savedLocator = xctxt . getSAXLocator ( ) ; try { xctxt . setSAXLocator ( m_template ) ; transformer . pushElemTemplateElement ( m_template ) ; m_template . execute ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; xctxt . setSAXLocator ( savedLocator ) ; vars . unlink ( thisframe ) ; } } else { transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_TEMPLATE_NOT_FOUND , new Object [ ] { m_templateName } ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } protected ElemWithParam [ ] m_paramElems = null ; public int getParamElemCount ( ) { return ( m_paramElems == null ) ? 0 : m_paramElems . length ; } public ElemWithParam getParamElem ( int i ) { return m_paramElems [ i ] ; } public void setParamElem ( ElemWithParam ParamElem ) { if ( null == m_paramElems ) { m_paramElems = new ElemWithParam [ 1 ] ; m_paramElems [ 0 ] = ParamElem ; } else { int length = m_paramElems . length ; ElemWithParam [ ] ewp = new ElemWithParam [ length + 1 ] ; System . arraycopy ( m_paramElems , 0 , ewp , 0 , length ) ; m_paramElems = ewp ; ewp [ length ] = ParamElem ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; if ( Constants . ELEMNAME_WITHPARAM == type ) { setParamElem ( ( ElemWithParam ) newChild ) ; } return super . appendChild ( newChild ) ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { super . callChildVisitors ( visitor , callAttrs ) ; } } 	1
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Node ; public class XPathException extends TransformerException { Object m_styleNode = null ; public Object getStylesheetNode ( ) { return m_styleNode ; } public void setStylesheetNode ( Object styleNode ) { m_styleNode = styleNode ; } protected Exception m_exception ; public XPathException ( String message , ExpressionNode ex ) { super ( message ) ; this . setLocator ( ex ) ; setStylesheetNode ( getStylesheetNode ( ex ) ) ; } public XPathException ( String message ) { super ( message ) ; } public org . w3c . dom . Node getStylesheetNode ( ExpressionNode ex ) { ExpressionNode owner = getExpressionOwner ( ex ) ; if ( null != owner && owner instanceof org . w3c . dom . Node ) { return ( ( org . w3c . dom . Node ) owner ) ; } return null ; } protected ExpressionNode getExpressionOwner ( ExpressionNode ex ) { ExpressionNode parent = ex . exprGetParent ( ) ; while ( ( null != parent ) && ( parent instanceof Expression ) ) parent = parent . exprGetParent ( ) ; return parent ; } public XPathException ( String message , Object styleNode ) { super ( message ) ; m_styleNode = styleNode ; } public XPathException ( String message , Node styleNode , Exception e ) { super ( message ) ; m_styleNode = styleNode ; this . m_exception = e ; } public XPathException ( String message , Exception e ) { super ( message ) ; this . m_exception = e ; } public void printStackTrace ( java . io . PrintStream s ) { if ( s == null ) s = System . err ; try { super . printStackTrace ( s ) ; } catch ( Exception e ) { } Throwable exception = m_exception ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; exception . printStackTrace ( s ) ; if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) break ; } else { exception = null ; } } } public String getMessage ( ) { String lastMessage = super . getMessage ( ) ; Throwable exception = m_exception ; while ( null != exception ) { String nextMessage = exception . getMessage ( ) ; if ( null != nextMessage ) lastMessage = nextMessage ; if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) break ; } else { exception = null ; } } return ( null != lastMessage ) ? lastMessage : "" ; } public void printStackTrace ( java . io . PrintWriter s ) { if ( s == null ) s = new java . io . PrintWriter ( System . err ) ; try { super . printStackTrace ( s ) ; } catch ( Exception e ) { } Throwable exception = m_exception ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; try { exception . printStackTrace ( s ) ; } catch ( Exception e ) { s . println ( "Could not print stack trace..." ) ; } if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) { exception = null ; break ; } } else { exception = null ; } } } public Throwable getException ( ) { return m_exception ; } } 	1
package org . apache . xml . utils . synthetic ; public class SynthesisException extends Exception { int code ; public static final int SYNTAX = 0 ; public static final int UNSUPPORTED = 1 ; public static final int REIFIED = 2 ; public static final int UNREIFIED = 3 ; public static final int WRONG_OWNER = 4 ; public static final String [ ] errToString = { "(Syntax error; specific message should be passed in)" , "Feature not yet supported" , "Can't change features of 'real' class" , "Can't yet instantiate/invoke without 'real' class" , "Can't add Member to an object other than its declarer" , } ; public SynthesisException ( int code ) { super ( errToString [ code ] ) ; this . code = code ; } public SynthesisException ( int code , String msg ) { super ( msg ) ; this . code = code ; } int getCode ( ) { return code ; } } 	1
package org . apache . xalan . xsltc . dom ; public interface Filter { public boolean test ( int node ) ; } 	0
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class ForwardPositionIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; public ForwardPositionIterator ( DTMAxisIterator source ) { _source = source ; } public DTMAxisIterator cloneIterator ( ) { try { final ForwardPositionIterator clone = ( ForwardPositionIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public int next ( ) { return returnNode ( _source . next ( ) ) ; } public DTMAxisIterator setStartNode ( int node ) { _source . setStartNode ( node ) ; return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ClassGen ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public class ClassGenerator extends ClassGen { protected static int TRANSLET_INDEX = 0 ; protected static int INVALID_INDEX = - 1 ; private Stylesheet _stylesheet ; private final Parser _parser ; private final Instruction _aloadTranslet ; private final String _domClass ; private final String _domClassSig ; private final String _applyTemplatesSig ; public ClassGenerator ( String class_name , String super_class_name , String file_name , int access_flags , String [ ] interfaces , Stylesheet stylesheet ) { super ( class_name , super_class_name , file_name , access_flags , interfaces ) ; _stylesheet = stylesheet ; _parser = stylesheet . getParser ( ) ; _aloadTranslet = new ALOAD ( TRANSLET_INDEX ) ; if ( stylesheet . isMultiDocument ( ) ) { _domClass = "org.apache.xalan.xsltc.dom.MultiDOM" ; _domClassSig = "Lorg/apache/xalan/xsltc/dom/MultiDOM;" ; } else { _domClass = "org.apache.xalan.xsltc.dom.DOMAdapter" ; _domClassSig = "Lorg/apache/xalan/xsltc/dom/DOMAdapter;" ; } _applyTemplatesSig = "(" + Constants . DOM_INTF_SIG + Constants . NODE_ITERATOR_SIG + Constants . TRANSLET_OUTPUT_SIG + ")V" ; } public final Parser getParser ( ) { return _parser ; } public final Stylesheet getStylesheet ( ) { return _stylesheet ; } public final String getClassName ( ) { return _stylesheet . getClassName ( ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public final String getDOMClass ( ) { return _domClass ; } public final String getDOMClassSig ( ) { return _domClassSig ; } public final String getApplyTemplatesSig ( ) { return _applyTemplatesSig ; } public boolean isExternal ( ) { return false ; } } 	0
package org . apache . xalan . res ; public class XSLTErrorResources_en extends XSLTErrorResources { } 	1
package org . apache . xalan . xsltc . util ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; public class JavaCupRedirect { private final static String ERRMSG = "You must supply a filename with the -stdin option." ; public static void main ( String args [ ] ) { boolean systemExitOK = true ; InputStream input = null ; final int argc = args . length ; String [ ] new_args = new String [ argc - 2 ] ; int new_argc = 0 ; for ( int i = 0 ; i < argc ; i ++ ) { if ( args [ i ] . equals ( "-stdin" ) ) { if ( ( ++ i >= argc ) || ( args [ i ] . startsWith ( "-" ) ) ) { System . err . println ( ERRMSG ) ; doSystemExit ( systemExitOK ) ; } try { input = new FileInputStream ( args [ i ] ) ; } catch ( FileNotFoundException e ) { System . err . println ( "Could not open file " + args [ i ] ) ; doSystemExit ( systemExitOK ) ; } catch ( SecurityException e ) { System . err . println ( "No permission to file " + args [ i ] ) ; doSystemExit ( systemExitOK ) ; } } else { if ( new_argc == new_args . length ) { System . err . println ( "Missing -stdin option!" ) ; doSystemExit ( systemExitOK ) ; } new_args [ new_argc ++ ] = args [ i ] ; } } System . setIn ( input ) ; try { java_cup . Main . main ( new_args ) ; } catch ( Exception e ) { System . err . println ( "Error running JavaCUP:" ) ; e . printStackTrace ( ) ; doSystemExit ( systemExitOK ) ; } } public static void doSystemExit ( boolean doExit ) { if ( doExit ) System . exit ( - 1 ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; final class KeyPattern extends IdKeyPattern { public KeyPattern ( String index , String value ) { super ( index , value ) ; } } 	0
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . compiler . Compiler ; public class ChildTestIterator extends BasicTestIterator { transient protected DTMAxisTraverser m_traverser ; ChildTestIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; } public ChildTestIterator ( DTMAxisTraverser traverser ) { super ( null ) ; m_traverser = traverser ; } protected int getNextNode ( ) { if ( true ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } return m_lastFetched ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { ChildTestIterator clone = ( ChildTestIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; return clone ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( Axis . CHILD ) ; } public int getAxis ( ) { return org . apache . xml . dtm . Axis . CHILD ; } public void detach ( ) { if ( m_allowDetach ) { m_traverser = null ; super . detach ( ) ; } } } 	1
package org . apache . xml . utils . res ; import java . util . ListResourceBundle ; abstract public class XResourceBundleBase extends ListResourceBundle { abstract public String getMessageKey ( int errorCode ) ; abstract public String getWarningKey ( int errorCode ) ; } 	1
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemIf extends ElemTemplateElement { private XPath m_test = null ; public void setTest ( XPath v ) { m_test = v ; } public XPath getTest ( ) { return m_test ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_test ) m_test . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_IF ; } public String getNodeName ( ) { return Constants . ELEMNAME_IF_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject test = m_test . execute ( xctxt , sourceNode , this ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "test" , m_test , test ) ; if ( test . bool ( ) ) { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } else if ( m_test . bool ( xctxt , sourceNode , this ) ) { transformer . executeChildTemplates ( this , true ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_test . getExpression ( ) . callVisitors ( m_test , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public final class DOMAdapter implements DOM { private SAXImpl _saxImpl ; private DOM _dom ; private String [ ] _namesArray ; private String [ ] _namespaceArray ; private short [ ] _mapping = null ; private int [ ] _reverse = null ; private short [ ] _NSmapping = null ; private short [ ] _NSreverse = null ; private StripFilter _filter = null ; private int _multiDOMMask ; public DOMAdapter ( DOM dom , String [ ] namesArray , String [ ] namespaceArray ) { if ( dom instanceof SAXImpl ) { _saxImpl = ( SAXImpl ) dom ; } _dom = dom ; _namesArray = namesArray ; _namespaceArray = namespaceArray ; } public void setupMapping ( String [ ] names , String [ ] namespaces ) { _namesArray = names ; _namespaceArray = namespaces ; } public String [ ] getNamesArray ( ) { return _namesArray ; } public String [ ] getNamespaceArray ( ) { return _namespaceArray ; } public DOM getDOMImpl ( ) { return _dom ; } private short [ ] getMapping ( ) { if ( _mapping == null ) { if ( _saxImpl != null ) { _mapping = _saxImpl . getMapping ( _namesArray ) ; } } return _mapping ; } private int [ ] getReverse ( ) { if ( _reverse == null ) { if ( _saxImpl != null ) { _reverse = _saxImpl . getReverseMapping ( _namesArray ) ; } } return _reverse ; } private short [ ] getNSMapping ( ) { if ( _NSmapping == null ) { if ( _saxImpl != null ) { _NSmapping = _saxImpl . getNamespaceMapping ( _namespaceArray ) ; } } return _NSmapping ; } private short [ ] getNSReverse ( ) { if ( _NSreverse == null ) { if ( _saxImpl != null ) { _NSreverse = _saxImpl . getReverseNamespaceMapping ( _namespaceArray ) ; } } return _NSreverse ; } public DTMAxisIterator getIterator ( ) { return _dom . getIterator ( ) ; } public String getStringValue ( ) { return _dom . getStringValue ( ) ; } public DTMAxisIterator getChildren ( final int node ) { if ( _saxImpl != null ) { return _saxImpl . getChildren ( node ) ; } else { DTMAxisIterator iterator = _dom . getChildren ( node ) ; return iterator . setStartNode ( node ) ; } } public void setFilter ( StripFilter filter ) { _filter = filter ; } public DTMAxisIterator getTypedChildren ( final int type ) { final int [ ] reverse = getReverse ( ) ; if ( _saxImpl != null ) { return _saxImpl . getTypedChildren ( reverse [ type ] ) ; } else { return _dom . getTypedChildren ( type ) ; } } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { return _dom . getNamespaceAxisIterator ( axis , getNSReverse ( ) [ ns ] ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { if ( _saxImpl != null ) { return _saxImpl . getAxisIterator ( axis ) ; } else { return _dom . getAxisIterator ( axis ) ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { final int [ ] reverse = getReverse ( ) ; if ( axis == Axis . NAMESPACE ) { short [ ] NSReverse = getNSReverse ( ) ; if ( type == NO_TYPE || type > NSReverse . length ) { return _dom . getAxisIterator ( axis ) ; } else { return _dom . getTypedAxisIterator ( axis , NSReverse [ type ] ) ; } } else if ( _saxImpl != null ) { return _saxImpl . getTypedAxisIterator ( axis , reverse [ type ] ) ; } else { return _dom . getTypedAxisIterator ( axis , type ) ; } } public int getMultiDOMMask ( ) { return _multiDOMMask ; } public void setMultiDOMMask ( int mask ) { _multiDOMMask = mask ; } public DTMAxisIterator getNthDescendant ( int type , int n , boolean includeself ) { return _dom . getNthDescendant ( getReverse ( ) [ type ] , n , includeself ) ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iterator , int type , String value , boolean op ) { return _dom . getNodeValueIterator ( iterator , type , value , op ) ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return _dom . orderNodes ( source , node ) ; } public int getExpandedTypeID ( final int node ) { if ( _saxImpl != null ) { return getMapping ( ) [ _saxImpl . getExpandedTypeID2 ( node ) ] ; } else { return getMapping ( ) [ _dom . getExpandedTypeID ( node ) ] ; } } public int getNamespaceType ( final int node ) { return getNSMapping ( ) [ _dom . getNSType ( node ) ] ; } public int getNSType ( int node ) { return _dom . getNSType ( node ) ; } public int getParent ( final int node ) { return _dom . getParent ( node ) ; } public int getAttributeNode ( final int type , final int element ) { return _dom . getAttributeNode ( getReverse ( ) [ type ] , element ) ; } public String getNodeName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNodeName ( node ) ; } public String getNodeNameX ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNodeNameX ( node ) ; } public String getNamespaceName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNamespaceName ( node ) ; } public String getStringValueX ( final int node ) { if ( _saxImpl != null ) { return _saxImpl . getStringValueX ( node ) ; } else { if ( node == DTM . NULL ) { return "" ; } return _dom . getStringValueX ( node ) ; } } public void copy ( final int node , SerializationHandler handler ) throws TransletException { _dom . copy ( node , handler ) ; } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { _dom . copy ( nodes , handler ) ; } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { if ( _saxImpl != null ) { return _saxImpl . shallowCopy ( node , handler ) ; } else { return _dom . shallowCopy ( node , handler ) ; } } public boolean lessThan ( final int node1 , final int node2 ) { return _dom . lessThan ( node1 , node2 ) ; } public void characters ( final int textNode , SerializationHandler handler ) throws TransletException { if ( _saxImpl != null ) { _saxImpl . characters ( textNode , handler ) ; } else { _dom . characters ( textNode , handler ) ; } } public Node makeNode ( int index ) { return _dom . makeNode ( index ) ; } public Node makeNode ( DTMAxisIterator iter ) { return _dom . makeNode ( iter ) ; } public NodeList makeNodeList ( int index ) { return _dom . makeNodeList ( index ) ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return _dom . makeNodeList ( iter ) ; } public String getLanguage ( int node ) { return _dom . getLanguage ( node ) ; } public int getSize ( ) { return _dom . getSize ( ) ; } public void setDocumentURI ( String uri ) { if ( _saxImpl != null ) { _saxImpl . setDocumentURI ( uri ) ; } } public String getDocumentURI ( ) { if ( _saxImpl != null ) { return _saxImpl . getDocumentURI ( ) ; } else { return "" ; } } public String getDocumentURI ( int node ) { return _dom . getDocumentURI ( node ) ; } public int getDocument ( ) { return _dom . getDocument ( ) ; } public boolean isElement ( final int node ) { return ( _dom . isElement ( node ) ) ; } public boolean isAttribute ( final int node ) { return ( _dom . isAttribute ( node ) ) ; } public int getNodeIdent ( int nodeHandle ) { return _dom . getNodeIdent ( nodeHandle ) ; } public int getNodeHandle ( int nodeId ) { return _dom . getNodeHandle ( nodeId ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType ) { if ( _saxImpl != null ) { return _saxImpl . getResultTreeFrag ( initSize , rtfType ) ; } else { return _dom . getResultTreeFrag ( initSize , rtfType ) ; } } public SerializationHandler getOutputDomBuilder ( ) { return _dom . getOutputDomBuilder ( ) ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return _dom . lookupNamespace ( node , prefix ) ; } public String getUnparsedEntityURI ( String entity ) { return _dom . getUnparsedEntityURI ( entity ) ; } public Hashtable getElementsWithIDs ( ) { return _dom . getElementsWithIDs ( ) ; } } 	1
package org . apache . xml . dtm . ref . dom2dtm ; import org . apache . xml . dtm . DTMException ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class DOM2DTMdefaultNamespaceDeclarationNode implements Attr { final String NOT_SUPPORTED_ERR = "Unsupported operation on pseudonode" ; Element pseudoparent ; String prefix , uri , nodename ; int handle ; DOM2DTMdefaultNamespaceDeclarationNode ( Element pseudoparent , String prefix , String uri , int handle ) { this . pseudoparent = pseudoparent ; this . prefix = prefix ; this . uri = uri ; this . handle = handle ; this . nodename = "xmlns:" + prefix ; } public String getNodeName ( ) { return nodename ; } public String getName ( ) { return nodename ; } public String getNamespaceURI ( ) { return "http://www.w3.org/2000/xmlns/" ; } public String getPrefix ( ) { return prefix ; } public String getLocalName ( ) { return prefix ; } public String getNodeValue ( ) { return uri ; } public String getValue ( ) { return uri ; } public Element getOwnerElement ( ) { return pseudoparent ; } public boolean isSupported ( String feature , String version ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public boolean hasAttributes ( ) { return false ; } public Node getParentNode ( ) { return null ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public boolean getSpecified ( ) { return false ; } public void normalize ( ) { return ; } public NodeList getChildNodes ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public void setNodeValue ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public void setValue ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public void setPrefix ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node insertBefore ( Node a , Node b ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node replaceChild ( Node a , Node b ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node appendChild ( Node a ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node removeChild ( Node a ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Document getOwnerDocument ( ) { return pseudoparent . getOwnerDocument ( ) ; } public Node cloneNode ( boolean deep ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public int getHandleOfNode ( ) { return handle ; } } 	0
package org . apache . xml . utils ; public class XMLCharacterRecognizer { public static boolean isWhiteSpace ( char ch ) { return ( ch == 0x20 ) || ( ch == 0x09 ) || ( ch == 0xD ) || ( ch == 0xA ) ; } public static boolean isWhiteSpace ( char ch [ ] , int start , int length ) { int end = start + length ; for ( int s = start ; s < end ; s ++ ) { if ( ! isWhiteSpace ( ch [ s ] ) ) return false ; } return true ; } public static boolean isWhiteSpace ( StringBuffer buf ) { int n = buf . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! isWhiteSpace ( buf . charAt ( i ) ) ) return false ; } return true ; } public static boolean isWhiteSpace ( String s ) { if ( null != s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! isWhiteSpace ( s . charAt ( i ) ) ) return false ; } } return true ; } } 	1
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . NodeConsumer ; import org . apache . xml . utils . XMLString ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; public class DTMTreeWalker { private ContentHandler m_contentHandler = null ; protected DTM m_dtm ; public void setDTM ( DTM dtm ) { m_dtm = dtm ; } public ContentHandler getcontentHandler ( ) { return m_contentHandler ; } public void setcontentHandler ( ContentHandler ch ) { m_contentHandler = ch ; } public DTMTreeWalker ( ) { } public DTMTreeWalker ( ContentHandler contentHandler , DTM dtm ) { this . m_contentHandler = contentHandler ; m_dtm = dtm ; } public void traverse ( int pos ) throws org . xml . sax . SAXException { int top = pos ; while ( DTM . NULL != pos ) { startNode ( pos ) ; int nextNode = m_dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { endNode ( pos ) ; if ( top == pos ) break ; nextNode = m_dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = m_dtm . getParent ( pos ) ; if ( ( DTM . NULL == pos ) || ( top == pos ) ) { if ( DTM . NULL != pos ) endNode ( pos ) ; nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } public void traverse ( int pos , int top ) throws org . xml . sax . SAXException { while ( DTM . NULL != pos ) { startNode ( pos ) ; int nextNode = m_dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { endNode ( pos ) ; if ( ( DTM . NULL != top ) && top == pos ) break ; nextNode = m_dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = m_dtm . getParent ( pos ) ; if ( ( DTM . NULL == pos ) || ( ( DTM . NULL != top ) && ( top == pos ) ) ) { nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } boolean nextIsRaw = false ; private final void dispatachChars ( int node ) throws org . xml . sax . SAXException { m_dtm . dispatchCharactersEvents ( node , m_contentHandler , false ) ; } protected void startNode ( int node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof NodeConsumer ) { } switch ( m_dtm . getNodeType ( node ) ) { case DTM . COMMENT_NODE : { XMLString data = m_dtm . getStringValue ( node ) ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; data . dispatchAsComment ( lh ) ; } } break ; case DTM . DOCUMENT_FRAGMENT_NODE : break ; case DTM . DOCUMENT_NODE : this . m_contentHandler . startDocument ( ) ; break ; case DTM . ELEMENT_NODE : DTM dtm = m_dtm ; for ( int nsn = dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != nsn ; nsn = dtm . getNextNamespaceNode ( node , nsn , true ) ) { String prefix = dtm . getNodeNameX ( nsn ) ; this . m_contentHandler . startPrefixMapping ( prefix , dtm . getNodeValue ( nsn ) ) ; } String ns = dtm . getNamespaceURI ( node ) ; if ( null == ns ) ns = "" ; org . xml . sax . helpers . AttributesImpl attrs = new org . xml . sax . helpers . AttributesImpl ( ) ; for ( int i = dtm . getFirstAttribute ( node ) ; i != DTM . NULL ; i = dtm . getNextAttribute ( i ) ) { attrs . addAttribute ( dtm . getNamespaceURI ( i ) , dtm . getLocalName ( i ) , dtm . getNodeName ( i ) , "CDATA" , dtm . getNodeValue ( i ) ) ; } this . m_contentHandler . startElement ( ns , m_dtm . getLocalName ( node ) , m_dtm . getNodeName ( node ) , attrs ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : { String name = m_dtm . getNodeName ( node ) ; if ( name . equals ( "xslt-next-is-raw" ) ) { nextIsRaw = true ; } else { this . m_contentHandler . processingInstruction ( name , m_dtm . getNodeValue ( node ) ) ; } } break ; case DTM . CDATA_SECTION_NODE : { boolean isLexH = ( m_contentHandler instanceof LexicalHandler ) ; LexicalHandler lh = isLexH ? ( ( LexicalHandler ) this . m_contentHandler ) : null ; if ( isLexH ) { lh . startCDATA ( ) ; } dispatachChars ( node ) ; { if ( isLexH ) { lh . endCDATA ( ) ; } } } break ; case DTM . TEXT_NODE : { if ( nextIsRaw ) { nextIsRaw = false ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; dispatachChars ( node ) ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { dispatachChars ( node ) ; } } break ; case DTM . ENTITY_REFERENCE_NODE : { if ( m_contentHandler instanceof LexicalHandler ) { ( ( LexicalHandler ) this . m_contentHandler ) . startEntity ( m_dtm . getNodeName ( node ) ) ; } else { } } break ; default : } } protected void endNode ( int node ) throws org . xml . sax . SAXException { switch ( m_dtm . getNodeType ( node ) ) { case DTM . DOCUMENT_NODE : this . m_contentHandler . endDocument ( ) ; break ; case DTM . ELEMENT_NODE : String ns = m_dtm . getNamespaceURI ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dtm . getLocalName ( node ) , m_dtm . getNodeName ( node ) ) ; for ( int nsn = m_dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != nsn ; nsn = m_dtm . getNextNamespaceNode ( node , nsn , true ) ) { String prefix = m_dtm . getNodeNameX ( nsn ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } break ; case DTM . CDATA_SECTION_NODE : break ; case DTM . ENTITY_REFERENCE_NODE : { if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( m_dtm . getNodeName ( node ) ) ; } } break ; default : } } } 	1
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class MultipleNodeCounter extends NodeCounter { private DTMAxisIterator _precSiblings = null ; public MultipleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; _precSiblings = _document . getAxisIterator ( PRECEDINGSIBLING ) ; return this ; } public String getCounter ( ) { if ( _value != Integer . MIN_VALUE ) { return formatNumbers ( _value ) ; } IntegerArray ancestors = new IntegerArray ( ) ; int next = _node ; ancestors . add ( next ) ; while ( ( next = _document . getParent ( next ) ) > END && ! matchesFrom ( next ) ) { ancestors . add ( next ) ; } final int nAncestors = ancestors . cardinality ( ) ; final int [ ] counters = new int [ nAncestors ] ; for ( int i = 0 ; i < nAncestors ; i ++ ) { counters [ i ] = Integer . MIN_VALUE ; } for ( int j = 0 , i = nAncestors - 1 ; i >= 0 ; i -- , j ++ ) { final int counter = counters [ j ] ; final int ancestor = ancestors . at ( i ) ; if ( matchesCount ( ancestor ) ) { _precSiblings . setStartNode ( ancestor ) ; while ( ( next = _precSiblings . next ( ) ) != END ) { if ( matchesCount ( next ) ) { counters [ j ] = ( counters [ j ] == Integer . MIN_VALUE ) ? 1 : counters [ j ] + 1 ; } } counters [ j ] = counters [ j ] == Integer . MIN_VALUE ? 1 : counters [ j ] + 1 ; } } return formatNumbers ( counters ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { return new DefaultMultipleNodeCounter ( translet , document , iterator ) ; } static class DefaultMultipleNodeCounter extends MultipleNodeCounter { public DefaultMultipleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } } } 	0
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . dtm . DTM ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . XMLString ; public class ClonerToResultTree { public static void cloneToResultTree ( int node , int nodeType , DTM dtm , SerializationHandler rth , boolean shouldCloneAttributes ) throws TransformerException { try { switch ( nodeType ) { case DTM . TEXT_NODE : dtm . dispatchCharactersEvents ( node , rth , false ) ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . DOCUMENT_NODE : break ; case DTM . ELEMENT_NODE : { String ns = dtm . getNamespaceURI ( node ) ; if ( ns == null ) ns = "" ; String localName = dtm . getLocalName ( node ) ; rth . startElement ( ns , localName , dtm . getNodeNameX ( node ) ) ; if ( shouldCloneAttributes ) { SerializerUtils . addAttributes ( rth , node ) ; SerializerUtils . processNSDecls ( rth , node , nodeType , dtm ) ; } } break ; case DTM . CDATA_SECTION_NODE : rth . startCDATA ( ) ; dtm . dispatchCharactersEvents ( node , rth , false ) ; rth . endCDATA ( ) ; break ; case DTM . ATTRIBUTE_NODE : SerializerUtils . addAttribute ( rth , node ) ; break ; case DTM . NAMESPACE_NODE : SerializerUtils . processNSDecls ( rth , node , DTM . NAMESPACE_NODE , dtm ) ; break ; case DTM . COMMENT_NODE : XMLString xstr = dtm . getStringValue ( node ) ; xstr . dispatchAsComment ( rth ) ; break ; case DTM . ENTITY_REFERENCE_NODE : rth . entityReference ( dtm . getNodeNameX ( node ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : { rth . processingInstruction ( dtm . getNodeNameX ( node ) , dtm . getNodeValue ( node ) ) ; } break ; default : throw new TransformerException ( "Can't clone node: " + dtm . getNodeName ( node ) ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } } 	1
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathResult { public static final short ANY_TYPE = 0 ; public static final short NUMBER_TYPE = 1 ; public static final short STRING_TYPE = 2 ; public static final short BOOLEAN_TYPE = 3 ; public static final short UNORDERED_NODE_ITERATOR_TYPE = 4 ; public static final short ORDERED_NODE_ITERATOR_TYPE = 5 ; public static final short UNORDERED_NODE_SNAPSHOT_TYPE = 6 ; public static final short ORDERED_NODE_SNAPSHOT_TYPE = 7 ; public static final short ANY_UNORDERED_NODE_TYPE = 8 ; public static final short FIRST_ORDERED_NODE_TYPE = 9 ; public short getResultType ( ) ; public double getNumberValue ( ) throws XPathException ; public String getStringValue ( ) throws XPathException ; public boolean getBooleanValue ( ) throws XPathException ; public Node getSingleNodeValue ( ) throws XPathException ; public boolean getInvalidIteratorState ( ) ; public int getSnapshotLength ( ) throws XPathException ; public Node iterateNext ( ) throws XPathException , DOMException ; public Node snapshotItem ( int index ) throws XPathException ; } 	0
package org . apache . xml . utils ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; public class PrefixResolverDefault implements PrefixResolver { Node m_context ; public PrefixResolverDefault ( Node xpathExpressionContext ) { m_context = xpathExpressionContext ; } public String getNamespaceForPrefix ( String prefix ) { return getNamespaceForPrefix ( prefix , m_context ) ; } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node namespaceContext ) { Node parent = namespaceContext ; String namespace = null ; if ( prefix . equals ( "xml" ) ) { namespace = Constants . S_XMLNAMESPACEURI ; } else { int type ; while ( ( null != parent ) && ( null == namespace ) && ( ( ( type = parent . getNodeType ( ) ) == Node . ELEMENT_NODE ) || ( type == Node . ENTITY_REFERENCE_NODE ) ) ) { if ( type == Node . ELEMENT_NODE ) { NamedNodeMap nnm = parent . getAttributes ( ) ; for ( int i = 0 ; i < nnm . getLength ( ) ; i ++ ) { Node attr = nnm . item ( i ) ; String aname = attr . getNodeName ( ) ; boolean isPrefix = aname . startsWith ( "xmlns:" ) ; if ( isPrefix || aname . equals ( "xmlns" ) ) { int index = aname . indexOf ( ':' ) ; String p = isPrefix ? aname . substring ( index + 1 ) : "" ; if ( p . equals ( prefix ) ) { namespace = attr . getNodeValue ( ) ; break ; } } } } parent = parent . getParentNode ( ) ; } } return namespace ; } public String getBaseIdentifier ( ) { return null ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1
package org . apache . xalan . lib ; import java . util . StringTokenizer ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; public class ExsltStrings extends ExsltBase { private static Document m_doc = null ; private static ExsltStrings m_instance = new ExsltStrings ( ) ; public static String align ( String targetStr , String paddingStr , String type ) { if ( targetStr . length ( ) >= paddingStr . length ( ) ) return targetStr . substring ( 0 , paddingStr . length ( ) ) ; if ( type . equals ( "right" ) ) { return paddingStr . substring ( 0 , paddingStr . length ( ) - targetStr . length ( ) ) + targetStr ; } else if ( type . equals ( "center" ) ) { int startIndex = ( paddingStr . length ( ) - targetStr . length ( ) ) / 2 ; return paddingStr . substring ( 0 , startIndex ) + targetStr + paddingStr . substring ( startIndex + targetStr . length ( ) ) ; } else { return targetStr + paddingStr . substring ( paddingStr . length ( ) - targetStr . length ( ) ) ; } } public static String align ( String targetStr , String paddingStr ) { return align ( targetStr , paddingStr , "left" ) ; } public static String concat ( NodeList nl ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node node = nl . item ( i ) ; String value = toString ( node ) ; if ( value != null && value . length ( ) > 0 ) sb . append ( value ) ; } return sb . toString ( ) ; } public static String padding ( double length , String pattern ) { if ( pattern == null || pattern . length ( ) == 0 ) return "" ; StringBuffer sb = new StringBuffer ( ) ; int len = ( int ) length ; int numAdded = 0 ; int index = 0 ; while ( numAdded < len ) { if ( index == pattern . length ( ) ) index = 0 ; sb . append ( pattern . charAt ( index ) ) ; index ++ ; numAdded ++ ; } return sb . toString ( ) ; } public static String padding ( double length ) { return padding ( length , " " ) ; } public static NodeList split ( String str , String pattern ) { try { if ( m_doc == null ) { synchronized ( m_instance ) { if ( m_doc == null ) m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } } } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } NodeSet resultSet = new NodeSet ( ) ; resultSet . setShouldCacheNodes ( true ) ; boolean done = false ; int fromIndex = 0 ; int matchIndex = 0 ; String token = null ; while ( ! done && fromIndex < str . length ( ) ) { matchIndex = str . indexOf ( pattern , fromIndex ) ; if ( matchIndex >= 0 ) { token = str . substring ( fromIndex , matchIndex ) ; fromIndex = matchIndex + pattern . length ( ) ; } else { done = true ; token = str . substring ( fromIndex ) ; } synchronized ( m_doc ) { Element element = m_doc . createElement ( "token" ) ; Text text = m_doc . createTextNode ( token ) ; element . appendChild ( text ) ; resultSet . addNode ( element ) ; } } return resultSet ; } public static NodeList split ( String str ) { return split ( str , " " ) ; } public static NodeList tokenize ( String toTokenize , String delims ) { try { if ( m_doc == null ) { synchronized ( m_instance ) { if ( m_doc == null ) m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } } } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } NodeSet resultSet = new NodeSet ( ) ; if ( delims != null && delims . length ( ) > 0 ) { StringTokenizer lTokenizer = new StringTokenizer ( toTokenize , delims ) ; synchronized ( m_doc ) { while ( lTokenizer . hasMoreTokens ( ) ) { Element element = m_doc . createElement ( "token" ) ; element . appendChild ( m_doc . createTextNode ( lTokenizer . nextToken ( ) ) ) ; resultSet . addNode ( element ) ; } } } else { synchronized ( m_doc ) { for ( int i = 0 ; i < toTokenize . length ( ) ; i ++ ) { Element element = m_doc . createElement ( "token" ) ; element . appendChild ( m_doc . createTextNode ( toTokenize . substring ( i , i + 1 ) ) ) ; resultSet . addNode ( element ) ; } } } return resultSet ; } public static NodeList tokenize ( String toTokenize ) { return tokenize ( toTokenize , " \t\n\r" ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . xml . sax . InputSource ; public interface SourceLoader { public InputSource loadSource ( String href , String context , XSLTC xsltc ) ; } 	0
package org . apache . xml . utils ; public class SuballocatedByteVector { protected int m_blocksize ; protected int m_numblocks = 32 ; protected byte m_map [ ] [ ] ; protected int m_firstFree = 0 ; protected byte m_map0 [ ] ; public SuballocatedByteVector ( ) { this ( 2048 ) ; } public SuballocatedByteVector ( int blocksize ) { m_blocksize = blocksize ; m_map0 = new byte [ blocksize ] ; m_map = new byte [ m_numblocks ] [ ] ; m_map [ 0 ] = m_map0 ; } public SuballocatedByteVector ( int blocksize , int increaseSize ) { this ( blocksize ) ; } public int size ( ) { return m_firstFree ; } private void setSize ( int sz ) { if ( m_firstFree < sz ) m_firstFree = sz ; } public void addElement ( byte value ) { if ( m_firstFree < m_blocksize ) m_map0 [ m_firstFree ++ ] = value ; else { int index = m_firstFree / m_blocksize ; int offset = m_firstFree % m_blocksize ; ++ m_firstFree ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; block [ offset ] = value ; } } private void addElements ( byte value , int numberOfElements ) { if ( m_firstFree + numberOfElements < m_blocksize ) for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map0 [ m_firstFree ++ ] = value ; } else { int index = m_firstFree / m_blocksize ; int offset = m_firstFree % m_blocksize ; m_firstFree += numberOfElements ; while ( numberOfElements > 0 ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberOfElements ) ? m_blocksize - offset : numberOfElements ; numberOfElements -= copied ; while ( copied -- > 0 ) block [ offset ++ ] = value ; ++ index ; offset = 0 ; } } } private void addElements ( int numberOfElements ) { int newlen = m_firstFree + numberOfElements ; if ( newlen > m_blocksize ) { int index = m_firstFree % m_blocksize ; int newindex = ( m_firstFree + numberOfElements ) % m_blocksize ; for ( int i = index + 1 ; i <= newindex ; ++ i ) m_map [ i ] = new byte [ m_blocksize ] ; } m_firstFree = newlen ; } private void insertElementAt ( byte value , int at ) { if ( at == m_firstFree ) addElement ( value ) ; else if ( at > m_firstFree ) { int index = at / m_blocksize ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; int offset = at % m_blocksize ; block [ offset ] = value ; m_firstFree = offset + 1 ; } else { int index = at / m_blocksize ; int maxindex = m_firstFree + 1 / m_blocksize ; ++ m_firstFree ; int offset = at % m_blocksize ; byte push ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; byte [ ] block = m_map [ index ] ; if ( null == block ) { push = 0 ; block = m_map [ index ] = new byte [ m_blocksize ] ; } else { push = block [ m_blocksize - 1 ] ; System . arraycopy ( block , offset , block , offset + 1 , copylen ) ; } block [ offset ] = value ; value = push ; offset = 0 ; ++ index ; } } } public void removeAllElements ( ) { m_firstFree = 0 ; } private boolean removeElement ( byte s ) { int at = indexOf ( s , 0 ) ; if ( at < 0 ) return false ; removeElementAt ( at ) ; return true ; } private void removeElementAt ( int at ) { if ( at < m_firstFree ) { int index = at / m_blocksize ; int maxindex = m_firstFree / m_blocksize ; int offset = at % m_blocksize ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; else System . arraycopy ( block , offset + 1 , block , offset , copylen ) ; if ( index < maxindex ) { byte [ ] next = m_map [ index + 1 ] ; if ( next != null ) block [ m_blocksize - 1 ] = ( next != null ) ? next [ 0 ] : 0 ; } else block [ m_blocksize - 1 ] = 0 ; offset = 0 ; ++ index ; } } -- m_firstFree ; } public void setElementAt ( byte value , int at ) { if ( at < m_blocksize ) { m_map0 [ at ] = value ; return ; } int index = at / m_blocksize ; int offset = at % m_blocksize ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; block [ offset ] = value ; if ( at >= m_firstFree ) m_firstFree = at + 1 ; } public byte elementAt ( int i ) { if ( i < m_blocksize ) return m_map0 [ i ] ; return m_map [ i / m_blocksize ] [ i % m_blocksize ] ; } private boolean contains ( byte s ) { return ( indexOf ( s , 0 ) >= 0 ) ; } public int indexOf ( byte elem , int index ) { if ( index >= m_firstFree ) return - 1 ; int bindex = index / m_blocksize ; int boffset = index % m_blocksize ; int maxindex = m_firstFree / m_blocksize ; byte [ ] block ; for ( ; bindex < maxindex ; ++ bindex ) { block = m_map [ bindex ] ; if ( block != null ) for ( int offset = boffset ; offset < m_blocksize ; ++ offset ) if ( block [ offset ] == elem ) return offset + bindex * m_blocksize ; boffset = 0 ; } int maxoffset = m_firstFree % m_blocksize ; block = m_map [ maxindex ] ; for ( int offset = boffset ; offset < maxoffset ; ++ offset ) if ( block [ offset ] == elem ) return offset + maxindex * m_blocksize ; return - 1 ; } public int indexOf ( byte elem ) { return indexOf ( elem , 0 ) ; } private int lastIndexOf ( byte elem ) { int boffset = m_firstFree % m_blocksize ; for ( int index = m_firstFree / m_blocksize ; index >= 0 ; -- index ) { byte [ ] block = m_map [ index ] ; if ( block != null ) for ( int offset = boffset ; offset >= 0 ; -- offset ) if ( block [ offset ] == elem ) return offset + index * m_blocksize ; boffset = 0 ; } return - 1 ; } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Lte extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . lessThanOrEqual ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0
package org . apache . xalan . templates ; public class Constants extends org . apache . xml . utils . Constants { public static final int ELEMNAME_UNDEFINED = - 1 , ELEMNAME_WITHPARAM = 2 , ELEMNAME_ADDATTRIBUTE = 4 , ELEMNAME_ANCHOR = 22 , ELEMNAME_APPLY_TEMPLATES = 50 , ELEMNAME_USE = 34 , ELEMNAME_CHILDREN = 6 , ELEMNAME_CHOOSE = 37 , ELEMNAME_COMMENT = 59 , ELEMNAME_CONSTRUCT = 7 , ELEMNAME_CONTENTS = 8 , ELEMNAME_COPY = 9 , ELEMNAME_COPY_OF = 74 , ELEMNAME_DECIMALFORMAT = 83 , ELEMNAME_DEFINEATTRIBUTESET = 40 , ELEMNAME_DEFINESCRIPT = 11 , ELEMNAME_DISPLAYIF = 12 , ELEMNAME_EMPTY = 14 , ELEMNAME_EVAL = 15 , ELEMNAME_EXPECTEDCHILDREN = 16 , ELEMNAME_EXTENSION = 54 , ELEMNAME_EXTENSIONHANDLER = 63 , ELEMNAME_FOREACH = 28 , ELEMNAME_KEY = 31 , ELEMNAME_IF = 36 , ELEMNAME_IMPORT = 26 , ELEMNAME_INCLUDE = 27 , ELEMNAME_CALLTEMPLATE = 17 , ELEMNAME_PARAMVARIABLE = 41 , ELEMNAME_NUMBER = 35 , ELEMNAME_NSALIAS = 84 , ELEMNAME_OTHERWISE = 39 , ELEMNAME_PI = 58 , ELEMNAME_PRESERVESPACE = 33 , ELEMNAME_REMOVEATTRIBUTE = 5 , ELEMNAME_TEMPLATE = 19 , ELEMNAME_SORT = 64 , ELEMNAME_STRIPSPACE = 32 , ELEMNAME_STYLESHEET = 25 , ELEMNAME_TEXT = 42 , ELEMNAME_VALUEOF = 30 , ELEMNAME_WHEN = 38 , ELEMNAME_ROOT = 44 , ELEMNAME_ANY = 45 , ELEMNAME_ELEMENT = 46 , ELEMNAME_TARGETELEMENT = 47 , ELEMNAME_ATTRIBUTE = 48 , ELEMNAME_TARGETATTRIBUTE = 49 , ELEMNAME_URL = 52 , ELEMNAME_CALL = 55 , ELEMNAME_FALLBACK = 57 , ELEMNAME_TARGETPI = 60 , ELEMNAME_TARGETCOMMENT = 61 , ELEMNAME_TARGETTEXT = 62 , ELEMNAME_CSSSTYLECONVERSION = 65 , ELEMNAME_COUNTER = 66 , ELEMNAME_COUNTERS = 67 , ELEMNAME_COUNTERINCREMENT = 68 , ELEMNAME_COUNTERRESET = 69 , ELEMNAME_COUNTERSCOPE = 71 , ELEMNAME_APPLY_IMPORTS = 72 , ELEMNAME_VARIABLE = 73 , ELEMNAME_MESSAGE = 75 , ELEMNAME_LOCALE = 76 , ELEMNAME_LITERALRESULT = 77 , ELEMNAME_TEXTLITERALRESULT = 78 , ELEMNAME_EXTENSIONCALL = 79 , ELEMNAME_EXTENSIONDECL = 85 , ELEMNAME_EXTENSIONSCRIPT = 86 , ELEMNAME_OUTPUT = 80 , ELEMNAME_COMPONENT = 81 , ELEMNAME_SCRIPT = 82 ; public static final String ELEMNAME_ANCHOR_STRING = "anchor" , ELEMNAME_ANY_STRING = "any" , ELEMNAME_APPLY_IMPORTS_STRING = "apply-imports" , ELEMNAME_APPLY_TEMPLATES_STRING = "apply-templates" , ELEMNAME_ARG_STRING = "arg" , ELEMNAME_ATTRIBUTESET_STRING = "attribute-set" , ELEMNAME_ATTRIBUTE_STRING = "attribute" , ELEMNAME_CALLTEMPLATEARG_STRING = "invoke-arg" , ELEMNAME_CALLTEMPLATE_STRING = "call-template" , ELEMNAME_CALL_STRING = "call" , ELEMNAME_CHILDREN_STRING = "children" , ELEMNAME_CHOOSE_STRING = "choose" , ELEMNAME_COMMENT_STRING = "comment" , ELEMNAME_COMPONENT_STRING = "component" , ELEMNAME_CONSTRUCT_STRING = "construct" , ELEMNAME_CONTENTS_STRING = "contents" , ELEMNAME_COPY_OF_STRING = "copy-of" , ELEMNAME_COPY_STRING = "copy" , ELEMNAME_COUNTERINCREMENT_STRING = "counter-increment" , ELEMNAME_COUNTERRESET_STRING = "counter-reset" , ELEMNAME_COUNTERSCOPE_STRING = "counter-scope" , ELEMNAME_COUNTERS_STRING = "counters" , ELEMNAME_COUNTER_STRING = "counter" , ELEMNAME_CSSSTYLECONVERSION_STRING = "css-style-conversion" , ELEMNAME_DECIMALFORMAT_STRING = "decimal-format" , ELEMNAME_DISPLAYIF_STRING = "display-if" , ELEMNAME_ELEMENT_STRING = "element" , ELEMNAME_EMPTY_STRING = "empty" , ELEMNAME_EVAL_STRING = "eval" , ELEMNAME_EXPECTEDCHILDREN_STRING = "expectedchildren" , ELEMNAME_EXTENSIONHANDLER_STRING = "code-dispatcher" , ELEMNAME_EXTENSION_STRING = "functions" , ELEMNAME_FALLBACK_STRING = "fallback" , ELEMNAME_FOREACH_STRING = "for-each" , ELEMNAME_IF_STRING = "if" , ELEMNAME_IMPORT_STRING = "import" , ELEMNAME_INCLUDE_STRING = "include" , ELEMNAME_KEY_STRING = "key" , ELEMNAME_LOCALE_STRING = "locale" , ELEMNAME_MESSAGE_STRING = "message" , ELEMNAME_NSALIAS_STRING = "namespace-alias" , ELEMNAME_NUMBER_STRING = "number" , ELEMNAME_OTHERWISE_STRING = "otherwise" , ELEMNAME_OUTPUT_STRING = "output" , ELEMNAME_PARAMVARIABLE_STRING = "param" , ELEMNAME_PI_OLD_STRING = "pi" , ELEMNAME_PI_STRING = "processing-instruction" , ELEMNAME_PRESERVESPACE_STRING = "preserve-space" , ELEMNAME_ROOT_STRING = "root" , ELEMNAME_SCRIPT_STRING = "script" , ELEMNAME_SORT_STRING = "sort" , ELEMNAME_STRIPSPACE_STRING = "strip-space" , ELEMNAME_STYLESHEET_STRING = "stylesheet" , ELEMNAME_TARGETATTRIBUTE_STRING = "target-attribute" , ELEMNAME_TARGETCOMMENT_STRING = "target-comment" , ELEMNAME_TARGETELEMENT_STRING = "target-element" , ELEMNAME_TARGETPI_STRING = "target-pi" , ELEMNAME_TARGETTEXT_STRING = "target-text" , ELEMNAME_TEMPLATE_STRING = "template" , ELEMNAME_TEXT_STRING = "text" , ELEMNAME_TRANSFORM_STRING = "transform" , ELEMNAME_URL_STRING = "uri" , ELEMNAME_USE_STRING = "use" , ELEMNAME_VALUEOF_STRING = "value-of" , ELEMNAME_VARIABLE_STRING = "variable" , ELEMNAME_WHEN_STRING = "when" , ELEMNAME_WITHPARAM_STRING = "with-param" ; public static final String EXSLT_ELEMNAME_FUNCTION_STRING = "function" , EXSLT_ELEMNAME_FUNCRESULT_STRING = "result" ; public static final int EXSLT_ELEMNAME_FUNCTION = 88 , EXSLT_ELEMNAME_FUNCRESULT = 89 ; public static final String ATTRNAME_AMOUNT = "amount" , ATTRNAME_ANCESTOR = "ancestor" , ATTRNAME_ARCHIVE = "archive" , ATTRNAME_ATTRIBUTE = "attribute" , ATTRNAME_ATTRIBUTE_SET = "attribute-set" , ATTRNAME_CASEORDER = "case-order" , ATTRNAME_CLASS = "class" , ATTRNAME_CLASSID = "classid" , ATTRNAME_CODEBASE = "codebase" , ATTRNAME_CODETYPE = "type" , ATTRNAME_CONDITION = "condition" , ATTRNAME_COPYTYPE = "copy-type" , ATTRNAME_COUNT = "count" , ATTRNAME_DATATYPE = "data-type" , ATTRNAME_DECIMALSEPARATOR = "decimal-separator" , ATTRNAME_DEFAULT = "default" , ATTRNAME_DEFAULTSPACE = "default-space" , ATTRNAME_DEPTH = "with-children" , ATTRNAME_DIGIT = "digit" , ATTRNAME_DIGITGROUPSEP = "digit-group-sep" , ATTRNAME_DISABLE_OUTPUT_ESCAPING = "disable-output-escaping" , ATTRNAME_ELEMENT = "element" , ATTRNAME_ELEMENTS = "elements" , ATTRNAME_EXCLUDE_RESULT_PREFIXES = "exclude-result-prefixes" , ATTRNAME_EXPR = "expr" , ATTRNAME_EXTENSIONELEMENTPREFIXES = "extension-element-prefixes" , ATTRNAME_FORMAT = "format" , ATTRNAME_FROM = "from" , ATTRNAME_GROUPINGSEPARATOR = "grouping-separator" , ATTRNAME_GROUPINGSIZE = "grouping-size" , ATTRNAME_HREF = "href" , ATTRNAME_ID = "id" , ATTRNAME_IMPORTANCE = "importance" , ATTRNAME_INDENTRESULT = "indent-result" , ATTRNAME_INFINITY = "infinity" , ATTRNAME_LANG = "lang" , ATTRNAME_LETTERVALUE = "letter-value" , ATTRNAME_LEVEL = "level" , ATTRNAME_MATCH = "match" , ATTRNAME_METHOD = "calls" , ATTRNAME_MINUSSIGN = "minus-sign" , ATTRNAME_MODE = "mode" , ATTRNAME_NAME = "name" , ATTRNAME_NAMESPACE = "namespace" , ATTRNAME_NAN = "NaN" , ATTRNAME_NDIGITSPERGROUP = "n-digits-per-group" , ATTRNAME_NS = "ns" , ATTRNAME_ONLY = "only" , ATTRNAME_ORDER = "order" , ATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = "cdata-section-elements" , ATTRNAME_OUTPUT_DOCTYPE_PUBLIC = "doctype-public" , ATTRNAME_OUTPUT_DOCTYPE_SYSTEM = "doctype-system" , ATTRNAME_OUTPUT_ENCODING = "encoding" , ATTRNAME_OUTPUT_INDENT = "indent" , ATTRNAME_OUTPUT_MEDIATYPE = "media-type" , ATTRNAME_OUTPUT_METHOD = "method" , ATTRNAME_OUTPUT_OMITXMLDECL = "omit-xml-declaration" , ATTRNAME_OUTPUT_STANDALONE = "standalone" , ATTRNAME_OUTPUT_VERSION = "version" , ATTRNAME_PATTERNSEPARATOR = "pattern-separator" , ATTRNAME_PERCENT = "percent" , ATTRNAME_PERMILLE = "per-mille" , ATTRNAME_PRIORITY = "priority" , ATTRNAME_REFID = "refID" , ATTRNAME_RESULTNS = "result-ns" , ATTRNAME_RESULT_PREFIX = "result-prefix" , ATTRNAME_SELECT = "select" , ATTRNAME_SEQUENCESRC = "sequence-src" , ATTRNAME_STYLE = "style" , ATTRNAME_STYLESHEET_PREFIX = "stylesheet-prefix" , ATTRNAME_TERMINATE = "terminate" , ATTRNAME_TEST = "test" , ATTRNAME_TOSTRING = "to-string" , ATTRNAME_TYPE = "type" , ATTRNAME_USE = "use" , ATTRNAME_USEATTRIBUTESETS = "use-attribute-sets" , ATTRNAME_VALUE = "value" , ATTRNAME_VERSION = "version" , ATTRNAME_XMLNS = "xmlns:" , ATTRNAME_XMLNSDEF = "xmlns" , ATTRNAME_XMLSPACE = "xml:space" , ATTRNAME_ZERODIGIT = "zero-digit" ; public static final int TATTRNAME_OUTPUT_METHOD = 1 , TATTRNAME_AMOUNT = 2 , TATTRNAME_ANCESTOR = 3 , TATTRNAME_ARCHIVE = 4 , TATTRNAME_ATTRIBUTE = 5 , TATTRNAME_ATTRIBUTE_SET = 6 , TATTRNAME_CASEORDER = 7 , TATTRNAME_CLASS = 8 , TATTRNAME_CLASSID = 9 , TATTRNAME_CODEBASE = 10 , TATTRNAME_CODETYPE = 11 , TATTRNAME_CONDITION = 12 , TATTRNAME_COPYTYPE = 13 , TATTRNAME_COUNT = 14 , TATTRNAME_DATATYPE = 15 , TATTRNAME_DEFAULT = 16 , TATTRNAME_DEFAULTSPACE = 17 , TATTRNAME_DEPTH = 18 , TATTRNAME_DIGITGROUPSEP = 19 , TATTRNAME_DISABLE_OUTPUT_ESCAPING = 20 , TATTRNAME_ELEMENT = 21 , TATTRNAME_ELEMENTS = 22 , TATTRNAME_EXPR = 23 , TATTRNAME_EXTENSIONELEMENTPREFIXES = 24 , TATTRNAME_FORMAT = 25 , TATTRNAME_FROM = 26 , TATTRNAME_GROUPINGSEPARATOR = 27 , TATTRNAME_GROUPINGSIZE = 28 , TATTRNAME_HREF = 29 , TATTRNAME_ID = 30 , TATTRNAME_IMPORTANCE = 31 , TATTRNAME_INDENTRESULT = 32 , TATTRNAME_LANG = 33 , TATTRNAME_LETTERVALUE = 34 , TATTRNAME_LEVEL = 35 , TATTRNAME_MATCH = 36 , TATTRNAME_METHOD = 37 , TATTRNAME_MODE = 38 , TATTRNAME_NAME = 39 , TATTRNAME_NAMESPACE = 40 , TATTRNAME_NDIGITSPERGROUP = 41 , TATTRNAME_NS = 42 , TATTRNAME_ONLY = 43 , TATTRNAME_ORDER = 44 , TATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = 45 , TATTRNAME_OUTPUT_DOCTYPE_PUBLIC = 46 , TATTRNAME_OUTPUT_DOCTYPE_SYSTEM = 47 , TATTRNAME_OUTPUT_ENCODING = 48 , TATTRNAME_OUTPUT_INDENT = 49 , TATTRNAME_OUTPUT_MEDIATYPE = 50 , TATTRNAME_OUTPUT_STANDALONE = 51 , TATTRNAME_OUTPUT_VERSION = 52 , TATTRNAME_OUTPUT_OMITXMLDECL = 53 , TATTRNAME_PRIORITY = 54 , TATTRNAME_REFID = 55 , TATTRNAME_RESULTNS = 56 , TATTRNAME_SELECT = 57 , TATTRNAME_SEQUENCESRC = 58 , TATTRNAME_STYLE = 59 , TATTRNAME_TEST = 60 , TATTRNAME_TOSTRING = 61 , TATTRNAME_TYPE = 62 , TATTRNAME_USE = 63 , TATTRNAME_USEATTRIBUTESETS = 64 , TATTRNAME_VALUE = 65 , TATTRNAME_XMLNSDEF = 66 , TATTRNAME_XMLNS = 67 , TATTRNAME_XMLSPACE = 68 , TATTRNAME_EXCLUDE_RESULT_PREFIXES = 69 ; public static final String ATTRVAL_OUTPUT_METHOD_HTML = "html" , ATTRVAL_OUTPUT_METHOD_XML = "xml" , ATTRVAL_OUTPUT_METHOD_TEXT = "text" ; public static final int ATTRVAL_PRESERVE = 1 , ATTRVAL_STRIP = 2 ; public static final boolean ATTRVAL_YES = true , ATTRVAL_NO = false ; public static final String ATTRVAL_ALPHABETIC = "alphabetic" , ATTRVAL_OTHER = "other" , ATTRVAL_TRADITIONAL = "traditional" ; public static final String ATTRVAL_SINGLE = "single" , ATTRVAL_MULTI = "multiple" , ATTRVAL_ANY = "any" ; public static final String ATTRVAL_DEFAULT_PREFIX = "#default" ; public static final int NUMBERLETTER_ALPHABETIC = 1 , NUMBERLETTER_TRADITIONAL = 2 ; public static final int NUMBERLEVEL_SINGLE = 1 , NUMBERLEVEL_MULTI = 2 , NUMBERLEVEL_ANY = 3 , MAX_MULTI_COUNTING_DEPTH = 32 ; public static final String ATTRVAL_THIS = "." , ATTRVAL_PARENT = ".." , ATTRVAL_ANCESTOR = "ancestor" , ATTRVAL_ID = "id" ; public static final String ATTRVAL_DATATYPE_TEXT = "text" , ATTRVAL_DATATYPE_NUMBER = "number" , ATTRVAL_ORDER_ASCENDING = "ascending" , ATTRVAL_ORDER_DESCENDING = "descending" , ATTRVAL_CASEORDER_UPPER = "upper-first" , ATTRVAL_CASEORDER_LOWER = "lower-first" ; public static final int SORTDATATYPE_TEXT = 1 , SORTDATATYPE_NUMBER = 2 ; public static final int SORTORDER_ASCENDING = 1 , SORTORDER_DESCENDING = 2 ; public static final int SORTCASEORDER_UPPERFIRST = 1 , SORTCASEORDER_LOWERFIRST = 2 ; public static final String ATTRVAL_INFINITY = "Infinity" , ATTRVAL_NAN = "NaN" , DEFAULT_DECIMAL_FORMAT = "#default" ; public static final String ATTRNAME_XXXX = "XXXX" ; } 	1
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemFallback extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_FALLBACK ; } public String getNodeName ( ) { return Constants . ELEMNAME_FALLBACK_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { } public void executeFallback ( TransformerImpl transformer ) throws TransformerException { if ( Constants . ELEMNAME_EXTENSIONCALL == m_parentNode . getXSLToken ( ) ) { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } else { System . out . println ( "Error!  parent of xsl:fallback must be an extension element!" ) ; } } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Number extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { if ( XObject . CLASS_NUMBER == right . getType ( ) ) return right ; else return new XNumber ( right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_right . num ( xctxt ) ; } } 	0
package org . apache . xml . utils ; import java . io . IOException ; import java . io . Serializable ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class URI implements Serializable { public static class MalformedURIException extends IOException { public MalformedURIException ( ) { super ( ) ; } public MalformedURIException ( String p_msg ) { super ( p_msg ) ; } } private static final String RESERVED_CHARACTERS = ";/?:@&=+$," ; private static final String MARK_CHARACTERS = "-_.!~*'() " ; private static final String SCHEME_CHARACTERS = "+-." ; private static final String USERINFO_CHARACTERS = ";:&=+$," ; private String m_scheme = null ; private String m_userinfo = null ; private String m_host = null ; private int m_port = - 1 ; private String m_path = null ; private String m_queryString = null ; private String m_fragment = null ; private static boolean DEBUG = false ; public URI ( ) { } public URI ( URI p_other ) { initialize ( p_other ) ; } public URI ( String p_uriSpec ) throws MalformedURIException { this ( ( URI ) null , p_uriSpec ) ; } public URI ( URI p_base , String p_uriSpec ) throws MalformedURIException { initialize ( p_base , p_uriSpec ) ; } public URI ( String p_scheme , String p_schemeSpecificPart ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme!" ) ; } if ( p_schemeSpecificPart == null || p_schemeSpecificPart . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme-specific part!" ) ; } setScheme ( p_scheme ) ; setPath ( p_schemeSpecificPart ) ; } public URI ( String p_scheme , String p_host , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { this ( p_scheme , null , p_host , - 1 , p_path , p_queryString , p_fragment ) ; } public URI ( String p_scheme , String p_userinfo , String p_host , int p_port , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_REQUIRED , null ) ) ; } if ( p_host == null ) { if ( p_userinfo != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_USERINFO_IF_NO_HOST , null ) ) ; } if ( p_port != - 1 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_PORT_IF_NO_HOST , null ) ) ; } } if ( p_path != null ) { if ( p_path . indexOf ( '?' ) != - 1 && p_queryString != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_QUERY_STRING_IN_PATH , null ) ) ; } if ( p_path . indexOf ( '#' ) != - 1 && p_fragment != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_FRAGMENT_STRING_IN_PATH , null ) ) ; } } setScheme ( p_scheme ) ; setHost ( p_host ) ; setPort ( p_port ) ; setUserinfo ( p_userinfo ) ; setPath ( p_path ) ; setQueryString ( p_queryString ) ; setFragment ( p_fragment ) ; } private void initialize ( URI p_other ) { m_scheme = p_other . getScheme ( ) ; m_userinfo = p_other . getUserinfo ( ) ; m_host = p_other . getHost ( ) ; m_port = p_other . getPort ( ) ; m_path = p_other . getPath ( ) ; m_queryString = p_other . getQueryString ( ) ; m_fragment = p_other . getFragment ( ) ; } private void initialize ( URI p_base , String p_uriSpec ) throws MalformedURIException { if ( p_base == null && ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANNOT_INIT_URI_EMPTY_PARMS , null ) ) ; } if ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) { initialize ( p_base ) ; return ; } String uriSpec = p_uriSpec . trim ( ) ; int uriSpecLen = uriSpec . length ( ) ; int index = 0 ; int colonIndex = uriSpec . indexOf ( ':' ) ; if ( colonIndex < 0 ) { if ( p_base == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_SCHEME_IN_URI , new Object [ ] { uriSpec } ) ) ; } } else { initializeScheme ( uriSpec ) ; uriSpec = uriSpec . substring ( colonIndex + 1 ) ; uriSpecLen = uriSpec . length ( ) ; } if ( ( ( index + 1 ) < uriSpecLen ) && ( uriSpec . substring ( index ) . startsWith ( "//" ) ) ) { index += 2 ; int startPos = index ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = uriSpec . charAt ( index ) ; if ( testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } if ( index > startPos ) { initializeAuthority ( uriSpec . substring ( startPos , index ) ) ; } else { m_host = "" ; } } initializePath ( uriSpec . substring ( index ) ) ; if ( p_base != null ) { if ( m_path . length ( ) == 0 && m_scheme == null && m_host == null ) { m_scheme = p_base . getScheme ( ) ; m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; m_path = p_base . getPath ( ) ; if ( m_queryString == null ) { m_queryString = p_base . getQueryString ( ) ; } return ; } if ( m_scheme == null ) { m_scheme = p_base . getScheme ( ) ; } if ( m_host == null ) { m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; } else { return ; } if ( m_path . length ( ) > 0 && m_path . startsWith ( "/" ) ) { return ; } String path = new String ( ) ; String basePath = p_base . getPath ( ) ; if ( basePath != null ) { int lastSlash = basePath . lastIndexOf ( '/' ) ; if ( lastSlash != - 1 ) { path = basePath . substring ( 0 , lastSlash + 1 ) ; } } path = path . concat ( m_path ) ; index = - 1 ; while ( ( index = path . indexOf ( "/./" ) ) != - 1 ) { path = path . substring ( 0 , index + 1 ) . concat ( path . substring ( index + 3 ) ) ; } if ( path . endsWith ( "/." ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } index = - 1 ; int segIndex = - 1 ; String tempString = null ; while ( ( index = path . indexOf ( "/../" ) ) > 0 ) { tempString = path . substring ( 0 , path . indexOf ( "/../" ) ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { if ( ! tempString . substring ( segIndex ++ ) . equals ( ".." ) ) { path = path . substring ( 0 , segIndex ) . concat ( path . substring ( index + 4 ) ) ; } } } if ( path . endsWith ( "/.." ) ) { tempString = path . substring ( 0 , path . length ( ) - 3 ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { path = path . substring ( 0 , segIndex + 1 ) ; } } m_path = path ; } } private void initializeScheme ( String p_uriSpec ) throws MalformedURIException { int uriSpecLen = p_uriSpec . length ( ) ; int index = 0 ; String scheme = null ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } scheme = p_uriSpec . substring ( 0 , index ) ; if ( scheme . length ( ) == 0 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_SCHEME_INURI , null ) ) ; } else { setScheme ( scheme ) ; } } private void initializeAuthority ( String p_uriSpec ) throws MalformedURIException { int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; String userinfo = null ; if ( p_uriSpec . indexOf ( '@' , start ) != - 1 ) { while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '@' ) { break ; } index ++ ; } userinfo = p_uriSpec . substring ( start , index ) ; index ++ ; } String host = null ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' ) { break ; } index ++ ; } host = p_uriSpec . substring ( start , index ) ; int port = - 1 ; if ( host . length ( ) > 0 ) { if ( testChar == ':' ) { index ++ ; start = index ; while ( index < end ) { index ++ ; } String portStr = p_uriSpec . substring ( start , index ) ; if ( portStr . length ( ) > 0 ) { for ( int i = 0 ; i < portStr . length ( ) ; i ++ ) { if ( ! isDigit ( portStr . charAt ( i ) ) ) { throw new MalformedURIException ( portStr + " is invalid. Port should only contain digits!" ) ; } } try { port = Integer . parseInt ( portStr ) ; } catch ( NumberFormatException nfe ) { } } } } setHost ( host ) ; setPort ( port ) ; setUserinfo ( userinfo ) ; } private void initializePath ( String p_uriSpec ) throws MalformedURIException { if ( p_uriSpec == null ) { throw new MalformedURIException ( "Cannot initialize path from null string!" ) ; } int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '?' || testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , null ) ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { if ( '\\' != testChar ) throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { String . valueOf ( testChar ) } ) ) ; } index ++ ; } m_path = p_uriSpec . substring ( start , index ) ; if ( testChar == '?' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Query string contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Query string contains invalid character:" + testChar ) ; } index ++ ; } m_queryString = p_uriSpec . substring ( start , index ) ; } if ( testChar == '#' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Fragment contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Fragment contains invalid character:" + testChar ) ; } index ++ ; } m_fragment = p_uriSpec . substring ( start , index ) ; } } public String getScheme ( ) { return m_scheme ; } public String getSchemeSpecificPart ( ) { StringBuffer schemespec = new StringBuffer ( ) ; if ( m_userinfo != null || m_host != null || m_port != - 1 ) { schemespec . append ( "//" ) ; } if ( m_userinfo != null ) { schemespec . append ( m_userinfo ) ; schemespec . append ( '@' ) ; } if ( m_host != null ) { schemespec . append ( m_host ) ; } if ( m_port != - 1 ) { schemespec . append ( ':' ) ; schemespec . append ( m_port ) ; } if ( m_path != null ) { schemespec . append ( ( m_path ) ) ; } if ( m_queryString != null ) { schemespec . append ( '?' ) ; schemespec . append ( m_queryString ) ; } if ( m_fragment != null ) { schemespec . append ( '#' ) ; schemespec . append ( m_fragment ) ; } return schemespec . toString ( ) ; } public String getUserinfo ( ) { return m_userinfo ; } public String getHost ( ) { return m_host ; } public int getPort ( ) { return m_port ; } public String getPath ( boolean p_includeQueryString , boolean p_includeFragment ) { StringBuffer pathString = new StringBuffer ( m_path ) ; if ( p_includeQueryString && m_queryString != null ) { pathString . append ( '?' ) ; pathString . append ( m_queryString ) ; } if ( p_includeFragment && m_fragment != null ) { pathString . append ( '#' ) ; pathString . append ( m_fragment ) ; } return pathString . toString ( ) ; } public String getPath ( ) { return m_path ; } public String getQueryString ( ) { return m_queryString ; } public String getFragment ( ) { return m_fragment ; } public void setScheme ( String p_scheme ) throws MalformedURIException { if ( p_scheme == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_FROM_NULL_STRING , null ) ) ; } if ( ! isConformantSchemeName ( p_scheme ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_NOT_CONFORMANT , null ) ) ; } m_scheme = p_scheme . toLowerCase ( ) ; } public void setUserinfo ( String p_userinfo ) throws MalformedURIException { if ( p_userinfo == null ) { m_userinfo = null ; } else { if ( m_host == null ) { throw new MalformedURIException ( "Userinfo cannot be set when host is null!" ) ; } int index = 0 ; int end = p_userinfo . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_userinfo . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Userinfo contains invalid escape sequence!" ) ; } } else if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { throw new MalformedURIException ( "Userinfo contains invalid character:" + testChar ) ; } index ++ ; } } m_userinfo = p_userinfo ; } public void setHost ( String p_host ) throws MalformedURIException { if ( p_host == null || p_host . trim ( ) . length ( ) == 0 ) { m_host = p_host ; m_userinfo = null ; m_port = - 1 ; } else if ( ! isWellFormedAddress ( p_host ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_HOST_ADDRESS_NOT_WELLFORMED , null ) ) ; } m_host = p_host ; } public void setPort ( int p_port ) throws MalformedURIException { if ( p_port >= 0 && p_port <= 65535 ) { if ( m_host == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PORT_WHEN_HOST_NULL , null ) ) ; } } else if ( p_port != - 1 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_PORT , null ) ) ; } m_port = p_port ; } public void setPath ( String p_path ) throws MalformedURIException { if ( p_path == null ) { m_path = null ; m_queryString = null ; m_fragment = null ; } else { initializePath ( p_path ) ; } } public void appendPath ( String p_addToPath ) throws MalformedURIException { if ( p_addToPath == null || p_addToPath . trim ( ) . length ( ) == 0 ) { return ; } if ( ! isURIString ( p_addToPath ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { p_addToPath } ) ) ; } if ( m_path == null || m_path . trim ( ) . length ( ) == 0 ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = p_addToPath ; } else { m_path = "/" + p_addToPath ; } } else if ( m_path . endsWith ( "/" ) ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; } else { m_path = m_path . concat ( p_addToPath ) ; } } else { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath ) ; } else { m_path = m_path . concat ( "/" + p_addToPath ) ; } } } public void setQueryString ( String p_queryString ) throws MalformedURIException { if ( p_queryString == null ) { m_queryString = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( "Query string can only be set for a generic URI!" ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( "Query string cannot be set when path is null!" ) ; } else if ( ! isURIString ( p_queryString ) ) { throw new MalformedURIException ( "Query string contains invalid character!" ) ; } else { m_queryString = p_queryString ; } } public void setFragment ( String p_fragment ) throws MalformedURIException { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_FOR_GENERIC_URI , null ) ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_WHEN_PATH_NULL , null ) ) ; } else if ( ! isURIString ( p_fragment ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_INVALID_CHAR , null ) ) ; } else { m_fragment = p_fragment ; } } public boolean equals ( Object p_test ) { if ( p_test instanceof URI ) { URI testURI = ( URI ) p_test ; if ( ( ( m_scheme == null && testURI . m_scheme == null ) || ( m_scheme != null && testURI . m_scheme != null && m_scheme . equals ( testURI . m_scheme ) ) ) && ( ( m_userinfo == null && testURI . m_userinfo == null ) || ( m_userinfo != null && testURI . m_userinfo != null && m_userinfo . equals ( testURI . m_userinfo ) ) ) && ( ( m_host == null && testURI . m_host == null ) || ( m_host != null && testURI . m_host != null && m_host . equals ( testURI . m_host ) ) ) && m_port == testURI . m_port && ( ( m_path == null && testURI . m_path == null ) || ( m_path != null && testURI . m_path != null && m_path . equals ( testURI . m_path ) ) ) && ( ( m_queryString == null && testURI . m_queryString == null ) || ( m_queryString != null && testURI . m_queryString != null && m_queryString . equals ( testURI . m_queryString ) ) ) && ( ( m_fragment == null && testURI . m_fragment == null ) || ( m_fragment != null && testURI . m_fragment != null && m_fragment . equals ( testURI . m_fragment ) ) ) ) { return true ; } } return false ; } public String toString ( ) { StringBuffer uriSpecString = new StringBuffer ( ) ; if ( m_scheme != null ) { uriSpecString . append ( m_scheme ) ; uriSpecString . append ( ':' ) ; } uriSpecString . append ( getSchemeSpecificPart ( ) ) ; return uriSpecString . toString ( ) ; } public boolean isGenericURI ( ) { return ( m_host != null ) ; } public static boolean isConformantSchemeName ( String p_scheme ) { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { return false ; } if ( ! isAlpha ( p_scheme . charAt ( 0 ) ) ) { return false ; } char testChar ; for ( int i = 1 ; i < p_scheme . length ( ) ; i ++ ) { testChar = p_scheme . charAt ( i ) ; if ( ! isAlphanum ( testChar ) && SCHEME_CHARACTERS . indexOf ( testChar ) == - 1 ) { return false ; } } return true ; } public static boolean isWellFormedAddress ( String p_address ) { if ( p_address == null ) { return false ; } String address = p_address . trim ( ) ; int addrLength = address . length ( ) ; if ( addrLength == 0 || addrLength > 255 ) { return false ; } if ( address . startsWith ( "." ) || address . startsWith ( "-" ) ) { return false ; } int index = address . lastIndexOf ( '.' ) ; if ( address . endsWith ( "." ) ) { index = address . substring ( 0 , index ) . lastIndexOf ( '.' ) ; } if ( index + 1 < addrLength && isDigit ( p_address . charAt ( index + 1 ) ) ) { char testChar ; int numDots = 0 ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isDigit ( address . charAt ( i - 1 ) ) || ( i + 1 < addrLength && ! isDigit ( address . charAt ( i + 1 ) ) ) ) { return false ; } numDots ++ ; } else if ( ! isDigit ( testChar ) ) { return false ; } } if ( numDots != 3 ) { return false ; } } else { char testChar ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isAlphanum ( address . charAt ( i - 1 ) ) ) { return false ; } if ( i + 1 < addrLength && ! isAlphanum ( address . charAt ( i + 1 ) ) ) { return false ; } } else if ( ! isAlphanum ( testChar ) && testChar != '-' ) { return false ; } } } return true ; } private static boolean isDigit ( char p_char ) { return p_char >= '0' && p_char <= '9' ; } private static boolean isHex ( char p_char ) { return ( isDigit ( p_char ) || ( p_char >= 'a' && p_char <= 'f' ) || ( p_char >= 'A' && p_char <= 'F' ) ) ; } private static boolean isAlpha ( char p_char ) { return ( ( p_char >= 'a' && p_char <= 'z' ) || ( p_char >= 'A' && p_char <= 'Z' ) ) ; } private static boolean isAlphanum ( char p_char ) { return ( isAlpha ( p_char ) || isDigit ( p_char ) ) ; } private static boolean isReservedCharacter ( char p_char ) { return RESERVED_CHARACTERS . indexOf ( p_char ) != - 1 ; } private static boolean isUnreservedCharacter ( char p_char ) { return ( isAlphanum ( p_char ) || MARK_CHARACTERS . indexOf ( p_char ) != - 1 ) ; } private static boolean isURIString ( String p_uric ) { if ( p_uric == null ) { return false ; } int end = p_uric . length ( ) ; char testChar = '\0' ; for ( int i = 0 ; i < end ; i ++ ) { testChar = p_uric . charAt ( i ) ; if ( testChar == '%' ) { if ( i + 2 >= end || ! isHex ( p_uric . charAt ( i + 1 ) ) || ! isHex ( p_uric . charAt ( i + 2 ) ) ) { return false ; } else { i += 2 ; continue ; } } if ( isReservedCharacter ( testChar ) || isUnreservedCharacter ( testChar ) ) { continue ; } else { return false ; } } return true ; } } 	0
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Mult extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) * right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) * m_right . num ( xctxt ) ) ; } } 	0
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . BitSet ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . WrappedRuntimeException ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; abstract public class ToStream extends SerializerBase { private static final String COMMENT_BEGIN = "<!--" ; private static final String COMMENT_END = "-->" ; protected BoolStack m_disableOutputEscapingStates = new BoolStack ( ) ; boolean m_triedToGetConverter = false ; java . lang . reflect . Method m_canConvertMeth ; Object m_charToByteConverter = null ; protected BoolStack m_preserves = new BoolStack ( ) ; protected boolean m_ispreserve = false ; protected boolean m_isprevtext = false ; private static CharInfo m_xmlcharInfo = CharInfo . getCharInfo ( CharInfo . XML_ENTITIES_RESOURCE ) ; protected int m_maxCharacter = Encodings . getLastPrintable ( ) ; protected final char [ ] m_lineSep = System . getProperty ( "line.separator" ) . toCharArray ( ) ; protected final int m_lineSepLen = m_lineSep . length ; protected CharInfo m_charInfo ; private static Hashtable m_charInfos = null ; boolean m_shouldFlush = true ; protected boolean m_spaceBeforeClose = false ; boolean m_startNewLine ; protected boolean m_inDoctype = false ; boolean m_isUTF8 = false ; protected Properties m_format ; protected boolean m_cdataStartCalled = false ; public ToStream ( ) { } protected void closeCDATA ( ) throws org . xml . sax . SAXException { try { m_writer . write ( CDATA_DELIMITER_CLOSE ) ; m_cdataTagOpen = false ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void serialize ( Node node ) throws IOException { try { TreeWalker walker = new TreeWalker ( this , new org . apache . xml . utils . DOM2Helper ( ) ) ; walker . traverse ( node ) ; } catch ( org . xml . sax . SAXException se ) { throw new WrappedRuntimeException ( se ) ; } } static final boolean isUTF16Surrogate ( char c ) { return ( c & 0xFC00 ) == 0xD800 ; } private boolean m_escaping = true ; protected final void flushWriter ( ) throws org . xml . sax . SAXException { if ( null != m_writer ) { try { if ( m_writer instanceof WriterToUTF8Buffered ) { if ( m_shouldFlush ) ( ( WriterToUTF8Buffered ) m_writer ) . flush ( ) ; else ( ( WriterToUTF8Buffered ) m_writer ) . flushBuffer ( ) ; } if ( m_writer instanceof WriterToUTF8 ) { if ( m_shouldFlush ) m_writer . flush ( ) ; } else if ( m_writer instanceof WriterToASCI ) { if ( m_shouldFlush ) m_writer . flush ( ) ; } else { m_writer . flush ( ) ; } } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( ioe ) ; } } } public OutputStream getOutputStream ( ) { if ( m_writer instanceof WriterToUTF8Buffered ) return ( ( WriterToUTF8Buffered ) m_writer ) . getOutputStream ( ) ; if ( m_writer instanceof WriterToUTF8 ) return ( ( WriterToUTF8 ) m_writer ) . getOutputStream ( ) ; else if ( m_writer instanceof WriterToASCI ) return ( ( WriterToASCI ) m_writer ) . getOutputStream ( ) ; else return null ; } public void elementDecl ( String name , String model ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_inDoctype ) { m_writer . write ( " [" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } m_writer . write ( "<!ELEMENT " ) ; m_writer . write ( name ) ; m_writer . write ( ' ' ) ; m_writer . write ( model ) ; m_writer . write ( '>' ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_inDoctype ) { m_writer . write ( " [" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } outputEntityDecl ( name , value ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } void outputEntityDecl ( String name , String value ) throws IOException { m_writer . write ( "<!ENTITY " ) ; m_writer . write ( name ) ; m_writer . write ( " \"" ) ; m_writer . write ( value ) ; m_writer . write ( "\">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } protected final void outputLineSep ( ) throws IOException { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } public void setOutputFormat ( Properties format ) { boolean shouldFlush = m_shouldFlush ; init ( m_writer , format , false , false ) ; m_shouldFlush = shouldFlush ; } private synchronized void init ( Writer writer , Properties format , boolean defaultProperties , boolean shouldFlush ) { m_shouldFlush = shouldFlush ; if ( m_tracer != null && ! ( writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; else m_writer = writer ; m_format = format ; setCdataSectionElements ( OutputKeys . CDATA_SECTION_ELEMENTS , format ) ; setIndentAmount ( OutputPropertyUtils . getIntProperty ( OutputPropertiesFactory . S_KEY_INDENT_AMOUNT , format ) ) ; setIndent ( OutputPropertyUtils . getBooleanProperty ( OutputKeys . INDENT , format ) ) ; boolean shouldNotWriteXMLHeader = OutputPropertyUtils . getBooleanProperty ( OutputKeys . OMIT_XML_DECLARATION , format ) ; setOmitXMLDeclaration ( shouldNotWriteXMLHeader ) ; setDoctypeSystem ( format . getProperty ( OutputKeys . DOCTYPE_SYSTEM ) ) ; String doctypePublic = format . getProperty ( OutputKeys . DOCTYPE_PUBLIC ) ; setDoctypePublic ( doctypePublic ) ; if ( format . get ( OutputKeys . STANDALONE ) != null ) { String val = format . getProperty ( OutputKeys . STANDALONE ) ; if ( defaultProperties ) setStandaloneInternal ( val ) ; else setStandalone ( val ) ; } setMediaType ( format . getProperty ( OutputKeys . MEDIA_TYPE ) ) ; if ( null != doctypePublic ) { if ( doctypePublic . startsWith ( "-//W3C//DTD XHTML" ) ) m_spaceBeforeClose = true ; } String encoding = getEncoding ( ) ; if ( null == encoding ) { encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; setEncoding ( encoding ) ; } m_isUTF8 = encoding . equals ( Encodings . DEFAULT_MIME_ENCODING ) ; m_maxCharacter = Encodings . getLastPrintable ( encoding ) ; String entitiesFileName = ( String ) format . get ( OutputPropertiesFactory . S_KEY_ENTITIES ) ; if ( null != entitiesFileName ) { m_charInfo = CharInfo . getCharInfo ( entitiesFileName ) ; } } private synchronized void init ( Writer writer , Properties format ) { init ( writer , format , false , false ) ; } protected synchronized void init ( OutputStream output , Properties format , boolean defaultProperties ) throws UnsupportedEncodingException { String encoding = getEncoding ( ) ; if ( encoding == null ) { encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; setEncoding ( encoding ) ; } if ( encoding . equalsIgnoreCase ( "UTF-8" ) ) { m_isUTF8 = true ; if ( output instanceof java . io . BufferedOutputStream ) { init ( new WriterToUTF8 ( output ) , format , defaultProperties , true ) ; } else { init ( new WriterToUTF8Buffered ( output ) , format , defaultProperties , true ) ; } } else if ( encoding . equals ( "WINDOWS-1250" ) || encoding . equals ( "US-ASCII" ) || encoding . equals ( "ASCII" ) ) { init ( new WriterToASCI ( output ) , format , defaultProperties , true ) ; } else { Writer osw ; try { osw = Encodings . getWriter ( output , encoding ) ; } catch ( UnsupportedEncodingException uee ) { System . out . println ( "Warning: encoding \"" + encoding + "\" not supported" + ", using " + Encodings . DEFAULT_MIME_ENCODING ) ; encoding = Encodings . DEFAULT_MIME_ENCODING ; setEncoding ( encoding ) ; osw = Encodings . getWriter ( output , encoding ) ; } m_maxCharacter = Encodings . getLastPrintable ( encoding ) ; init ( osw , format , defaultProperties , true ) ; } } public Properties getOutputFormat ( ) { return m_format ; } public void setWriter ( Writer writer ) { if ( m_tracer != null && ! ( writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; else m_writer = writer ; } public void setOutputStream ( OutputStream output ) { try { Properties format ; if ( null == m_format ) format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . XML ) ; else format = m_format ; init ( output , format , true ) ; } catch ( UnsupportedEncodingException uee ) { } } public boolean setEscaping ( boolean escape ) { final boolean temp = m_escaping ; m_escaping = escape ; return temp ; } public boolean reset ( ) { m_needToCallStartDocument = true ; return false ; } protected void indent ( ) throws IOException { if ( m_startNewLine ) outputLineSep ( ) ; if ( m_indentAmount > 0 ) printSpace ( m_currentElemDepth * m_indentAmount ) ; } private void printSpace ( int n ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { m_writer . write ( ' ' ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_inDoctype ) { m_writer . write ( " [" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } m_writer . write ( "<!ATTLIST " ) ; m_writer . write ( eName ) ; m_writer . write ( " " ) ; m_writer . write ( aName ) ; m_writer . write ( " " ) ; m_writer . write ( type ) ; if ( valueDefault != null ) { m_writer . write ( " " ) ; m_writer . write ( valueDefault ) ; } m_writer . write ( ">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public Writer getWriter ( ) { return m_writer ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } protected boolean escapingNotNeeded ( char ch ) { if ( ch < 127 ) { if ( ch >= 0x20 || ( 0x0A == ch || 0x0D == ch || 0x09 == ch ) ) return true ; else return false ; } if ( null == m_charToByteConverter && false == m_triedToGetConverter ) { m_triedToGetConverter = true ; try { m_charToByteConverter = Encodings . getCharToByteConverter ( getEncoding ( ) ) ; if ( null != m_charToByteConverter ) { Class argsTypes [ ] = new Class [ 1 ] ; argsTypes [ 0 ] = Character . TYPE ; Class convClass = m_charToByteConverter . getClass ( ) ; m_canConvertMeth = convClass . getMethod ( "canConvert" , argsTypes ) ; } } catch ( Exception e ) { System . err . println ( "Warning: " + e . getMessage ( ) ) ; } } if ( null != m_charToByteConverter ) { try { Object args [ ] = new Object [ 1 ] ; args [ 0 ] = new Character ( ch ) ; Boolean bool = ( Boolean ) m_canConvertMeth . invoke ( m_charToByteConverter , args ) ; return bool . booleanValue ( ) ? ! Character . isISOControl ( ch ) : false ; } catch ( java . lang . reflect . InvocationTargetException ite ) { System . err . println ( "Warning: InvocationTargetException in canConvert!" ) ; } catch ( java . lang . IllegalAccessException iae ) { System . err . println ( "Warning: IllegalAccessException in canConvert!" ) ; } } return ( ch <= m_maxCharacter ) ; } protected int writeUTF16Surrogate ( char c , char ch [ ] , int i , int end ) throws IOException { int surrogateValue = getURF16SurrogateValue ( c , ch , i , end ) ; i ++ ; m_writer . write ( '&' ) ; m_writer . write ( '#' ) ; m_writer . write ( Integer . toString ( surrogateValue ) ) ; m_writer . write ( ';' ) ; return i ; } int getURF16SurrogateValue ( char c , char ch [ ] , int i , int end ) throws IOException { int next ; if ( i + 1 >= end ) { throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) } ) ) ; } else { next = ch [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( c - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } return next ; } protected int accumDefaultEntity ( java . io . Writer writer , char ch , int i , char [ ] chars , int len , boolean escLF ) throws IOException { if ( ! escLF && CharInfo . S_LINEFEED == ch ) { writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else { if ( m_charInfo . isSpecial ( ch ) ) { String entityRef = m_charInfo . getEntityNameForChar ( ch ) ; if ( null != entityRef ) { writer . write ( '&' ) ; writer . write ( entityRef ) ; writer . write ( ';' ) ; } else return i ; } else return i ; } return i + 1 ; } void writeNormalizedChars ( char ch [ ] , int start , int length , boolean isCData ) throws IOException , org . xml . sax . SAXException { int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; if ( CharInfo . S_LINEFEED == c ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( isCData && ( ! escapingNotNeeded ( c ) ) ) { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; m_writer . write ( intStr ) ; m_writer . write ( ';' ) ; } } else if ( isCData && ( ( i < ( end - 2 ) ) && ( ']' == c ) && ( ']' == ch [ i + 1 ] ) && ( '>' == ch [ i + 2 ] ) ) ) { m_writer . write ( CDATA_CONTINUE ) ; i += 2 ; } else { if ( escapingNotNeeded ( c ) ) { if ( isCData && ! m_cdataTagOpen ) { m_writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } m_writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { if ( m_cdataTagOpen ) closeCDATA ( ) ; i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; m_writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; m_writer . write ( intStr ) ; m_writer . write ( ';' ) ; } } } } public void endNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . pop ( ) ; } public void startNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . push ( true ) ; } protected void cdata ( char ch [ ] , int start , final int length ) throws org . xml . sax . SAXException { try { final int old_start = start ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; if ( shouldIndent ( ) ) indent ( ) ; boolean writeCDataBrackets = ( ( ( length >= 1 ) && escapingNotNeeded ( ch [ start ] ) ) ) ; if ( writeCDataBrackets && ! m_cdataTagOpen ) { m_writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } if ( isEscapingDisabled ( ) ) { charactersRaw ( ch , start , length ) ; } else writeNormalizedChars ( ch , start , length , true ) ; if ( writeCDataBrackets ) { if ( ch [ start + length - 1 ] == ']' ) closeCDATA ( ) ; } super . fireCDATAEvent ( ch , old_start , length ) ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } private boolean isEscapingDisabled ( ) { return m_disableOutputEscapingStates . peekOrFalse ( ) ; } protected void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; m_writer . write ( ch , start , length ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void characters ( char chars [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( 0 == length ) { super . fireCharEvent ( chars , start , length ) ; return ; } if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; } if ( m_cdataStartCalled || m_cdataSectionStates . peekOrFalse ( ) ) { cdata ( chars , start , length ) ; return ; } if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( m_disableOutputEscapingStates . peekOrFalse ( ) || ( ! m_escaping ) ) { charactersRaw ( chars , start , length ) ; super . fireCharEvent ( chars , start , length ) ; return ; } if ( m_startTagOpen ) closeStartTag ( ) ; int startClean = start ; int lengthClean = 0 ; int end = start + length ; boolean checkWhite = true ; final int maxCharacter = m_maxCharacter ; final BitSet specialsMap = m_charInfo . m_specialsMap ; try { for ( int i = start ; i < end ; i ++ ) { char ch = chars [ i ] ; if ( checkWhite && ( ( ch > 0x20 ) || ! ( ( ch == 0x20 ) || ( ch == 0x09 ) || ( ch == 0xD ) || ( ch == 0xA ) ) ) ) { m_ispreserve = true ; checkWhite = false ; } if ( ( ( ( ch < 127 ) && ( 0x20 <= ch || ( 0x0A == ch || 0x0D == ch || 0x09 == ch ) ) ) && ( ! specialsMap . get ( ch ) ) ) || ( '"' == ch ) ) { lengthClean ++ ; } else if ( ( escapingNotNeeded ( ch ) && ( ! specialsMap . get ( ch ) ) ) || ( '"' == ch ) ) { lengthClean ++ ; } else { if ( lengthClean > 0 ) { m_writer . write ( chars , startClean , lengthClean ) ; lengthClean = 0 ; } if ( CharInfo . S_LINEFEED == ch ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; startClean = i + 1 ; } else { startClean = accumDefaultEscape ( m_writer , ch , i , chars , end , false ) ; i = startClean - 1 ; } } } if ( lengthClean > 0 ) { m_writer . write ( chars , startClean , lengthClean ) ; } m_isprevtext = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } super . fireCharEvent ( chars , start , length ) ; } public void characters ( String s ) throws org . xml . sax . SAXException { characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; } protected int accumDefaultEscape ( Writer writer , char ch , int i , char [ ] chars , int len , boolean escLF ) throws IOException { int pos = accumDefaultEntity ( writer , ch , i , chars , len , escLF ) ; if ( i == pos ) { pos ++ ; if ( 0xd800 <= ch && ch < 0xdc00 ) { int next ; if ( i + 1 >= len ) { throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) } ) ) ; } else { next = chars [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( ch - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } writer . write ( "&#" ) ; writer . write ( Integer . toString ( next ) ) ; writer . write ( ";" ) ; } else { if ( ! escapingNotNeeded ( ch ) || ( m_charInfo . isSpecial ( ch ) ) ) { writer . write ( "&#" ) ; writer . write ( Integer . toString ( ch ) ) ; writer . write ( ";" ) ; } else { writer . write ( ch ) ; } } } return pos ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } else if ( m_cdataTagOpen ) closeCDATA ( ) ; try { if ( ( true == m_needToOutputDocTypeDecl ) && ( null != getDoctypeSystem ( ) ) ) { outputDocTypeDecl ( name , true ) ; } m_needToOutputDocTypeDecl = false ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } if ( namespaceURI != null ) ensurePrefixIsDeclared ( namespaceURI , name ) ; m_elementLocalName = localName ; m_elementURI = namespaceURI ; m_elementName = name ; m_ispreserve = false ; if ( shouldIndent ( ) && m_startNewLine ) { indent ( ) ; } m_startNewLine = true ; m_writer . write ( '<' ) ; m_writer . write ( name ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( atts != null ) addAttributes ( atts ) ; m_startTagOpen = true ; m_currentElemDepth ++ ; m_isprevtext = false ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { startElement ( elementNamespaceURI , elementLocalName , elementName , null ) ; } public void startElement ( String elementName ) throws SAXException { startElement ( null , null , elementName , null ) ; } void outputDocTypeDecl ( String name , boolean closeDecl ) throws SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; try { m_writer . write ( "<!DOCTYPE " ) ; m_writer . write ( name ) ; String doctypePublic = getDoctypePublic ( ) ; if ( null != doctypePublic ) { m_writer . write ( " PUBLIC \"" ) ; m_writer . write ( doctypePublic ) ; m_writer . write ( '\"' ) ; } String doctypeSystem = getDoctypeSystem ( ) ; if ( null != doctypeSystem ) { if ( null == doctypePublic ) m_writer . write ( " SYSTEM \"" ) ; else m_writer . write ( " \"" ) ; m_writer . write ( doctypeSystem ) ; if ( closeDecl ) { m_writer . write ( "\">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; closeDecl = false ; } else m_writer . write ( '\"' ) ; } boolean dothis = false ; if ( dothis ) { if ( closeDecl ) { m_writer . write ( ">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void processAttributes ( ) throws IOException , SAXException { super . fireStartElem ( m_elementName ) ; int nAttrs = 0 ; if ( ( nAttrs = m_attributes . getLength ( ) ) > 0 ) { String encoding = getEncoding ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; m_writer . write ( ' ' ) ; m_writer . write ( name ) ; m_writer . write ( "=\"" ) ; writeAttrString ( m_writer , value , encoding ) ; m_writer . write ( '\"' ) ; } m_attributes . clear ( ) ; } } public void writeAttrString ( Writer writer , String string , String encoding ) throws IOException { final char [ ] stringChars = string . toCharArray ( ) ; final int len = stringChars . length ; for ( int i = 0 ; i < len ; i ++ ) { char ch = stringChars [ i ] ; if ( escapingNotNeeded ( ch ) && ( ! m_charInfo . isSpecial ( ch ) ) ) { writer . write ( ch ) ; } else { if ( ( CharInfo . S_CARRIAGERETURN == ch ) && ( ( i + 1 ) < len ) && ( CharInfo . S_LINEFEED == stringChars [ i + 1 ] ) ) { i ++ ; ch = CharInfo . S_LINEFEED ; } accumDefaultEscape ( writer , ch , i , stringChars , len , true ) ; } } } public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_prefixMap . popNamespaces ( m_currentElemDepth ) ; m_currentElemDepth -- ; try { if ( m_startTagOpen ) { processAttributes ( ) ; if ( m_spaceBeforeClose ) m_writer . write ( " />" ) ; else m_writer . write ( "/>" ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( shouldIndent ( ) ) indent ( ) ; m_writer . write ( '<' ) ; m_writer . write ( '/' ) ; m_writer . write ( name ) ; m_writer . write ( '>' ) ; m_cdataSectionStates . pop ( ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( ! m_startTagOpen ) { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } m_isprevtext = false ; m_startTagOpen = false ; super . fireEndElem ( name ) ; } public void endElement ( String name ) throws org . xml . sax . SAXException { endElement ( null , null , name ) ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws org . xml . sax . SAXException { boolean pushed ; int pushDepth ; if ( shouldFlush ) { flushPending ( ) ; pushDepth = m_currentElemDepth + 1 ; } else { pushDepth = m_currentElemDepth ; } pushed = m_prefixMap . pushNamespace ( prefix , uri , pushDepth ) ; if ( pushed ) { String name ; if ( EMPTYSTRING . equals ( prefix ) ) { name = "xmlns" ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } else { if ( ! EMPTYSTRING . equals ( uri ) ) { name = "xmlns:" + prefix ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } } } return pushed ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { int start_old = start ; if ( m_inEntityRef ) return ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } try { if ( shouldIndent ( ) ) indent ( ) ; final int limit = start + length ; boolean wasDash = false ; if ( m_cdataTagOpen ) closeCDATA ( ) ; m_writer . write ( COMMENT_BEGIN ) ; for ( int i = start ; i < limit ; i ++ ) { if ( wasDash && ch [ i ] == '-' ) { m_writer . write ( ch , start , i - start ) ; m_writer . write ( " -" ) ; start = i + 1 ; } wasDash = ( ch [ i ] == '-' ) ; } if ( length > 0 ) { final int remainingChars = ( limit - start ) ; if ( remainingChars > 0 ) m_writer . write ( ch , start , remainingChars ) ; if ( ch [ limit - 1 ] == '-' ) m_writer . write ( ' ' ) ; } m_writer . write ( COMMENT_END ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } m_startNewLine = true ; super . fireCommentEvent ( ch , start_old , length ) ; } public void endCDATA ( ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; m_cdataStartCalled = false ; } public void endDTD ( ) throws org . xml . sax . SAXException { try { if ( m_needToOutputDocTypeDecl ) { outputDocTypeDecl ( m_elementName , false ) ; m_needToOutputDocTypeDecl = false ; } if ( ! m_inDoctype ) m_writer . write ( "]>" ) ; else { m_writer . write ( '>' ) ; } m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( 0 == length ) return ; characters ( ch , start , length ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { } public void startCDATA ( ) throws org . xml . sax . SAXException { m_cdataStartCalled = true ; } public void startEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = true ; m_inEntityRef = true ; } protected void closeStartTag ( ) throws SAXException { if ( m_startTagOpen ) { try { processAttributes ( ) ; m_writer . write ( '>' ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } pushCdataSectionState ( ) ; m_isprevtext = false ; m_preserves . push ( m_ispreserve ) ; m_startTagOpen = false ; } } public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { setDoctypeSystem ( systemId ) ; setDoctypePublic ( publicId ) ; m_elementName = name ; m_inDoctype = true ; } public int getIndentAmount ( ) { return m_indentAmount ; } public void setIndentAmount ( int m_indentAmount ) { this . m_indentAmount = m_indentAmount ; } protected boolean shouldIndent ( ) { return m_doIndent && ( ! m_ispreserve && ! m_isprevtext ) ; } private void setCdataSectionElements ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) { Vector v = new Vector ( ) ; int l = s . length ( ) ; boolean inCurly = false ; FastStringBuffer buf = new FastStringBuffer ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! inCurly ) { if ( buf . length ( ) > 0 ) { addCdataSectionElement ( buf . toString ( ) , v ) ; buf . reset ( ) ; } continue ; } } else if ( '{' == c ) inCurly = true ; else if ( '}' == c ) inCurly = false ; buf . append ( c ) ; } if ( buf . length ( ) > 0 ) { addCdataSectionElement ( buf . toString ( ) , v ) ; buf . reset ( ) ; } setCdataSectionElements ( v ) ; } } private void addCdataSectionElement ( String URI_and_localName , Vector v ) { StringTokenizer tokenizer = new StringTokenizer ( URI_and_localName , "{}" , false ) ; QName qname ; String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) { v . addElement ( null ) ; v . addElement ( s1 ) ; } else { v . addElement ( s1 ) ; v . addElement ( s2 ) ; } } public void setCdataSectionElements ( Vector URI_and_localNames ) { m_cdataSectionElements = URI_and_localNames ; } protected String ensureAttributesNamespaceIsDeclared ( String ns , String localName , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index = 0 ; String prefixFromRawName = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( index > 0 ) { String uri = m_prefixMap . lookupNamespace ( prefixFromRawName ) ; if ( uri != null && uri . equals ( ns ) ) { return null ; } else { this . startPrefixMapping ( prefixFromRawName , ns , false ) ; this . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefixFromRawName , "xmlns:" + prefixFromRawName , "CDATA" , ns ) ; return prefixFromRawName ; } } else { String prefix = m_prefixMap . lookupPrefix ( ns ) ; if ( prefix == null ) { prefix = m_prefixMap . generateNextPrefix ( ) ; this . startPrefixMapping ( prefix , ns , false ) ; this . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns:" + prefix , "CDATA" , ns ) ; } return prefix ; } } return null ; } private void ensurePrefixIsDeclared ( String ns , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index ; String prefix = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( null != prefix ) { String foundURI = m_prefixMap . lookupNamespace ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( ns ) ) { this . startPrefixMapping ( prefix , ns ) ; this . addAttributeAlways ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns" + ( prefix . length ( ) == 0 ? "" : ":" ) + prefix , "CDATA" , ns ) ; } } } } public void flushPending ( ) { try { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = false ; } } catch ( SAXException e ) { } } public void setContentHandler ( ContentHandler ch ) { } public void addAttributeAlways ( String uri , String localName , String rawName , String type , String value ) { int index ; index = m_attributes . getIndex ( rawName ) ; if ( index >= 0 ) { String old_value = null ; if ( m_tracer != null ) { old_value = m_attributes . getValue ( index ) ; if ( value . equals ( old_value ) ) old_value = null ; } m_attributes . setValue ( index , value ) ; if ( old_value != null ) firePseudoAttributes ( ) ; } else { m_attributes . addAttribute ( uri , localName , rawName , type , value ) ; if ( m_tracer != null ) firePseudoAttributes ( ) ; } } protected void firePseudoAttributes ( ) { int nAttrs ; if ( m_tracer != null && ( nAttrs = m_attributes . getLength ( ) ) > 0 ) { String encoding = getEncoding ( ) ; StringBuffer sb = new StringBuffer ( ) ; java . io . Writer writer = new ToStream . WritertoStringBuffer ( sb ) ; try { for ( int i = 0 ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; sb . append ( ' ' ) ; sb . append ( name ) ; sb . append ( "=\"" ) ; writeAttrString ( writer , value , encoding ) ; sb . append ( '\"' ) ; } } catch ( IOException ioe ) { } char ch [ ] = sb . toString ( ) . toCharArray ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS , ch , 0 , ch . length ) ; } } private class WritertoStringBuffer extends java . io . Writer { final private StringBuffer m_stringbuf ; WritertoStringBuffer ( StringBuffer sb ) { m_stringbuf = sb ; } public void write ( char [ ] arg0 , int arg1 , int arg2 ) throws IOException { m_stringbuf . append ( arg0 , arg1 , arg2 ) ; } public void flush ( ) throws IOException { } public void close ( ) throws IOException { } public void write ( int i ) { m_stringbuf . append ( ( char ) i ) ; } public void write ( String s ) { m_stringbuf . append ( s ) ; } } public void setTransformer ( Transformer transformer ) { super . setTransformer ( transformer ) ; if ( m_tracer != null && ! ( m_writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( m_writer , m_tracer ) ; } } 	1
package org . apache . xalan . res ; import java . util . Locale ; public class XSLTErrorResources_it extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Errore: Impossibile inserire '{' nell'espressione." } , { ER_ILLEGAL_ATTRIBUTE , "{0} ha un attributo illegale: {1}." } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode nullo in xsl:apply-imports" } , { ER_CANNOT_ADD , "Impossibile aggiungere {0} a {1}." } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode nullo in handleApplyTemplatesInstruction." } , { ER_NO_NAME_ATTRIB , "{0} deve avere un attributo nome." } , { ER_TEMPLATE_NOT_FOUND , "Impossibile trovare il modello denominato: {0}." } , { ER_CANT_RESOLVE_NAME_AVT , "Impossibile risolvere il nome AVT in xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} richiede l'attributo: {1}." } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} deve avere un attributo ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valore non valido su attributo livello: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Il nome dell'istruzione di elaborazione non può essere 'xml'." } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Il nome dell'istruzione di elaborazione deve essere un NCName valido: {0}." } , { ER_NEED_MATCH_ATTRIB , "{0} deve avere un attributo corrispondenza se ha una modalità." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} richiede un attributo nome o corrispondenza." } , { ER_CANT_RESOLVE_NSPREFIX , "Impossibile risolvere il prefisso namespace: {0}." } , { ER_ILLEGAL_VALUE , "xml:space ha valore non valido: {0}." } , { ER_NO_OWNERDOC , "Il nodo secondario non ha alcun documento di proprietà." } , { ER_ELEMTEMPLATEELEM_ERR , "Errore ElemTemplateElement: {0}." } , { ER_NULL_CHILD , "Tentativo di aggiungere un elemento secondario nullo." } , { ER_NEED_SELECT_ATTRIB , "{0} richiede un attributo selezione." } , { ER_NEED_TEST_ATTRIB , "xsl:when deve avere un attributo 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param deve avere un attributo 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "Il contesto non ha un documento di proprietà." } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Impossibile creare un XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: il processo non è riuscito." } , { ER_NOT_SUCCESSFUL , "Xalan: non è riuscito." } , { ER_ENCODING_NOT_SUPPORTED , "Codifica non supportata: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Impossibile creare TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key richiede un attributo 'nome'." } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key richiede un attributo 'corrispondenza'." } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key richiede un attributo 'uso'." } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} richiede un attributo ''elementi''." } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} attributo ''prefisso'' mancante" } , { ER_BAD_STYLESHEET_URL , "URL del foglio di stile non valido: {0}" } , { ER_FILE_NOT_FOUND , "File del foglio di stile non trovato: {0}" } , { ER_IOEXCEPTION , "Rilevata eccezione IO con il file del foglio di stile: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Impossibile trovare l'attributo href per {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} include se stesso direttamente o indirettamente." } , { ER_PROCESSINCLUDE_ERROR , "Errore StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} attributo ''lang'' mancante" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) elemento {0} fuori posto? ''Componente'' dell'elemento contenitore mancante" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "È possibile eseguire l'output solo in Element, DocumentFragment, Document o PrintWriter." } , { ER_PROCESS_ERROR , "Errore in StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Errore in UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Errore. L'espressione di selezione del percorso (-select) non è stata trovata." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Impossibile serializzare un XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Input del foglio di stile non specificato." } , { ER_FAILED_PROCESS_STYLESHEET , "Elaborazione del foglio di stile non riuscita." } , { ER_COULDNT_PARSE_DOC , "Impossibile analizzare il documento {0}." } , { ER_COULDNT_FIND_FRAGMENT , "Impossibile trovare il frammento: {0}" } , { ER_NODE_NOT_ELEMENT , "Il nodo a cui puntava l'identificatore del frammento non era un elemento: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each deve avere un attributo corrispondenza o nome." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "I modelli devono avere un attributo corrispondenza o nome." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Nessun duplicato di frammento di un documento." } , { ER_CANT_CREATE_ITEM , "Impossibile creare un elemento nell'albero del risultato: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space nell'XML sorgente ha valore non valido: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Dichiarazione xsl:key mancante per {0}!" } , { ER_CANT_CREATE_URL , "Errore. Impossibile creare URL per: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions non supportato" } , { ER_PROCESSOR_ERROR , "Errore XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} non consentito in un foglio di stile." } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns non è più supportato. Utilizzare xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space non è più supportato. Utilizzare xsl:strip-space o xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result non è più supportato. Utilizzare xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} ha un attributo non valido {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elemento XSL sconosciuto: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort può essere utilizzato solo con xsl:apply-templates o xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when fuori posto." } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when non dipende da xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise fuori posto." } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise non dipende da xsl:choose." } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} non è consentito in un modello." } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} prefisso namespace di estensione {1} sconosciuto" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Le importazioni sono possibili solo come primi elementi di un foglio di stile." } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} sta importando se stesso direttamente o indirettamente." } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space ha valore non valido: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet non è riuscito." } , { ER_SAX_EXCEPTION , "Eccezione SAX" } , { ER_XSLT_ERROR , "Errore XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "Il segno di valuta non è consentito nelle stringhe modello di formato." } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Funzione documento non supportata nel foglio di stile DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Impossibile risolvere il prefisso del risolutore non-Prefix." } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Estensione di reindirizzamento: Impossibile trovare il nome file. Il file o l'attributo di selezione devono generare una stringa valida." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Impossibile generare FormatterListener nell'estensione di reindirizzamento." } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Il prefisso in exclude-result-prefixes non è valido: {0}" } , { ER_MISSING_NS_URI , "URI namespace mancante per il prefisso specificato." } , { ER_MISSING_ARG_FOR_OPTION , "Argomento mancante per l'opzione: {0}" } , { ER_INVALID_OPTION , "Opzione non valida: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Stringa di formato non valida: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet richiede un attributo 'versione'." } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attributo: {0} ha un valore non valido: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose richiede xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports non consentito in xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Impossibile utilizzare un collegamento DTM per un nodo DOM di output. Utilizzare org.apache.xpath.DOM2Helper." } , { ER_CANT_USE_DTM_FOR_INPUT , "Impossibile utilizzare un collegamento DTM per un nodo DOM di input. Utilizzare org.apache.xpath.DOM2Helper." } , { ER_CALL_TO_EXT_FAILED , "Chiamata all'elemento di estensione non riuscita: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Il prefisso deve risolvere in namespace: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Rilevato surrogato di UTF-16 non valido: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} ha utilizzato se stesso, generando un loop infinito." } , { ER_CANNOT_MIX_XERCESDOM , "Impossibile combinare un input non Xerces-DOM con un input Xerces-DOM." } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "In ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Trovato più di un modello denominato: {0}" } , { ER_INVALID_KEY_CALL , "Chiamata di funzione non valida: le chiamate chiave() ricorsive non sono consentite." } , { ER_REFERENCING_ITSELF , "La variabile {0} fa riferimento a se stessa direttamente o indirettamente." } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Il nodo di input non può essere nullo per DOMSource per newTemplates." } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "File di classe non trovato per l'opzione {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Elemento richiesto non trovato: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream non può essere nullo." } , { ER_URI_CANNOT_BE_NULL , "L'URI non può essere nullo." } , { ER_FILE_CANNOT_BE_NULL , "Il file non può essere nullo." } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource non può essere nullo." } , { ER_CANNOT_INIT_BSFMGR , "Impossibile inizializzare BSF Manager." } , { ER_CANNOT_CMPL_EXTENSN , "Impossibile compilare l'estensione." } , { ER_CANNOT_CREATE_EXTENSN , "Impossibile creare l'estensione: {0} a causa di: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "La chiamata del metodo istanza al metodo {0} richiede un'istanza oggetto come primo argomento." } , { ER_INVALID_ELEMENT_NAME , "È stato specificato un nome elemento non valido {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Il metodo del nome elemento deve essere statico {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Funzione estensione {0} : {1} sconosciuta." } , { ER_MORE_MATCH_CONSTRUCTOR , "Più di una corrispondenza migliore per costruttore per {0}." } , { ER_MORE_MATCH_METHOD , "Più di una corrispondenza migliore per il metodo {0}" } , { ER_MORE_MATCH_ELEMENT , "Più di una corrispondenza migliore per il metodo elemento {0}" } , { ER_INVALID_CONTEXT_PASSED , "Contesto non valido passato da valutare {0}." } , { ER_POOL_EXISTS , "Pool già esistente." } , { ER_NO_DRIVER_NAME , "Non è stato specificato alcun nome di driver." } , { ER_NO_URL , "Non è stato specificato alcun URL." } , { ER_POOL_SIZE_LESSTHAN_ONE , "Le dimensioni del pool sono minori di uno." } , { ER_INVALID_DRIVER , "È stato specificato un nome di driver non valido." } , { ER_NO_STYLESHEETROOT , "Impossibile trovare la root del foglio di stile." } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valore non valido per xml:space." } , { ER_PROCESSFROMNODE_FAILED , "processFromNode non riuscito." } , { ER_RESOURCE_COULD_NOT_LOAD , "Impossibile caricare la risorsa [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Dimensioni del buffer <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Errore sconosciuto nella chiamata dell'estensione." } , { ER_NO_NAMESPACE_DECL , "Il prefisso {0} non ha una corrispondente dichiarazione namespace." } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Contenuto dell'elemento non consentito per lang=javaclass {0}." } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Conclusione richiesta dal foglio di stile." } , { ER_ONE_OR_TWO , "1 o 2" } , { ER_TWO_OR_THREE , "2 o 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Impossibile caricare {0} (verificare CLASSPATH). Attualmente sono in uso i valori predefiniti." } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Impossibile inizializzare i modelli predefiniti." } , { ER_RESULT_NULL , "Il risultato non dovrebbe essere nullo." } , { ER_RESULT_COULD_NOT_BE_SET , "Impossibile stabilire il risultato." } , { ER_NO_OUTPUT_SPECIFIED , "Nessun output specificato." } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Impossibile trasformare in un risultato di tipo {0}." } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Impossibile trasformare un sorgente di tipo {0}." } , { ER_NULL_CONTENT_HANDLER , "Contenuto gestore nullo" } , { ER_NULL_ERROR_HANDLER , "Errore gestore nullo" } , { ER_CANNOT_CALL_PARSE , "Impossibile chiamare l'analisi se non è impostato ContentHandler." } , { ER_NO_PARENT_FOR_FILTER , "Nessun elemento principale per il filtro." } , { ER_NO_STYLESHEET_IN_MEDIA , "Nessun foglio di stile trovato in: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "Nessun xml-stylesheet PI trovato in : {0}" } , { ER_NOT_SUPPORTED , "Non supportato: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Il valore della proprietà {0} deve essere un'istanza booleana" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "L'attributo src non è ancora supportato per {0}." } , { ER_RESOURCE_COULD_NOT_FIND , "Impossibile trovare la risorsa [ {0} ].\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "La proprietà dell'output non è riconosciuta: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Creazione non riuscita dell'istanza ElemLiteralResult." } , { ER_VALUE_SHOULD_BE_NUMBER , "Il valore di {0} deve contenere un numero analizzabile." } , { ER_VALUE_SHOULD_EQUAL , "Il valore di {0} deve essere sì o no." } , { ER_FAILED_CALLING_METHOD , "Chiamata non riuscita del metodo {0}." } , { ER_FAILED_CREATING_ELEMTMPL , "Creazione non riuscita dell'istanza ElemTemplateElement." } , { ER_CHARS_NOT_ALLOWED , "I caratteri non sono consentiti in questo punto del documento." } , { ER_ATTR_NOT_ALLOWED , "\"{0}\": questo attributo non è consentito sull'elemento {1}." } , { ER_BAD_VALUE , "{0} valore non valido {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} valore dell'attributo non trovato." } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} valore dell'attributo non riconosciuto " } , { ER_NULL_URI_NAMESPACE , "Tentativo di generare un prefisso di namespace con URI nullo" } , { ER_NUMBER_TOO_BIG , "Tentativo di formattare un numero maggiore dell'intero lungo più grande" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Impossibile trovare classe driver SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "La classe di driver SAX1 {0} è stata trovata ma è impossibile caricarla" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "La classe di driver SAX1 {0} è stata caricata ma non è possibile creare istanze" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La classe di driver SAX1 {0} non implementa org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Proprietà di sistema org.xml.sax.parser non specificata" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "L'argomento del Parser non deve essere nullo" } , { ER_FEATURE , "Caratteristica:a {0}" } , { ER_PROPERTY , "Proprietà:a {0}" } , { ER_NULL_ENTITY_RESOLVER , "Il risolutore dell'entità è nullo" } , { ER_NULL_DTD_HANDLER , "Il gestore DTD è nullo" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Nessun nome di driver specificato." } , { ER_NO_URL_SPECIFIED , "Nessun URL specificato." } , { ER_POOLSIZE_LESS_THAN_ONE , "La dimensione pool è inferiore a 1." } , { ER_INVALID_DRIVER_NAME , "Il nome specificato del driver non è valido." } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Errore del programmatore. L'espressione non presenta ElemTemplateElement superiore." } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Affermazione del programmatore in RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} non è consentito in questa posizione nel foglio di stile." } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Il testo senza spazi non è consentito nel foglio di stile." } , { INVALID_TCHAR , "Valore non consentito: {1} utilizzato per attributo CHAR: {0}. L'attributo di tipo CHAR deve contenere 1 solo carattere." } , { INVALID_QNAME , "Valore non consentito:a {1} utilizzato per attributo QNAME:a {0}" } , { INVALID_ENUM , "Valore non consentito:a {1} utilizzato per attributo ENUM:a {0}. I valori validi sono:a {2}." } , { INVALID_NMTOKEN , "Valore non consentito:a {1} utilizzato per attributo NMTOKEN:a {0} " } , { INVALID_NCNAME , "Valore non consentito:a {1} utilizzato per attributo NCNAME:a {0} " } , { INVALID_BOOLEAN , "Valore non consentito:a {1} utilizzato per attributo boolean:a {0} " } , { INVALID_NUMBER , "Valore non consentito:a {1} utilizzato per attributo number:a {0} " } , { ER_ARG_LITERAL , "L'argomento di {0} nel pattern di corrispondenza deve essere letterale." } , { ER_DUPLICATE_GLOBAL_VAR , "Dichiarazione variabile globale duplicata." } , { ER_DUPLICATE_VAR , "Dichiarazione variabile duplicata." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template deve presentare un name o attributo match (o entrambi)" } , { ER_INVALID_PREFIX , "Il prefisso in exclude-result-prefixes non è valido:a {0}" } , { ER_NO_ATTRIB_SET , "la serie di attributi denominata {0} è inesistente" } , { WG_FOUND_CURLYBRACE , "Trovato '}' ma non vi è alcun modello di attributi aperto." } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Avvertenza: l'attributo di conteggio non corrisponde a un predecessore in xsl:number! Target = {0}." } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Sintassi precedente: il nome dell'attributo 'expr' è stato cambiato in 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan non gestisce ancora il nome locale nella funzione format-number." } , { WG_LOCALE_NOT_FOUND , "Avvertenza: impossibile trovare la versione locale per xml:lang={0}." } , { WG_CANNOT_MAKE_URL_FROM , "Impossibile creare l'URL da: {0}." } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Impossibile caricare il documento richiesto: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Impossibile trovare il collatore per <sort xml:lang={0}." } , { WG_FUNCTIONS_SHOULD_USE_URL , "Sintassi precedente: l'istruzione delle funzioni deve utilizzare l'URL {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "codifica non supportata: {0}, utilizzando UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Codifica non supportata: {0}, utilizzando Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Trovati conflitti di specificità: {0} Sarà utilizzato l'ultimo trovato nel foglio di stile." } , { WG_PARSING_AND_PREPARING , "========= Analisi e preparazione {0} ==========" } , { WG_ATTR_TEMPLATE , "Modello attr., {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflitto di corrispondenza tra xsl:strip-space e xsl:preserve-space." } , { WG_ATTRIB_NOT_HANDLED , "Xalan non gestisce ancora l'attributo {0}." } , { WG_NO_DECIMALFORMAT_DECLARATION , "Non è stata trovata alcuna dichiarazione per il formato decimale: {0}" } , { WG_OLD_XSLT_NS , "XSLT Namespace mancante o non valido. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "È consentita solo una dichiarazione xsl:decimal-format predefinita." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "I nomi xsl:decimal-format devono essere univoci. Il nome \"{0}\" è duplicato." } , { WG_ILLEGAL_ATTRIBUTE , "{0} ha un attributo non valido: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Impossibile risolvere il prefisso namespace: {0}. Nodo ignorato." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet richiede un attributo 'versione'." } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nome attributo non valido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Valore non valido per l'attributo {0}: {1}." } , { WG_EMPTY_SECOND_ARG , "Il nodeset risultante dal secondo argomento della funzione documento è vuoto. Sarà utilizzato il primo argomento." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Il valore dell'attributo 'name' del nome xsl:processing-instruction name non deve essere 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Il valore dell'attributo ''name'' di xsl:processing-instruction deve essere un NCName valido:a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Impossibile aggiungere l'attributo {0} dopo i nodi secondari o prima della produzione di un elemento.  L'attributo verrà ignorato." } , { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "BAD_CODE" , "I parametri di createMessage sono esterni ai limiti" } , { "FORMAT_FAILED" , "Eccezione generata durante la chiamata di messageFormat" } , { "version" , ">>>>>>> Xalan Versione " } , { "version2" , "<<<<<<<" } , { "yes" , "sì" } , { "line" , "Linea #" } , { "column" , "Colonna #" } , { "xsldone" , "XSLProcessor: done" } , { "xslProc_option" , "opzioni dalla riga di comando della classe Process di Xalan-J:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER nome di classe pienamente qualificato del collegamento parser]" } , { "optionE" , "   [-E (Non espandere i rif entità)]" } , { "optionV" , "   [-E (Non espandere i rif entità)]" } , { "optionQC" , "   [-QC (Avvertenze di conflitti Quiet Pattern)]" } , { "optionQ" , "   [-Q  (Modalità Quiet)]" } , { "optionLF" , "   [-LF (Usa nuove righe solo su output {valore predefinito CR/LF})]" } , { "optionCR" , "   [-CR (Usa ritorno a capo solo su output {valore predefinito CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Quali carattere saltare {valore predefinito <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Controlla il numero di spazi del rientro {valore predefinito 0})]" } , { "optionTT" , "   [-TT (Traccia i modelli man mano che sono chiamati)]" } , { "optionTG" , "   [-TG (Traccia ogni evento di generazione)]" } , { "optionTS" , "   [-TS (Traccia ogni evento di selezione)]" } , { "optionTTC" , "   [-TTC (Traccia gli elementi secondari del modello man mano che sono elaborati)]" } , { "optionTCLASS" , "   [-TCLASS (Classe TraceListener per le estensioni di traccia)]" } , { "optionVALIDATE" , "   [-VALIDATE (Imposta se eseguire la validazione. Il valore predefinito è validazione disattivata.)]" } , { "optionEDUMP" , "   [-EDUMP {nome file opzionale} (Esegue il dump dello stack in caso di errore)]" } , { "optionXML" , "   [-XML (Utilizza il formattatore XML e aggiunge l'intestazione XML)]" } , { "optionTEXT" , "   [-TEXT (Utilizza il formattatore di testo semplice)]" } , { "optionHTML" , "   [-HTML (Utilizza il formattatore HTML)]" } , { "optionPARAM" , "   [-PARAM espressione nome (Imposta un parametro di foglio di stile)]" } , { "noParsermsg1" , "Processo XSL non riuscito." } , { "noParsermsg2" , "** Impossibile trovare il parser **" } , { "noParsermsg3" , "Verificare il classpath." } , { "noParsermsg4" , "Se non si dispone del parser XML IBM per Java, scaricarlo da" } , { "noParsermsg5" , "AlphaWorks IBM: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER nome classe completo (URIResolver da utilizzare per risolvere gli URI)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER nome classe completo (EntityResolver da utilizzare per risolvere le entità)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER nome classe completo (ContentHandler da utilizzare per serializzare l'output)]" } , { "optionLINENUMBERS" , "   [-L utilizza i numeri di linea per i documenti sorgente]" } , { "optionMEDIA" , " [-MEDIA mediaType (utilizzare l'attributo media per trovare il foglio di stile associato a un documento.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (utilizzare esplicitamente s2s=SAX o d2d=DOM per effettuare la trasformazione.)] " } , { "optionDIAG" , " [-DIAG (stampa i millisecondi globali impiegati dalla trasformazione.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (richiede la costruzione DTM incrementale impostando a true http://xml.apache.org/xalan/features/incremental.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (non richiede l'elaborazione dell'ottimizzazione del foglio di stile impostando a false http://xml.apache.org/xalan/features/optimize.)]" } , { "optionRL" , " [-RL recursionlimit (garantisce il limite numerico sulla profondità di ricorsione del foglio di stile.)]" } , { "optionXO" , " [-XO [transletName] (assegna il nome al translet generato)]" } , { "optionXD" , " [-XD destinationDirectory (specifica una directory di destinazione per il translet)]" } , { "optionXJ" , " [-XJ jarfile (compatta la classi del translet in un file jar denominato <filejar>)]" } , { "optionXP" , " [-XP package (specifica un prefisso del nome di pacchetto per tutte le classi translet generate)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Errore: " ; public static final String WARNING_HEADER = "Avvertenza: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ValueOf extends Instruction { private Expression _select ; private boolean _escaping = true ; private boolean _isString = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ValueOf" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; return ; } final String str = getAttribute ( "disable-output-escaping" ) ; if ( ( str != null ) && ( str . equals ( "yes" ) ) ) _escaping = false ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type type = _select . typeCheck ( stable ) ; if ( type != null && ! type . identicalTo ( Type . Node ) ) { if ( type . identicalTo ( Type . NodeSet ) ) { _select = new CastExpr ( _select , Type . Node ) ; } else { _isString = true ; if ( ! type . identicalTo ( Type . String ) ) { _select = new CastExpr ( _select , Type . String ) ; } _isString = true ; } } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int setEscaping = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "setEscaping" , "(Z)Z" ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( setEscaping , 2 ) ) ; } if ( _isString ) { final int characters = cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( characters ) ) ; } else { final int characters = cpg . addInterfaceMethodref ( DOM_INTF , CHARACTERS , CHARACTERS_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( characters , 3 ) ) ; } if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( setEscaping , 2 ) ) ; il . append ( POP ) ; } } } 	0
package org . apache . xalan . processor ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetComposed ; import org . apache . xalan . templates . StylesheetRoot ; import org . xml . sax . Attributes ; class ProcessorStylesheetElement extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { super . startElement ( handler , uri , localName , rawName , attributes ) ; try { int stylesheetType = handler . getStylesheetType ( ) ; Stylesheet stylesheet ; if ( stylesheetType == StylesheetHandler . STYPE_ROOT ) { try { stylesheet = new StylesheetRoot ( handler . getSchema ( ) , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; } catch ( TransformerConfigurationException tfe ) { throw new TransformerException ( tfe ) ; } } else { Stylesheet parent = handler . getStylesheet ( ) ; if ( stylesheetType == StylesheetHandler . STYPE_IMPORT ) { StylesheetComposed sc = new StylesheetComposed ( parent ) ; parent . setImport ( sc ) ; stylesheet = sc ; } else { stylesheet = new Stylesheet ( parent ) ; parent . setInclude ( stylesheet ) ; } } stylesheet . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; stylesheet . setLocaterInfo ( handler . getLocator ( ) ) ; stylesheet . setPrefixes ( handler . getNamespaceSupport ( ) ) ; handler . pushStylesheet ( stylesheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , handler . getStylesheet ( ) ) ; handler . pushElemTemplateElement ( handler . getStylesheet ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { super . endElement ( handler , uri , localName , rawName ) ; handler . popElemTemplateElement ( ) ; handler . popStylesheet ( ) ; } } 	0
package org . apache . xalan . transformer ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; import org . apache . xml . serializer . Method ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xml . utils . DOMBuilder ; import org . apache . xml . utils . TreeWalker ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . XMLReaderFactory ; public class TransformerIdentityImpl extends Transformer implements TransformerHandler , DeclHandler { public TransformerIdentityImpl ( ) { m_outputFormat = new OutputProperties ( Method . XML ) ; } public void setResult ( Result result ) throws IllegalArgumentException { if ( null == result ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_NULL , null ) ) ; m_result = result ; } public void setSystemId ( String systemID ) { m_systemID = systemID ; } public String getSystemId ( ) { return m_systemID ; } public Transformer getTransformer ( ) { return this ; } private void createResultContentHandler ( Result outputTarget ) throws TransformerException { if ( outputTarget instanceof SAXResult ) { SAXResult saxResult = ( SAXResult ) outputTarget ; m_resultContentHandler = saxResult . getHandler ( ) ; m_resultLexicalHandler = saxResult . getLexicalHandler ( ) ; if ( m_resultContentHandler instanceof Serializer ) { m_serializer = ( Serializer ) m_resultContentHandler ; } } else if ( outputTarget instanceof DOMResult ) { DOMResult domResult = ( DOMResult ) outputTarget ; Node outputNode = domResult . getNode ( ) ; Document doc ; short type ; if ( null != outputNode ) { type = outputNode . getNodeType ( ) ; doc = ( Node . DOCUMENT_NODE == type ) ? ( Document ) outputNode : outputNode . getOwnerDocument ( ) ; } else { try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; doc = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new TransformerException ( pce ) ; } outputNode = doc ; type = outputNode . getNodeType ( ) ; ( ( DOMResult ) outputTarget ) . setNode ( outputNode ) ; } m_resultContentHandler = ( Node . DOCUMENT_FRAGMENT_NODE == type ) ? new DOMBuilder ( doc , ( DocumentFragment ) outputNode ) : new DOMBuilder ( doc , outputNode ) ; m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; } else if ( outputTarget instanceof StreamResult ) { StreamResult sresult = ( StreamResult ) outputTarget ; String method = m_outputFormat . getProperty ( OutputKeys . METHOD ) ; try { Serializer serializer = SerializerFactory . getSerializer ( m_outputFormat . getProperties ( ) ) ; m_serializer = serializer ; if ( null != sresult . getWriter ( ) ) serializer . setWriter ( sresult . getWriter ( ) ) ; else if ( null != sresult . getOutputStream ( ) ) serializer . setOutputStream ( sresult . getOutputStream ( ) ) ; else if ( null != sresult . getSystemId ( ) ) { String fileURL = sresult . getSystemId ( ) ; if ( fileURL . startsWith ( "file:///" ) ) { if ( fileURL . substring ( 8 ) . indexOf ( ":" ) > 0 ) fileURL = fileURL . substring ( 8 ) ; else fileURL = fileURL . substring ( 7 ) ; } m_outputStream = new java . io . FileOutputStream ( fileURL ) ; serializer . setOutputStream ( m_outputStream ) ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_OUTPUT_SPECIFIED , null ) ) ; m_resultContentHandler = serializer . asContentHandler ( ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , new Object [ ] { outputTarget . getClass ( ) . getName ( ) } ) ) ; } if ( m_resultContentHandler instanceof DTDHandler ) m_resultDTDHandler = ( DTDHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof DeclHandler ) m_resultDeclHandler = ( DeclHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof LexicalHandler ) m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; } public void transform ( Source source , Result outputTarget ) throws TransformerException { createResultContentHandler ( outputTarget ) ; try { if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; m_systemID = dsource . getSystemId ( ) ; Node dNode = dsource . getNode ( ) ; if ( null != dNode ) { try { if ( dNode . getNodeType ( ) != Node . DOCUMENT_NODE ) this . startDocument ( ) ; try { if ( dNode . getNodeType ( ) == Node . ATTRIBUTE_NODE ) { String data = dNode . getNodeValue ( ) ; char [ ] chars = data . toCharArray ( ) ; characters ( chars , 0 , chars . length ) ; } else { TreeWalker walker = new TreeWalker ( this , new org . apache . xml . utils . DOM2Helper ( ) , m_systemID ) ; walker . traverse ( dNode ) ; } } finally { if ( dNode . getNodeType ( ) != Node . DOCUMENT_NODE ) this . endDocument ( ) ; } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } return ; } else { String messageStr = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_DOMSOURCE_INPUT , null ) ; throw new IllegalArgumentException ( messageStr ) ; } } InputSource xmlSource = SAXSource . sourceToInputSource ( source ) ; if ( null == xmlSource ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_SOURCE_TYPE , new Object [ ] { source . getClass ( ) . getName ( ) } ) ) ; } if ( null != xmlSource . getSystemId ( ) ) m_systemID = xmlSource . getSystemId ( ) ; try { XMLReader reader = null ; if ( source instanceof SAXSource ) reader = ( ( SAXSource ) source ) . getXMLReader ( ) ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } ContentHandler inputHandler = this ; reader . setContentHandler ( inputHandler ) ; if ( inputHandler instanceof org . xml . sax . DTDHandler ) reader . setDTDHandler ( ( org . xml . sax . DTDHandler ) inputHandler ) ; try { if ( inputHandler instanceof org . xml . sax . ext . LexicalHandler ) reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , inputHandler ) ; if ( inputHandler instanceof org . xml . sax . ext . DeclHandler ) reader . setProperty ( "http://xml.org/sax/properties/declaration-handler" , inputHandler ) ; } catch ( org . xml . sax . SAXException se ) { } try { if ( inputHandler instanceof org . xml . sax . ext . LexicalHandler ) reader . setProperty ( "http://xml.org/sax/handlers/LexicalHandler" , inputHandler ) ; if ( inputHandler instanceof org . xml . sax . ext . DeclHandler ) reader . setProperty ( "http://xml.org/sax/handlers/DeclHandler" , inputHandler ) ; } catch ( org . xml . sax . SAXNotRecognizedException snre ) { } reader . parse ( xmlSource ) ; } catch ( org . apache . xml . utils . WrappedRuntimeException wre ) { Throwable throwable = wre . getException ( ) ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } throw new TransformerException ( wre . getException ( ) ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } finally { if ( null != m_outputStream ) { try { m_outputStream . close ( ) ; } catch ( IOException ioe ) { } m_outputStream = null ; } } } public void setParameter ( String name , Object value ) { if ( null == m_params ) { m_params = new Hashtable ( ) ; } m_params . put ( name , value ) ; } public Object getParameter ( String name ) { if ( null == m_params ) return null ; return m_params . get ( name ) ; } public void clearParameters ( ) { if ( null == m_params ) return ; m_params . clear ( ) ; } public void setURIResolver ( URIResolver resolver ) { m_URIResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_URIResolver ; } public void setOutputProperties ( Properties oformat ) throws IllegalArgumentException { if ( null != oformat ) { String method = ( String ) oformat . get ( OutputKeys . METHOD ) ; if ( null != method ) m_outputFormat = new OutputProperties ( method ) ; else m_outputFormat = new OutputProperties ( ) ; } if ( null != oformat ) { m_outputFormat . copyFrom ( oformat ) ; } } public Properties getOutputProperties ( ) { return ( Properties ) m_outputFormat . getProperties ( ) . clone ( ) ; } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { if ( ! m_outputFormat . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; m_outputFormat . setProperty ( name , value ) ; } public String getOutputProperty ( String name ) throws IllegalArgumentException { String value = null ; OutputProperties props = m_outputFormat ; value = props . getProperty ( name ) ; if ( null == value ) { if ( ! props . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; } return value ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; else m_errorListener = listener ; } public ErrorListener getErrorListener ( ) { return m_errorListener ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( null != m_resultDTDHandler ) m_resultDTDHandler . notationDecl ( name , publicId , systemId ) ; } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( null != m_resultDTDHandler ) m_resultDTDHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } public void setDocumentLocator ( Locator locator ) { try { if ( null == m_resultContentHandler ) createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } m_resultContentHandler . setDocumentLocator ( locator ) ; } public void startDocument ( ) throws SAXException { try { if ( null == m_resultContentHandler ) createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new SAXException ( te . getMessage ( ) , te ) ; } m_flushedStartDoc = false ; m_foundFirstElement = false ; } boolean m_flushedStartDoc = false ; protected final void flushStartDoc ( ) throws SAXException { if ( ! m_flushedStartDoc ) { if ( m_resultContentHandler == null ) { try { createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new SAXException ( te ) ; } } m_resultContentHandler . startDocument ( ) ; m_flushedStartDoc = true ; } } public void endDocument ( ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . endDocument ( ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . endPrefixMapping ( prefix ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( ! m_foundFirstElement && null != m_serializer ) { m_foundFirstElement = true ; Serializer newSerializer ; try { newSerializer = SerializerSwitcher . switchSerializerIfHTML ( uri , localName , m_outputFormat . getProperties ( ) , m_serializer ) ; } catch ( TransformerException te ) { throw new SAXException ( te ) ; } if ( newSerializer != m_serializer ) { try { m_resultContentHandler = newSerializer . asContentHandler ( ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } if ( m_resultContentHandler instanceof DTDHandler ) m_resultDTDHandler = ( DTDHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof LexicalHandler ) m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; m_serializer = newSerializer ; } } flushStartDoc ( ) ; m_resultContentHandler . startElement ( uri , localName , qName , attributes ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { m_resultContentHandler . endElement ( uri , localName , qName ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . characters ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { m_resultContentHandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . processingInstruction ( target , data ) ; } public void skippedEntity ( String name ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . skippedEntity ( name ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { flushStartDoc ( ) ; if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startDTD ( name , publicId , systemId ) ; } public void endDTD ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endDTD ( ) ; } public void startEntity ( String name ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startEntity ( name ) ; } public void endEntity ( String name ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endEntity ( name ) ; } public void startCDATA ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startCDATA ( ) ; } public void endCDATA ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endCDATA ( ) ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { flushStartDoc ( ) ; if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . comment ( ch , start , length ) ; } public void elementDecl ( String name , String model ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . elementDecl ( name , model ) ; } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . internalEntityDecl ( name , value ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . externalEntityDecl ( name , publicId , systemId ) ; } private java . io . FileOutputStream m_outputStream = null ; private ContentHandler m_resultContentHandler ; private LexicalHandler m_resultLexicalHandler ; private DTDHandler m_resultDTDHandler ; private DeclHandler m_resultDeclHandler ; private Serializer m_serializer ; private Result m_result ; private String m_systemID ; private Hashtable m_params ; private ErrorListener m_errorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; URIResolver m_URIResolver ; private OutputProperties m_outputFormat ; boolean m_foundFirstElement ; } 	1
package org . apache . xml . utils ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Attr ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . Entity ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; public class DOMHelper { public static Document createDocument ( ) { try { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( true ) ; dfactory . setValidating ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Document outNode = docBuilder . newDocument ( ) ; return outNode ; } catch ( ParserConfigurationException pce ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CREATEDOCUMENT_NOT_SUPPORTED , null ) ) ; } } public boolean shouldStripSourceNode ( Node textNode ) throws javax . xml . transform . TransformerException { return false ; } public String getUniqueID ( Node node ) { return "N" + Integer . toHexString ( node . hashCode ( ) ) . toUpperCase ( ) ; } public static boolean isNodeAfter ( Node node1 , Node node2 ) { if ( node1 == node2 || isNodeTheSame ( node1 , node2 ) ) return true ; boolean isNodeAfter = true ; Node parent1 = getParentOfNode ( node1 ) ; Node parent2 = getParentOfNode ( node2 ) ; if ( parent1 == parent2 || isNodeTheSame ( parent1 , parent2 ) ) { if ( null != parent1 ) isNodeAfter = isNodeAfterSibling ( parent1 , node1 , node2 ) ; else { } } else { int nParents1 = 2 , nParents2 = 2 ; while ( parent1 != null ) { nParents1 ++ ; parent1 = getParentOfNode ( parent1 ) ; } while ( parent2 != null ) { nParents2 ++ ; parent2 = getParentOfNode ( parent2 ) ; } Node startNode1 = node1 , startNode2 = node2 ; if ( nParents1 < nParents2 ) { int adjust = nParents2 - nParents1 ; for ( int i = 0 ; i < adjust ; i ++ ) { startNode2 = getParentOfNode ( startNode2 ) ; } } else if ( nParents1 > nParents2 ) { int adjust = nParents1 - nParents2 ; for ( int i = 0 ; i < adjust ; i ++ ) { startNode1 = getParentOfNode ( startNode1 ) ; } } Node prevChild1 = null , prevChild2 = null ; while ( null != startNode1 ) { if ( startNode1 == startNode2 || isNodeTheSame ( startNode1 , startNode2 ) ) { if ( null == prevChild1 ) { isNodeAfter = ( nParents1 < nParents2 ) ? true : false ; break ; } else { isNodeAfter = isNodeAfterSibling ( startNode1 , prevChild1 , prevChild2 ) ; break ; } } prevChild1 = startNode1 ; startNode1 = getParentOfNode ( startNode1 ) ; prevChild2 = startNode2 ; startNode2 = getParentOfNode ( startNode2 ) ; } } return isNodeAfter ; } public static boolean isNodeTheSame ( Node node1 , Node node2 ) { if ( node1 instanceof DTMNodeProxy && node2 instanceof DTMNodeProxy ) return ( ( DTMNodeProxy ) node1 ) . equals ( ( DTMNodeProxy ) node2 ) ; else return ( node1 == node2 ) ; } private static boolean isNodeAfterSibling ( Node parent , Node child1 , Node child2 ) { boolean isNodeAfterSibling = false ; short child1type = child1 . getNodeType ( ) ; short child2type = child2 . getNodeType ( ) ; if ( ( Node . ATTRIBUTE_NODE != child1type ) && ( Node . ATTRIBUTE_NODE == child2type ) ) { isNodeAfterSibling = false ; } else if ( ( Node . ATTRIBUTE_NODE == child1type ) && ( Node . ATTRIBUTE_NODE != child2type ) ) { isNodeAfterSibling = true ; } else if ( Node . ATTRIBUTE_NODE == child1type ) { NamedNodeMap children = parent . getAttributes ( ) ; int nNodes = children . getLength ( ) ; boolean found1 = false , found2 = false ; for ( int i = 0 ; i < nNodes ; i ++ ) { Node child = children . item ( i ) ; if ( child1 == child || isNodeTheSame ( child1 , child ) ) { if ( found2 ) { isNodeAfterSibling = false ; break ; } found1 = true ; } else if ( child2 == child || isNodeTheSame ( child2 , child ) ) { if ( found1 ) { isNodeAfterSibling = true ; break ; } found2 = true ; } } } else { Node child = parent . getFirstChild ( ) ; boolean found1 = false , found2 = false ; while ( null != child ) { if ( child1 == child || isNodeTheSame ( child1 , child ) ) { if ( found2 ) { isNodeAfterSibling = false ; break ; } found1 = true ; } else if ( child2 == child || isNodeTheSame ( child2 , child ) ) { if ( found1 ) { isNodeAfterSibling = true ; break ; } found2 = true ; } child = child . getNextSibling ( ) ; } } return isNodeAfterSibling ; } public short getLevel ( Node n ) { short level = 1 ; while ( null != ( n = getParentOfNode ( n ) ) ) { level ++ ; } return level ; } public String getNamespaceForPrefix ( String prefix , Element namespaceContext ) { int type ; Node parent = namespaceContext ; String namespace = null ; if ( prefix . equals ( "xml" ) ) { namespace = QName . S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { namespace = "http://www.w3.org/2000/xmlns/" ; } else { String declname = ( prefix == "" ) ? "xmlns" : "xmlns:" + prefix ; while ( ( null != parent ) && ( null == namespace ) && ( ( ( type = parent . getNodeType ( ) ) == Node . ELEMENT_NODE ) || ( type == Node . ENTITY_REFERENCE_NODE ) ) ) { if ( type == Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) parent ) . getAttributeNode ( declname ) ; if ( attr != null ) { namespace = attr . getNodeValue ( ) ; break ; } } parent = getParentOfNode ( parent ) ; } } return namespace ; } Hashtable m_NSInfos = new Hashtable ( ) ; protected static final NSInfo m_NSInfoUnProcWithXMLNS = new NSInfo ( false , true ) ; protected static final NSInfo m_NSInfoUnProcWithoutXMLNS = new NSInfo ( false , false ) ; protected static final NSInfo m_NSInfoUnProcNoAncestorXMLNS = new NSInfo ( false , false , NSInfo . ANCESTORNOXMLNS ) ; protected static final NSInfo m_NSInfoNullWithXMLNS = new NSInfo ( true , true ) ; protected static final NSInfo m_NSInfoNullWithoutXMLNS = new NSInfo ( true , false ) ; protected static final NSInfo m_NSInfoNullNoAncestorXMLNS = new NSInfo ( true , false , NSInfo . ANCESTORNOXMLNS ) ; protected Vector m_candidateNoAncestorXMLNS = new Vector ( ) ; public String getNamespaceOfNode ( Node n ) { String namespaceOfPrefix ; boolean hasProcessedNS ; NSInfo nsInfo ; short ntype = n . getNodeType ( ) ; if ( Node . ATTRIBUTE_NODE != ntype ) { Object nsObj = m_NSInfos . get ( n ) ; nsInfo = ( nsObj == null ) ? null : ( NSInfo ) nsObj ; hasProcessedNS = ( nsInfo == null ) ? false : nsInfo . m_hasProcessedNS ; } else { hasProcessedNS = false ; nsInfo = null ; } if ( hasProcessedNS ) { namespaceOfPrefix = nsInfo . m_namespace ; } else { namespaceOfPrefix = null ; String nodeName = n . getNodeName ( ) ; int indexOfNSSep = nodeName . indexOf ( ':' ) ; String prefix ; if ( Node . ATTRIBUTE_NODE == ntype ) { if ( indexOfNSSep > 0 ) { prefix = nodeName . substring ( 0 , indexOfNSSep ) ; } else { return namespaceOfPrefix ; } } else { prefix = ( indexOfNSSep >= 0 ) ? nodeName . substring ( 0 , indexOfNSSep ) : "" ; } boolean ancestorsHaveXMLNS = false ; boolean nHasXMLNS = false ; if ( prefix . equals ( "xml" ) ) { namespaceOfPrefix = QName . S_XMLNAMESPACEURI ; } else { int parentType ; Node parent = n ; while ( ( null != parent ) && ( null == namespaceOfPrefix ) ) { if ( ( null != nsInfo ) && ( nsInfo . m_ancestorHasXMLNSAttrs == NSInfo . ANCESTORNOXMLNS ) ) { break ; } parentType = parent . getNodeType ( ) ; if ( ( null == nsInfo ) || nsInfo . m_hasXMLNSAttrs ) { boolean elementHasXMLNS = false ; if ( parentType == Node . ELEMENT_NODE ) { NamedNodeMap nnm = parent . getAttributes ( ) ; for ( int i = 0 ; i < nnm . getLength ( ) ; i ++ ) { Node attr = nnm . item ( i ) ; String aname = attr . getNodeName ( ) ; if ( aname . charAt ( 0 ) == 'x' ) { boolean isPrefix = aname . startsWith ( "xmlns:" ) ; if ( aname . equals ( "xmlns" ) || isPrefix ) { if ( n == parent ) nHasXMLNS = true ; elementHasXMLNS = true ; ancestorsHaveXMLNS = true ; String p = isPrefix ? aname . substring ( 6 ) : "" ; if ( p . equals ( prefix ) ) { namespaceOfPrefix = attr . getNodeValue ( ) ; break ; } } } } } if ( ( Node . ATTRIBUTE_NODE != parentType ) && ( null == nsInfo ) && ( n != parent ) ) { nsInfo = elementHasXMLNS ? m_NSInfoUnProcWithXMLNS : m_NSInfoUnProcWithoutXMLNS ; m_NSInfos . put ( parent , nsInfo ) ; } } if ( Node . ATTRIBUTE_NODE == parentType ) { parent = getParentOfNode ( parent ) ; } else { m_candidateNoAncestorXMLNS . addElement ( parent ) ; m_candidateNoAncestorXMLNS . addElement ( nsInfo ) ; parent = parent . getParentNode ( ) ; } if ( null != parent ) { Object nsObj = m_NSInfos . get ( parent ) ; nsInfo = ( nsObj == null ) ? null : ( NSInfo ) nsObj ; } } int nCandidates = m_candidateNoAncestorXMLNS . size ( ) ; if ( nCandidates > 0 ) { if ( ( false == ancestorsHaveXMLNS ) && ( null == parent ) ) { for ( int i = 0 ; i < nCandidates ; i += 2 ) { Object candidateInfo = m_candidateNoAncestorXMLNS . elementAt ( i + 1 ) ; if ( candidateInfo == m_NSInfoUnProcWithoutXMLNS ) { m_NSInfos . put ( m_candidateNoAncestorXMLNS . elementAt ( i ) , m_NSInfoUnProcNoAncestorXMLNS ) ; } else if ( candidateInfo == m_NSInfoNullWithoutXMLNS ) { m_NSInfos . put ( m_candidateNoAncestorXMLNS . elementAt ( i ) , m_NSInfoNullNoAncestorXMLNS ) ; } } } m_candidateNoAncestorXMLNS . removeAllElements ( ) ; } } if ( Node . ATTRIBUTE_NODE != ntype ) { if ( null == namespaceOfPrefix ) { if ( ancestorsHaveXMLNS ) { if ( nHasXMLNS ) m_NSInfos . put ( n , m_NSInfoNullWithXMLNS ) ; else m_NSInfos . put ( n , m_NSInfoNullWithoutXMLNS ) ; } else { m_NSInfos . put ( n , m_NSInfoNullNoAncestorXMLNS ) ; } } else { m_NSInfos . put ( n , new NSInfo ( namespaceOfPrefix , nHasXMLNS ) ) ; } } } return namespaceOfPrefix ; } public String getLocalNameOfNode ( Node n ) { String qname = n . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; return ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } public String getExpandedElementName ( Element elem ) { String namespace = getNamespaceOfNode ( elem ) ; return ( null != namespace ) ? namespace + ":" + getLocalNameOfNode ( elem ) : getLocalNameOfNode ( elem ) ; } public String getExpandedAttributeName ( Attr attr ) { String namespace = getNamespaceOfNode ( attr ) ; return ( null != namespace ) ? namespace + ":" + getLocalNameOfNode ( attr ) : getLocalNameOfNode ( attr ) ; } public boolean isIgnorableWhitespace ( Text node ) { boolean isIgnorable = false ; return isIgnorable ; } public Node getRoot ( Node node ) { Node root = null ; while ( node != null ) { root = node ; node = getParentOfNode ( node ) ; } return root ; } public Node getRootNode ( Node n ) { int nt = n . getNodeType ( ) ; return ( ( Node . DOCUMENT_NODE == nt ) || ( Node . DOCUMENT_FRAGMENT_NODE == nt ) ) ? n : n . getOwnerDocument ( ) ; } public boolean isNamespaceNode ( Node n ) { if ( Node . ATTRIBUTE_NODE == n . getNodeType ( ) ) { String attrName = n . getNodeName ( ) ; return ( attrName . startsWith ( "xmlns:" ) || attrName . equals ( "xmlns" ) ) ; } return false ; } public static Node getParentOfNode ( Node node ) throws RuntimeException { Node parent ; short nodeType = node . getNodeType ( ) ; if ( Node . ATTRIBUTE_NODE == nodeType ) { Document doc = node . getOwnerDocument ( ) ; DOMImplementation impl = doc . getImplementation ( ) ; if ( impl != null && impl . hasFeature ( "Core" , "2.0" ) ) { parent = ( ( Attr ) node ) . getOwnerElement ( ) ; return parent ; } Element rootElem = doc . getDocumentElement ( ) ; if ( null == rootElem ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , null ) ) ; } parent = locateAttrParent ( rootElem , node ) ; } else { parent = node . getParentNode ( ) ; } return parent ; } public Element getElementByID ( String id , Document doc ) { return null ; } public String getUnparsedEntityURI ( String name , Document doc ) { String url = "" ; DocumentType doctype = doc . getDoctype ( ) ; if ( null != doctype ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( null == entities ) return url ; Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( null == entity ) return url ; String notationName = entity . getNotationName ( ) ; if ( null != notationName ) { url = entity . getSystemId ( ) ; if ( null == url ) { url = entity . getPublicId ( ) ; } else { } } } return url ; } private static Node locateAttrParent ( Element elem , Node attr ) { Node parent = null ; Attr check = elem . getAttributeNode ( attr . getNodeName ( ) ) ; if ( check == attr ) parent = elem ; if ( null == parent ) { for ( Node node = elem . getFirstChild ( ) ; null != node ; node = node . getNextSibling ( ) ) { if ( Node . ELEMENT_NODE == node . getNodeType ( ) ) { parent = locateAttrParent ( ( Element ) node , attr ) ; if ( null != parent ) break ; } } } return parent ; } protected Document m_DOMFactory = null ; public void setDOMFactory ( Document domFactory ) { this . m_DOMFactory = domFactory ; } public Document getDOMFactory ( ) { if ( null == this . m_DOMFactory ) { this . m_DOMFactory = createDocument ( ) ; } return this . m_DOMFactory ; } public static String getNodeData ( Node node ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( node , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return s ; } public static void getNodeData ( Node node , FastStringBuffer buf ) { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { getNodeData ( child , buf ) ; } } break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . ATTRIBUTE_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : break ; default : break ; } } } 	1
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . Type ; final class SlotAllocator { private int _firstAvailableSlot ; private int _size = 8 ; private int _free = 0 ; private int [ ] _slotsTaken = new int [ _size ] ; public void initialize ( LocalVariableGen [ ] vars ) { final int length = vars . length ; int slot = 0 , size , index ; for ( int i = 0 ; i < length ; i ++ ) { size = vars [ i ] . getType ( ) . getSize ( ) ; index = vars [ i ] . getIndex ( ) ; slot = Math . max ( slot , index + size ) ; } _firstAvailableSlot = slot ; } public int allocateSlot ( Type type ) { final int size = type . getSize ( ) ; final int limit = _free ; int slot = _firstAvailableSlot , where = 0 ; if ( _free + size > _size ) { final int [ ] array = new int [ _size *= 2 ] ; for ( int j = 0 ; j < limit ; j ++ ) array [ j ] = _slotsTaken [ j ] ; _slotsTaken = array ; } while ( where < limit ) { if ( slot + size <= _slotsTaken [ where ] ) { for ( int j = limit - 1 ; j >= where ; j -- ) _slotsTaken [ j + size ] = _slotsTaken [ j ] ; break ; } else { slot = _slotsTaken [ where ++ ] + 1 ; } } for ( int j = 0 ; j < size ; j ++ ) _slotsTaken [ where + j ] = slot + j ; _free += size ; return slot ; } public void releaseSlot ( LocalVariableGen lvg ) { final int size = lvg . getType ( ) . getSize ( ) ; final int slot = lvg . getIndex ( ) ; final int limit = _free ; for ( int i = 0 ; i < limit ; i ++ ) { if ( _slotsTaken [ i ] == slot ) { int j = i + size ; while ( j < limit ) { _slotsTaken [ i ++ ] = _slotsTaken [ j ++ ] ; } _free -= size ; return ; } } String state = "Variable slot allocation error" + "(size=" + size + ", slot=" + slot + ", limit=" + limit + ")" ; ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , state ) ; throw new Error ( err . toString ( ) ) ; } } 	0
package org . apache . xpath . domapi ; import org . w3c . dom . Attr ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . xpath . XPathNamespace ; public class XPathNamespaceImpl implements XPathNamespace { Node m_attributeNode = null ; public XPathNamespaceImpl ( Node node ) { m_attributeNode = node ; } public Element getOwnerElement ( ) { return ( ( Attr ) m_attributeNode ) . getOwnerElement ( ) ; } public String getNodeName ( ) { return "#namespace" ; } public String getNodeValue ( ) throws DOMException { return m_attributeNode . getNodeValue ( ) ; } public void setNodeValue ( String arg0 ) throws DOMException { } public short getNodeType ( ) { return XPathNamespace . XPATH_NAMESPACE_NODE ; } public Node getParentNode ( ) { return m_attributeNode . getParentNode ( ) ; } public NodeList getChildNodes ( ) { return m_attributeNode . getChildNodes ( ) ; } public Node getFirstChild ( ) { return m_attributeNode . getFirstChild ( ) ; } public Node getLastChild ( ) { return m_attributeNode . getLastChild ( ) ; } public Node getPreviousSibling ( ) { return m_attributeNode . getPreviousSibling ( ) ; } public Node getNextSibling ( ) { return m_attributeNode . getNextSibling ( ) ; } public NamedNodeMap getAttributes ( ) { return m_attributeNode . getAttributes ( ) ; } public Document getOwnerDocument ( ) { return m_attributeNode . getOwnerDocument ( ) ; } public Node insertBefore ( Node arg0 , Node arg1 ) throws DOMException { return null ; } public Node replaceChild ( Node arg0 , Node arg1 ) throws DOMException { return null ; } public Node removeChild ( Node arg0 ) throws DOMException { return null ; } public Node appendChild ( Node arg0 ) throws DOMException { return null ; } public boolean hasChildNodes ( ) { return false ; } public Node cloneNode ( boolean arg0 ) { throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , null ) ; } public void normalize ( ) { m_attributeNode . normalize ( ) ; } public boolean isSupported ( String arg0 , String arg1 ) { return m_attributeNode . isSupported ( arg0 , arg1 ) ; } public String getNamespaceURI ( ) { return m_attributeNode . getNodeValue ( ) ; } public String getPrefix ( ) { return m_attributeNode . getPrefix ( ) ; } public void setPrefix ( String arg0 ) throws DOMException { } public String getLocalName ( ) { return m_attributeNode . getPrefix ( ) ; } public boolean hasAttributes ( ) { return m_attributeNode . hasAttributes ( ) ; } } 	1
package org . apache . xalan . trace ; import java . util . TooManyListenersException ; import java . util . Vector ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; public class TraceManager { private TransformerImpl m_transformer ; public TraceManager ( TransformerImpl transformer ) { m_transformer = transformer ; } private Vector m_traceListeners = null ; public void addTraceListener ( TraceListener tl ) throws TooManyListenersException { TransformerImpl . S_DEBUG = true ; if ( null == m_traceListeners ) m_traceListeners = new Vector ( ) ; m_traceListeners . addElement ( tl ) ; } public void removeTraceListener ( TraceListener tl ) { if ( null != m_traceListeners ) { m_traceListeners . removeElement ( tl ) ; if ( 0 == m_traceListeners . size ( ) ) m_traceListeners = null ; } } public void fireGenerateEvent ( GenerateEvent te ) { if ( null != m_traceListeners ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . generated ( te ) ; } } } public boolean hasTraceListeners ( ) { return ( null != m_traceListeners ) ; } public void fireTraceEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEndEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx2 ) { ( ( TraceListenerEx2 ) tl ) . traceEnd ( te ) ; } } } } public void fireTraceEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . trace ( te ) ; } } } public void fireSelectedEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEvent ( new SelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEndEvent ( new EndSelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( EndSelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx ) ( ( TraceListenerEx ) tl ) . selectEnd ( se ) ; } } } public void fireSelectedEvent ( SelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . selected ( se ) ; } } } } 	0
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . Type ; import org . apache . xalan . xsltc . compiler . Constants ; public final class Util { static public char filesep ; static { String temp = System . getProperty ( "file.separator" , "/" ) ; filesep = temp . charAt ( 0 ) ; } public static String noExtName ( String name ) { final int index = name . lastIndexOf ( '.' ) ; return name . substring ( 0 , index >= 0 ? index : name . length ( ) ) ; } public static String baseName ( String name ) { int index = name . lastIndexOf ( '\\' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '/' ) ; } if ( index >= 0 ) return name . substring ( index + 1 ) ; else { int lastColonIndex = name . lastIndexOf ( ':' ) ; if ( lastColonIndex > 0 ) return name . substring ( lastColonIndex + 1 ) ; else return name ; } } public static String pathName ( String name ) { int index = name . lastIndexOf ( '/' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '\\' ) ; } return name . substring ( 0 , index + 1 ) ; } public static String toJavaName ( String name ) { if ( name . length ( ) > 0 ) { final StringBuffer result = new StringBuffer ( ) ; char ch = name . charAt ( 0 ) ; result . append ( Character . isJavaIdentifierStart ( ch ) ? ch : '_' ) ; final int n = name . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { ch = name . charAt ( i ) ; result . append ( Character . isJavaIdentifierPart ( ch ) ? ch : '_' ) ; } return result . toString ( ) ; } return name ; } public static Type getJCRefType ( String signature ) { return Type . getType ( signature ) ; } public static String internalName ( String cname ) { return cname . replace ( '.' , filesep ) ; } public static void println ( String s ) { System . out . println ( s ) ; } public static void println ( char ch ) { System . out . println ( ch ) ; } public static void TRACE1 ( ) { System . out . println ( "TRACE1" ) ; } public static void TRACE2 ( ) { System . out . println ( "TRACE2" ) ; } public static void TRACE3 ( ) { System . out . println ( "TRACE3" ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } public static String escape ( String input ) { return replace ( input , ".-/:" , new String [ ] { "$dot$" , "$dash$" , "$slash$" , "$colon$" } ) ; } public static String getLocalName ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( index + 1 ) : qname ; } public static String getPrefix ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : Constants . EMPTYSTRING ; } } 	1
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ClassGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; public final class AttributeSetMethodGenerator extends MethodGenerator { private static int HANDLER_INDEX = 1 ; private static int ITERATOR_INDEX = 2 ; private static final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 2 ] ; private static final String [ ] argNames = new String [ 2 ] ; static { argTypes [ 0 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; argNames [ 0 ] = TRANSLET_OUTPUT_PNAME ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argNames [ 1 ] = ITERATOR_PNAME ; } private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; public AttributeSetMethodGenerator ( String methodName , ClassGen classGen ) { super ( org . apache . bcel . Constants . ACC_PRIVATE , org . apache . bcel . generic . Type . VOID , argTypes , argNames , methodName , classGen . getClassName ( ) , new InstructionList ( ) , classGen . getConstantPool ( ) ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public int getIteratorIndex ( ) { return ITERATOR_INDEX ; } public Instruction storeHandler ( ) { return _astoreHandler ; } public Instruction loadHandler ( ) { return _aloadHandler ; } public int getLocalIndex ( String name ) { return INVALID_INDEX ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FilteredAbsoluteLocationPath extends Expression { private Expression _path ; public FilteredAbsoluteLocationPath ( ) { _path = null ; } public FilteredAbsoluteLocationPath ( Expression path ) { _path = path ; if ( path != null ) { _path . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _path != null ) { _path . setParser ( parser ) ; } } public Expression getPath ( ) { return ( _path ) ; } public String toString ( ) { return "FilteredAbsoluteLocationPath(" + ( _path != null ? _path . toString ( ) : "null" ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _path != null ) { final Type ptype = _path . typeCheck ( stable ) ; if ( ptype instanceof NodeType ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _path != null ) { final int initDFI = cpg . addMethodref ( DUP_FILTERED_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DUP_FILTERED_ITERATOR ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initDFI ) ) ; } else { final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEINTERFACE ( git , 1 ) ) ; } } } 	0
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . PredicatedNodeTest ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncCurrent extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { Object subContextList = xctxt . getSubContextList ( ) ; int currentNode ; if ( null != subContextList && subContextList instanceof PredicatedNodeTest ) { LocPathIterator lpi = xctxt . getCurrentNodeList ( ) ; currentNode = lpi . getCurrentContextNode ( ) ; } else if ( xctxt . getIteratorRoot ( ) != DTM . NULL ) { currentNode = xctxt . getIteratorRoot ( ) ; } else { DTMIterator cnl = xctxt . getContextNodeList ( ) ; if ( null != cnl ) { currentNode = cnl . getCurrentNode ( ) ; } else currentNode = DTM . NULL ; } return new XNodeSet ( currentNode , xctxt . getDTMManager ( ) ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1
package org . apache . xml . serializer ; import java . util . Properties ; public class OutputPropertyUtils { public static boolean getBooleanProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s || ! s . equals ( "yes" ) ) return false ; else return true ; } public static int getIntProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s ) return 0 ; else return Integer . parseInt ( s ) ; } } 	0
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . IntStack ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . AttributesImpl ; public class XSLTElementProcessor extends ElemTemplateElement { XSLTElementProcessor ( ) { } private IntStack m_savedLastOrder ; private XSLTElementDef m_elemDef ; XSLTElementDef getElemDef ( ) { return m_elemDef ; } void setElemDef ( XSLTElementDef def ) { m_elemDef = def ; } public InputSource resolveEntity ( StylesheetHandler handler , String publicId , String systemId ) throws org . xml . sax . SAXException { return null ; } public void notationDecl ( StylesheetHandler handler , String name , String publicId , String systemId ) { } public void unparsedEntityDecl ( StylesheetHandler handler , String name , String publicId , String systemId , String notationName ) { } public void startNonText ( StylesheetHandler handler ) throws org . xml . sax . SAXException { } public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { if ( m_savedLastOrder == null ) m_savedLastOrder = new IntStack ( ) ; m_savedLastOrder . push ( getElemDef ( ) . getLastOrder ( ) ) ; getElemDef ( ) . setLastOrder ( - 1 ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { if ( m_savedLastOrder != null && ! m_savedLastOrder . empty ( ) ) getElemDef ( ) . setLastOrder ( m_savedLastOrder . pop ( ) ) ; if ( ! getElemDef ( ) . getRequiredFound ( ) ) handler . error ( XSLTErrorResources . ER_REQUIRED_ELEM_NOT_FOUND , new Object [ ] { getElemDef ( ) . getRequiredElem ( ) } , null ) ; } public void characters ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { handler . error ( XSLTErrorResources . ER_CHARS_NOT_ALLOWED , null , null ) ; } public void ignorableWhitespace ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { } public void processingInstruction ( StylesheetHandler handler , String target , String data ) throws org . xml . sax . SAXException { } public void skippedEntity ( StylesheetHandler handler , String name ) throws org . xml . sax . SAXException { } void setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , ElemTemplateElement target ) throws org . xml . sax . SAXException { setPropertiesFromAttributes ( handler , rawName , attributes , target , true ) ; } Attributes setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , ElemTemplateElement target , boolean throwError ) throws org . xml . sax . SAXException { XSLTElementDef def = getElemDef ( ) ; AttributesImpl undefines = throwError ? null : new AttributesImpl ( ) ; Vector processedDefs = new Vector ( ) ; Vector errorDefs = new Vector ( ) ; int nAttrs = attributes . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { String attrUri = attributes . getURI ( i ) ; if ( ( null != attrUri ) && ( attrUri . length ( ) == 0 ) && ( attributes . getQName ( i ) . startsWith ( "xmlns:" ) || attributes . getQName ( i ) . equals ( "xmlns" ) ) ) { attrUri = org . apache . xalan . templates . Constants . S_XMLNAMESPACEURI ; } String attrLocalName = attributes . getLocalName ( i ) ; XSLTAttributeDef attrDef = def . getAttributeDef ( attrUri , attrLocalName ) ; if ( null == attrDef ) { if ( throwError ) { handler . error ( XSLTErrorResources . ER_ATTR_NOT_ALLOWED , new Object [ ] { attributes . getQName ( i ) , rawName } , null ) ; } else { undefines . addAttribute ( attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } } else { boolean success = attrDef . setAttrValue ( handler , attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getValue ( i ) , target ) ; if ( success ) processedDefs . addElement ( attrDef ) ; else errorDefs . addElement ( attrDef ) ; } } XSLTAttributeDef [ ] attrDefs = def . getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int i = 0 ; i < nAttrDefs ; i ++ ) { XSLTAttributeDef attrDef = attrDefs [ i ] ; String defVal = attrDef . getDefault ( ) ; if ( null != defVal ) { if ( ! processedDefs . contains ( attrDef ) ) { attrDef . setDefAttrValue ( handler , target ) ; } } if ( attrDef . getRequired ( ) ) { if ( ( ! processedDefs . contains ( attrDef ) ) && ( ! errorDefs . contains ( attrDef ) ) ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_REQUIRES_ATTRIB , new Object [ ] { rawName , attrDef . getName ( ) } ) , null ) ; } } return undefines ; } } 	1
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; public class ElemPI extends ElemTemplateElement { private AVT m_name_atv = null ; public void setName ( AVT v ) { m_name_atv = v ; } public AVT getName ( ) { return m_name_atv ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_name_atv ) m_name_atv . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_PI ; } public String getNodeName ( ) { return Constants . ELEMNAME_PI_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String piName = m_name_atv == null ? null : m_name_atv . evaluate ( xctxt , sourceNode , this ) ; if ( piName == null ) return ; if ( piName . equalsIgnoreCase ( "xml" ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , new Object [ ] { Constants . ATTRNAME_NAME , piName } ) ; return ; } else if ( ( ! m_name_atv . isSimple ( ) ) && ( ! isValidNCName ( piName ) ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , new Object [ ] { Constants . ATTRNAME_NAME , piName } ) ; return ; } String data = transformer . transformToString ( this ) ; try { transformer . getResultTreeHandler ( ) . processingInstruction ( piName , data ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	1
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public abstract class DTMDefaultBaseTraversers extends DTMDefaultBase { public DTMDefaultBaseTraversers ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; } public DTMDefaultBaseTraversers ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; } public DTMAxisTraverser getAxisTraverser ( final int axis ) { DTMAxisTraverser traverser ; if ( null == m_traversers ) { m_traversers = new DTMAxisTraverser [ Axis . names . length ] ; traverser = null ; } else { traverser = m_traversers [ axis ] ; if ( traverser != null ) return traverser ; } switch ( axis ) { case Axis . ANCESTOR : traverser = new AncestorTraverser ( ) ; break ; case Axis . ANCESTORORSELF : traverser = new AncestorOrSelfTraverser ( ) ; break ; case Axis . ATTRIBUTE : traverser = new AttributeTraverser ( ) ; break ; case Axis . CHILD : traverser = new ChildTraverser ( ) ; break ; case Axis . DESCENDANT : traverser = new DescendantTraverser ( ) ; break ; case Axis . DESCENDANTORSELF : traverser = new DescendantOrSelfTraverser ( ) ; break ; case Axis . FOLLOWING : traverser = new FollowingTraverser ( ) ; break ; case Axis . FOLLOWINGSIBLING : traverser = new FollowingSiblingTraverser ( ) ; break ; case Axis . NAMESPACE : traverser = new NamespaceTraverser ( ) ; break ; case Axis . NAMESPACEDECLS : traverser = new NamespaceDeclsTraverser ( ) ; break ; case Axis . PARENT : traverser = new ParentTraverser ( ) ; break ; case Axis . PRECEDING : traverser = new PrecedingTraverser ( ) ; break ; case Axis . PRECEDINGSIBLING : traverser = new PrecedingSiblingTraverser ( ) ; break ; case Axis . SELF : traverser = new SelfTraverser ( ) ; break ; case Axis . ALL : traverser = new AllFromRootTraverser ( ) ; break ; case Axis . ALLFROMNODE : traverser = new AllFromNodeTraverser ( ) ; break ; case Axis . PRECEDINGANDANCESTOR : traverser = new PrecedingAndAncestorTraverser ( ) ; break ; case Axis . DESCENDANTSFROMROOT : traverser = new DescendantFromRootTraverser ( ) ; break ; case Axis . DESCENDANTSORSELFFROMROOT : traverser = new DescendantOrSelfFromRootTraverser ( ) ; break ; case Axis . ROOT : traverser = new RootTraverser ( ) ; break ; case Axis . FILTEREDLIST : return null ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_UNKNOWN_AXIS_TYPE , new Object [ ] { Integer . toString ( axis ) } ) ) ; } if ( null == traverser ) throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_AXIS_TRAVERSER_NOT_SUPPORTED , new Object [ ] { Axis . names [ axis ] } ) ) ; m_traversers [ axis ] = traverser ; return traverser ; } private class AncestorTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getParent ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( DTM . NULL != ( current = m_parent . elementAt ( current ) ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } private class AncestorOrSelfTraverser extends AncestorTraverser { public int first ( int context ) { return context ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( context ) == expandedTypeID ) ? context : next ( context , context , expandedTypeID ) ; } } private class AttributeTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstAttribute ( context ) : getNextAttribute ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstAttribute ( context ) : getNextAttribute ( current ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextAttribute ( current ) ) ) ; return NULL ; } } private class ChildTraverser extends DTMAxisTraverser { protected int getNextIndexed ( int axisRoot , int nextPotential , int expandedTypeID ) { int nsIndex = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; int lnIndex = m_expandedNameTable . getLocalNameID ( expandedTypeID ) ; for ( ; ; ) { int nextID = findElementFromIndex ( nsIndex , lnIndex , nextPotential ) ; if ( NOTPROCESSED != nextID ) { int parentID = m_parent . elementAt ( nextID ) ; if ( parentID == axisRoot ) return nextID ; if ( parentID < axisRoot ) return NULL ; do { parentID = m_parent . elementAt ( parentID ) ; if ( parentID < axisRoot ) return NULL ; } while ( parentID > axisRoot ) ; nextPotential = nextID + 1 ; continue ; } nextNode ( ) ; if ( ! ( m_nextsib . elementAt ( axisRoot ) == NOTPROCESSED ) ) break ; } return DTM . NULL ; } public int first ( int context ) { return getFirstChild ( context ) ; } public int first ( int context , int expandedTypeID ) { if ( true ) { int identity = makeNodeIdentity ( context ) ; int firstMatch = getNextIndexed ( identity , _firstch ( identity ) , expandedTypeID ) ; return makeNodeHandle ( firstMatch ) ; } else { for ( int current = _firstch ( makeNodeIdentity ( context ) ) ; DTM . NULL != current ; current = _nextsib ( current ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } public int next ( int context , int current ) { return getNextSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { for ( current = _nextsib ( makeNodeIdentity ( current ) ) ; DTM . NULL != current ; current = _nextsib ( current ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } private abstract class IndexedDTMAxisTraverser extends DTMAxisTraverser { protected final boolean isIndexed ( int expandedTypeID ) { return ( m_indexing && ExpandedNameTable . ELEMENT == m_expandedNameTable . getType ( expandedTypeID ) ) ; } protected abstract boolean isAfterAxis ( int axisRoot , int identity ) ; protected abstract boolean axisHasBeenProcessed ( int axisRoot ) ; protected int getNextIndexed ( int axisRoot , int nextPotential , int expandedTypeID ) { int nsIndex = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; int lnIndex = m_expandedNameTable . getLocalNameID ( expandedTypeID ) ; while ( true ) { int next = findElementFromIndex ( nsIndex , lnIndex , nextPotential ) ; if ( NOTPROCESSED != next ) { if ( isAfterAxis ( axisRoot , next ) ) return NULL ; return next ; } else if ( axisHasBeenProcessed ( axisRoot ) ) break ; nextNode ( ) ; } return DTM . NULL ; } } private class DescendantTraverser extends IndexedDTMAxisTraverser { protected int getFirstPotential ( int identity ) { return identity + 1 ; } protected boolean axisHasBeenProcessed ( int axisRoot ) { return ! ( m_nextsib . elementAt ( axisRoot ) == NOTPROCESSED ) ; } protected int getSubtreeRoot ( int handle ) { return makeNodeIdentity ( handle ) ; } protected boolean isDescendant ( int subtreeRootIdentity , int identity ) { return _parent ( identity ) >= subtreeRootIdentity ; } protected boolean isAfterAxis ( int axisRoot , int identity ) { do { if ( identity == axisRoot ) return false ; identity = m_parent . elementAt ( identity ) ; } while ( identity >= axisRoot ) ; return true ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = getSubtreeRoot ( context ) ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } return next ( context , context , expandedTypeID ) ; } public int next ( int context , int current ) { int subtreeRootIdent = getSubtreeRoot ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int type = _type ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = getSubtreeRoot ( context ) ; current = makeNodeIdentity ( current ) + 1 ; if ( isIndexed ( expandedTypeID ) ) { return makeNodeHandle ( getNextIndexed ( subtreeRootIdent , current , expandedTypeID ) ) ; } for ( ; ; current ++ ) { int exptype = _exptype ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class DescendantOrSelfTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return identity ; } public int first ( int context ) { return context ; } } private class AllFromNodeTraverser extends DescendantOrSelfTraverser { public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { _exptype ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; return makeNodeHandle ( current ) ; } } } private class FollowingTraverser extends DescendantTraverser { public int first ( int context ) { context = makeNodeIdentity ( context ) ; int first ; int type = _type ( context ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { context = _parent ( context ) ; first = _firstch ( context ) ; if ( NULL != first ) return makeNodeHandle ( first ) ; } do { first = _nextsib ( context ) ; if ( NULL == first ) context = _parent ( context ) ; } while ( NULL == first && NULL != context ) ; return makeNodeHandle ( first ) ; } public int first ( int context , int expandedTypeID ) { int first ; int type = getNodeType ( context ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { context = getParent ( context ) ; first = getFirstChild ( context ) ; if ( NULL != first ) { if ( getExpandedTypeID ( first ) == expandedTypeID ) return first ; else return next ( context , first , expandedTypeID ) ; } } do { first = getNextSibling ( context ) ; if ( NULL == first ) context = getParent ( context ) ; else { if ( getExpandedTypeID ( first ) == expandedTypeID ) return first ; else return next ( context , first , expandedTypeID ) ; } } while ( NULL == first && NULL != context ) ; return first ; } public int next ( int context , int current ) { current = makeNodeIdentity ( current ) ; while ( true ) { current ++ ; int type = _type ( current ) ; if ( NULL == type ) return NULL ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( true ) { current ++ ; int etype = _exptype ( current ) ; if ( NULL == etype ) return NULL ; if ( etype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class FollowingSiblingTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getNextSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { while ( DTM . NULL != ( current = getNextSibling ( current ) ) ) { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } return NULL ; } } private class NamespaceDeclsTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstNamespaceNode ( context , false ) : getNextNamespaceNode ( context , current , false ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstNamespaceNode ( context , false ) : getNextNamespaceNode ( context , current , false ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextNamespaceNode ( context , current , false ) ) ) ; return NULL ; } } private class NamespaceTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstNamespaceNode ( context , true ) : getNextNamespaceNode ( context , current , true ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstNamespaceNode ( context , true ) : getNextNamespaceNode ( context , current , true ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextNamespaceNode ( context , current , true ) ) ) ; return NULL ; } } private class ParentTraverser extends DTMAxisTraverser { public int first ( int context ) { return getParent ( context ) ; } public int first ( int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( NULL != ( current = m_parent . elementAt ( current ) ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class PrecedingTraverser extends DTMAxisTraverser { protected boolean isAncestor ( int contextIdent , int currentIdent ) { for ( contextIdent = m_parent . elementAt ( contextIdent ) ; DTM . NULL != contextIdent ; contextIdent = m_parent . elementAt ( contextIdent ) ) { if ( contextIdent == currentIdent ) return true ; } return false ; } public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { short type = _type ( current ) ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type || isAncestor ( subtreeRootIdent , current ) ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { int exptype = m_exptype . elementAt ( current ) ; if ( exptype != expandedTypeID || isAncestor ( subtreeRootIdent , current ) ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } } private class PrecedingAndAncestorTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { short type = _type ( current ) ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { int exptype = m_exptype . elementAt ( current ) ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } } private class PrecedingSiblingTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getPreviousSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { while ( DTM . NULL != ( current = getPreviousSibling ( current ) ) ) { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } return NULL ; } } private class SelfTraverser extends DTMAxisTraverser { public int first ( int context ) { return context ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( context ) == expandedTypeID ) ? context : NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class AllFromRootTraverser extends AllFromNodeTraverser { public int first ( int context ) { return getDocumentRoot ( context ) ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( getDocumentRoot ( context ) ) == expandedTypeID ) ? context : next ( context , context , expandedTypeID ) ; } public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int type = _type ( current ) ; if ( type == NULL ) return NULL ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int exptype = _exptype ( current ) ; if ( exptype == NULL ) return NULL ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class RootTraverser extends AllFromRootTraverser { public int first ( int context , int expandedTypeID ) { int root = getDocumentRoot ( context ) ; return ( getExpandedTypeID ( root ) == expandedTypeID ) ? root : NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class DescendantOrSelfFromRootTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return identity ; } protected int getSubtreeRoot ( int handle ) { return makeNodeIdentity ( getDocument ( ) ) ; } public int first ( int context ) { return getDocumentRoot ( context ) ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = 0 ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } int root = first ( context ) ; return next ( root , root , expandedTypeID ) ; } } private class DescendantFromRootTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return _firstch ( 0 ) ; } protected int getSubtreeRoot ( int handle ) { return 0 ; } public int first ( int context ) { return makeNodeHandle ( _firstch ( 0 ) ) ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = 0 ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } int root = getDocumentRoot ( context ) ; return next ( root , root , expandedTypeID ) ; } } } 	0
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . net . URL ; import java . util . Enumeration ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; final class Import extends TopLevelElement { private Stylesheet _imported = null ; public Stylesheet getImportedStylesheet ( ) { return _imported ; } public void parseContents ( final Parser parser ) { final Stylesheet context = parser . getCurrentStylesheet ( ) ; try { String docToLoad = getAttribute ( "href" ) ; if ( context . checkForLoop ( docToLoad ) ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CIRCULAR_INCLUDE_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } String currLoadedDoc = context . getSystemId ( ) ; SourceLoader loader = context . getSourceLoader ( ) ; InputSource input = null ; XMLReader reader = null ; if ( loader != null ) { final XSLTC xsltc = parser . getXSLTC ( ) ; input = loader . loadSource ( docToLoad , currLoadedDoc , xsltc ) ; reader = xsltc . getXMLReader ( ) ; } else { File file = new File ( currLoadedDoc ) ; if ( file . exists ( ) ) currLoadedDoc = "file:" + currLoadedDoc ; final URL url = new URL ( new URL ( currLoadedDoc ) , docToLoad ) ; docToLoad = url . toString ( ) ; input = new InputSource ( docToLoad ) ; } if ( input == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } final SyntaxTreeNode root ; if ( reader != null ) { root = parser . parse ( reader , input ) ; } else { root = parser . parse ( input ) ; } if ( root == null ) return ; _imported = parser . makeStylesheet ( root ) ; if ( _imported == null ) return ; _imported . setSourceLoader ( loader ) ; _imported . setSystemId ( docToLoad ) ; _imported . setParentStylesheet ( context ) ; _imported . setImportingStylesheet ( context ) ; final int currPrecedence = parser . getCurrentImportPrecedence ( ) ; final int nextPrecedence = parser . getNextImportPrecedence ( ) ; _imported . setImportPrecedence ( currPrecedence ) ; context . setImportPrecedence ( nextPrecedence ) ; parser . setCurrentStylesheet ( _imported ) ; _imported . parseContents ( parser ) ; final Enumeration elements = _imported . elements ( ) ; final Stylesheet topStylesheet = parser . getTopLevelStylesheet ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof TopLevelElement ) { if ( element instanceof Variable ) { topStylesheet . addVariable ( ( Variable ) element ) ; } else if ( element instanceof Param ) { topStylesheet . addParam ( ( Param ) element ) ; } else { topStylesheet . addElement ( ( TopLevelElement ) element ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { parser . setCurrentStylesheet ( context ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	1
package org . apache . xml . utils ; import java . io . Serializable ; import org . apache . xml . dtm . DTM ; public class NodeVector implements Serializable , Cloneable { private int m_blocksize ; private int m_map [ ] ; protected int m_firstFree = 0 ; private int m_mapSize ; public NodeVector ( ) { m_blocksize = 32 ; m_mapSize = 0 ; } public NodeVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = 0 ; } public Object clone ( ) throws CloneNotSupportedException { NodeVector clone = ( NodeVector ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new int [ this . m_map . length ] ; System . arraycopy ( this . m_map , 0 , clone . m_map , 0 , this . m_map . length ) ; } return clone ; } public int size ( ) { return m_firstFree ; } public void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void push ( int value ) { int ff = m_firstFree ; if ( ( ff + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , ff + 1 ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; } public final int pop ( ) { m_firstFree -- ; int n = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = DTM . NULL ; return n ; } public final int popAndTop ( ) { m_firstFree -- ; m_map [ m_firstFree ] = DTM . NULL ; return ( m_firstFree == 0 ) ? DTM . NULL : m_map [ m_firstFree - 1 ] ; } public final void popQuick ( ) { m_firstFree -- ; m_map [ m_firstFree ] = DTM . NULL ; } public final int peepOrNull ( ) { return ( ( null != m_map ) && ( m_firstFree > 0 ) ) ? m_map [ m_firstFree - 1 ] : DTM . NULL ; } public final void pushPair ( int v1 , int v2 ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + 1 ] = v2 ; m_firstFree += 2 ; } public final void popPair ( ) { m_firstFree -= 2 ; m_map [ m_firstFree ] = DTM . NULL ; m_map [ m_firstFree + 1 ] = DTM . NULL ; } public final void setTail ( int n ) { m_map [ m_firstFree - 1 ] = n ; } public final void setTailSub1 ( int n ) { m_map [ m_firstFree - 2 ] = n ; } public final int peepTail ( ) { return m_map [ m_firstFree - 1 ] ; } public final int peepTailSub1 ( ) { return m_map [ m_firstFree - 2 ] ; } public void insertInOrder ( int value ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( value < m_map [ i ] ) { insertElementAt ( value , i ) ; return ; } } addElement ( value ) ; } public void insertElementAt ( int value , int at ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public void appendNodes ( NodeVector nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new int [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , 0 , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; } public void removeAllElements ( ) { if ( null == m_map ) return ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = DTM . NULL ; } m_firstFree = 0 ; } public void RemoveAllNoClear ( ) { if ( null == m_map ) return ; m_firstFree = 0 ; } public boolean removeElement ( int s ) { if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == s ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = DTM . NULL ; m_firstFree -- ; return true ; } } return false ; } public void removeElementAt ( int i ) { if ( null == m_map ) return ; if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = DTM . NULL ; } public void setElementAt ( int node , int index ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } if ( index == - 1 ) addElement ( node ) ; m_map [ index ] = node ; } public int elementAt ( int i ) { if ( null == m_map ) return DTM . NULL ; return m_map [ i ] ; } public boolean contains ( int s ) { if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == s ) return true ; } return false ; } public int indexOf ( int elem , int index ) { if ( null == m_map ) return - 1 ; for ( int i = index ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == elem ) return i ; } return - 1 ; } public int indexOf ( int elem ) { if ( null == m_map ) return - 1 ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == elem ) return i ; } return - 1 ; } public void sort ( int a [ ] , int lo0 , int hi0 ) throws Exception { int lo = lo0 ; int hi = hi0 ; if ( lo >= hi ) { return ; } else if ( lo == hi - 1 ) { if ( a [ lo ] > a [ hi ] ) { int T = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = T ; } return ; } int pivot = a [ ( lo + hi ) / 2 ] ; a [ ( lo + hi ) / 2 ] = a [ hi ] ; a [ hi ] = pivot ; while ( lo < hi ) { while ( a [ lo ] <= pivot && lo < hi ) { lo ++ ; } while ( pivot <= a [ hi ] && lo < hi ) { hi -- ; } if ( lo < hi ) { int T = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = T ; } } a [ hi0 ] = a [ hi ] ; a [ hi ] = pivot ; sort ( a , lo0 , lo - 1 ) ; sort ( a , hi + 1 , hi0 ) ; } public void sort ( ) throws Exception { sort ( m_map , 0 , m_firstFree - 1 ) ; } } 	1
package org . apache . xml . dtm ; public interface DTMWSFilter { public static final short NOTSTRIP = 1 ; public static final short STRIP = 2 ; public static final short INHERIT = 3 ; public short getShouldStripSpace ( int elementHandle , DTM dtm ) ; } 	0
package org . w3c . dom . xpath ; public class XPathException extends RuntimeException { public XPathException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INVALID_EXPRESSION_ERR = 1 ; public static final short TYPE_ERR = 2 ; } 	0
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . WhiteSpaceInfo ; import org . apache . xpath . XPath ; import org . xml . sax . Attributes ; class ProcessorStripSpace extends ProcessorPreserveSpace { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { Stylesheet thisSheet = handler . getStylesheet ( ) ; WhitespaceInfoPaths paths = new WhitespaceInfoPaths ( thisSheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , paths ) ; Vector xpaths = paths . getElements ( ) ; for ( int i = 0 ; i < xpaths . size ( ) ; i ++ ) { WhiteSpaceInfo wsi = new WhiteSpaceInfo ( ( XPath ) xpaths . elementAt ( i ) , true , thisSheet ) ; wsi . setUid ( handler . nextUid ( ) ) ; thisSheet . setStripSpaces ( wsi ) ; } paths . clearElements ( ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import java . io . BufferedOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Map ; import java . util . Properties ; import java . util . Vector ; import java . util . jar . JarEntry ; import java . util . jar . JarOutputStream ; import java . util . jar . Manifest ; import org . apache . bcel . classfile . JavaClass ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . dtm . DTM ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public final class XSLTC { private Parser _parser ; private XMLReader _reader = null ; private SourceLoader _loader = null ; private Stylesheet _stylesheet = null ; private int _modeSerial = 1 ; private int _stylesheetSerial = 1 ; private int _stepPatternSerial = 1 ; private int _helperClassSerial = 0 ; private int _attributeSetSerial = 0 ; private int [ ] _numberFieldIndexes ; private int _nextGType ; private Vector _namesIndex ; private Hashtable _elements ; private Hashtable _attributes ; private int _nextNSType ; private Vector _namespaceIndex ; private Hashtable _namespaces ; public static final int FILE_OUTPUT = 0 ; public static final int JAR_OUTPUT = 1 ; public static final int BYTEARRAY_OUTPUT = 2 ; public static final int CLASSLOADER_OUTPUT = 3 ; public static final int BYTEARRAY_AND_FILE_OUTPUT = 4 ; public static final int BYTEARRAY_AND_JAR_OUTPUT = 5 ; private boolean _debug = false ; private String _jarFileName = null ; private String _className = null ; private String _packageName = null ; private File _destDir = null ; private int _outputType = FILE_OUTPUT ; private Vector _classes ; private Vector _bcelClasses ; private boolean _callsNodeset = false ; private boolean _multiDocument = false ; private boolean _hasIdCall = false ; private boolean _templateInlining = false ; public XSLTC ( ) { _parser = new Parser ( this ) ; } public Parser getParser ( ) { return _parser ; } public void setOutputType ( int type ) { _outputType = type ; } public Properties getOutputProperties ( ) { return _parser . getOutputProperties ( ) ; } public void init ( ) { reset ( ) ; _reader = null ; _classes = new Vector ( ) ; _bcelClasses = new Vector ( ) ; } private void reset ( ) { _nextGType = DTM . NTYPES ; _elements = new Hashtable ( ) ; _attributes = new Hashtable ( ) ; _namespaces = new Hashtable ( ) ; _namespaces . put ( "" , new Integer ( _nextNSType ) ) ; _namesIndex = new Vector ( 128 ) ; _namespaceIndex = new Vector ( 32 ) ; _parser . init ( ) ; _modeSerial = 1 ; _stylesheetSerial = 1 ; _stepPatternSerial = 1 ; _helperClassSerial = 0 ; _attributeSetSerial = 0 ; _multiDocument = false ; _hasIdCall = false ; _numberFieldIndexes = new int [ ] { - 1 , - 1 , - 1 } ; } public void setSourceLoader ( SourceLoader loader ) { _loader = loader ; } public void setTemplateInlining ( boolean templateInlining ) { _templateInlining = templateInlining ; } public void setPIParameters ( String media , String title , String charset ) { _parser . setPIParameters ( media , title , charset ) ; } public boolean compile ( URL url ) { try { final InputStream stream = url . openStream ( ) ; final InputSource input = new InputSource ( stream ) ; input . setSystemId ( url . toString ( ) ) ; return compile ( input , _className ) ; } catch ( IOException e ) { _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; return false ; } } public boolean compile ( URL url , String name ) { try { final InputStream stream = url . openStream ( ) ; final InputSource input = new InputSource ( stream ) ; input . setSystemId ( url . toString ( ) ) ; return compile ( input , name ) ; } catch ( IOException e ) { _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; return false ; } } public boolean compile ( InputStream stream , String name ) { final InputSource input = new InputSource ( stream ) ; input . setSystemId ( name ) ; return compile ( input , name ) ; } public boolean compile ( InputSource input , String name ) { try { reset ( ) ; String systemId = null ; if ( input != null ) { systemId = input . getSystemId ( ) ; } if ( _className == null ) { if ( name != null ) setClassName ( name ) ; else if ( ( systemId != null ) && ( ! systemId . equals ( "" ) ) ) setClassName ( Util . baseName ( systemId ) ) ; else setClassName ( "GregorSamsa" ) ; } SyntaxTreeNode element = null ; if ( _reader == null ) { element = _parser . parse ( input ) ; } else { element = _parser . parse ( _reader , input ) ; } if ( ( ! _parser . errorsFound ( ) ) && ( element != null ) ) { _stylesheet = _parser . makeStylesheet ( element ) ; _stylesheet . setSourceLoader ( _loader ) ; _stylesheet . setSystemId ( systemId ) ; _stylesheet . setParentStylesheet ( null ) ; _stylesheet . setTemplateInlining ( _templateInlining ) ; _parser . setCurrentStylesheet ( _stylesheet ) ; _parser . createAST ( _stylesheet ) ; } if ( ( ! _parser . errorsFound ( ) ) && ( _stylesheet != null ) ) { _stylesheet . setCallsNodeset ( _callsNodeset ) ; _stylesheet . setMultiDocument ( _multiDocument ) ; _stylesheet . setHasIdCall ( _hasIdCall ) ; synchronized ( getClass ( ) ) { _stylesheet . translate ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; } catch ( Error e ) { if ( _debug ) e . printStackTrace ( ) ; _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; } finally { _reader = null ; return ! _parser . errorsFound ( ) ; } } public boolean compile ( Vector stylesheets ) { final int count = stylesheets . size ( ) ; if ( count == 0 ) return true ; if ( count == 1 ) { final Object url = stylesheets . firstElement ( ) ; if ( url instanceof URL ) return compile ( ( URL ) url ) ; else return false ; } else { final Enumeration urls = stylesheets . elements ( ) ; while ( urls . hasMoreElements ( ) ) { _className = null ; final Object url = urls . nextElement ( ) ; if ( url instanceof URL ) { if ( ! compile ( ( URL ) url ) ) return false ; } } } return true ; } public byte [ ] [ ] getBytecodes ( ) { final int count = _classes . size ( ) ; final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) result [ i ] = ( byte [ ] ) _classes . elementAt ( i ) ; return result ; } public byte [ ] [ ] compile ( String name , InputSource input , int outputType ) { _outputType = outputType ; if ( compile ( input , name ) ) return getBytecodes ( ) ; else return null ; } public byte [ ] [ ] compile ( String name , InputSource input ) { return compile ( name , input , BYTEARRAY_OUTPUT ) ; } public void setXMLReader ( XMLReader reader ) { _reader = reader ; } public XMLReader getXMLReader ( ) { return _reader ; } public Vector getErrors ( ) { return _parser . getErrors ( ) ; } public Vector getWarnings ( ) { return _parser . getWarnings ( ) ; } public void printErrors ( ) { _parser . printErrors ( ) ; } public void printWarnings ( ) { _parser . printWarnings ( ) ; } protected void setMultiDocument ( boolean flag ) { _multiDocument = flag ; } public boolean isMultiDocument ( ) { return _multiDocument ; } protected void setCallsNodeset ( boolean flag ) { if ( flag ) setMultiDocument ( flag ) ; _callsNodeset = flag ; } public boolean callsNodeset ( ) { return _callsNodeset ; } protected void setHasIdCall ( boolean flag ) { _hasIdCall = flag ; } public boolean hasIdCall ( ) { return _hasIdCall ; } public void setClassName ( String className ) { final String base = Util . baseName ( className ) ; final String noext = Util . noExtName ( base ) ; String name = Util . toJavaName ( noext ) ; if ( _packageName == null ) _className = name ; else _className = _packageName + '.' + name ; } public String getClassName ( ) { return _className ; } private String classFileName ( final String className ) { return className . replace ( '.' , File . separatorChar ) + ".class" ; } private File getOutputFile ( String className ) { if ( _destDir != null ) return new File ( _destDir , classFileName ( className ) ) ; else return new File ( classFileName ( className ) ) ; } public boolean setDestDirectory ( String dstDirName ) { final File dir = new File ( dstDirName ) ; if ( dir . exists ( ) || dir . mkdirs ( ) ) { _destDir = dir ; return true ; } else { _destDir = null ; return false ; } } public void setPackageName ( String packageName ) { _packageName = packageName ; if ( _className != null ) setClassName ( _className ) ; } public void setJarFileName ( String jarFileName ) { final String JAR_EXT = ".jar" ; if ( jarFileName . endsWith ( JAR_EXT ) ) _jarFileName = jarFileName ; else _jarFileName = jarFileName + JAR_EXT ; _outputType = JAR_OUTPUT ; } public String getJarFileName ( ) { return _jarFileName ; } public void setStylesheet ( Stylesheet stylesheet ) { if ( _stylesheet == null ) _stylesheet = stylesheet ; } public Stylesheet getStylesheet ( ) { return _stylesheet ; } public int registerAttribute ( QName name ) { Integer code = ( Integer ) _attributes . get ( name . toString ( ) ) ; if ( code == null ) { code = new Integer ( _nextGType ++ ) ; _attributes . put ( name . toString ( ) , code ) ; final String uri = name . getNamespace ( ) ; final String local = "@" + name . getLocalPart ( ) ; if ( ( uri != null ) && ( ! uri . equals ( "" ) ) ) _namesIndex . addElement ( uri + ":" + local ) ; else _namesIndex . addElement ( local ) ; if ( name . getLocalPart ( ) . equals ( "*" ) ) { registerNamespace ( name . getNamespace ( ) ) ; } } return code . intValue ( ) ; } public int registerElement ( QName name ) { Integer code = ( Integer ) _elements . get ( name . toString ( ) ) ; if ( code == null ) { _elements . put ( name . toString ( ) , code = new Integer ( _nextGType ++ ) ) ; _namesIndex . addElement ( name . toString ( ) ) ; } if ( name . getLocalPart ( ) . equals ( "*" ) ) { registerNamespace ( name . getNamespace ( ) ) ; } return code . intValue ( ) ; } public int registerNamespace ( QName name ) { final SymbolTable stable = _parser . getSymbolTable ( ) ; final String uri = stable . lookupNamespace ( name . toString ( ) ) ; final int code = registerNamespace ( uri ) ; return code ; } public int registerNamespace ( String namespaceURI ) { Integer code = ( Integer ) _namespaces . get ( namespaceURI ) ; if ( code == null ) { code = new Integer ( _nextNSType ++ ) ; _namespaces . put ( namespaceURI , code ) ; _namespaceIndex . addElement ( namespaceURI ) ; } return code . intValue ( ) ; } public int nextModeSerial ( ) { return _modeSerial ++ ; } public int nextStylesheetSerial ( ) { return _stylesheetSerial ++ ; } public int nextStepPatternSerial ( ) { return _stepPatternSerial ++ ; } public int [ ] getNumberFieldIndexes ( ) { return _numberFieldIndexes ; } public int nextHelperClassSerial ( ) { return _helperClassSerial ++ ; } public int nextAttributeSetSerial ( ) { return _attributeSetSerial ++ ; } public Vector getNamesIndex ( ) { return _namesIndex ; } public Vector getNamespaceIndex ( ) { return _namespaceIndex ; } public String getHelperClassName ( ) { return getClassName ( ) + '$' + _helperClassSerial ++ ; } public void dumpClass ( JavaClass clazz ) { if ( _outputType == FILE_OUTPUT || _outputType == BYTEARRAY_AND_FILE_OUTPUT ) { File outFile = getOutputFile ( clazz . getClassName ( ) ) ; String parentDir = outFile . getParent ( ) ; if ( parentDir != null ) { File parentFile = new File ( parentDir ) ; if ( ! parentFile . exists ( ) ) parentFile . mkdirs ( ) ; } } try { switch ( _outputType ) { case FILE_OUTPUT : clazz . dump ( new BufferedOutputStream ( new FileOutputStream ( getOutputFile ( clazz . getClassName ( ) ) ) ) ) ; break ; case JAR_OUTPUT : _bcelClasses . addElement ( clazz ) ; break ; case BYTEARRAY_OUTPUT : case BYTEARRAY_AND_FILE_OUTPUT : case BYTEARRAY_AND_JAR_OUTPUT : case CLASSLOADER_OUTPUT : ByteArrayOutputStream out = new ByteArrayOutputStream ( 2048 ) ; clazz . dump ( out ) ; _classes . addElement ( out . toByteArray ( ) ) ; if ( _outputType == BYTEARRAY_AND_FILE_OUTPUT ) clazz . dump ( new BufferedOutputStream ( new FileOutputStream ( getOutputFile ( clazz . getClassName ( ) ) ) ) ) ; else if ( _outputType == BYTEARRAY_AND_JAR_OUTPUT ) _bcelClasses . addElement ( clazz ) ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private String entryName ( File f ) throws IOException { return f . getName ( ) . replace ( File . separatorChar , '/' ) ; } public void outputToJar ( ) throws IOException { final Manifest manifest = new Manifest ( ) ; final java . util . jar . Attributes atrs = manifest . getMainAttributes ( ) ; atrs . put ( java . util . jar . Attributes . Name . MANIFEST_VERSION , "1.2" ) ; final Map map = manifest . getEntries ( ) ; Enumeration classes = _bcelClasses . elements ( ) ; final String now = ( new Date ( ) ) . toString ( ) ; final java . util . jar . Attributes . Name dateAttr = new java . util . jar . Attributes . Name ( "Date" ) ; while ( classes . hasMoreElements ( ) ) { final JavaClass clazz = ( JavaClass ) classes . nextElement ( ) ; final String className = clazz . getClassName ( ) . replace ( '.' , '/' ) ; final java . util . jar . Attributes attr = new java . util . jar . Attributes ( ) ; attr . put ( dateAttr , now ) ; map . put ( className + ".class" , attr ) ; } final File jarFile = new File ( _destDir , _jarFileName ) ; final JarOutputStream jos = new JarOutputStream ( new FileOutputStream ( jarFile ) , manifest ) ; classes = _bcelClasses . elements ( ) ; while ( classes . hasMoreElements ( ) ) { final JavaClass clazz = ( JavaClass ) classes . nextElement ( ) ; final String className = clazz . getClassName ( ) . replace ( '.' , '/' ) ; jos . putNextEntry ( new JarEntry ( className + ".class" ) ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( 2048 ) ; clazz . dump ( out ) ; out . writeTo ( jos ) ; } jos . close ( ) ; } public void setDebug ( boolean debug ) { _debug = debug ; } public boolean debug ( ) { return _debug ; } } 	1
package org . apache . xml . utils . synthetic . reflection ; public class Constructor extends EntryPoint implements Member { private org . apache . xml . utils . synthetic . Class declaringclass = null ; private java . lang . reflect . Constructor realconstructor = null ; private org . apache . xml . utils . synthetic . Class [ ] parametertypes ; private String [ ] parameternames ; private org . apache . xml . utils . synthetic . Class [ ] exceptiontypes ; private int modifiers ; public Constructor ( org . apache . xml . utils . synthetic . Class declaringclass ) { super ( declaringclass ) ; } public Constructor ( java . lang . reflect . Constructor ctor , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( ctor , declaringclass ) ; } public Constructor ( java . lang . reflect . Constructor realconstructor ) { super ( realconstructor ) ; } public int hashCode ( ) { return getDeclaringClass ( ) . getName ( ) . hashCode ( ) ; } public Object newInstance ( Object initargs [ ] ) throws InstantiationException , IllegalAccessException , IllegalArgumentException , java . lang . reflect . InvocationTargetException { if ( realep != null ) return ( ( java . lang . reflect . Constructor ) realep ) . newInstance ( initargs ) ; else throw new InstantiationException ( "Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation" ) ; } } 	1
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; import org . apache . xalan . xsltc . dom . SAXImpl ; public class DOM2SAX implements XMLReader , Locator { private final static String EMPTYSTRING = "" ; private static final String XMLNS_PREFIX = "xmlns" ; private Node _dom = null ; private ContentHandler _sax = null ; private LexicalHandler _lex = null ; private SAXImpl _saxImpl = null ; private Hashtable _nsPrefixes = new Hashtable ( ) ; public DOM2SAX ( Node root ) { _dom = root ; } public ContentHandler getContentHandler ( ) { return _sax ; } public void setContentHandler ( ContentHandler handler ) throws NullPointerException { _sax = handler ; if ( handler instanceof LexicalHandler ) { _lex = ( LexicalHandler ) handler ; } if ( handler instanceof SAXImpl ) { _saxImpl = ( SAXImpl ) handler ; } } private boolean startPrefixMapping ( String prefix , String uri ) throws SAXException { boolean pushed = true ; Stack uriStack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( uriStack != null ) { if ( uriStack . isEmpty ( ) ) { _sax . startPrefixMapping ( prefix , uri ) ; uriStack . push ( uri ) ; } else { final String lastUri = ( String ) uriStack . peek ( ) ; if ( ! lastUri . equals ( uri ) ) { _sax . startPrefixMapping ( prefix , uri ) ; uriStack . push ( uri ) ; } else { pushed = false ; } } } else { _sax . startPrefixMapping ( prefix , uri ) ; _nsPrefixes . put ( prefix , uriStack = new Stack ( ) ) ; uriStack . push ( uri ) ; } return pushed ; } private void endPrefixMapping ( String prefix ) throws SAXException { final Stack uriStack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( uriStack != null ) { _sax . endPrefixMapping ( prefix ) ; uriStack . pop ( ) ; } } private static String getLocalName ( Node node ) { final String localName = node . getLocalName ( ) ; if ( localName == null ) { final String qname = node . getNodeName ( ) ; final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : qname ; } return localName ; } public void parse ( InputSource unused ) throws IOException , SAXException { parse ( _dom ) ; } public void parse ( ) throws IOException , SAXException { if ( _dom != null ) { boolean isIncomplete = ( _dom . getNodeType ( ) != org . w3c . dom . Node . DOCUMENT_NODE ) ; if ( isIncomplete ) { _sax . startDocument ( ) ; parse ( _dom ) ; _sax . endDocument ( ) ; } else { parse ( _dom ) ; } } } private void parse ( Node node ) throws IOException , SAXException { Node first = null ; if ( node == null ) return ; switch ( node . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . NOTATION_NODE : break ; case Node . CDATA_SECTION_NODE : final String cdata = node . getNodeValue ( ) ; if ( _lex != null ) { _lex . startCDATA ( ) ; _sax . characters ( cdata . toCharArray ( ) , 0 , cdata . length ( ) ) ; _lex . endCDATA ( ) ; } else { _sax . characters ( cdata . toCharArray ( ) , 0 , cdata . length ( ) ) ; } break ; case Node . COMMENT_NODE : if ( _lex != null ) { final String value = node . getNodeValue ( ) ; _lex . comment ( value . toCharArray ( ) , 0 , value . length ( ) ) ; } break ; case Node . DOCUMENT_NODE : _sax . setDocumentLocator ( this ) ; _sax . startDocument ( ) ; Node next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _sax . endDocument ( ) ; break ; case Node . ELEMENT_NODE : String prefix ; Vector pushedPrefixes = new Vector ( ) ; final AttributesImpl attrs = new AttributesImpl ( ) ; final NamedNodeMap map = node . getAttributes ( ) ; final int length = map . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNodeValue ( ) ; final int colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( colon + 1 ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uriAttr ) ) { pushedPrefixes . addElement ( prefix ) ; } } } for ( int i = 0 ; i < length ; i ++ ) { final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( ! qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNamespaceURI ( ) ; final String localNameAttr = getLocalName ( attr ) ; if ( uriAttr != null ) { final int colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( 0 , colon ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uriAttr ) ) { pushedPrefixes . addElement ( prefix ) ; } } attrs . addAttribute ( attr . getNamespaceURI ( ) , getLocalName ( attr ) , qnameAttr , "CDATA" , attr . getNodeValue ( ) ) ; } } final String qname = node . getNodeName ( ) ; final String uri = node . getNamespaceURI ( ) ; final String localName = getLocalName ( node ) ; if ( uri != null ) { final int colon = qname . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qname . substring ( 0 , colon ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uri ) ) { pushedPrefixes . addElement ( prefix ) ; } } if ( _saxImpl != null ) { _saxImpl . startElement ( uri , localName , qname , attrs , node ) ; } else { _sax . startElement ( uri , localName , qname , attrs ) ; } next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _sax . endElement ( uri , localName , qname ) ; final int nPushedPrefixes = pushedPrefixes . size ( ) ; for ( int i = 0 ; i < nPushedPrefixes ; i ++ ) { endPrefixMapping ( ( String ) pushedPrefixes . elementAt ( i ) ) ; } break ; case Node . PROCESSING_INSTRUCTION_NODE : _sax . processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . TEXT_NODE : final String data = node . getNodeValue ( ) ; _sax . characters ( data . toCharArray ( ) , 0 , data . length ( ) ) ; break ; } } public DTDHandler getDTDHandler ( ) { return null ; } public ErrorHandler getErrorHandler ( ) { return null ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return false ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public void parse ( String sysId ) throws IOException , SAXException { throw new IOException ( "This method is not yet implemented." ) ; } public void setDTDHandler ( DTDHandler handler ) throws NullPointerException { } public void setEntityResolver ( EntityResolver resolver ) throws NullPointerException { } public EntityResolver getEntityResolver ( ) { return null ; } public void setErrorHandler ( ErrorHandler handler ) throws NullPointerException { } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return null ; } public int getColumnNumber ( ) { return 0 ; } public int getLineNumber ( ) { return 0 ; } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { return null ; } private String getNodeTypeFromCode ( short code ) { String retval = null ; switch ( code ) { case Node . ATTRIBUTE_NODE : retval = "ATTRIBUTE_NODE" ; break ; case Node . CDATA_SECTION_NODE : retval = "CDATA_SECTION_NODE" ; break ; case Node . COMMENT_NODE : retval = "COMMENT_NODE" ; break ; case Node . DOCUMENT_FRAGMENT_NODE : retval = "DOCUMENT_FRAGMENT_NODE" ; break ; case Node . DOCUMENT_NODE : retval = "DOCUMENT_NODE" ; break ; case Node . DOCUMENT_TYPE_NODE : retval = "DOCUMENT_TYPE_NODE" ; break ; case Node . ELEMENT_NODE : retval = "ELEMENT_NODE" ; break ; case Node . ENTITY_NODE : retval = "ENTITY_NODE" ; break ; case Node . ENTITY_REFERENCE_NODE : retval = "ENTITY_REFERENCE_NODE" ; break ; case Node . NOTATION_NODE : retval = "NOTATION_NODE" ; break ; case Node . PROCESSING_INSTRUCTION_NODE : retval = "PROCESSING_INSTRUCTION_NODE" ; break ; case Node . TEXT_NODE : retval = "TEXT_NODE" ; break ; } return retval ; } } 	0
package org . apache . xml . dtm ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } public static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } public ClassLoader getContextClassLoader ( ) { return null ; } public String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } public FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } public InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } 	0
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public class SingletonIterator extends DTMAxisIteratorBase { private int _node ; private final boolean _isConstant ; public SingletonIterator ( ) { this ( Integer . MIN_VALUE , false ) ; } public SingletonIterator ( int node ) { this ( node , false ) ; } public SingletonIterator ( int node , boolean constant ) { _node = _startNode = node ; _isConstant = constant ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isConstant ) { _node = _startNode ; return resetPosition ( ) ; } else if ( _isRestartable ) { if ( _node <= 0 ) _node = _startNode = node ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { if ( _isConstant ) { _node = _startNode ; return resetPosition ( ) ; } else { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; } return this ; } public int next ( ) { final int result = _node ; _node = DTMAxisIterator . END ; return returnNode ( result ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } 	0
package org . apache . xpath . objects ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; public class XNumber extends XObject { double m_val ; public XNumber ( double d ) { super ( ) ; m_val = d ; } public XNumber ( Number num ) { super ( ) ; m_val = num . doubleValue ( ) ; m_obj = num ; } public int getType ( ) { return CLASS_NUMBER ; } public String getTypeString ( ) { return "#NUMBER" ; } public double num ( ) { return m_val ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_val ; } public boolean bool ( ) { return ( Double . isNaN ( m_val ) || ( m_val == 0.0 ) ) ? false : true ; } public String str ( ) { if ( Double . isNaN ( m_val ) ) { return "NaN" ; } else if ( Double . isInfinite ( m_val ) ) { if ( m_val > 0 ) return "Infinity" ; else return "-Infinity" ; } double num = m_val ; String s = Double . toString ( num ) ; int len = s . length ( ) ; if ( s . charAt ( len - 2 ) == '.' && s . charAt ( len - 1 ) == '0' ) { s = s . substring ( 0 , len - 2 ) ; if ( s . equals ( "-0" ) ) return "0" ; return s ; } int e = s . indexOf ( 'E' ) ; if ( e < 0 ) { if ( s . charAt ( len - 1 ) == '0' ) return s . substring ( 0 , len - 1 ) ; else return s ; } int exp = Integer . parseInt ( s . substring ( e + 1 ) ) ; String sign ; if ( s . charAt ( 0 ) == '-' ) { sign = "-" ; s = s . substring ( 1 ) ; -- e ; } else sign = "" ; int nDigits = e - 2 ; if ( exp >= nDigits ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) + zeros ( exp - nDigits ) ; while ( s . charAt ( e - 1 ) == '0' ) e -- ; if ( exp > 0 ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , 2 + exp ) + "." + s . substring ( 2 + exp , e ) ; return sign + "0." + zeros ( - 1 - exp ) + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) ; } static private String zeros ( int n ) { if ( n < 1 ) return "" ; char [ ] buf = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { buf [ i ] = '0' ; } return new String ( buf ) ; } public Object object ( ) { if ( null == m_obj ) m_obj = new Double ( m_val ) ; return m_obj ; } public boolean equals ( XObject obj2 ) { int t = obj2 . getType ( ) ; try { if ( t == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; else if ( t == XObject . CLASS_BOOLEAN ) return obj2 . bool ( ) == bool ( ) ; else return m_val == obj2 . num ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } public boolean isStableNumber ( ) { return true ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitNumberLiteral ( owner , this ) ; } } 	1
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . NodeSetDTM ; public class RTFIterator extends NodeSetDTM { public RTFIterator ( int root , DTMManager manager ) { super ( root , manager ) ; } } 	1
package org . apache . xalan . transformer ; import javax . xml . transform . Transformer ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public class XalanTransformState implements TransformState { Node m_node = null ; ElemTemplateElement m_currentElement = null ; ElemTemplate m_currentTemplate = null ; ElemTemplate m_matchedTemplate = null ; int m_currentNodeHandle = DTM . NULL ; Node m_currentNode = null ; int m_matchedNode = DTM . NULL ; DTMIterator m_contextNodeList = null ; boolean m_elemPending = false ; TransformerImpl m_transformer = null ; public void setCurrentNode ( Node n ) { m_node = n ; } public void resetState ( Transformer transformer ) { if ( ( transformer != null ) && ( transformer instanceof TransformerImpl ) ) { m_transformer = ( TransformerImpl ) transformer ; m_currentElement = m_transformer . getCurrentElement ( ) ; m_currentTemplate = m_transformer . getCurrentTemplate ( ) ; m_matchedTemplate = m_transformer . getMatchedTemplate ( ) ; int currentNodeHandle = m_transformer . getCurrentNode ( ) ; DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( currentNodeHandle ) ; m_currentNode = dtm . getNode ( currentNodeHandle ) ; m_matchedNode = m_transformer . getMatchedNode ( ) ; m_contextNodeList = m_transformer . getContextNodeList ( ) ; } } public ElemTemplateElement getCurrentElement ( ) { if ( m_elemPending ) return m_currentElement ; else return m_transformer . getCurrentElement ( ) ; } public Node getCurrentNode ( ) { if ( m_currentNode != null ) { return m_currentNode ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getCurrentNode ( ) ) ; return dtm . getNode ( m_transformer . getCurrentNode ( ) ) ; } } public ElemTemplate getCurrentTemplate ( ) { if ( m_elemPending ) return m_currentTemplate ; else return m_transformer . getCurrentTemplate ( ) ; } public ElemTemplate getMatchedTemplate ( ) { if ( m_elemPending ) return m_matchedTemplate ; else return m_transformer . getMatchedTemplate ( ) ; } public Node getMatchedNode ( ) { if ( m_elemPending ) { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_matchedNode ) ; return dtm . getNode ( m_matchedNode ) ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getMatchedNode ( ) ) ; return dtm . getNode ( m_transformer . getMatchedNode ( ) ) ; } } public NodeIterator getContextNodeList ( ) { if ( m_elemPending ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_contextNodeList ) ; } else { return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_transformer . getContextNodeList ( ) ) ; } } public Transformer getTransformer ( ) { return m_transformer ; } } 	0
package org . apache . xalan . processor ; public class StopParseException extends org . xml . sax . SAXException { StopParseException ( ) { super ( "Stylesheet PIs found, stop the parse" ) ; } } 	1
package org . apache . xml . utils . res ; public class XResources_he extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "he" } , { "help_language" , "he" } , { "language" , "he" } , { "alphabet" , new char [ ] { 0x05D0 , 0x05D1 , 0x05D2 , 0x05D3 , 0x05D4 , 0x05D5 , 0x05D6 , 0x05D7 , 0x05D8 , 0x05D9 , 0x05DA , 0x05DB , 0x05DC , 0x05DD , 0x05DE , 0x05DF , 0x05E0 , 0x05E1 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "RightToLeft" } , { "numbering" , "additive" } , { "numberGroups" , new int [ ] { 10 , 1 } } , { "digits" , new char [ ] { 0x05D0 , 0x05D1 , 0x05D2 , 0x05D3 , 0x05D4 , 0x05D5 , 0x05D6 , 0x05D7 , 0x05D8 } } , { "tens" , new char [ ] { 0x05D9 , 0x05DA , 0x05DB , 0x05DC , 0x05DD , 0x05DE , 0x05DF , 0x05E0 , 0x05E1 } } , { "tables" , new String [ ] { "tens" , "digits" } } } ; } 	1
package org . apache . xalan . processor ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . DefaultHandler ; public class StylesheetPIHandler extends DefaultHandler { String m_baseID ; String m_media ; String m_title ; String m_charset ; Vector m_stylesheets = new Vector ( ) ; URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } public StylesheetPIHandler ( String baseID , String media , String title , String charset ) { m_baseID = baseID ; m_media = media ; m_title = title ; m_charset = charset ; } public Source getAssociatedStylesheet ( ) { int sz = m_stylesheets . size ( ) ; if ( sz > 0 ) { Source source = ( Source ) m_stylesheets . elementAt ( sz - 1 ) ; return source ; } else return null ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( target . equals ( "xml-stylesheet" ) ) { String href = null ; String type = null ; String title = null ; String media = null ; String charset = null ; boolean alternate = false ; StringTokenizer tokenizer = new StringTokenizer ( data , " \t=\n" , true ) ; boolean lookedAhead = false ; Source source = null ; String token = "" ; while ( tokenizer . hasMoreTokens ( ) ) { if ( ! lookedAhead ) token = tokenizer . nextToken ( ) ; else lookedAhead = false ; if ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) continue ; String name = token ; if ( name . equals ( "type" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; type = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "href" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; href = token ; if ( tokenizer . hasMoreTokens ( ) ) { token = tokenizer . nextToken ( ) ; while ( token . equals ( "=" ) && tokenizer . hasMoreTokens ( ) ) { href = href + token + tokenizer . nextToken ( ) ; if ( tokenizer . hasMoreTokens ( ) ) { token = tokenizer . nextToken ( ) ; lookedAhead = true ; } else { break ; } } } href = href . substring ( 1 , href . length ( ) - 1 ) ; try { if ( m_uriResolver != null ) { source = m_uriResolver . resolve ( href , m_baseID ) ; } else { href = SystemIDResolver . getAbsoluteURI ( href , m_baseID ) ; source = new SAXSource ( new InputSource ( href ) ) ; } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else if ( name . equals ( "title" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; title = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "media" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; media = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "charset" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; charset = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "alternate" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; alternate = token . substring ( 1 , token . length ( ) - 1 ) . equals ( "yes" ) ; } } if ( ( null != type ) && ( type . equals ( "text/xsl" ) || type . equals ( "text/xml" ) || type . equals ( "application/xml+xslt" ) ) && ( null != href ) ) { if ( null != m_media ) { if ( null != media ) { if ( ! media . equals ( m_media ) ) return ; } else return ; } if ( null != m_charset ) { if ( null != charset ) { if ( ! charset . equals ( m_charset ) ) return ; } else return ; } if ( null != m_title ) { if ( null != title ) { if ( ! title . equals ( m_title ) ) return ; } else return ; } m_stylesheets . addElement ( source ) ; } } } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws org . xml . sax . SAXException { throw new StopParseException ( ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IF_ICMPNE ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . SIPUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MultiHashtable ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; final class CastExpr extends Expression { private final Expression _left ; static private MultiHashtable InternalTypeMap = new MultiHashtable ( ) ; static { InternalTypeMap . put ( Type . Boolean , Type . Boolean ) ; InternalTypeMap . put ( Type . Boolean , Type . Real ) ; InternalTypeMap . put ( Type . Boolean , Type . String ) ; InternalTypeMap . put ( Type . Boolean , Type . Reference ) ; InternalTypeMap . put ( Type . Boolean , Type . Object ) ; InternalTypeMap . put ( Type . Real , Type . Real ) ; InternalTypeMap . put ( Type . Real , Type . Int ) ; InternalTypeMap . put ( Type . Real , Type . Boolean ) ; InternalTypeMap . put ( Type . Real , Type . String ) ; InternalTypeMap . put ( Type . Real , Type . Reference ) ; InternalTypeMap . put ( Type . Real , Type . Object ) ; InternalTypeMap . put ( Type . Int , Type . Int ) ; InternalTypeMap . put ( Type . Int , Type . Real ) ; InternalTypeMap . put ( Type . Int , Type . Boolean ) ; InternalTypeMap . put ( Type . Int , Type . String ) ; InternalTypeMap . put ( Type . Int , Type . Reference ) ; InternalTypeMap . put ( Type . Int , Type . Object ) ; InternalTypeMap . put ( Type . String , Type . String ) ; InternalTypeMap . put ( Type . String , Type . Boolean ) ; InternalTypeMap . put ( Type . String , Type . Real ) ; InternalTypeMap . put ( Type . String , Type . Reference ) ; InternalTypeMap . put ( Type . String , Type . Object ) ; InternalTypeMap . put ( Type . NodeSet , Type . NodeSet ) ; InternalTypeMap . put ( Type . NodeSet , Type . Boolean ) ; InternalTypeMap . put ( Type . NodeSet , Type . Real ) ; InternalTypeMap . put ( Type . NodeSet , Type . String ) ; InternalTypeMap . put ( Type . NodeSet , Type . Node ) ; InternalTypeMap . put ( Type . NodeSet , Type . Reference ) ; InternalTypeMap . put ( Type . NodeSet , Type . Object ) ; InternalTypeMap . put ( Type . Node , Type . Node ) ; InternalTypeMap . put ( Type . Node , Type . Boolean ) ; InternalTypeMap . put ( Type . Node , Type . Real ) ; InternalTypeMap . put ( Type . Node , Type . String ) ; InternalTypeMap . put ( Type . Node , Type . NodeSet ) ; InternalTypeMap . put ( Type . Node , Type . Reference ) ; InternalTypeMap . put ( Type . Node , Type . Object ) ; InternalTypeMap . put ( Type . ResultTree , Type . ResultTree ) ; InternalTypeMap . put ( Type . ResultTree , Type . Boolean ) ; InternalTypeMap . put ( Type . ResultTree , Type . Real ) ; InternalTypeMap . put ( Type . ResultTree , Type . String ) ; InternalTypeMap . put ( Type . ResultTree , Type . NodeSet ) ; InternalTypeMap . put ( Type . ResultTree , Type . Reference ) ; InternalTypeMap . put ( Type . ResultTree , Type . Object ) ; InternalTypeMap . put ( Type . Reference , Type . Reference ) ; InternalTypeMap . put ( Type . Reference , Type . Boolean ) ; InternalTypeMap . put ( Type . Reference , Type . Int ) ; InternalTypeMap . put ( Type . Reference , Type . Real ) ; InternalTypeMap . put ( Type . Reference , Type . String ) ; InternalTypeMap . put ( Type . Reference , Type . Node ) ; InternalTypeMap . put ( Type . Reference , Type . NodeSet ) ; InternalTypeMap . put ( Type . Reference , Type . ResultTree ) ; InternalTypeMap . put ( Type . Reference , Type . Object ) ; InternalTypeMap . put ( Type . Object , Type . String ) ; InternalTypeMap . put ( Type . Void , Type . String ) ; } private boolean _typeTest = false ; public CastExpr ( Expression left , Type type ) throws TypeCheckError { _left = left ; _type = type ; if ( ( _left instanceof Step ) && ( _type == Type . Boolean ) ) { Step step = ( Step ) _left ; if ( ( step . getAxis ( ) == Axis . SELF ) && ( step . getNodeType ( ) != - 1 ) ) _typeTest = true ; } setParser ( left . getParser ( ) ) ; setParent ( left . getParent ( ) ) ; left . setParent ( this ) ; typeCheck ( left . getParser ( ) . getSymbolTable ( ) ) ; } public Expression getExpr ( ) { return _left ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) ) ; } public boolean hasLastCall ( ) { return ( _left . hasLastCall ( ) ) ; } public String toString ( ) { return "cast(" + _left + ", " + _type + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type tleft = _left . getType ( ) ; if ( tleft == null ) { tleft = _left . typeCheck ( stable ) ; } if ( tleft instanceof NodeType ) { tleft = Type . Node ; } else if ( tleft instanceof ResultTreeType ) { tleft = Type . ResultTree ; } if ( InternalTypeMap . maps ( tleft , _type ) != null ) { return _type ; } throw new TypeCheckError ( new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , tleft . toString ( ) , _type . toString ( ) ) ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { FlowList fl ; final Type ltype = _left . getType ( ) ; if ( _typeTest ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int idx = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; il . append ( new SIPUSH ( ( short ) ( ( Step ) _left ) . getNodeType ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( idx , 2 ) ) ; _falseList . add ( il . append ( new IF_ICMPNE ( null ) ) ) ; } else { _left . translate ( classGen , methodGen ) ; if ( _type != ltype ) { _left . startResetIterator ( classGen , methodGen ) ; if ( _type instanceof BooleanType ) { fl = ltype . translateToDesynthesized ( classGen , methodGen , _type ) ; if ( fl != null ) { _falseList . append ( fl ) ; } } else { ltype . translateTo ( classGen , methodGen , _type ) ; } } } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Type ltype = _left . getType ( ) ; _left . translate ( classGen , methodGen ) ; if ( _type . identicalTo ( ltype ) == false ) { _left . startResetIterator ( classGen , methodGen ) ; ltype . translateTo ( classGen , methodGen , _type ) ; } } } 	0
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Function not supported!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Cannot overwrite cause" } , { ER_NO_DEFAULT_IMPL , "No default implementation found " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) not currently supported" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset bigger than slot" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine not available, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager received co_exit() request" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() failed" } , { ER_COROUTINE_PARAM , "Coroutine parameter error ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: Parser doTerminate answers {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse may not be called while parsing" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: typed iterator for axis  {0} not implemented" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: iterator for axis {0} not implemented " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Iterator clone not supported" } , { ER_UNKNOWN_AXIS_TYPE , "Unknown axis traversal type: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axis traverser not supported: {0}" } , { ER_NO_DTMIDS_AVAIL , "No more DTM IDs are available" } , { ER_NOT_SUPPORTED , "Not supported: {0}" } , { ER_NODE_NON_NULL , "Node must be non-null for getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Could not resolve the node to a handle" } , { ER_STARTPARSE_WHILE_PARSING , "startParse may not be called while parsing" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse needs a non-null SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "could not initialize parser with" } , { ER_EXCEPTION_CREATING_POOL , "exception creating new instance for pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Path contains invalid escape sequence" } , { ER_SCHEME_REQUIRED , "Scheme is required!" } , { ER_NO_SCHEME_IN_URI , "No scheme found in URI: {0}" } , { ER_NO_SCHEME_INURI , "No scheme found in URI" } , { ER_PATH_INVALID_CHAR , "Path contains invalid character: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Cannot set scheme from null string" } , { ER_SCHEME_NOT_CONFORMANT , "The scheme is not conformant." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Host is not a well formed address" } , { ER_PORT_WHEN_HOST_NULL , "Port cannot be set when host is null" } , { ER_INVALID_PORT , "Invalid port number" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment can only be set for a generic URI" } , { ER_FRAG_WHEN_PATH_NULL , "Fragment cannot be set when path is null" } , { ER_FRAG_INVALID_CHAR , "Fragment contains invalid character" } , { ER_PARSER_IN_USE , "Parser is already in use" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Cannot change {0} {1} while parsing" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Self-causation not permitted" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo may not be specified if host is not specified" } , { ER_NO_PORT_IF_NO_HOST , "Port may not be specified if host is not specified" } , { ER_NO_QUERY_STRING_IN_PATH , "Query string cannot be specified in path and query string" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment cannot be specified in both the path and fragment" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Cannot initialize URI with empty parameters" } , { ER_METHOD_NOT_SUPPORTED , "Method not yet supported " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter not currently restartable" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader not before startParse request" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Axis traverser not supported: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler created with null PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "SystemId Unknown" } , { ER_LOCATION_UNKNOWN , "Location of error unknown" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() not supported in XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Attribute child does not have an owner document!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Attribute child does not have an owner document element!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Warning: can't output text before document element!  Ignoring..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Can't have more than one root on a DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' is null" } , { ER_ARG_LOCALNAME_INVALID , "Localname in QNAME should be a valid NCName" } , { ER_ARG_PREFIX_INVALID , "Prefix in QNAME should be a valid NCName" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "line" , "Line #" } , { "column" , "Column #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "The serializer class ''{0}'' does not implement org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "The resource [ {0} ] could not be found.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "The resource [ {0} ] could not load: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Buffer size <=0" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_OIERROR , "IO error" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored." } , { ER_NAMESPACE_PREFIX , "Namespace for prefix ''{0}'' has not been declared." } , { ER_STRAY_ATTRIBUTE , "Attribute ''{0}'' outside of element." } , { ER_STRAY_NAMESPACE , "Namespace declaration ''{0}''=''{1}'' outside of element." } , { ER_COULD_NOT_LOAD_RESOURCE , "Could not load ''{0}'' (check CLASSPATH), now using just the defaults" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Could not load the propery file ''{0}'' for output method ''{1}'' (check CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1
package org . apache . xml . utils . res ; public class XResources_ja_JP_I extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x30a4 , 0x30ed , 0x30cf , 0x30cb , 0x30db , 0x30d8 , 0x30c8 , 0x30c1 , 0x30ea , 0x30cc , 0x30eb , 0x30f2 , 0x30ef , 0x30ab , 0x30e8 , 0x30bf , 0x30ec , 0x30bd , 0x30c4 , 0x30cd , 0x30ca , 0x30e9 , 0x30e0 , 0x30a6 , 0x30f0 , 0x30ce , 0x30aa , 0x30af , 0x30e4 , 0x30de , 0x30b1 , 0x30d5 , 0x30b3 , 0x30a8 , 0x30c6 , 0x30a2 , 0x30b5 , 0x30ad , 0x30e6 , 0x30e1 , 0x30df , 0x30b7 , 0x30f1 , 0x30d2 , 0x30e2 , 0x30bb , 0x30b9 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncContains extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String s1 = m_arg0 . execute ( xctxt ) . str ( ) ; String s2 = m_arg1 . execute ( xctxt ) . str ( ) ; if ( s1 . length ( ) == 0 && s2 . length ( ) == 0 ) return XBoolean . S_TRUE ; int index = s1 . indexOf ( s2 ) ; return ( index > - 1 ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	1
package org . apache . xalan . xsltc . compiler . util ; import java . util . Vector ; public final class MethodType extends Type { private final Type _resultType ; private final Vector _argsType ; public MethodType ( Type resultType ) { _argsType = null ; _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 ) { if ( arg1 != Type . Void ) { _argsType = new Vector ( ) ; _argsType . addElement ( arg1 ) ; } else { _argsType = null ; } _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 , Type arg2 ) { _argsType = new Vector ( 2 ) ; _argsType . addElement ( arg1 ) ; _argsType . addElement ( arg2 ) ; _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 , Type arg2 , Type arg3 ) { _argsType = new Vector ( 3 ) ; _argsType . addElement ( arg1 ) ; _argsType . addElement ( arg2 ) ; _argsType . addElement ( arg3 ) ; _resultType = resultType ; } public MethodType ( Type resultType , Vector argsType ) { _resultType = resultType ; _argsType = argsType . size ( ) > 0 ? argsType : null ; } public String toString ( ) { StringBuffer result = new StringBuffer ( "method{" ) ; if ( _argsType != null ) { final int count = _argsType . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { result . append ( _argsType . elementAt ( i ) ) ; if ( i != ( count - 1 ) ) result . append ( ',' ) ; } } else { result . append ( "void" ) ; } result . append ( '}' ) ; return result . toString ( ) ; } public String toSignature ( ) { return toSignature ( "" ) ; } public String toSignature ( String lastArgSig ) { final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; if ( _argsType != null ) { final int n = _argsType . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { buffer . append ( ( ( Type ) _argsType . elementAt ( i ) ) . toSignature ( ) ) ; } } return buffer . append ( lastArgSig ) . append ( ')' ) . append ( _resultType . toSignature ( ) ) . toString ( ) ; } public org . apache . bcel . generic . Type toJCType ( ) { return null ; } public boolean identicalTo ( Type other ) { boolean result = false ; if ( other instanceof MethodType ) { final MethodType temp = ( MethodType ) other ; if ( _resultType . identicalTo ( temp . _resultType ) ) { final int len = argsCount ( ) ; result = len == temp . argsCount ( ) ; for ( int i = 0 ; i < len && result ; i ++ ) { final Type arg1 = ( Type ) _argsType . elementAt ( i ) ; final Type arg2 = ( Type ) temp . _argsType . elementAt ( i ) ; result = arg1 . identicalTo ( arg2 ) ; } } } return result ; } public int distanceTo ( Type other ) { int result = Integer . MAX_VALUE ; if ( other instanceof MethodType ) { final MethodType mtype = ( MethodType ) other ; if ( _argsType != null ) { final int len = _argsType . size ( ) ; if ( len == mtype . _argsType . size ( ) ) { result = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Type arg1 = ( Type ) _argsType . elementAt ( i ) ; Type arg2 = ( Type ) mtype . _argsType . elementAt ( i ) ; final int temp = arg1 . distanceTo ( arg2 ) ; if ( temp == Integer . MAX_VALUE ) { result = temp ; break ; } else { result += arg1 . distanceTo ( arg2 ) ; } } } } else if ( mtype . _argsType == null ) { result = 0 ; } } return result ; } public Type resultType ( ) { return _resultType ; } public Vector argsType ( ) { return _argsType ; } public int argsCount ( ) { return _argsType == null ? 0 : _argsType . size ( ) ; } } 	0
package org . apache . xml . utils ; public class FastStringBuffer { static final int DEBUG_FORCE_INIT_BITS = 0 ; static boolean DEBUG_FORCE_FIXED_CHUNKSIZE = true ; public static final int SUPPRESS_LEADING_WS = 0x01 ; public static final int SUPPRESS_TRAILING_WS = 0x02 ; public static final int SUPPRESS_BOTH = SUPPRESS_LEADING_WS | SUPPRESS_TRAILING_WS ; private static final int CARRY_WS = 0x04 ; int m_chunkBits = 15 ; int m_maxChunkBits = 15 ; int m_rebundleBits = 2 ; int m_chunkSize ; int m_chunkMask ; char [ ] [ ] m_array ; int m_lastChunk = 0 ; int m_firstFree = 0 ; FastStringBuffer m_innerFSB = null ; public FastStringBuffer ( int initChunkBits , int maxChunkBits , int rebundleBits ) { if ( DEBUG_FORCE_INIT_BITS != 0 ) initChunkBits = DEBUG_FORCE_INIT_BITS ; if ( DEBUG_FORCE_FIXED_CHUNKSIZE ) maxChunkBits = initChunkBits ; m_array = new char [ 16 ] [ ] ; if ( initChunkBits > maxChunkBits ) initChunkBits = maxChunkBits ; m_chunkBits = initChunkBits ; m_maxChunkBits = maxChunkBits ; m_rebundleBits = rebundleBits ; m_chunkSize = 1 << ( initChunkBits ) ; m_chunkMask = m_chunkSize - 1 ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public FastStringBuffer ( int initChunkBits , int maxChunkBits ) { this ( initChunkBits , maxChunkBits , 2 ) ; } public FastStringBuffer ( int initChunkBits ) { this ( initChunkBits , 15 , 2 ) ; } public FastStringBuffer ( ) { this ( 10 , 15 , 2 ) ; } public final int size ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final int length ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final void reset ( ) { m_lastChunk = 0 ; m_firstFree = 0 ; FastStringBuffer innermost = this ; while ( innermost . m_innerFSB != null ) { innermost = innermost . m_innerFSB ; } m_chunkBits = innermost . m_chunkBits ; m_chunkSize = innermost . m_chunkSize ; m_chunkMask = innermost . m_chunkMask ; m_innerFSB = null ; m_array = new char [ 16 ] [ 0 ] ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public final void setLength ( int l ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , this ) ; } else { m_firstFree = l & m_chunkMask ; if ( m_firstFree == 0 && m_lastChunk > 0 ) { -- m_lastChunk ; m_firstFree = m_chunkSize ; } } } private final void setLength ( int l , FastStringBuffer rootFSB ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , rootFSB ) ; } else { rootFSB . m_chunkBits = m_chunkBits ; rootFSB . m_maxChunkBits = m_maxChunkBits ; rootFSB . m_rebundleBits = m_rebundleBits ; rootFSB . m_chunkSize = m_chunkSize ; rootFSB . m_chunkMask = m_chunkMask ; rootFSB . m_array = m_array ; rootFSB . m_innerFSB = m_innerFSB ; rootFSB . m_lastChunk = m_lastChunk ; rootFSB . m_firstFree = l & m_chunkMask ; } } public final String toString ( ) { int length = ( m_lastChunk << m_chunkBits ) + m_firstFree ; return getString ( new StringBuffer ( length ) , 0 , 0 , length ) . toString ( ) ; } public final void append ( char value ) { char [ ] chunk ; boolean lastchunk = ( m_lastChunk + 1 == m_array . length ) ; if ( m_firstFree < m_chunkSize ) chunk = m_array [ m_lastChunk ] ; else { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } m_firstFree = 0 ; } chunk [ m_firstFree ++ ] = value ; } public final void append ( String value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( StringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( char [ ] chars , int start , int length ) { int strlen = length ; if ( 0 == strlen ) return ; int copyfrom = start ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; System . arraycopy ( chars , copyfrom , m_array [ m_lastChunk ] , m_firstFree , available ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( FastStringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; int sourcechunk = ( copyfrom + value . m_chunkSize - 1 ) > > > value . m_chunkBits ; int sourcecolumn = copyfrom & value . m_chunkMask ; int runlength = value . m_chunkSize - sourcecolumn ; if ( runlength > available ) runlength = available ; System . arraycopy ( value . m_array [ sourcechunk ] , sourcecolumn , m_array [ m_lastChunk ] , m_firstFree , runlength ) ; if ( runlength != available ) System . arraycopy ( value . m_array [ sourcechunk + 1 ] , 0 , m_array [ m_lastChunk ] , m_firstFree + runlength , available - runlength ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public boolean isWhitespace ( int start , int length ) { int sourcechunk = start > > > m_chunkBits ; int sourcecolumn = start & m_chunkMask ; int available = m_chunkSize - sourcecolumn ; boolean chunkOK ; while ( length > 0 ) { int runlength = ( length <= available ) ? length : available ; if ( sourcechunk == 0 && m_innerFSB != null ) chunkOK = m_innerFSB . isWhitespace ( sourcecolumn , runlength ) ; else chunkOK = org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( m_array [ sourcechunk ] , sourcecolumn , runlength ) ; if ( ! chunkOK ) return false ; length -= runlength ; ++ sourcechunk ; sourcecolumn = 0 ; available = m_chunkSize ; } return true ; } public String getString ( int start , int length ) { int startColumn = start & m_chunkMask ; int startChunk = start > > > m_chunkBits ; if ( startColumn + length < m_chunkMask && m_innerFSB == null ) { return getOneChunkString ( startChunk , startColumn , length ) ; } return getString ( new StringBuffer ( length ) , startChunk , startColumn , length ) . toString ( ) ; } protected String getOneChunkString ( int startChunk , int startColumn , int length ) { return new String ( m_array [ startChunk ] , startColumn , length ) ; } StringBuffer getString ( StringBuffer sb , int start , int length ) { return getString ( sb , start > > > m_chunkBits , start & m_chunkMask , length ) ; } StringBuffer getString ( StringBuffer sb , int startChunk , int startColumn , int length ) { int stop = ( startChunk << m_chunkBits ) + startColumn + length ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , m_chunkSize - startColumn ) ; else sb . append ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) sb . append ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; return sb ; } public char charAt ( int pos ) { int startChunk = pos > > > m_chunkBits ; if ( startChunk == 0 && m_innerFSB != null ) return m_innerFSB . charAt ( pos & m_chunkMask ) ; else return m_array [ startChunk ] [ pos & m_chunkMask ] ; } public void sendSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; if ( startColumn + length < m_chunkMask && m_innerFSB == null ) { ch . characters ( m_array [ startChunk ] , startColumn , length ) ; return ; } int stop = start + length ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else ch . characters ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { ch . characters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; } } public int sendNormalizedSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int stateForNextChunk = SUPPRESS_LEADING_WS ; int stop = start + length ; int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ i ] , startColumn , m_chunkSize - startColumn , ch , stateForNextChunk ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn , ch , stateForNextChunk | SUPPRESS_TRAILING_WS ) ; } return stateForNextChunk ; } static final char [ ] SINGLE_SPACE = { ' ' } ; static int sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler , int edgeTreatmentFlags ) throws org . xml . sax . SAXException { boolean processingLeadingWhitespace = ( ( edgeTreatmentFlags & SUPPRESS_LEADING_WS ) != 0 ) ; boolean seenWhitespace = ( ( edgeTreatmentFlags & CARRY_WS ) != 0 ) ; boolean suppressTrailingWhitespace = ( ( edgeTreatmentFlags & SUPPRESS_TRAILING_WS ) != 0 ) ; int currPos = start ; int limit = start + length ; if ( processingLeadingWhitespace ) { for ( ; currPos < limit && XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( currPos == limit ) { return edgeTreatmentFlags ; } } while ( currPos < limit ) { int startNonWhitespace = currPos ; for ( ; currPos < limit && ! XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( startNonWhitespace != currPos ) { if ( seenWhitespace ) { handler . characters ( SINGLE_SPACE , 0 , 1 ) ; seenWhitespace = false ; } handler . characters ( ch , startNonWhitespace , currPos - startNonWhitespace ) ; } int startWhitespace = currPos ; for ( ; currPos < limit && XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( startWhitespace != currPos ) { seenWhitespace = true ; } } return ( seenWhitespace ? CARRY_WS : 0 ) | ( edgeTreatmentFlags & SUPPRESS_TRAILING_WS ) ; } public static void sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler ) throws org . xml . sax . SAXException { sendNormalizedSAXcharacters ( ch , start , length , handler , SUPPRESS_BOTH ) ; } public void sendSAXComment ( org . xml . sax . ext . LexicalHandler ch , int start , int length ) throws org . xml . sax . SAXException { String comment = getString ( start , length ) ; ch . comment ( comment . toCharArray ( ) , 0 , length ) ; } private void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { } private FastStringBuffer ( FastStringBuffer source ) { m_chunkBits = source . m_chunkBits ; m_maxChunkBits = source . m_maxChunkBits ; m_rebundleBits = source . m_rebundleBits ; m_chunkSize = source . m_chunkSize ; m_chunkMask = source . m_chunkMask ; m_array = source . m_array ; m_innerFSB = source . m_innerFSB ; m_lastChunk = source . m_lastChunk - 1 ; m_firstFree = source . m_chunkSize ; source . m_array = new char [ 16 ] [ ] ; source . m_innerFSB = this ; source . m_lastChunk = 1 ; source . m_firstFree = 0 ; source . m_chunkBits += m_rebundleBits ; source . m_chunkSize = 1 << ( source . m_chunkBits ) ; source . m_chunkMask = source . m_chunkSize - 1 ; } } 	0
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xml . serializer . EmptySerializer ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringDefault ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import javax . xml . transform . SourceLocator ; public class SimpleResultTreeImpl extends EmptySerializer implements DOM , DTM { public final class SimpleIterator extends DTMAxisIteratorBase { static final int DIRECTION_UP = 0 ; static final int DIRECTION_DOWN = 1 ; static final int NO_TYPE = - 1 ; int _direction = DIRECTION_DOWN ; int _type = NO_TYPE ; int _currentNode ; public SimpleIterator ( ) { } public SimpleIterator ( int direction ) { _direction = direction ; } public SimpleIterator ( int direction , int type ) { _direction = direction ; _type = type ; } public int next ( ) { if ( _direction == DIRECTION_DOWN ) { while ( _currentNode < NUMBER_OF_NODES ) { if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return returnNode ( getNodeHandle ( _currentNode ++ ) ) ; else _currentNode ++ ; } else return returnNode ( getNodeHandle ( _currentNode ++ ) ) ; } return END ; } else { while ( _currentNode >= 0 ) { if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return returnNode ( getNodeHandle ( _currentNode -- ) ) ; else _currentNode -- ; } else return returnNode ( getNodeHandle ( _currentNode -- ) ) ; } return END ; } } public DTMAxisIterator setStartNode ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; _startNode = nodeID ; if ( ! _includeSelf && nodeID != DTM . NULL ) { if ( _direction == DIRECTION_DOWN ) nodeID ++ ; else if ( _direction == DIRECTION_UP ) nodeID -- ; } _currentNode = nodeID ; return this ; } public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } } public final class SingletonIterator extends DTMAxisIteratorBase { static final int NO_TYPE = - 1 ; int _type = NO_TYPE ; int _currentNode ; public SingletonIterator ( ) { } public SingletonIterator ( int type ) { _type = type ; } public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } public DTMAxisIterator setStartNode ( int nodeHandle ) { _currentNode = _startNode = getNodeIdent ( nodeHandle ) ; return this ; } public int next ( ) { if ( _currentNode == END ) return END ; _currentNode = END ; if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return getNodeHandle ( _currentNode ) ; } else return getNodeHandle ( _currentNode ) ; return END ; } } private final static DTMAxisIterator EMPTY_ITERATOR = new DTMAxisIteratorBase ( ) { public DTMAxisIterator reset ( ) { return this ; } public DTMAxisIterator setStartNode ( int node ) { return this ; } public int next ( ) { return DTM . NULL ; } public void setMark ( ) { } public void gotoMark ( ) { } public int getLast ( ) { return 0 ; } public int getPosition ( ) { return 0 ; } public DTMAxisIterator cloneIterator ( ) { return this ; } public void setRestartable ( boolean isRestartable ) { } } ; public static final int RTF_ROOT = 0 ; public static final int RTF_TEXT = 1 ; public static final int NUMBER_OF_NODES = 2 ; private static int _documentURIIndex = 0 ; private static final String EMPTY_STR = "" ; private String _text ; protected String [ ] _textArray ; protected XSLTCDTMManager _dtmManager ; protected int _size = 0 ; private int _documentID ; private BitArray _dontEscape = null ; private boolean _escaping = true ; public SimpleResultTreeImpl ( XSLTCDTMManager dtmManager , int documentID ) { _dtmManager = dtmManager ; _documentID = documentID ; _textArray = new String [ 4 ] ; } public DTMManagerDefault getDTMManager ( ) { return _dtmManager ; } public int getDocument ( ) { return _documentID ; } public String getStringValue ( ) { return _text ; } public DTMAxisIterator getIterator ( ) { return new SingletonIterator ( getDocument ( ) ) ; } public DTMAxisIterator getChildren ( final int node ) { return new SimpleIterator ( ) . setStartNode ( node ) ; } public DTMAxisIterator getTypedChildren ( final int type ) { return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { switch ( axis ) { case Axis . CHILD : case Axis . DESCENDANT : return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN ) ; case Axis . PARENT : case Axis . ANCESTOR : return new SimpleIterator ( SimpleIterator . DIRECTION_UP ) ; case Axis . ANCESTORORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_UP ) ) . includeSelf ( ) ; case Axis . DESCENDANTORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_DOWN ) ) . includeSelf ( ) ; case Axis . SELF : return new SingletonIterator ( ) ; default : return EMPTY_ITERATOR ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { switch ( axis ) { case Axis . CHILD : case Axis . DESCENDANT : return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ; case Axis . PARENT : case Axis . ANCESTOR : return new SimpleIterator ( SimpleIterator . DIRECTION_UP , type ) ; case Axis . ANCESTORORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_UP , type ) ) . includeSelf ( ) ; case Axis . DESCENDANTORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ) . includeSelf ( ) ; case Axis . SELF : return new SingletonIterator ( type ) ; default : return EMPTY_ITERATOR ; } } public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) { return null ; } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { return null ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iter , int returnType , String value , boolean op ) { return null ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return source ; } public String getNodeName ( final int node ) { if ( getNodeIdent ( node ) == RTF_TEXT ) return "#text" ; else return EMPTY_STR ; } public String getNodeNameX ( final int node ) { return EMPTY_STR ; } public String getNamespaceName ( final int node ) { return EMPTY_STR ; } public int getExpandedTypeID ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return DTM . TEXT_NODE ; else if ( nodeID == RTF_ROOT ) return DTM . ROOT_NODE ; else return DTM . NULL ; } public int getNamespaceType ( final int node ) { return 0 ; } public int getParent ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; return ( nodeID == RTF_TEXT ) ? getNodeHandle ( RTF_ROOT ) : DTM . NULL ; } public int getAttributeNode ( final int gType , final int element ) { return DTM . NULL ; } public String getStringValueX ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_ROOT || nodeID == RTF_TEXT ) return _text ; else return EMPTY_STR ; } public void copy ( final int node , SerializationHandler handler ) throws TransletException { characters ( node , handler ) ; } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DTM . NULL ) { copy ( node , handler ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { characters ( node , handler ) ; return null ; } public boolean lessThan ( final int node1 , final int node2 ) { if ( node1 == DTM . NULL ) { return false ; } else if ( node2 == DTM . NULL ) { return true ; } else return ( node1 < node2 ) ; } public void characters ( final int node , SerializationHandler handler ) throws TransletException { int nodeID = getNodeIdent ( node ) ; if ( nodeID == RTF_ROOT || nodeID == RTF_TEXT ) { boolean escapeBit = false ; boolean oldEscapeSetting = false ; try { for ( int i = 0 ; i < _size ; i ++ ) { if ( _dontEscape != null ) { escapeBit = _dontEscape . getBit ( i ) ; if ( escapeBit ) { oldEscapeSetting = handler . setEscaping ( false ) ; } } handler . characters ( _textArray [ i ] ) ; if ( escapeBit ) { handler . setEscaping ( oldEscapeSetting ) ; } } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } } public Node makeNode ( int index ) { return null ; } public Node makeNode ( DTMAxisIterator iter ) { return null ; } public NodeList makeNodeList ( int index ) { return null ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return null ; } public String getLanguage ( int node ) { return null ; } public int getSize ( ) { return 2 ; } public String getDocumentURI ( int node ) { return "simple_rtf" + _documentURIIndex ++ ; } public void setFilter ( StripFilter filter ) { } public void setupMapping ( String [ ] names , String [ ] namespaces ) { } public boolean isElement ( final int node ) { return false ; } public boolean isAttribute ( final int node ) { return false ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return null ; } public int getNodeIdent ( final int nodehandle ) { return ( nodehandle != DTM . NULL ) ? ( nodehandle - _documentID ) : DTM . NULL ; } public int getNodeHandle ( final int nodeId ) { return ( nodeId != DTM . NULL ) ? ( nodeId + _documentID ) : DTM . NULL ; } public DOM getResultTreeFrag ( int initialSize , int rtfType ) { return null ; } public SerializationHandler getOutputDomBuilder ( ) { return this ; } public int getNSType ( int node ) { return 0 ; } public String getUnparsedEntityURI ( String name ) { return null ; } public Hashtable getElementsWithIDs ( ) { return null ; } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { if ( _size == 1 ) _text = _textArray [ 0 ] ; else { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < _size ; i ++ ) { buffer . append ( _textArray [ i ] ) ; } _text = buffer . toString ( ) ; } } public void characters ( String str ) throws SAXException { if ( _size >= _textArray . length ) { String [ ] newTextArray = new String [ _textArray . length * 2 ] ; System . arraycopy ( _textArray , 0 , newTextArray , 0 , _textArray . length ) ; _textArray = newTextArray ; } if ( ! _escaping ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( 8 ) ; } if ( _size >= _dontEscape . size ( ) ) _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; _dontEscape . setBit ( _size ) ; } _textArray [ _size ++ ] = str ; } public void characters ( char [ ] ch , int offset , int length ) throws SAXException { if ( _size >= _textArray . length ) { String [ ] newTextArray = new String [ _textArray . length * 2 ] ; System . arraycopy ( _textArray , 0 , newTextArray , 0 , _textArray . length ) ; _textArray = newTextArray ; } if ( ! _escaping ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( 8 ) ; } if ( _size >= _dontEscape . size ( ) ) _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; _dontEscape . setBit ( _size ) ; } _textArray [ _size ++ ] = new String ( ch , offset , length ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { final boolean temp = _escaping ; _escaping = escape ; return temp ; } public void setFeature ( String featureId , boolean state ) { } public void setProperty ( String property , Object value ) { } public DTMAxisTraverser getAxisTraverser ( final int axis ) { return null ; } public boolean hasChildNodes ( int nodeHandle ) { return ( getNodeIdent ( nodeHandle ) == RTF_ROOT ) ; } public int getFirstChild ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_ROOT ) return getNodeHandle ( RTF_TEXT ) ; else return DTM . NULL ; } public int getLastChild ( int nodeHandle ) { return getFirstChild ( nodeHandle ) ; } public int getAttributeNode ( int elementHandle , String namespaceURI , String name ) { return DTM . NULL ; } public int getFirstAttribute ( int nodeHandle ) { return DTM . NULL ; } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { return DTM . NULL ; } public int getNextSibling ( int nodeHandle ) { return DTM . NULL ; } public int getPreviousSibling ( int nodeHandle ) { return DTM . NULL ; } public int getNextAttribute ( int nodeHandle ) { return DTM . NULL ; } public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) { return DTM . NULL ; } public int getOwnerDocument ( int nodeHandle ) { return getDocument ( ) ; } public int getDocumentRoot ( int nodeHandle ) { return getDocument ( ) ; } public XMLString getStringValue ( int nodeHandle ) { return new XMLStringDefault ( getStringValueX ( nodeHandle ) ) ; } public int getStringValueChunkCount ( int nodeHandle ) { return 0 ; } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { return null ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { return DTM . NULL ; } public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) { return EMPTY_STR ; } public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) { return EMPTY_STR ; } public String getLocalName ( int nodeHandle ) { return EMPTY_STR ; } public String getPrefix ( int nodeHandle ) { return null ; } public String getNamespaceURI ( int nodeHandle ) { return EMPTY_STR ; } public String getNodeValue ( int nodeHandle ) { return ( getNodeIdent ( nodeHandle ) == RTF_TEXT ) ? _text : null ; } public short getNodeType ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return DTM . TEXT_NODE ; else if ( nodeID == RTF_ROOT ) return DTM . ROOT_NODE ; else return DTM . NULL ; } public short getLevel ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return 2 ; else if ( nodeID == RTF_ROOT ) return 1 ; else return DTM . NULL ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getDocumentBaseURI ( ) { return EMPTY_STR ; } public void setDocumentBaseURI ( String baseURI ) { } public String getDocumentSystemIdentifier ( int nodeHandle ) { return null ; } public String getDocumentEncoding ( int nodeHandle ) { return null ; } public String getDocumentStandalone ( int nodeHandle ) { return null ; } public String getDocumentVersion ( int documentHandle ) { return null ; } public boolean getDocumentAllDeclarationsProcessed ( ) { return false ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { return null ; } public int getElementById ( String elementId ) { return DTM . NULL ; } public boolean supportsPreStripping ( ) { return false ; } public boolean isNodeAfter ( int firstNodeHandle , int secondNodeHandle ) { return lessThan ( firstNodeHandle , secondNodeHandle ) ; } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { return false ; } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { return false ; } public boolean isAttributeSpecified ( int attributeHandle ) { return false ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { } public org . w3c . dom . Node getNode ( int nodeHandle ) { return makeNode ( nodeHandle ) ; } public boolean needsTwoThreads ( ) { return false ; } public org . xml . sax . ContentHandler getContentHandler ( ) { return null ; } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { return null ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { } public void appendTextChild ( String str ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } public void documentRegistration ( ) { } public void documentRelease ( ) { } } 	0
package org . apache . xml . serializer ; import java . util . Vector ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . ext . LexicalHandler ; abstract public class ToSAXHandler extends SerializerBase { public ToSAXHandler ( ) { } public ToSAXHandler ( ContentHandler hdlr , LexicalHandler lex , String encoding ) { setContentHandler ( hdlr ) ; setLexHandler ( lex ) ; setEncoding ( encoding ) ; } public ToSAXHandler ( ContentHandler handler , String encoding ) { setContentHandler ( handler ) ; setEncoding ( encoding ) ; } protected ContentHandler m_saxHandler ; protected LexicalHandler m_lexHandler ; protected TransformStateSetter m_state = null ; protected void startDocumentInternal ( ) throws SAXException { if ( m_needToCallStartDocument ) { super . startDocumentInternal ( ) ; m_saxHandler . startDocument ( ) ; m_needToCallStartDocument = false ; } } public void startDTD ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void characters ( String characters ) throws SAXException { characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public void comment ( String comment ) throws SAXException { if ( m_startTagOpen ) { closeStartTag ( ) ; } else if ( m_cdataTagOpen ) { closeCDATA ( ) ; } if ( m_lexHandler != null ) { m_lexHandler . comment ( comment . toCharArray ( ) , 0 , comment . length ( ) ) ; super . fireCommentEvent ( comment . toCharArray ( ) , 0 , comment . length ( ) ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { } protected void closeStartTag ( ) throws SAXException { } protected void closeCDATA ( ) throws SAXException { } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } super . fireStartElem ( arg2 ) ; } public void setLexHandler ( LexicalHandler _lexHandler ) { this . m_lexHandler = _lexHandler ; } public void setContentHandler ( ContentHandler _saxHandler ) { this . m_saxHandler = _saxHandler ; if ( m_lexHandler == null && _saxHandler instanceof LexicalHandler ) { m_lexHandler = ( LexicalHandler ) _saxHandler ; } } public void setCdataSectionElements ( Vector URI_and_localNames ) { } public void flushPending ( ) { try { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = false ; } } catch ( SAXException e ) { } } public void setTransformState ( TransformStateSetter ts ) { this . m_state = ts ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } super . fireStartElem ( qName ) ; } public void startElement ( String qName ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } super . fireStartElem ( qName ) ; } public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { if ( m_state != null ) { m_state . setCurrentNode ( node ) ; } super . characters ( node ) ; } public void fatalError ( SAXParseException exc ) throws SAXException { super . fatalError ( exc ) ; m_needToCallStartDocument = false ; if ( m_saxHandler instanceof ErrorHandler ) { ( ( ErrorHandler ) m_saxHandler ) . fatalError ( exc ) ; } } public void error ( SAXParseException exc ) throws SAXException { super . error ( exc ) ; if ( m_saxHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_saxHandler ) . error ( exc ) ; } public void warning ( SAXParseException exc ) throws SAXException { super . warning ( exc ) ; if ( m_saxHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_saxHandler ) . warning ( exc ) ; } } 	1
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xml . utils . MutableAttrListImpl ; public abstract class QueuedEvents { protected int m_eventCount = 0 ; public boolean m_docPending = false ; protected boolean m_docEnded = false ; public boolean m_elemIsPending = false ; public boolean m_elemIsEnded = false ; protected MutableAttrListImpl m_attributes = new MutableAttrListImpl ( ) ; protected boolean m_nsDeclsHaveBeenAdded = false ; protected String m_name ; protected String m_url ; protected String m_localName ; protected Vector m_namespaces = null ; protected void reInitEvents ( ) { } public void reset ( ) { pushDocumentEvent ( ) ; reInitEvents ( ) ; } void pushDocumentEvent ( ) { m_docPending = true ; m_eventCount ++ ; } void popEvent ( ) { m_elemIsPending = false ; m_attributes . clear ( ) ; m_nsDeclsHaveBeenAdded = false ; m_name = null ; m_url = null ; m_localName = null ; m_namespaces = null ; m_eventCount -- ; } private org . apache . xml . serializer . Serializer m_serializer ; void setSerializer ( org . apache . xml . serializer . Serializer s ) { m_serializer = s ; } org . apache . xml . serializer . Serializer getSerializer ( ) { return m_serializer ; } } 	0
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncSum extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator nodes = m_arg0 . asIterator ( xctxt , xctxt . getCurrentNode ( ) ) ; double sum = 0.0 ; int pos ; while ( DTM . NULL != ( pos = nodes . nextNode ( ) ) ) { DTM dtm = nodes . getDTM ( pos ) ; XMLString s = dtm . getStringValue ( pos ) ; if ( null != s ) sum += s . toDouble ( ) ; } nodes . detach ( ) ; return new XNumber ( sum ) ; } } 	1
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class NthIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final int _position ; private boolean _ready ; public NthIterator ( DTMAxisIterator source , int n ) { _source = source ; _position = n ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final NthIterator clone = ( NthIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public int next ( ) { if ( _ready ) { _ready = false ; return _source . getNodeByPosition ( _position ) ; } return DTMAxisIterator . END ; } public DTMAxisIterator setStartNode ( final int node ) { if ( _isRestartable ) { _source . setStartNode ( node ) ; _ready = true ; } return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; _ready = true ; return this ; } public int getLast ( ) { return 1 ; } public int getPosition ( ) { return 1 ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; public class StylesheetComposed extends Stylesheet { public StylesheetComposed ( Stylesheet parent ) { super ( parent ) ; } public boolean isAggregatedType ( ) { return true ; } public void recompose ( Vector recomposableElements ) throws TransformerException { int n = getIncludeCountComposed ( ) ; for ( int i = - 1 ; i < n ; i ++ ) { Stylesheet included = getIncludeComposed ( i ) ; int s = included . getOutputCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getOutput ( j ) ) ; } s = included . getAttributeSetCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getAttributeSet ( j ) ) ; } s = included . getDecimalFormatCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getDecimalFormat ( j ) ) ; } s = included . getKeyCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getKey ( j ) ) ; } s = included . getNamespaceAliasCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getNamespaceAlias ( j ) ) ; } s = included . getTemplateCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getTemplate ( j ) ) ; } s = included . getVariableOrParamCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getVariableOrParam ( j ) ) ; } s = included . getStripSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getStripSpace ( j ) ) ; } s = included . getPreserveSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getPreserveSpace ( j ) ) ; } } } private int m_importNumber = - 1 ; private int m_importCountComposed ; private int m_endImportCountComposed ; void recomposeImports ( ) { m_importNumber = getStylesheetRoot ( ) . getImportNumber ( this ) ; StylesheetRoot root = getStylesheetRoot ( ) ; int globalImportCount = root . getGlobalImportCount ( ) ; m_importCountComposed = ( globalImportCount - m_importNumber ) - 1 ; int count = getImportCount ( ) ; if ( count > 0 ) { m_endImportCountComposed += count ; while ( count > 0 ) m_endImportCountComposed += this . getImport ( -- count ) . getEndImportCountComposed ( ) ; } count = getIncludeCountComposed ( ) ; while ( count > 0 ) { int imports = getIncludeComposed ( -- count ) . getImportCount ( ) ; m_endImportCountComposed += imports ; while ( imports > 0 ) m_endImportCountComposed += getIncludeComposed ( count ) . getImport ( -- imports ) . getEndImportCountComposed ( ) ; } } public StylesheetComposed getImportComposed ( int i ) throws ArrayIndexOutOfBoundsException { StylesheetRoot root = getStylesheetRoot ( ) ; return root . getGlobalImport ( 1 + m_importNumber + i ) ; } public int getImportCountComposed ( ) { return m_importCountComposed ; } public int getEndImportCountComposed ( ) { return m_endImportCountComposed ; } private transient Vector m_includesComposed ; void recomposeIncludes ( Stylesheet including ) { int n = including . getIncludeCount ( ) ; if ( n > 0 ) { if ( null == m_includesComposed ) m_includesComposed = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Stylesheet included = including . getInclude ( i ) ; m_includesComposed . addElement ( included ) ; recomposeIncludes ( included ) ; } } } public Stylesheet getIncludeComposed ( int i ) throws ArrayIndexOutOfBoundsException { if ( - 1 == i ) return this ; if ( null == m_includesComposed ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( Stylesheet ) m_includesComposed . elementAt ( i ) ; } public int getIncludeCountComposed ( ) { return ( null != m_includesComposed ) ? m_includesComposed . size ( ) : 0 ; } public void recomposeTemplates ( boolean flushFirst ) throws TransformerException { } } 	0
package org . apache . xpath . domapi ; import org . apache . xml . utils . PrefixResolverDefault ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathNSResolver ; public class XPathNSResolverImpl extends PrefixResolverDefault implements XPathNSResolver { public XPathNSResolverImpl ( Node xpathExpressionContext ) { super ( xpathExpressionContext ) ; } public String lookupNamespaceURI ( String prefix ) { return super . getNamespaceForPrefix ( prefix ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class ForwardPositionExpr extends Expression { private Expression _expr ; public ForwardPositionExpr ( Expression expr ) { _expr = expr ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _expr . setParser ( parser ) ; } public String toString ( ) { return "forward-position-expr(" + _expr + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return ( _type = _expr . typeCheck ( stable ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { _expr . translate ( classGen , methodGen ) ; if ( _type == Type . NodeSet ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( FORWARD_POSITION_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( FORWARD_POSITION_ITERATOR ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } } } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncTranslate extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String theFirstString = m_arg0 . execute ( xctxt ) . str ( ) ; String theSecondString = m_arg1 . execute ( xctxt ) . str ( ) ; String theThirdString = m_arg2 . execute ( xctxt ) . str ( ) ; int theFirstStringLength = theFirstString . length ( ) ; int theThirdStringLength = theThirdString . length ( ) ; StringBuffer sbuffer = new StringBuffer ( ) ; for ( int i = 0 ; i < theFirstStringLength ; i ++ ) { char theCurrentChar = theFirstString . charAt ( i ) ; int theIndex = theSecondString . indexOf ( theCurrentChar ) ; if ( theIndex < 0 ) { sbuffer . append ( theCurrentChar ) ; } else if ( theIndex < theThirdStringLength ) { sbuffer . append ( theThirdString . charAt ( theIndex ) ) ; } else { } } return new XString ( sbuffer . toString ( ) ) ; } } 	1
package org . apache . xalan . xsltc . compiler . util ; public abstract class NumberType extends Type { public boolean isNumber ( ) { return true ; } public boolean isSimple ( ) { return true ; } } 	0
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . w3c . dom . Node ; public class ProcessorCharacters extends XSLTElementProcessor { public void startNonText ( StylesheetHandler handler ) throws org . xml . sax . SAXException { if ( this == handler . getCurrentProcessor ( ) ) { handler . popProcessor ( ) ; } int nChars = m_accumulator . length ( ) ; if ( ( nChars > 0 ) && ( ( null != m_xslTextElement ) || ! XMLCharacterRecognizer . isWhiteSpace ( m_accumulator ) ) || handler . isSpacePreserve ( ) ) { ElemTextLiteral elem = new ElemTextLiteral ( ) ; elem . setDOMBackPointer ( m_firstBackPointer ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; try { elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } boolean doe = ( null != m_xslTextElement ) ? m_xslTextElement . getDisableOutputEscaping ( ) : false ; elem . setDisableOutputEscaping ( doe ) ; elem . setPreserveSpace ( true ) ; char [ ] chars = new char [ nChars ] ; m_accumulator . getChars ( 0 , nChars , chars , 0 ) ; elem . setChars ( chars ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( elem ) ; } m_accumulator . setLength ( 0 ) ; m_firstBackPointer = null ; } protected Node m_firstBackPointer = null ; public void characters ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { m_accumulator . append ( ch , start , length ) ; if ( null == m_firstBackPointer ) m_firstBackPointer = handler . getOriginatingNode ( ) ; if ( this != handler . getCurrentProcessor ( ) ) handler . pushProcessor ( this ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { startNonText ( handler ) ; handler . getCurrentProcessor ( ) . endElement ( handler , uri , localName , rawName ) ; handler . popProcessor ( ) ; } private StringBuffer m_accumulator = new StringBuffer ( ) ; private ElemText m_xslTextElement ; void setXslTextElement ( ElemText xslTextElement ) { m_xslTextElement = xslTextElement ; } } 	0
package org . apache . xalan . extensions ; import java . util . Vector ; import org . apache . xalan . templates . Constants ; public class ExtensionNamespacesManager { private Vector m_extensions = new Vector ( ) ; private Vector m_predefExtensions = new Vector ( 7 ) ; private Vector m_unregisteredExtensions = new Vector ( ) ; public ExtensionNamespacesManager ( ) { setPredefinedNamespaces ( ) ; } public void registerExtension ( String namespace ) { if ( namespaceIndex ( namespace , m_extensions ) == - 1 ) { int predef = namespaceIndex ( namespace , m_predefExtensions ) ; if ( predef != - 1 ) m_extensions . addElement ( m_predefExtensions . elementAt ( predef ) ) ; else if ( ! ( m_unregisteredExtensions . contains ( namespace ) ) ) m_unregisteredExtensions . addElement ( namespace ) ; } } public void registerExtension ( ExtensionNamespaceSupport extNsSpt ) { String namespace = extNsSpt . getNamespace ( ) ; if ( namespaceIndex ( namespace , m_extensions ) == - 1 ) { m_extensions . addElement ( extNsSpt ) ; if ( m_unregisteredExtensions . contains ( namespace ) ) m_unregisteredExtensions . removeElement ( namespace ) ; } } public int namespaceIndex ( String namespace , Vector extensions ) { for ( int i = 0 ; i < extensions . size ( ) ; i ++ ) { if ( ( ( ExtensionNamespaceSupport ) extensions . elementAt ( i ) ) . getNamespace ( ) . equals ( namespace ) ) return i ; } return - 1 ; } public Vector getExtensions ( ) { return m_extensions ; } public void registerUnregisteredNamespaces ( ) { for ( int i = 0 ; i < m_unregisteredExtensions . size ( ) ; i ++ ) { String ns = ( String ) m_unregisteredExtensions . elementAt ( i ) ; ExtensionNamespaceSupport extNsSpt = defineJavaNamespace ( ns ) ; if ( extNsSpt != null ) m_extensions . addElement ( extNsSpt ) ; } } public ExtensionNamespaceSupport defineJavaNamespace ( String ns ) { return defineJavaNamespace ( ns , ns ) ; } public ExtensionNamespaceSupport defineJavaNamespace ( String ns , String classOrPackage ) { if ( null == ns || ns . trim ( ) . length ( ) == 0 ) return null ; String className = classOrPackage ; if ( className . startsWith ( "class:" ) ) className = className . substring ( 6 ) ; int lastSlash = className . lastIndexOf ( "/" ) ; if ( - 1 != lastSlash ) className = className . substring ( lastSlash + 1 ) ; if ( null == className || className . trim ( ) . length ( ) == 0 ) return null ; try { ExtensionHandler . getClassForName ( className ) ; return new ExtensionNamespaceSupport ( ns , "org.apache.xalan.extensions.ExtensionHandlerJavaClass" , new Object [ ] { ns , "javaclass" , className } ) ; } catch ( ClassNotFoundException e ) { return new ExtensionNamespaceSupport ( ns , "org.apache.xalan.extensions.ExtensionHandlerJavaPackage" , new Object [ ] { ns , "javapackage" , className + "." } ) ; } } private void setPredefinedNamespaces ( ) { String uri = Constants . S_EXTENSIONS_JAVA_URL ; String handlerClassName = "org.apache.xalan.extensions.ExtensionHandlerJavaPackage" ; String lang = "javapackage" ; String lib = "" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_OLD_JAVA_URL ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_LOTUSXSL_JAVA_URL ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_XALANLIB_URL ; handlerClassName = "org.apache.xalan.extensions.ExtensionHandlerJavaClass" ; lang = "javaclass" ; lib = "org.apache.xalan.lib.Extensions" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_REDIRECT_URL ; lib = "org.apache.xalan.lib.Redirect" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_PIPE_URL ; lib = "org.apache.xalan.lib.PipeDocument" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_SQL_URL ; lib = "org.apache.xalan.lib.sql.XConnection" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_COMMON_URL ; lib = "org.apache.xalan.lib.ExsltCommon" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_MATH_URL ; lib = "org.apache.xalan.lib.ExsltMath" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_SETS_URL ; lib = "org.apache.xalan.lib.ExsltSets" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_DATETIME_URL ; lib = "org.apache.xalan.lib.ExsltDatetime" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_DYNAMIC_URL ; lib = "org.apache.xalan.lib.ExsltDynamic" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_STRINGS_URL ; lib = "org.apache.xalan.lib.ExsltStrings" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; } } 	1
package org . apache . xalan . extensions ; import java . lang . reflect . Constructor ; import javax . xml . transform . TransformerException ; public class ExtensionNamespaceSupport { String m_namespace = null ; String m_handlerClass = null ; Class [ ] m_sig = null ; Object [ ] m_args = null ; public ExtensionNamespaceSupport ( String namespace , String handlerClass , Object [ ] constructorArgs ) { m_namespace = namespace ; m_handlerClass = handlerClass ; m_args = constructorArgs ; m_sig = new Class [ m_args . length ] ; for ( int i = 0 ; i < m_args . length ; i ++ ) { if ( m_args [ i ] != null ) m_sig [ i ] = m_args [ i ] . getClass ( ) ; else { m_sig = null ; break ; } } } public String getNamespace ( ) { return m_namespace ; } public ExtensionHandler launch ( ) throws TransformerException { ExtensionHandler handler = null ; try { Class cl = ExtensionHandler . getClassForName ( m_handlerClass ) ; Constructor con = null ; if ( m_sig != null ) con = cl . getConstructor ( m_sig ) ; else { Constructor [ ] cons = cl . getConstructors ( ) ; for ( int i = 0 ; i < cons . length ; i ++ ) { if ( cons [ i ] . getParameterTypes ( ) . length == m_args . length ) { con = cons [ i ] ; break ; } } } if ( con != null ) handler = ( ExtensionHandler ) con . newInstance ( m_args ) ; else throw new TransformerException ( "ExtensionHandler constructor not found" ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } return handler ; } } 	0
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemVariable ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ProcessorExsltFuncResult extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = "" ; super . startElement ( handler , uri , localName , rawName , attributes ) ; ElemTemplateElement ancestor = handler . getElemTemplateElement ( ) . getParentElem ( ) ; while ( ancestor != null && ! ( ancestor instanceof ElemExsltFunction ) ) { if ( ancestor instanceof ElemVariable || ancestor instanceof ElemParam || ancestor instanceof ElemExsltFuncResult ) { msg = "func:result cannot appear within a variable, parameter, or another func:result." ; handler . error ( msg , new SAXException ( msg ) ) ; } ancestor = ancestor . getParentElem ( ) ; } if ( ancestor == null ) { msg = "func:result must appear in a func:function element" ; handler . error ( msg , new SAXException ( msg ) ) ; } } } 	1
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . xml . sax . Attributes ; public class ProcessorTemplateElem extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { super . startElement ( handler , uri , localName , rawName , attributes ) ; try { XSLTElementDef def = getElemDef ( ) ; Class classObject = def . getClassObject ( ) ; ElemTemplateElement elem = null ; try { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( InstantiationException ie ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMTMPL , null , ie ) ; } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMTMPL , null , iae ) ; } setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; appendAndPush ( handler , elem ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; if ( null != parent ) { parent . appendChild ( elem ) ; handler . pushElemTemplateElement ( elem ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { super . endElement ( handler , uri , localName , rawName ) ; handler . popElemTemplateElement ( ) ; } } 	1
package org . apache . xalan . lib . sql ; import java . lang . reflect . Method ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . DriverManager ; import java . sql . SQLException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class DefaultConnectionPool implements ConnectionPool { private Driver m_Driver = null ; private static final boolean DEBUG = false ; private String m_driver = new String ( "" ) ; private String m_url = new String ( "" ) ; private int m_PoolMinSize = 1 ; private Properties m_ConnectionProtocol = new Properties ( ) ; private Vector m_pool = new Vector ( ) ; private boolean m_IsActive = false ; public DefaultConnectionPool ( ) { } public boolean isEnabled ( ) { return m_IsActive ; } public void setDriver ( String d ) { m_driver = d ; } public void setURL ( String url ) { m_url = url ; } public void freeUnused ( ) { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { if ( DEBUG ) { System . err . println ( "Closing JDBC Connection " + x ) ; } pcon . close ( ) ; } } } public boolean hasActiveConnections ( ) { return ( m_pool . size ( ) > 0 ) ; } public void setPassword ( String p ) { m_ConnectionProtocol . put ( "password" , p ) ; } public void setUser ( String u ) { m_ConnectionProtocol . put ( "user" , u ) ; } public void setProtocol ( Properties p ) { Enumeration e = p . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; m_ConnectionProtocol . put ( key , p . getProperty ( key ) ) ; } } public void setMinConnections ( int n ) { m_PoolMinSize = n ; } public boolean testConnection ( ) { try { if ( DEBUG ) { System . out . println ( "Testing Connection" ) ; } Connection conn = getConnection ( ) ; if ( DEBUG ) { DatabaseMetaData dma = conn . getMetaData ( ) ; System . out . println ( "\nConnected to " + dma . getURL ( ) ) ; System . out . println ( "Driver   " + dma . getDriverName ( ) ) ; System . out . println ( "Version  " + dma . getDriverVersion ( ) ) ; System . out . println ( "" ) ; } if ( conn == null ) return false ; releaseConnection ( conn ) ; if ( DEBUG ) { System . out . println ( "Testing Connection, SUCCESS" ) ; } return true ; } catch ( Exception e ) { if ( DEBUG ) { System . out . println ( "Testing Connection, FAILED" ) ; e . printStackTrace ( ) ; } return false ; } } public synchronized Connection getConnection ( ) throws IllegalArgumentException , SQLException { PooledConnection pcon = null ; if ( m_pool . size ( ) < m_PoolMinSize ) { initializePool ( ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . setInUse ( true ) ; return pcon . getConnection ( ) ; } } Connection con = createConnection ( ) ; pcon = new PooledConnection ( con ) ; pcon . setInUse ( true ) ; m_pool . addElement ( pcon ) ; return pcon . getConnection ( ) ; } public synchronized void releaseConnection ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection " + x ) ; } if ( ! isEnabled ( ) ) { con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } } else { pcon . setInUse ( false ) ; } break ; } } } public synchronized void releaseConnectionOnError ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection On Error" + x ) ; } con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } break ; } } } private Connection createConnection ( ) throws SQLException { Connection con = null ; con = m_Driver . connect ( m_url , m_ConnectionProtocol ) ; return con ; } public synchronized void initializePool ( ) throws IllegalArgumentException , SQLException { if ( m_driver == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_DRIVER_NAME_SPECIFIED , null ) ) ; } if ( m_url == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_URL_SPECIFIED , null ) ) ; } if ( m_PoolMinSize < 1 ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_POOLSIZE_LESS_THAN_ONE , null ) ) ; } try { Class cls = null ; try { Method m = Thread . class . getMethod ( "getContextClassLoader" , null ) ; ClassLoader classLoader = ( ClassLoader ) m . invoke ( Thread . currentThread ( ) , null ) ; cls = classLoader . loadClass ( m_driver ) ; } catch ( Exception e ) { cls = Class . forName ( m_driver ) ; } if ( cls == null ) cls = Class . forName ( m_driver ) ; m_Driver = ( Driver ) cls . newInstance ( ) ; DriverManager . registerDriver ( m_Driver ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_DRIVER_NAME , null ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_DRIVER_NAME , null ) ) ; } if ( ! m_IsActive ) return ; do { Connection con = createConnection ( ) ; if ( con != null ) { PooledConnection pcon = new PooledConnection ( con ) ; addConnection ( pcon ) ; if ( DEBUG ) System . out . println ( "Adding DB Connection to the Pool" ) ; } } while ( m_pool . size ( ) < m_PoolMinSize ) ; } private void addConnection ( PooledConnection value ) { m_pool . addElement ( value ) ; } protected void finalize ( ) throws Throwable { if ( DEBUG ) { System . out . println ( "In Default Connection Pool, Finalize" ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { if ( DEBUG ) { System . out . println ( "Closing JDBC Connection " + x ) ; } PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . close ( ) ; } else { if ( DEBUG ) { System . out . println ( "--> Force close" ) ; } try { java . lang . Thread . sleep ( 30000 ) ; pcon . close ( ) ; } catch ( InterruptedException ie ) { if ( DEBUG ) System . err . println ( ie . getMessage ( ) ) ; } } } if ( DEBUG ) { System . out . println ( "Exit Default Connection Pool, Finalize" ) ; } super . finalize ( ) ; } public void setPoolEnabled ( boolean flag ) { m_IsActive = flag ; if ( ! flag ) freeUnused ( ) ; } } 	1
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemExsltFuncResult extends ElemVariable { public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext context = transformer . getXPathContext ( ) ; ElemExsltFunction owner = getOwnerFunction ( ) ; if ( owner != null ) { if ( owner . isResultSet ( ) ) throw new TransformerException ( "An EXSLT function cannot set more than one result!" ) ; int sourceNode = context . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; owner . setResult ( var ) ; } } public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ; } public ElemExsltFunction getOwnerFunction ( ) { ElemTemplateElement elem = this ; while ( ( elem != null ) && ! ( elem instanceof ElemExsltFunction ) ) { elem = elem . getParentElem ( ) ; } return ( ElemExsltFunction ) elem ; } } 	1
package org . apache . xml . utils ; public class WrappedRuntimeException extends RuntimeException { private Exception m_exception ; public WrappedRuntimeException ( Exception e ) { super ( e . getMessage ( ) ) ; m_exception = e ; } public WrappedRuntimeException ( String msg , Exception e ) { super ( msg ) ; m_exception = e ; } public Exception getException ( ) { return m_exception ; } } 	0
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . objects . XObject ; public class ElemParam extends ElemVariable { int m_qnameID ; public ElemParam ( ) { } public int getXSLToken ( ) { return Constants . ELEMNAME_PARAMVARIABLE ; } public String getNodeName ( ) { return Constants . ELEMNAME_PARAMVARIABLE_STRING ; } public ElemParam ( ElemParam param ) throws TransformerException { super ( param ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_qnameID = sroot . getComposeState ( ) . getQNameID ( m_qname ) ; if ( m_parentNode . getXSLToken ( ) == Constants . ELEMNAME_TEMPLATE ) ( ( ElemTemplate ) m_parentNode ) . m_inArgsSize ++ ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; VariableStack vars = transformer . getXPathContext ( ) . getVarStack ( ) ; if ( ! vars . isLocalSet ( m_index ) ) { int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1
package org . apache . xpath . patterns ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FunctionPattern extends StepPattern { public FunctionPattern ( Expression expr , int axis , int predaxis ) { super ( 0 , null , null , axis , predaxis ) ; m_functionExpr = expr ; } public final void calcScore ( ) { m_score = SCORE_OTHER ; if ( null == m_targetString ) calcTargetString ( ) ; } Expression m_functionExpr ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_functionExpr . fixupVariables ( vars , globalsSize ) ; } public XObject execute ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } } nl . detach ( ) ; return score ; } public XObject execute ( XPathContext xctxt , int context , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } nl . detach ( ) ; } return score ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } nl . detach ( ) ; } return score ; } class FunctionOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_functionExpr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FunctionPattern . this ) ; m_functionExpr = exp ; } } protected void callSubtreeVisitors ( XPathVisitor visitor ) { m_functionExpr . callVisitors ( new FunctionOwner ( ) , visitor ) ; super . callSubtreeVisitors ( visitor ) ; } } 	1
package org . apache . xml . utils ; public class Constants { public static final String S_XMLNAMESPACEURI = "http://www.w3.org/XML/1998/namespace" , S_XSLNAMESPACEURL = "http://www.w3.org/1999/XSL/Transform" , S_OLDXSLNAMESPACEURL = "http://www.w3.org/XSL/Transform/1.0" ; public static final String S_VENDOR = "Apache Software Foundation" , S_VENDORURL = "http://xml.apache.org" ; public static final String S_BUILTIN_EXTENSIONS_URL = "http://xml.apache.org/xalan" ; public static final String S_BUILTIN_OLD_EXTENSIONS_URL = "http://xml.apache.org/xslt" ; public static final String S_EXTENSIONS_OLD_JAVA_URL = "http://xml.apache.org/xslt/java" , S_EXTENSIONS_JAVA_URL = "http://xml.apache.org/xalan/java" , S_EXTENSIONS_LOTUSXSL_JAVA_URL = "http://xsl.lotus.com/java" , S_EXTENSIONS_XALANLIB_URL = "http://xml.apache.org/xalan" , S_EXTENSIONS_REDIRECT_URL = "http://xml.apache.org/xalan/redirect" , S_EXTENSIONS_PIPE_URL = "http://xml.apache.org/xalan/PipeDocument" , S_EXTENSIONS_SQL_URL = "http://xml.apache.org/xalan/sql" ; public static final String S_EXSLT_COMMON_URL = "http://exslt.org/common" , S_EXSLT_MATH_URL = "http://exslt.org/math" , S_EXSLT_SETS_URL = "http://exslt.org/sets" , S_EXSLT_DATETIME_URL = "http://exslt.org/dates-and-times" , S_EXSLT_FUNCTIONS_URL = "http://exslt.org/functions" , S_EXSLT_DYNAMIC_URL = "http://exslt.org/dynamic" , S_EXSLT_STRINGS_URL = "http://exslt.org/strings" ; public static final double XSLTVERSUPPORTED = 1.0 ; } 	1
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public abstract class DTMDefaultBaseIterators extends DTMDefaultBaseTraversers { public DTMDefaultBaseIterators ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; } public DTMDefaultBaseIterators ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; } public DTMAxisIterator getTypedAxisIterator ( int axis , int type ) { DTMAxisIterator iterator = null ; { switch ( axis ) { case Axis . SELF : iterator = new TypedSingletonIterator ( type ) ; break ; case Axis . CHILD : iterator = new TypedChildrenIterator ( type ) ; break ; case Axis . PARENT : return ( new ParentIterator ( ) . setNodeType ( type ) ) ; case Axis . ANCESTOR : return ( new TypedAncestorIterator ( type ) ) ; case Axis . ANCESTORORSELF : return ( ( new TypedAncestorIterator ( type ) ) . includeSelf ( ) ) ; case Axis . ATTRIBUTE : return ( new TypedAttributeIterator ( type ) ) ; case Axis . DESCENDANT : iterator = new TypedDescendantIterator ( type ) ; break ; case Axis . DESCENDANTORSELF : iterator = ( new TypedDescendantIterator ( type ) ) . includeSelf ( ) ; break ; case Axis . FOLLOWING : iterator = new TypedFollowingIterator ( type ) ; break ; case Axis . PRECEDING : iterator = new TypedPrecedingIterator ( type ) ; break ; case Axis . FOLLOWINGSIBLING : iterator = new TypedFollowingSiblingIterator ( type ) ; break ; case Axis . PRECEDINGSIBLING : iterator = new TypedPrecedingSiblingIterator ( type ) ; break ; case Axis . NAMESPACE : iterator = new TypedNamespaceIterator ( type ) ; break ; case Axis . ROOT : iterator = new TypedRootIterator ( type ) ; break ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , new Object [ ] { Axis . names [ axis ] } ) ) ; } } return ( iterator ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { DTMAxisIterator iterator = null ; switch ( axis ) { case Axis . SELF : iterator = new SingletonIterator ( ) ; break ; case Axis . CHILD : iterator = new ChildrenIterator ( ) ; break ; case Axis . PARENT : return ( new ParentIterator ( ) ) ; case Axis . ANCESTOR : return ( new AncestorIterator ( ) ) ; case Axis . ANCESTORORSELF : return ( ( new AncestorIterator ( ) ) . includeSelf ( ) ) ; case Axis . ATTRIBUTE : return ( new AttributeIterator ( ) ) ; case Axis . DESCENDANT : iterator = new DescendantIterator ( ) ; break ; case Axis . DESCENDANTORSELF : iterator = ( new DescendantIterator ( ) ) . includeSelf ( ) ; break ; case Axis . FOLLOWING : iterator = new FollowingIterator ( ) ; break ; case Axis . PRECEDING : iterator = new PrecedingIterator ( ) ; break ; case Axis . FOLLOWINGSIBLING : iterator = new FollowingSiblingIterator ( ) ; break ; case Axis . PRECEDINGSIBLING : iterator = new PrecedingSiblingIterator ( ) ; break ; case Axis . NAMESPACE : iterator = new NamespaceIterator ( ) ; break ; case Axis . ROOT : iterator = new RootIterator ( ) ; break ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_AXIS_NOT_IMPLEMENTED , new Object [ ] { Axis . names [ axis ] } ) ) ; } return ( iterator ) ; } public abstract class InternalAxisIteratorBase extends DTMAxisIteratorBase { protected int _currentNode ; public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } } public final class ChildrenIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != NULL ) { int node = _currentNode ; _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return END ; } } public final class ParentIterator extends InternalAxisIteratorBase { private int _nodeType = - 1 ; public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getParent ( node ) ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator setNodeType ( final int type ) { _nodeType = type ; return this ; } public int next ( ) { int result = _currentNode ; if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType != getExpandedTypeID ( _currentNode ) ) { result = END ; } } else if ( _nodeType != NULL ) { if ( _nodeType != getNodeType ( _currentNode ) ) { result = END ; } } _currentNode = END ; return returnNode ( result ) ; } } public final class TypedChildrenIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedChildrenIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch ( makeNodeIdentity ( _startNode ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int eType ; int node = _currentNode ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( node != DTM . NULL && _exptype ( node ) != nodeType ) { node = _nextsib ( node ) ; } } else { while ( node != DTM . NULL ) { eType = _exptype ( node ) ; if ( eType < DTM . NTYPES ) { if ( eType == nodeType ) { break ; } } else if ( m_expandedNameTable . getType ( eType ) == nodeType ) { break ; } node = _nextsib ( node ) ; } } if ( node == DTM . NULL ) { _currentNode = DTM . NULL ; return DTM . NULL ; } else { _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class NamespaceChildrenIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceChildrenIterator ( final int type ) { _nsType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : NOTPROCESSED ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != DTM . NULL ) { for ( int node = ( NOTPROCESSED == _currentNode ) ? _firstch ( makeNodeIdentity ( _startNode ) ) : _nextsib ( _currentNode ) ; node != END ; node = _nextsib ( node ) ) { if ( m_expandedNameTable . getNamespaceID ( _exptype ( node ) ) == _nsType ) { _currentNode = node ; return returnNode ( node ) ; } } } return END ; } } public class NamespaceIterator extends InternalAxisIteratorBase { public NamespaceIterator ( ) { super ( ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstNamespaceNode ( node , true ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( DTM . NULL != node ) _currentNode = getNextNamespaceNode ( _startNode , node , true ) ; return returnNode ( node ) ; } } public class TypedNamespaceIterator extends NamespaceIterator { private final int _nodeType ; public TypedNamespaceIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { int node ; for ( node = _currentNode ; node != END ; node = getNextNamespaceNode ( _startNode , node , true ) ) { if ( getExpandedTypeID ( node ) == _nodeType || getNodeType ( node ) == _nodeType || getNamespaceType ( node ) == _nodeType ) { _currentNode = node ; return returnNode ( node ) ; } } return ( _currentNode = END ) ; } } public class RootIterator extends InternalAxisIteratorBase { public RootIterator ( ) { super ( ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = getDocumentRoot ( node ) ; _currentNode = NULL ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; _currentNode = _startNode ; return returnNode ( _startNode ) ; } } public class TypedRootIterator extends RootIterator { private final int _nodeType ; public TypedRootIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; int nodeType = _nodeType ; int node = _startNode ; int expType = getExpandedTypeID ( node ) ; _currentNode = node ; if ( nodeType >= DTM . NTYPES ) { if ( nodeType == expType ) { return returnNode ( node ) ; } } else { if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { return returnNode ( node ) ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { return returnNode ( node ) ; } } } return END ; } } public final class NamespaceAttributeIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceAttributeIterator ( int nsType ) { super ( ) ; _nsType = nsType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstNamespaceNode ( node , false ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( DTM . NULL != node ) _currentNode = getNextNamespaceNode ( _startNode , node , false ) ; return returnNode ( node ) ; } } public class FollowingSiblingIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = makeNodeIdentity ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { _currentNode = ( _currentNode == DTM . NULL ) ? DTM . NULL : _nextsib ( _currentNode ) ; return returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class TypedFollowingSiblingIterator extends FollowingSiblingIterator { private final int _nodeType ; public TypedFollowingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { if ( _currentNode == DTM . NULL ) { return DTM . NULL ; } int node = _currentNode ; int eType ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { do { node = _nextsib ( node ) ; } while ( node != DTM . NULL && _exptype ( node ) != nodeType ) ; } else { while ( ( node = _nextsib ( node ) ) != DTM . NULL ) { eType = _exptype ( node ) ; if ( eType < DTM . NTYPES ) { if ( eType == nodeType ) { break ; } } else if ( m_expandedNameTable . getType ( eType ) == nodeType ) { break ; } } } _currentNode = node ; return ( _currentNode == DTM . NULL ) ? DTM . NULL : returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class AttributeIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstAttributeIdentity ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; if ( node != NULL ) { _currentNode = getNextAttributeIdentity ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return NULL ; } } public final class TypedAttributeIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedAttributeIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; _currentNode = getTypedAttribute ( node , _nodeType ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; _currentNode = NULL ; return returnNode ( node ) ; } } public class PrecedingSiblingIterator extends InternalAxisIteratorBase { protected int _startNodeID ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = _startNodeID = makeNodeIdentity ( node ) ; if ( node == NULL ) { _currentNode = node ; return resetPosition ( ) ; } int type = m_expandedNameTable . getType ( _exptype ( node ) ) ; if ( ExpandedNameTable . ATTRIBUTE == type || ExpandedNameTable . NAMESPACE == type ) { _currentNode = node ; } else { _currentNode = _parent ( node ) ; if ( NULL != _currentNode ) _currentNode = _firstch ( _currentNode ) ; else _currentNode = node ; } return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode == _startNodeID || _currentNode == DTM . NULL ) { return NULL ; } else { final int node = _currentNode ; _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class TypedPrecedingSiblingIterator extends PrecedingSiblingIterator { private final int _nodeType ; public TypedPrecedingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; int expType ; int nodeType = _nodeType ; int startID = _startNodeID ; if ( nodeType >= DTM . NTYPES ) { while ( node != NULL && node != startID && _exptype ( node ) != nodeType ) { node = _nextsib ( node ) ; } } else { while ( node != NULL && node != startID ) { expType = _exptype ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { break ; } } node = _nextsib ( node ) ; } } if ( node == DTM . NULL || node == _startNodeID ) { _currentNode = NULL ; return NULL ; } else { _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public class PrecedingIterator extends InternalAxisIteratorBase { private final int _maxAncestors = 8 ; protected int [ ] _stack = new int [ _maxAncestors ] ; protected int _sp , _oldsp ; protected int _markedsp , _markedNode , _markedDescendant ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , 0 , stackCopy , 0 , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; int parent , index ; if ( _type ( node ) == DTM . ATTRIBUTE_NODE ) node = _parent ( node ) ; _startNode = node ; _stack [ index = 0 ] = node ; parent = node ; while ( ( parent = _parent ( parent ) ) != NULL ) { if ( ++ index == _stack . length ) { final int [ ] stack = new int [ index + 4 ] ; System . arraycopy ( _stack , 0 , stack , 0 , index ) ; _stack = stack ; } _stack [ index ] = parent ; } if ( index > 0 ) -- index ; _currentNode = _stack [ index ] ; _oldsp = _sp = index ; return resetPosition ( ) ; } return this ; } public int next ( ) { for ( ++ _currentNode ; _sp >= 0 ; ++ _currentNode ) { if ( _currentNode < _stack [ _sp ] ) { if ( _type ( _currentNode ) != ATTRIBUTE_NODE && _type ( _currentNode ) != NAMESPACE_NODE ) return returnNode ( makeNodeHandle ( _currentNode ) ) ; } else -- _sp ; } return NULL ; } public DTMAxisIterator reset ( ) { _sp = _oldsp ; return resetPosition ( ) ; } public void setMark ( ) { _markedsp = _sp ; _markedNode = _currentNode ; _markedDescendant = _stack [ 0 ] ; } public void gotoMark ( ) { _sp = _markedsp ; _currentNode = _markedNode ; } } public final class TypedPrecedingIterator extends PrecedingIterator { private final int _nodeType ; public TypedPrecedingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( true ) { node = node + 1 ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else if ( _exptype ( node ) == nodeType ) { break ; } } } else { int expType ; while ( true ) { node = node + 1 ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else { expType = _exptype ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { break ; } } } } } _currentNode = node ; return ( node == NULL ) ? NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public class FollowingIterator extends InternalAxisIteratorBase { DTMAxisTraverser m_traverser ; public FollowingIterator ( ) { m_traverser = getAxisTraverser ( Axis . FOLLOWING ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = m_traverser . first ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; _currentNode = m_traverser . next ( _startNode , _currentNode ) ; return returnNode ( node ) ; } } public final class TypedFollowingIterator extends FollowingIterator { private final int _nodeType ; public TypedFollowingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; do { node = _currentNode ; _currentNode = m_traverser . next ( _startNode , _currentNode ) ; } while ( node != DTM . NULL && ( getExpandedTypeID ( node ) != _nodeType && getNodeType ( node ) != _nodeType ) ) ; return ( node == DTM . NULL ? DTM . NULL : returnNode ( node ) ) ; } } public class AncestorIterator extends InternalAxisIteratorBase { org . apache . xml . utils . NodeVector m_ancestors = new org . apache . xml . utils . NodeVector ( ) ; int m_ancestorsPos ; int m_markedPos ; int m_realStartNode ; public int getStartNode ( ) { return m_realStartNode ; } public final boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final AncestorIterator clone = ( AncestorIterator ) super . clone ( ) ; clone . _startNode = _startNode ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; if ( ! _includeSelf && node != DTM . NULL ) { nodeID = _parent ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; while ( nodeID != END ) { m_ancestors . addElement ( node ) ; nodeID = _parent ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } public int next ( ) { int next = _currentNode ; int pos = -- m_ancestorsPos ; _currentNode = ( pos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return returnNode ( next ) ; } public void setMark ( ) { m_markedPos = m_ancestorsPos ; } public void gotoMark ( ) { m_ancestorsPos = m_markedPos ; _currentNode = m_ancestorsPos >= 0 ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; } } public final class TypedAncestorIterator extends AncestorIterator { private final int _nodeType ; public TypedAncestorIterator ( int type ) { _nodeType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; int nodeType = _nodeType ; if ( ! _includeSelf && node != DTM . NULL ) { nodeID = _parent ( nodeID ) ; } _startNode = node ; if ( nodeType >= DTM . NTYPES ) { while ( nodeID != END ) { int eType = _exptype ( nodeID ) ; if ( eType == nodeType ) { m_ancestors . addElement ( makeNodeHandle ( nodeID ) ) ; } nodeID = _parent ( nodeID ) ; } } else { while ( nodeID != END ) { int eType = _exptype ( nodeID ) ; if ( ( eType >= DTM . NTYPES && m_expandedNameTable . getType ( eType ) == nodeType ) || ( eType < DTM . NTYPES && eType == nodeType ) ) { m_ancestors . addElement ( makeNodeHandle ( nodeID ) ) ; } nodeID = _parent ( nodeID ) ; } } m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } return this ; } } public class DescendantIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; _startNode = node ; if ( _includeSelf ) node -- ; _currentNode = node ; return resetPosition ( ) ; } return this ; } protected boolean isDescendant ( int identity ) { return ( _parent ( identity ) >= _startNode ) || ( _startNode == identity ) ; } public int next ( ) { if ( _startNode == NULL ) { return NULL ; } if ( _includeSelf && ( _currentNode + 1 ) == _startNode ) return returnNode ( makeNodeHandle ( ++ _currentNode ) ) ; int node = _currentNode ; int type ; do { node ++ ; type = _type ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( ATTRIBUTE_NODE == type || TEXT_NODE == type || NAMESPACE_NODE == type ) ; _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( makeNodeHandle ( _startNode ) ) ; _isRestartable = temp ; return this ; } } public final class TypedDescendantIterator extends DescendantIterator { private final int _nodeType ; public TypedDescendantIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { int node ; int type ; if ( _startNode == NULL ) { return NULL ; } node = _currentNode ; do { node ++ ; type = _type ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( type != _nodeType && _exptype ( node ) != _nodeType ) ; _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } } public class NthDescendantIterator extends DescendantIterator { int _pos ; public NthDescendantIterator ( int pos ) { _pos = pos ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != END ) { node = makeNodeIdentity ( node ) ; int parent = _parent ( node ) ; int child = _firstch ( parent ) ; int pos = 0 ; do { int type = _type ( child ) ; if ( ELEMENT_NODE == type ) pos ++ ; } while ( ( pos < _pos ) && ( child = _nextsib ( child ) ) != END ) ; if ( node == child ) return node ; } return ( END ) ; } } public class SingletonIterator extends InternalAxisIteratorBase { private boolean _isConstant ; public SingletonIterator ( ) { this ( Integer . MIN_VALUE , false ) ; } public SingletonIterator ( int node ) { this ( node , false ) ; } public SingletonIterator ( int node , boolean constant ) { _currentNode = _startNode = node ; _isConstant = constant ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isConstant ) { _currentNode = _startNode ; return resetPosition ( ) ; } else if ( _isRestartable ) { if ( _currentNode == Integer . MIN_VALUE ) { _currentNode = _startNode = node ; } return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { if ( _isConstant ) { _currentNode = _startNode ; return resetPosition ( ) ; } else { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; } return this ; } public int next ( ) { final int result = _currentNode ; _currentNode = END ; return returnNode ( result ) ; } } public final class TypedSingletonIterator extends SingletonIterator { private final int _nodeType ; public TypedSingletonIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int result = _currentNode ; int nodeType = _nodeType ; _currentNode = END ; if ( nodeType >= DTM . NTYPES ) { if ( getExpandedTypeID ( result ) == nodeType ) { return returnNode ( result ) ; } } else { if ( getNodeType ( result ) == nodeType ) { return returnNode ( result ) ; } } return NULL ; } } } 	0
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; final class StringLengthCall extends FunctionCall { public StringLengthCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( argumentCount ( ) > 0 ) { argument ( ) . translate ( classGen , methodGen ) ; } else { il . append ( methodGen . loadContextNode ( ) ) ; Type . Node . translateTo ( classGen , methodGen , Type . String ) ; } il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ) ) ; } } 	0
package org . apache . xalan . xsltc . runtime ; import java . util . Vector ; public class AttributeList implements org . xml . sax . Attributes { private final static String EMPTYSTRING = "" ; private final static String CDATASTRING = "CDATA" ; private Hashtable _attributes ; private Vector _names ; private Vector _qnames ; private Vector _values ; private Vector _uris ; private int _length ; public AttributeList ( ) { _length = 0 ; } public AttributeList ( org . xml . sax . Attributes attributes ) { this ( ) ; if ( attributes != null ) { final int count = attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { add ( attributes . getQName ( i ) , attributes . getValue ( i ) ) ; } } } private void alloc ( ) { _attributes = new Hashtable ( ) ; _names = new Vector ( ) ; _values = new Vector ( ) ; _qnames = new Vector ( ) ; _uris = new Vector ( ) ; } public int getLength ( ) { return ( _length ) ; } public String getURI ( int index ) { if ( index < _length ) return ( ( String ) _uris . elementAt ( index ) ) ; else return ( null ) ; } public String getLocalName ( int index ) { if ( index < _length ) return ( ( String ) _names . elementAt ( index ) ) ; else return ( null ) ; } public String getQName ( int pos ) { if ( pos < _length ) return ( ( String ) _qnames . elementAt ( pos ) ) ; else return ( null ) ; } public String getType ( int index ) { return ( CDATASTRING ) ; } public int getIndex ( String namespaceURI , String localPart ) { return ( - 1 ) ; } public int getIndex ( String qname ) { return ( - 1 ) ; } public String getType ( String uri , String localName ) { return ( CDATASTRING ) ; } public String getType ( String qname ) { return ( CDATASTRING ) ; } public String getValue ( int pos ) { if ( pos < _length ) return ( ( String ) _values . elementAt ( pos ) ) ; else return ( null ) ; } public String getValue ( String qname ) { if ( _attributes != null ) { final Integer obj = ( Integer ) _attributes . get ( qname ) ; if ( obj == null ) return null ; return ( getValue ( obj . intValue ( ) ) ) ; } else return null ; } public String getValue ( String uri , String localName ) { return ( getValue ( uri + ':' + localName ) ) ; } public void add ( String qname , String value ) { if ( _attributes == null ) alloc ( ) ; Integer obj = ( Integer ) _attributes . get ( qname ) ; if ( obj == null ) { _attributes . put ( qname , obj = new Integer ( _length ++ ) ) ; _qnames . addElement ( qname ) ; _values . addElement ( value ) ; int col = qname . lastIndexOf ( ':' ) ; if ( col > - 1 ) { _uris . addElement ( qname . substring ( 0 , col ) ) ; _names . addElement ( qname . substring ( col + 1 ) ) ; } else { _uris . addElement ( EMPTYSTRING ) ; _names . addElement ( qname ) ; } } else { final int index = obj . intValue ( ) ; _values . set ( index , value ) ; } } public void clear ( ) { _length = 0 ; if ( _attributes != null ) { _attributes . clear ( ) ; _names . removeAllElements ( ) ; _values . removeAllElements ( ) ; _qnames . removeAllElements ( ) ; _uris . removeAllElements ( ) ; } } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class LiteralExpr extends Expression { private final String _value ; private final String _namespace ; public LiteralExpr ( String value ) { _value = value ; _namespace = null ; } public LiteralExpr ( String value , String namespace ) { _value = value ; _namespace = namespace . equals ( Constants . EMPTYSTRING ) ? null : namespace ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . String ; } public String toString ( ) { return "literal-expr(" + _value + ')' ; } protected boolean contextDependent ( ) { return false ; } protected String getValue ( ) { return _value ; } protected String getNamespace ( ) { return _namespace ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Text extends Instruction { private String _text ; private boolean _escaping = true ; private boolean _ignore = false ; private boolean _textElement = false ; public Text ( ) { _textElement = true ; } public Text ( String text ) { _text = text ; } protected String getText ( ) { return _text ; } protected void setText ( String text ) { if ( _text == null ) _text = text ; else _text = _text + text ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Text" ) ; indent ( indent + IndentIncrement ) ; Util . println ( _text ) ; } public void parseContents ( Parser parser ) { final String str = getAttribute ( "disable-output-escaping" ) ; if ( ( str != null ) && ( str . equals ( "yes" ) ) ) _escaping = false ; parseChildren ( parser ) ; if ( _text == null ) { if ( _textElement ) { _text = EMPTYSTRING ; } else { _ignore = true ; } } else if ( _textElement ) { if ( _text . length ( ) == 0 ) _ignore = true ; } else if ( getParent ( ) instanceof LiteralElement ) { LiteralElement element = ( LiteralElement ) getParent ( ) ; String space = element . getAttribute ( "xml:space" ) ; if ( ( space == null ) || ( ! space . equals ( "preserve" ) ) ) if ( _text . trim ( ) . length ( ) == 0 ) _ignore = true ; } else { if ( _text . trim ( ) . length ( ) == 0 ) _ignore = true ; } } public void ignore ( ) { _ignore = true ; } public boolean isTextElement ( ) { return _textElement ; } protected boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( ! _ignore ) { final int esc = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "setEscaping" , "(Z)Z" ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( esc , 2 ) ) ; } final int characters = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "characters" , "(" + STRING_SIG + ")V" ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _text ) ) ; il . append ( new INVOKEINTERFACE ( characters , 2 ) ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( esc , 2 ) ) ; il . append ( POP ) ; } } translateContents ( classGen , methodGen ) ; } } 	0
package org . apache . xml . utils ; public final class BoolStack implements Cloneable { private boolean m_values [ ] ; private int m_allocatedSize ; private int m_index ; public BoolStack ( ) { this ( 32 ) ; } public BoolStack ( int size ) { m_allocatedSize = size ; m_values = new boolean [ size ] ; m_index = - 1 ; } public final int size ( ) { return m_index + 1 ; } public final boolean push ( boolean val ) { if ( m_index == m_allocatedSize - 1 ) grow ( ) ; return ( m_values [ ++ m_index ] = val ) ; } public final boolean pop ( ) { return m_values [ m_index -- ] ; } public final boolean popAndTop ( ) { m_index -- ; return ( m_index >= 0 ) ? m_values [ m_index ] : false ; } public final void setTop ( boolean b ) { m_values [ m_index ] = b ; } public final boolean peek ( ) { return m_values [ m_index ] ; } public final boolean peekOrFalse ( ) { return ( m_index > - 1 ) ? m_values [ m_index ] : false ; } public final boolean peekOrTrue ( ) { return ( m_index > - 1 ) ? m_values [ m_index ] : true ; } public boolean isEmpty ( ) { return ( m_index == - 1 ) ; } private void grow ( ) { m_allocatedSize *= 2 ; boolean newVector [ ] = new boolean [ m_allocatedSize ] ; System . arraycopy ( m_values , 0 , newVector , 0 , m_index + 1 ) ; m_values = newVector ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } } 	1
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncDoclocation extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int whereNode = getArg0AsNode ( xctxt ) ; String fileLocation = null ; if ( DTM . NULL != whereNode ) { DTM dtm = xctxt . getDTM ( whereNode ) ; if ( DTM . DOCUMENT_FRAGMENT_NODE == dtm . getNodeType ( whereNode ) ) { whereNode = dtm . getFirstChild ( whereNode ) ; } if ( DTM . NULL != whereNode ) { fileLocation = dtm . getDocumentBaseURI ( ) ; } } return new XString ( ( null != fileLocation ) ? fileLocation : "" ) ; } } 	1
package org . apache . xalan . processor ; import org . apache . xalan . res . XSLTErrorResources ; class ProcessorImport extends ProcessorInclude { protected int getStylesheetType ( ) { return StylesheetHandler . STYPE_IMPORT ; } protected String getStylesheetInclErr ( ) { return XSLTErrorResources . ER_IMPORTING_ITSELF ; } } 	0
package org . apache . xalan . xsltc . dom ; import java . io . Externalizable ; import java . io . IOException ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import org . apache . xml . dtm . DTMAxisIterator ; public class BitArray implements Externalizable { private int [ ] _bits ; private int _bitSize ; private int _intSize ; private int _mask ; private final static int [ ] _masks = { 0x80000000 , 0x40000000 , 0x20000000 , 0x10000000 , 0x08000000 , 0x04000000 , 0x02000000 , 0x01000000 , 0x00800000 , 0x00400000 , 0x00200000 , 0x00100000 , 0x00080000 , 0x00040000 , 0x00020000 , 0x00010000 , 0x00008000 , 0x00004000 , 0x00002000 , 0x00001000 , 0x00000800 , 0x00000400 , 0x00000200 , 0x00000100 , 0x00000080 , 0x00000040 , 0x00000020 , 0x00000010 , 0x00000008 , 0x00000004 , 0x00000002 , 0x00000001 } ; private final static boolean DEBUG_ASSERTIONS = false ; public BitArray ( ) { this ( 32 ) ; } public BitArray ( int size ) { if ( size < 32 ) size = 32 ; _bitSize = size ; _intSize = ( _bitSize > > > 5 ) + 1 ; _bits = new int [ _intSize + 1 ] ; } public BitArray ( int size , int [ ] bits ) { if ( size < 32 ) size = 32 ; _bitSize = size ; _intSize = ( _bitSize > > > 5 ) + 1 ; _bits = bits ; } public void setMask ( int mask ) { _mask = mask ; } public int getMask ( ) { return ( _mask ) ; } public final int size ( ) { return ( _bitSize ) ; } public final boolean getBit ( int bit ) { if ( DEBUG_ASSERTIONS ) { if ( bit >= _bitSize ) { throw new Error ( "Programmer's assertion in  BitArray.getBit" ) ; } } return ( ( _bits [ bit > > > 5 ] & _masks [ bit % 32 ] ) != 0 ) ; } public final int getNextBit ( int startBit ) { for ( int i = ( startBit > > > 5 ) ; i <= _intSize ; i ++ ) { int bits = _bits [ i ] ; if ( bits != 0 ) { for ( int b = ( startBit % 32 ) ; b < 32 ; b ++ ) { if ( ( bits & _masks [ b ] ) != 0 ) { return ( ( i << 5 ) + b ) ; } } } startBit = 0 ; } return ( DTMAxisIterator . END ) ; } private int _pos = Integer . MAX_VALUE ; private int _node = 0 ; private int _int = 0 ; private int _bit = 0 ; public final int getBitNumber ( int pos ) { if ( pos == _pos ) return ( _node ) ; if ( pos < _pos ) { _int = _bit = _pos = 0 ; } for ( ; _int <= _intSize ; _int ++ ) { int bits = _bits [ _int ] ; if ( bits != 0 ) { for ( ; _bit < 32 ; _bit ++ ) { if ( ( bits & _masks [ _bit ] ) != 0 ) { if ( ++ _pos == pos ) { _node = ( ( _int << 5 ) + _bit ) - 1 ; return ( _node ) ; } } } _bit = 0 ; } } return ( 0 ) ; } public final int [ ] data ( ) { return ( _bits ) ; } int _first = Integer . MAX_VALUE ; int _last = Integer . MIN_VALUE ; public final void setBit ( int bit ) { if ( DEBUG_ASSERTIONS ) { if ( bit >= _bitSize ) { throw new Error ( "Programmer's assertion in  BitArray.getBit" ) ; } } if ( bit >= _bitSize ) return ; final int i = ( bit > > > 5 ) ; if ( i < _first ) _first = i ; if ( i > _last ) _last = i ; _bits [ i ] |= _masks [ bit % 32 ] ; } public final BitArray merge ( BitArray other ) { if ( _last == - 1 ) { _bits = other . _bits ; } else if ( other . _last != - 1 ) { int start = ( _first < other . _first ) ? _first : other . _first ; int stop = ( _last > other . _last ) ? _last : other . _last ; if ( other . _intSize > _intSize ) { if ( stop > _intSize ) stop = _intSize ; for ( int i = start ; i <= stop ; i ++ ) other . _bits [ i ] |= _bits [ i ] ; _bits = other . _bits ; } else { if ( stop > other . _intSize ) stop = other . _intSize ; for ( int i = start ; i <= stop ; i ++ ) _bits [ i ] |= other . _bits [ i ] ; } } return ( this ) ; } public final void resize ( int newSize ) { if ( newSize > _bitSize ) { _intSize = ( newSize > > > 5 ) + 1 ; final int [ ] newBits = new int [ _intSize + 1 ] ; System . arraycopy ( _bits , 0 , newBits , 0 , ( _bitSize > > > 5 ) + 1 ) ; _bits = newBits ; _bitSize = newSize ; } } public BitArray cloneArray ( ) { return ( new BitArray ( _intSize , _bits ) ) ; } public void writeExternal ( ObjectOutput out ) throws IOException { out . writeInt ( _bitSize ) ; out . writeInt ( _mask ) ; out . writeObject ( _bits ) ; out . flush ( ) ; } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { _bitSize = in . readInt ( ) ; _intSize = ( _bitSize > > > 5 ) + 1 ; _mask = in . readInt ( ) ; _bits = ( int [ ] ) in . readObject ( ) ; } } 	0
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemMessage extends ElemTemplateElement { private boolean m_terminate = Constants . ATTRVAL_NO ; public void setTerminate ( boolean v ) { m_terminate = v ; } public boolean getTerminate ( ) { return m_terminate ; } public int getXSLToken ( ) { return Constants . ELEMNAME_MESSAGE ; } public String getNodeName ( ) { return Constants . ELEMNAME_MESSAGE_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; String data = transformer . transformToString ( this ) ; transformer . getMsgMgr ( ) . message ( this , data , m_terminate ) ; if ( m_terminate ) transformer . getErrorListener ( ) . fatalError ( new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_STYLESHEET_DIRECTED_TERMINATION , null ) ) ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class RoundCall extends FunctionCall { public RoundCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( DUP2 ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( "java.lang.Double" , "isNaN" , "(D)Z" ) ) ) ; final BranchHandle skip = il . append ( new IFNE ( null ) ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( MATH_CLASS , "round" , "(D)J" ) ) ) ; il . append ( L2D ) ; skip . setTarget ( il . append ( NOP ) ) ; } } 	1
package org . apache . xalan . transformer ; public class ResultNameSpace { public ResultNameSpace m_next = null ; public String m_prefix ; public String m_uri ; public ResultNameSpace ( String prefix , String uri ) { m_prefix = prefix ; m_uri = uri ; } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Gte extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . greaterThanOrEqual ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMBuilder ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public final class XSLTCSource implements Source { private String _systemId = null ; private DOM _dom = null ; private final static String LEXICAL_HANDLER_PROPERTY = "http://xml.org/sax/properties/lexical-handler" ; public XSLTCSource ( int size ) { XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; int dtmPos = dtmManager . getFirstFreeDTMID ( ) ; int documentID = dtmPos << DTMManager . IDENT_DTM_NODE_BITS ; _dom = ( DOM ) new SAXImpl ( dtmManager , this , documentID , null , null , false , size , true ) ; dtmManager . addDTM ( ( DTM ) _dom , dtmPos ) ; } public XSLTCSource ( ) { XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; int dtmPos = dtmManager . getFirstFreeDTMID ( ) ; int documentID = dtmPos << DTMManager . IDENT_DTM_NODE_BITS ; _dom = ( DOM ) new SAXImpl ( dtmManager , this , documentID , null , null , false , true ) ; dtmManager . addDTM ( ( DTM ) _dom , dtmPos ) ; } public void setSystemId ( String systemId ) { if ( ( new File ( systemId ) ) . exists ( ) ) _systemId = "file:" + systemId ; else _systemId = systemId ; ( ( SAXImpl ) _dom ) . setDocumentURI ( _systemId ) ; } public String getSystemId ( ) { return ( _systemId ) ; } public void build ( XMLReader reader , String systemId ) throws SAXException { try { if ( ( systemId == null ) && ( _systemId == null ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . XSLTC_SOURCE_ERR ) ; throw new SAXException ( err . toString ( ) ) ; } if ( systemId == null ) systemId = _systemId ; setSystemId ( systemId ) ; InputSource input = new InputSource ( systemId ) ; DOMBuilder builder ; builder = ( ( SAXImpl ) _dom ) . getBuilder ( ) ; reader . setContentHandler ( builder ) ; reader . setDTDHandler ( builder ) ; try { reader . setProperty ( LEXICAL_HANDLER_PROPERTY , builder ) ; } catch ( SAXException e ) { } reader . parse ( input ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void build ( String systemId ) throws SAXException { try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; build ( reader , systemId ) ; } catch ( ParserConfigurationException e ) { throw new SAXException ( e ) ; } } public void build ( XMLReader reader ) throws SAXException { build ( reader , _systemId ) ; } public void build ( ) throws SAXException { build ( _systemId ) ; } protected DOM getDOM ( ) { return ( _dom ) ; } } 	1
package org . apache . xalan . templates ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class XUnresolvedVariable extends XObject { transient private int m_context ; transient private TransformerImpl m_transformer ; transient private int m_varStackPos = - 1 ; transient private int m_varStackContext ; private boolean m_isGlobal ; transient private boolean m_doneEval = true ; public XUnresolvedVariable ( ElemVariable obj , int sourceNode , TransformerImpl transformer , int varStackPos , int varStackContext , boolean isGlobal ) { super ( obj ) ; m_context = sourceNode ; m_transformer = transformer ; m_varStackPos = varStackPos ; m_varStackContext = varStackContext ; m_isGlobal = isGlobal ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( ! m_doneEval ) { this . m_transformer . getMsgMgr ( ) . error ( xctxt . getSAXLocator ( ) , XSLTErrorResources . ER_REFERENCING_ITSELF , new Object [ ] { ( ( ElemVariable ) this . object ( ) ) . getName ( ) . getLocalName ( ) } ) ; } VariableStack vars = xctxt . getVarStack ( ) ; int currentFrame = vars . getStackFrame ( ) ; ElemVariable velem = ( ElemVariable ) m_obj ; try { m_doneEval = false ; if ( - 1 != velem . m_frameSize ) vars . link ( velem . m_frameSize ) ; XObject var = velem . getValue ( m_transformer , m_context ) ; m_doneEval = true ; return var ; } finally { if ( - 1 != velem . m_frameSize ) vars . unlink ( currentFrame ) ; } } public void setVarStackPos ( int top ) { m_varStackPos = top ; } public void setVarStackContext ( int bottom ) { m_varStackContext = bottom ; } public int getType ( ) { return CLASS_UNRESOLVEDVARIABLE ; } public String getTypeString ( ) { return "XUnresolvedVariable (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } } 	0
package org . apache . xml . dtm . ref ; import org . w3c . dom . Node ; public class DTMNodeListBase implements org . w3c . dom . NodeList { public DTMNodeListBase ( ) { } public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } 	0
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; public class Counter { static final int MAXCOUNTNODES = 500 ; int m_countNodesStartCount = 0 ; NodeSetDTM m_countNodes ; int m_fromNode = DTM . NULL ; ElemNumber m_numberElem ; int m_countResult ; Counter ( ElemNumber numberElem , NodeSetDTM countNodes ) throws TransformerException { m_countNodes = countNodes ; m_numberElem = numberElem ; } int getPreviouslyCounted ( XPathContext support , int node ) { int n = m_countNodes . size ( ) ; m_countResult = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int countedNode = m_countNodes . elementAt ( i ) ; if ( node == countedNode ) { m_countResult = i + 1 + m_countNodesStartCount ; break ; } DTM dtm = support . getDTM ( countedNode ) ; if ( dtm . isNodeAfter ( countedNode , node ) ) break ; } return m_countResult ; } int getLast ( ) { int size = m_countNodes . size ( ) ; return ( size > 0 ) ? m_countNodes . elementAt ( size - 1 ) : DTM . NULL ; } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class NotCall extends FunctionCall { public NotCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; final Expression exp = argument ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; final BranchHandle gotoh = il . append ( new GOTO ( null ) ) ; _trueList = exp . _falseList ; _falseList = exp . _trueList ; _falseList . add ( gotoh ) ; } } 	0
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; public class ElemUse extends ElemTemplateElement { private QName m_attributeSetsNames [ ] = null ; public void setUseAttributeSets ( Vector v ) { int n = v . size ( ) ; m_attributeSetsNames = new QName [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { m_attributeSetsNames [ i ] = ( QName ) v . elementAt ( i ) ; } } public void setUseAttributeSets ( QName [ ] v ) { m_attributeSetsNames = v ; } public QName [ ] getUseAttributeSets ( ) { return m_attributeSetsNames ; } public void applyAttrSets ( TransformerImpl transformer , StylesheetRoot stylesheet ) throws TransformerException { applyAttrSets ( transformer , stylesheet , m_attributeSetsNames ) ; } private void applyAttrSets ( TransformerImpl transformer , StylesheetRoot stylesheet , QName attributeSetsNames [ ] ) throws TransformerException { if ( null != attributeSetsNames ) { int nNames = attributeSetsNames . length ; for ( int i = 0 ; i < nNames ; i ++ ) { QName qname = attributeSetsNames [ i ] ; Vector attrSets = stylesheet . getAttributeSetComposed ( qname ) ; if ( null != attrSets ) { int nSets = attrSets . size ( ) ; for ( int k = nSets - 1 ; k >= 0 ; k -- ) { ElemAttributeSet attrSet = ( ElemAttributeSet ) attrSets . elementAt ( k ) ; attrSet . execute ( transformer ) ; } } } } } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( null != m_attributeSetsNames ) { applyAttrSets ( transformer , getStylesheetRoot ( ) , m_attributeSetsNames ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; public class Function3Args extends Function2Args { Expression m_arg2 ; public Expression getArg2 ( ) { return m_arg2 ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_arg2 ) m_arg2 . fixupVariables ( vars , globalsSize ) ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) super . setArg ( arg , argNum ) ; else if ( 2 == argNum ) { m_arg2 = arg ; arg . exprSetParent ( this ) ; } else reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 3 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "three" , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return super . canTraverseOutsideSubtree ( ) ? true : m_arg2 . canTraverseOutsideSubtree ( ) ; } class Arg2Owner implements ExpressionOwner { public Expression getExpression ( ) { return m_arg2 ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Function3Args . this ) ; m_arg2 = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_arg2 ) m_arg2 . callVisitors ( new Arg2Owner ( ) , visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( null != m_arg2 ) { if ( null == ( ( Function3Args ) expr ) . m_arg2 ) return false ; if ( ! m_arg2 . deepEquals ( ( ( Function3Args ) expr ) . m_arg2 ) ) return false ; } else if ( null != ( ( Function3Args ) expr ) . m_arg2 ) return false ; return true ; } } 	1
package org . apache . xpath . objects ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . OneStepIterator ; public class XObjectFactory { static public XObject create ( Object val ) { XObject result ; if ( val instanceof XObject ) { result = ( XObject ) val ; } else if ( val instanceof String ) { result = new XString ( ( String ) val ) ; } else if ( val instanceof Boolean ) { result = new XBoolean ( ( Boolean ) val ) ; } else if ( val instanceof Double ) { result = new XNumber ( ( ( Double ) val ) ) ; } else { result = new XObject ( val ) ; } return result ; } static public XObject create ( Object val , XPathContext xctxt ) { XObject result ; if ( val instanceof XObject ) { result = ( XObject ) val ; } else if ( val instanceof String ) { result = new XString ( ( String ) val ) ; } else if ( val instanceof Boolean ) { result = new XBoolean ( ( Boolean ) val ) ; } else if ( val instanceof Number ) { result = new XNumber ( ( ( Number ) val ) ) ; } else if ( val instanceof DTM ) { DTM dtm = ( DTM ) val ; try { int dtmRoot = dtm . getDocument ( ) ; DTMAxisIterator iter = dtm . getAxisIterator ( Axis . SELF ) ; iter . setStartNode ( dtmRoot ) ; DTMIterator iterator = new OneStepIterator ( iter , Axis . SELF ) ; iterator . setRoot ( dtmRoot , xctxt ) ; result = new XNodeSet ( iterator ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } else if ( val instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) val ; try { DTMIterator iterator = new OneStepIterator ( iter , Axis . SELF ) ; iterator . setRoot ( iter . getStartNode ( ) , xctxt ) ; result = new XNodeSet ( iterator ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } else if ( val instanceof DTMIterator ) { result = new XNodeSet ( ( DTMIterator ) val ) ; } else if ( val instanceof org . w3c . dom . Node ) { result = new XNodeSetForDOM ( ( org . w3c . dom . Node ) val , xctxt ) ; } else if ( val instanceof org . w3c . dom . NodeList ) { result = new XNodeSetForDOM ( ( org . w3c . dom . NodeList ) val , xctxt ) ; } else if ( val instanceof org . w3c . dom . traversal . NodeIterator ) { result = new XNodeSetForDOM ( ( org . w3c . dom . traversal . NodeIterator ) val , xctxt ) ; } else { result = new XObject ( val ) ; } return result ; } } 	0
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . QName ; import org . apache . xpath . Expression ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . PsuedoNames ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; public class TemplateList implements java . io . Serializable { public TemplateList ( ) { super ( ) ; } public void setTemplate ( ElemTemplate template ) { if ( null != template . getName ( ) ) { ElemTemplate existingTemplate = ( ElemTemplate ) m_namedTemplates . get ( template . getName ( ) ) ; if ( null == existingTemplate ) { m_namedTemplates . put ( template . getName ( ) , template ) ; } else { int existingPrecedence = existingTemplate . getStylesheetComposed ( ) . getImportCountComposed ( ) ; int newPrecedence = template . getStylesheetComposed ( ) . getImportCountComposed ( ) ; if ( newPrecedence > existingPrecedence ) { m_namedTemplates . put ( template . getName ( ) , template ) ; } else if ( newPrecedence == existingPrecedence ) template . error ( XSLTErrorResources . ER_DUPLICATE_NAMED_TEMPLATE , new Object [ ] { template . getName ( ) } ) ; } } XPath matchXPath = template . getMatch ( ) ; if ( null != matchXPath ) { Expression matchExpr = matchXPath . getExpression ( ) ; if ( matchExpr instanceof StepPattern ) { insertPatternInTable ( ( StepPattern ) matchExpr , template ) ; } else if ( matchExpr instanceof UnionPattern ) { UnionPattern upat = ( UnionPattern ) matchExpr ; StepPattern [ ] pats = upat . getPatterns ( ) ; int n = pats . length ; for ( int i = 0 ; i < n ; i ++ ) { insertPatternInTable ( pats [ i ] , template ) ; } } else { } } } static boolean DEBUG = false ; void dumpAssociationTables ( ) { Enumeration associations = m_patternTable . elements ( ) ; while ( associations . hasMoreElements ( ) ) { TemplateSubPatternAssociation head = ( TemplateSubPatternAssociation ) associations . nextElement ( ) ; while ( null != head ) { System . out . print ( "(" + head . getTargetString ( ) + ", " + head . getPattern ( ) + ")" ) ; head = head . getNext ( ) ; } System . out . println ( "\n....." ) ; } TemplateSubPatternAssociation head = m_wildCardPatterns ; System . out . print ( "wild card list: " ) ; while ( null != head ) { System . out . print ( "(" + head . getTargetString ( ) + ", " + head . getPattern ( ) + ")" ) ; head = head . getNext ( ) ; } System . out . println ( "\n....." ) ; } public void compose ( StylesheetRoot sroot ) { if ( DEBUG ) { System . out . println ( "Before wildcard insert..." ) ; dumpAssociationTables ( ) ; } if ( null != m_wildCardPatterns ) { Enumeration associations = m_patternTable . elements ( ) ; while ( associations . hasMoreElements ( ) ) { TemplateSubPatternAssociation head = ( TemplateSubPatternAssociation ) associations . nextElement ( ) ; TemplateSubPatternAssociation wild = m_wildCardPatterns ; while ( null != wild ) { try { head = insertAssociationIntoList ( head , ( TemplateSubPatternAssociation ) wild . clone ( ) , true ) ; } catch ( CloneNotSupportedException cnse ) { } wild = wild . getNext ( ) ; } } } if ( DEBUG ) { System . out . println ( "After wildcard insert..." ) ; dumpAssociationTables ( ) ; } } private TemplateSubPatternAssociation insertAssociationIntoList ( TemplateSubPatternAssociation head , TemplateSubPatternAssociation item , boolean isWildCardInsert ) { double priority = getPriorityOrScore ( item ) ; double workPriority ; int importLevel = item . getImportLevel ( ) ; int docOrder = item . getDocOrderPos ( ) ; TemplateSubPatternAssociation insertPoint = head ; TemplateSubPatternAssociation next ; boolean insertBefore ; while ( true ) { next = insertPoint . getNext ( ) ; if ( null == next ) break ; else { workPriority = getPriorityOrScore ( next ) ; if ( importLevel > next . getImportLevel ( ) ) break ; else if ( importLevel < next . getImportLevel ( ) ) insertPoint = next ; else if ( priority > workPriority ) break ; else if ( priority < workPriority ) insertPoint = next ; else if ( docOrder >= next . getDocOrderPos ( ) ) break ; else insertPoint = next ; } } if ( ( null == next ) || ( insertPoint == head ) ) { workPriority = getPriorityOrScore ( insertPoint ) ; if ( importLevel > insertPoint . getImportLevel ( ) ) insertBefore = true ; else if ( importLevel < insertPoint . getImportLevel ( ) ) insertBefore = false ; else if ( priority > workPriority ) insertBefore = true ; else if ( priority < workPriority ) insertBefore = false ; else if ( docOrder >= insertPoint . getDocOrderPos ( ) ) insertBefore = true ; else insertBefore = false ; } else insertBefore = false ; if ( isWildCardInsert ) { if ( insertBefore ) { item . setNext ( insertPoint ) ; String key = insertPoint . getTargetString ( ) ; item . setTargetString ( key ) ; putHead ( key , item ) ; return item ; } else { item . setNext ( next ) ; insertPoint . setNext ( item ) ; return head ; } } else { if ( insertBefore ) { item . setNext ( insertPoint ) ; if ( insertPoint . isWild ( ) || item . isWild ( ) ) m_wildCardPatterns = item ; else putHead ( item . getTargetString ( ) , item ) ; return item ; } else { item . setNext ( next ) ; insertPoint . setNext ( item ) ; return head ; } } } private void insertPatternInTable ( StepPattern pattern , ElemTemplate template ) { String target = pattern . getTargetString ( ) ; if ( null != target ) { String pstring = template . getMatch ( ) . getPatternString ( ) ; TemplateSubPatternAssociation association = new TemplateSubPatternAssociation ( template , pattern , pstring ) ; boolean isWildCard = association . isWild ( ) ; TemplateSubPatternAssociation head = isWildCard ? m_wildCardPatterns : getHead ( target ) ; if ( null == head ) { if ( isWildCard ) m_wildCardPatterns = association ; else putHead ( target , association ) ; } else { insertAssociationIntoList ( head , association , false ) ; } } } private double getPriorityOrScore ( TemplateSubPatternAssociation matchPat ) { double priority = matchPat . getTemplate ( ) . getPriority ( ) ; if ( priority == XPath . MATCH_SCORE_NONE ) { Expression ex = matchPat . getStepPattern ( ) ; if ( ex instanceof NodeTest ) { return ( ( NodeTest ) ex ) . getDefaultScore ( ) ; } } return priority ; } public ElemTemplate getTemplate ( QName qname ) { return ( ElemTemplate ) m_namedTemplates . get ( qname ) ; } public TemplateSubPatternAssociation getHead ( XPathContext xctxt , int targetNode , DTM dtm ) { short targetNodeType = dtm . getNodeType ( targetNode ) ; TemplateSubPatternAssociation head ; switch ( targetNodeType ) { case DTM . ELEMENT_NODE : case DTM . ATTRIBUTE_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . TEXT_NODE : case DTM . CDATA_SECTION_NODE : head = m_textPatterns ; break ; case DTM . ENTITY_REFERENCE_NODE : case DTM . ENTITY_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . COMMENT_NODE : head = m_commentPatterns ; break ; case DTM . DOCUMENT_NODE : case DTM . DOCUMENT_FRAGMENT_NODE : head = m_docPatterns ; break ; case DTM . NOTATION_NODE : default : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; } return ( null == head ) ? m_wildCardPatterns : head ; } public ElemTemplate getTemplateFast ( XPathContext xctxt , int targetNode , int expTypeID , QName mode , int maxImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head ; switch ( dtm . getNodeType ( targetNode ) ) { case DTM . ELEMENT_NODE : case DTM . ATTRIBUTE_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalNameFromExpandedNameID ( expTypeID ) ) ; break ; case DTM . TEXT_NODE : case DTM . CDATA_SECTION_NODE : head = m_textPatterns ; break ; case DTM . ENTITY_REFERENCE_NODE : case DTM . ENTITY_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . COMMENT_NODE : head = m_commentPatterns ; break ; case DTM . DOCUMENT_NODE : case DTM . DOCUMENT_FRAGMENT_NODE : head = m_docPatterns ; break ; case DTM . NOTATION_NODE : default : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; } if ( null == head ) { head = m_wildCardPatterns ; if ( null == head ) return null ; } xctxt . pushNamespaceContextNull ( ) ; try { do { if ( ( maxImportLevel > - 1 ) && ( head . getImportLevel ( ) > maxImportLevel ) ) { continue ; } ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode , dtm , expTypeID ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popNamespaceContext ( ) ; } return null ; } public ElemTemplate getTemplate ( XPathContext xctxt , int targetNode , QName mode , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head = getHead ( xctxt , targetNode , dtm ) ; if ( null != head ) { xctxt . pushNamespaceContextNull ( ) ; xctxt . pushCurrentNodeAndExpression ( targetNode , targetNode ) ; try { do { ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; xctxt . popNamespaceContext ( ) ; } } return null ; } public ElemTemplate getTemplate ( XPathContext xctxt , int targetNode , QName mode , int maxImportLevel , int endImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head = getHead ( xctxt , targetNode , dtm ) ; if ( null != head ) { xctxt . pushNamespaceContextNull ( ) ; xctxt . pushCurrentNodeAndExpression ( targetNode , targetNode ) ; try { do { if ( ( maxImportLevel > - 1 ) && ( head . getImportLevel ( ) > maxImportLevel ) ) { continue ; } if ( head . getImportLevel ( ) <= maxImportLevel - endImportLevel ) return null ; ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; xctxt . popNamespaceContext ( ) ; } } return null ; } public TemplateWalker getWalker ( ) { return new TemplateWalker ( ) ; } private void checkConflicts ( TemplateSubPatternAssociation head , XPathContext xctxt , int targetNode , QName mode ) { } private void addObjectIfNotFound ( Object obj , Vector v ) { int n = v . size ( ) ; boolean addIt = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( v . elementAt ( i ) == obj ) { addIt = false ; break ; } } if ( addIt ) { v . addElement ( obj ) ; } } private Hashtable m_namedTemplates = new Hashtable ( 89 ) ; private Hashtable m_patternTable = new Hashtable ( 89 ) ; private TemplateSubPatternAssociation m_wildCardPatterns = null ; private TemplateSubPatternAssociation m_textPatterns = null ; private TemplateSubPatternAssociation m_docPatterns = null ; private TemplateSubPatternAssociation m_commentPatterns = null ; private Hashtable getNamedTemplates ( ) { return m_namedTemplates ; } private void setNamedTemplates ( Hashtable v ) { m_namedTemplates = v ; } private TemplateSubPatternAssociation getHead ( String key ) { return ( TemplateSubPatternAssociation ) m_patternTable . get ( key ) ; } private void putHead ( String key , TemplateSubPatternAssociation assoc ) { if ( key . equals ( PsuedoNames . PSEUDONAME_TEXT ) ) m_textPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_ROOT ) ) m_docPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_COMMENT ) ) m_commentPatterns = assoc ; m_patternTable . put ( key , assoc ) ; } public class TemplateWalker { private Enumeration hashIterator ; private boolean inPatterns ; private TemplateSubPatternAssociation curPattern ; private Hashtable m_compilerCache = new Hashtable ( ) ; private TemplateWalker ( ) { hashIterator = m_patternTable . elements ( ) ; inPatterns = true ; curPattern = null ; } public ElemTemplate next ( ) { ElemTemplate retValue = null ; ElemTemplate ct ; while ( true ) { if ( inPatterns ) { if ( null != curPattern ) curPattern = curPattern . getNext ( ) ; if ( null != curPattern ) retValue = curPattern . getTemplate ( ) ; else { if ( hashIterator . hasMoreElements ( ) ) { curPattern = ( TemplateSubPatternAssociation ) hashIterator . nextElement ( ) ; retValue = curPattern . getTemplate ( ) ; } else { inPatterns = false ; hashIterator = m_namedTemplates . elements ( ) ; } } } if ( ! inPatterns ) { if ( hashIterator . hasMoreElements ( ) ) retValue = ( ElemTemplate ) hashIterator . nextElement ( ) ; else return null ; } ct = ( ElemTemplate ) m_compilerCache . get ( new Integer ( retValue . getUid ( ) ) ) ; if ( null == ct ) { m_compilerCache . put ( new Integer ( retValue . getUid ( ) ) , retValue ) ; return retValue ; } } } } } 	1
package org . apache . xml . dtm ; import javax . xml . transform . SourceLocator ; public class DTMConfigurationException extends DTMException { public DTMConfigurationException ( ) { super ( "Configuration Error" ) ; } public DTMConfigurationException ( String msg ) { super ( msg ) ; } public DTMConfigurationException ( Throwable e ) { super ( e ) ; } public DTMConfigurationException ( String msg , Throwable e ) { super ( msg , e ) ; } public DTMConfigurationException ( String message , SourceLocator locator ) { super ( message , locator ) ; } public DTMConfigurationException ( String message , SourceLocator locator , Throwable e ) { super ( message , locator , e ) ; } } 	0
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncLast extends Function { private boolean m_isTopLevel ; public void postCompileStep ( Compiler compiler ) { m_isTopLevel = compiler . getLocationPathDepth ( ) == - 1 ; } public int getCountOfContextNodeList ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { SubContextList iter = m_isTopLevel ? null : xctxt . getSubContextList ( ) ; if ( null != iter ) return iter . getLastPos ( xctxt ) ; DTMIterator cnl = xctxt . getContextNodeList ( ) ; int count ; if ( null != cnl ) { count = cnl . getLength ( ) ; } else count = 0 ; return count ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XNumber xnum = new XNumber ( ( double ) getCountOfContextNodeList ( xctxt ) ) ; return xnum ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1
package org . apache . xalan . transformer ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class KeyTable { private int m_docKey ; private Vector m_keyDeclarations ; private Hashtable m_refsTable = null ; public int getDocKey ( ) { return m_docKey ; } private XNodeSet m_keyNodes ; KeyIterator getKeyIterator ( ) { return ( KeyIterator ) ( m_keyNodes . getContainedIter ( ) ) ; } public KeyTable ( int doc , PrefixResolver nscontext , QName name , Vector keyDeclarations , XPathContext xctxt ) throws javax . xml . transform . TransformerException { m_docKey = doc ; m_keyDeclarations = keyDeclarations ; KeyIterator ki = new KeyIterator ( name , keyDeclarations ) ; m_keyNodes = new XNodeSet ( ki ) ; m_keyNodes . allowDetachToRelease ( false ) ; m_keyNodes . setRoot ( doc , xctxt ) ; } public XNodeSet getNodeSetDTMByKey ( QName name , XMLString ref ) { XNodeSet refNodes = ( XNodeSet ) getRefsTable ( ) . get ( ref ) ; try { if ( refNodes != null ) { refNodes = ( XNodeSet ) refNodes . cloneWithReset ( ) ; } } catch ( CloneNotSupportedException e ) { refNodes = null ; } if ( refNodes == null ) { KeyIterator ki = ( KeyIterator ) ( m_keyNodes ) . getContainedIter ( ) ; XPathContext xctxt = ki . getXPathContext ( ) ; refNodes = new XNodeSet ( xctxt . getDTMManager ( ) ) { public void setRoot ( int nodeHandle , Object environment ) { } } ; refNodes . reset ( ) ; } return refNodes ; } public QName getKeyTableName ( ) { return getKeyIterator ( ) . getName ( ) ; } private KeyDeclaration getKeyDeclaration ( ) { int nDeclarations = m_keyDeclarations . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) m_keyDeclarations . elementAt ( i ) ; if ( kd . getName ( ) . equals ( getKeyTableName ( ) ) ) { return kd ; } } return null ; } private Hashtable getRefsTable ( ) { if ( m_refsTable == null ) { m_refsTable = new Hashtable ( 89 ) ; KeyIterator ki = ( KeyIterator ) ( m_keyNodes ) . getContainedIter ( ) ; XPathContext xctxt = ki . getXPathContext ( ) ; KeyDeclaration keyDeclaration = getKeyDeclaration ( ) ; int currentNode ; m_keyNodes . reset ( ) ; while ( DTM . NULL != ( currentNode = m_keyNodes . nextNode ( ) ) ) { try { XObject xuse = keyDeclaration . getUse ( ) . execute ( xctxt , currentNode , ki . getPrefixResolver ( ) ) ; if ( xuse . getType ( ) != xuse . CLASS_NODESET ) { XMLString exprResult = xuse . xstr ( ) ; addValueInRefsTable ( xctxt , exprResult , currentNode ) ; } else { DTMIterator i = ( ( XNodeSet ) xuse ) . iterRaw ( ) ; int currentNodeInUseClause ; while ( DTM . NULL != ( currentNodeInUseClause = i . nextNode ( ) ) ) { DTM dtm = xctxt . getDTM ( currentNodeInUseClause ) ; XMLString exprResult = dtm . getStringValue ( currentNodeInUseClause ) ; addValueInRefsTable ( xctxt , exprResult , currentNode ) ; } } } catch ( TransformerException te ) { throw new WrappedRuntimeException ( te ) ; } } } return m_refsTable ; } private void addValueInRefsTable ( XPathContext xctxt , XMLString ref , int node ) { XNodeSet nodes = ( XNodeSet ) m_refsTable . get ( ref ) ; if ( nodes == null ) { nodes = new XNodeSet ( node , xctxt . getDTMManager ( ) ) ; nodes . nextNode ( ) ; m_refsTable . put ( ref , nodes ) ; } else { if ( nodes . getCurrentNode ( ) != node ) { nodes . mutableNodeset ( ) . addNode ( node ) ; nodes . nextNode ( ) ; } } } } 	1
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; public class WriterToASCI extends Writer { private final OutputStream m_os ; public WriterToASCI ( OutputStream os ) { m_os = os ; } public void write ( char chars [ ] , int start , int length ) throws java . io . IOException { int n = length + start ; for ( int i = start ; i < n ; i ++ ) { m_os . write ( chars [ i ] ) ; } } public void write ( int c ) throws IOException { m_os . write ( c ) ; } public void write ( String s ) throws IOException { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m_os . write ( s . charAt ( i ) ) ; } } public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	0
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . Serializable ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . Properties ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . URIResolver ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public final class TemplatesImpl implements Templates , Serializable { private static String ABSTRACT_TRANSLET = "org.apache.xalan.xsltc.runtime.AbstractTranslet" ; private String _name = null ; private byte [ ] [ ] _bytecodes = null ; private Translet _translet = null ; private Class [ ] _class = null ; private int _transletIndex = - 1 ; private Properties _outputProperties ; private int _indentNumber ; private URIResolver _uriResolver = null ; private transient TransformerFactoryImpl _tfactory = null ; private class TransletClassLoader extends ClassLoader { protected TransletClassLoader ( ClassLoader parent ) { super ( parent ) ; } public Class defineClass ( byte [ ] b ) { return super . defineClass ( null , b , 0 , b . length ) ; } } protected TemplatesImpl ( byte [ ] [ ] bytecodes , String transletName , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _bytecodes = bytecodes ; _name = transletName ; _outputProperties = outputProperties ; _indentNumber = indentNumber ; _tfactory = tfactory ; } protected TemplatesImpl ( Translet translet , String transletName , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _translet = translet ; _name = transletName ; _outputProperties = outputProperties ; _indentNumber = indentNumber ; _tfactory = tfactory ; } public TemplatesImpl ( ) { } private void readObject ( ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject ( ) ; _tfactory = new TransformerFactoryImpl ( ) ; } public synchronized void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } protected synchronized void setTransletBytecodes ( byte [ ] [ ] bytecodes ) { _bytecodes = bytecodes ; } public synchronized byte [ ] [ ] getTransletBytecodes ( ) { return _bytecodes ; } public synchronized Class [ ] getTransletClasses ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _class ; } public synchronized int getTransletIndex ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _transletIndex ; } protected synchronized void setTransletName ( String name ) { _name = name ; } protected synchronized String getTransletName ( ) { return _name ; } private void defineTransletClasses ( ) throws TransformerConfigurationException { if ( _bytecodes == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_TRANSLET_CLASS_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } TransletClassLoader loader = ( TransletClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new TransletClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } ) ; try { final int classCount = _bytecodes . length ; _class = new Class [ classCount ] ; for ( int i = 0 ; i < classCount ; i ++ ) { _class [ i ] = loader . defineClass ( _bytecodes [ i ] ) ; final Class superClass = _class [ i ] . getSuperclass ( ) ; if ( superClass . getName ( ) . equals ( ABSTRACT_TRANSLET ) ) { _transletIndex = i ; } } if ( _transletIndex < 0 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_MAIN_TRANSLET_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } catch ( ClassFormatError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_CLASS_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( LinkageError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } private Translet getTransletInstance ( ) throws TransformerConfigurationException { try { if ( _name == null ) return null ; if ( _class == null ) defineTransletClasses ( ) ; Translet translet = ( Translet ) _class [ _transletIndex ] . newInstance ( ) ; final int classCount = _bytecodes . length ; for ( int i = 0 ; i < classCount ; i ++ ) { if ( i != _transletIndex ) { translet . addAuxiliaryClass ( _class [ i ] ) ; } } return translet ; } catch ( InstantiationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( IllegalAccessException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } public synchronized Transformer newTransformer ( ) throws TransformerConfigurationException { TransformerImpl transformer ; if ( _translet != null ) { transformer = new TransformerImpl ( _translet , _outputProperties , _indentNumber , _tfactory ) ; } else { transformer = new TransformerImpl ( getTransletInstance ( ) , _outputProperties , _indentNumber , _tfactory ) ; } if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return transformer ; } public synchronized Properties getOutputProperties ( ) { try { return newTransformer ( ) . getOutputProperties ( ) ; } catch ( TransformerConfigurationException e ) { return null ; } } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; final class Key extends TopLevelElement { private QName _name ; private Pattern _match ; private Expression _use ; private Type _useType ; public void parseContents ( Parser parser ) { _name = parser . getQNameIgnoreDefaultNs ( getAttribute ( "name" ) ) ; _match = parser . parsePattern ( this , "match" , null ) ; _use = parser . parseExpression ( this , "use" , null ) ; if ( _name == null ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; return ; } if ( _match . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "match" ) ; return ; } if ( _use . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "use" ) ; return ; } } public String getName ( ) { return _name . toString ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _match . typeCheck ( stable ) ; _useType = _use . typeCheck ( stable ) ; if ( _useType instanceof StringType == false && _useType instanceof NodeSetType == false ) { _use = new CastExpr ( _use , Type . String ) ; } return Type . Void ; } public void traverseNodeSet ( ClassGenerator classGen , MethodGenerator methodGen , int buildKeyIndex ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeValue = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; final int keyDom = cpg . addMethodref ( TRANSLET_CLASS , "setKeyIndexDom" , "(" + STRING_SIG + DOM_INTF_SIG + ")V" ) ; final LocalVariableGen parentNode = methodGen . addLocalVariable ( "parentNode" , Util . getJCRefType ( "I" ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( parentNode . getIndex ( ) ) ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( new ISTORE ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; _use . translate ( classGen , methodGen ) ; _use . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( new ILOAD ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getNodeValue , 2 ) ) ; il . append ( new INVOKEVIRTUAL ( buildKeyIndex ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , getName ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGE ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; final int key = cpg . addMethodref ( TRANSLET_CLASS , "buildKeyIndex" , "(" + STRING_SIG + "I" + OBJECT_SIG + ")V" ) ; final int keyDom = cpg . addMethodref ( TRANSLET_CLASS , "setKeyIndexDom" , "(" + STRING_SIG + DOM_INTF_SIG + ")V" ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . DESCENDANT ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . setStartNode ( ) ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _match . translate ( classGen , methodGen ) ; _match . synthesize ( classGen , methodGen ) ; final BranchHandle skipNode = il . append ( new IFEQ ( null ) ) ; if ( _useType instanceof NodeSetType ) { il . append ( methodGen . loadCurrentNode ( ) ) ; traverseNodeSet ( classGen , methodGen , key ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( DUP_X1 ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _use . translate ( classGen , methodGen ) ; il . append ( SWAP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( key ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; } final InstructionHandle skip = il . append ( NOP ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; nextNode . setTarget ( skip ) ; skipNode . setTarget ( skip ) ; } } 	1
package org . apache . xalan . xsltc . runtime ; import java . io . FileWriter ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . dom . DOMAdapter ; import org . apache . xalan . xsltc . dom . KeyIndex ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . runtime . output . TransletOutputHandlerFactory ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; public abstract class AbstractTranslet implements Translet { public String _version = "1.0" ; public String _method = null ; public String _encoding = "UTF-8" ; public boolean _omitHeader = false ; public String _standalone = null ; public String _doctypePublic = null ; public String _doctypeSystem = null ; public boolean _indent = false ; public String _mediaType = null ; public Vector _cdata = null ; protected String [ ] namesArray ; protected String [ ] namespaceArray ; protected boolean _hasIdCall = false ; protected StringValueHandler stringValueHandler = new StringValueHandler ( ) ; private final static String EMPTYSTRING = "" ; private final static String ID_INDEX_NAME = "##id" ; public void printInternalState ( ) { System . out . println ( "-------------------------------------" ) ; System . out . println ( "AbstractTranslet this = " + this ) ; System . out . println ( "pbase = " + pbase ) ; System . out . println ( "vframe = " + pframe ) ; System . out . println ( "paramsStack.size() = " + paramsStack . size ( ) ) ; System . out . println ( "namesArray.size = " + namesArray . length ) ; System . out . println ( "namespaceArray.size = " + namespaceArray . length ) ; System . out . println ( "" ) ; System . out . println ( "Total memory = " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; } public final DOMAdapter makeDOMAdapter ( DOM dom ) throws TransletException { return new DOMAdapter ( dom , namesArray , namespaceArray ) ; } protected int pbase = 0 , pframe = 0 ; protected ArrayList paramsStack = new ArrayList ( ) ; public final void pushParamFrame ( ) { paramsStack . add ( pframe , new Integer ( pbase ) ) ; pbase = ++ pframe ; } public final void popParamFrame ( ) { if ( pbase > 0 ) { final int oldpbase = ( ( Integer ) paramsStack . get ( -- pbase ) ) . intValue ( ) ; for ( int i = pframe - 1 ; i >= pbase ; i -- ) { paramsStack . remove ( i ) ; } pframe = pbase ; pbase = oldpbase ; } } public final Object addParameter ( String name , Object value ) { name = BasisLibrary . replace ( name , ".-" , new String [ ] { "$dot$" , "$dash$" } ) ; return addParameter ( name , value , false ) ; } public final Object addParameter ( String name , Object value , boolean isDefault ) { for ( int i = pframe - 1 ; i >= pbase ; i -- ) { final Parameter param = ( Parameter ) paramsStack . get ( i ) ; if ( param . _name . equals ( name ) ) { if ( param . _isDefault || ! isDefault ) { param . _value = value ; param . _isDefault = isDefault ; return value ; } return param . _value ; } } paramsStack . add ( pframe ++ , new Parameter ( name , value , isDefault ) ) ; return value ; } public void clearParameters ( ) { pbase = pframe = 0 ; paramsStack . clear ( ) ; } public final Object getParameter ( String name ) { for ( int i = pframe - 1 ; i >= pbase ; i -- ) { final Parameter param = ( Parameter ) paramsStack . get ( i ) ; if ( param . _name . equals ( name ) ) return param . _value ; } return null ; } private MessageHandler _msgHandler = null ; public final void setMessageHandler ( MessageHandler handler ) { _msgHandler = handler ; } public final void displayMessage ( String msg ) { if ( _msgHandler == null ) { System . err . println ( msg ) ; } else { _msgHandler . displayMessage ( msg ) ; } } public Hashtable _formatSymbols = null ; public void addDecimalFormat ( String name , DecimalFormatSymbols symbols ) { if ( _formatSymbols == null ) _formatSymbols = new Hashtable ( ) ; if ( name == null ) name = EMPTYSTRING ; final DecimalFormat df = new DecimalFormat ( ) ; if ( symbols != null ) { df . setDecimalFormatSymbols ( symbols ) ; } _formatSymbols . put ( name , df ) ; } public final DecimalFormat getDecimalFormat ( String name ) { if ( _formatSymbols != null ) { if ( name == null ) name = EMPTYSTRING ; DecimalFormat df = ( DecimalFormat ) _formatSymbols . get ( name ) ; if ( df == null ) df = ( DecimalFormat ) _formatSymbols . get ( EMPTYSTRING ) ; return df ; } return ( null ) ; } public final void prepassDocument ( DOM document ) { setIndexSize ( document . getSize ( ) ) ; buildIDIndex ( document ) ; } private final void buildIDIndex ( DOM document ) { if ( document instanceof SAXImpl ) { SAXImpl saxImpl = ( SAXImpl ) document ; if ( saxImpl . hasDOMSource ( ) ) { buildKeyIndex ( ID_INDEX_NAME , document ) ; return ; } else { final Hashtable elementsByID = saxImpl . getElementsWithIDs ( ) ; if ( elementsByID == null ) { return ; } final Enumeration idValues = elementsByID . keys ( ) ; boolean hasIDValues = false ; while ( idValues . hasMoreElements ( ) ) { final Object idValue = idValues . nextElement ( ) ; final int element = ( ( Integer ) elementsByID . get ( idValue ) ) . intValue ( ) ; buildKeyIndex ( ID_INDEX_NAME , element , idValue ) ; hasIDValues = true ; } if ( hasIDValues ) { setKeyIndexDom ( ID_INDEX_NAME , document ) ; } } } } private Hashtable _keyIndexes = null ; private KeyIndex _emptyKeyIndex = new KeyIndex ( 1 ) ; private int _indexSize = 0 ; public void setIndexSize ( int size ) { if ( size > _indexSize ) _indexSize = size ; } public KeyIndex createKeyIndex ( ) { return ( new KeyIndex ( _indexSize ) ) ; } public void buildKeyIndex ( String name , int node , Object value ) { if ( _keyIndexes == null ) _keyIndexes = new Hashtable ( ) ; KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) { _keyIndexes . put ( name , index = new KeyIndex ( _indexSize ) ) ; } index . add ( value , node ) ; } public void buildKeyIndex ( String name , DOM dom ) { if ( _keyIndexes == null ) _keyIndexes = new Hashtable ( ) ; KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) { _keyIndexes . put ( name , index = new KeyIndex ( _indexSize ) ) ; } index . setDom ( dom ) ; } public KeyIndex getKeyIndex ( String name ) { if ( _keyIndexes == null ) return ( _emptyKeyIndex ) ; final KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) return ( _emptyKeyIndex ) ; return ( index ) ; } public void buildKeys ( DOM document , DTMAxisIterator iterator , SerializationHandler handler , int root ) throws TransletException { } public void setKeyIndexDom ( String name , DOM document ) { getKeyIndex ( name ) . setDom ( document ) ; } private DOMCache _domCache = null ; public void setDOMCache ( DOMCache cache ) { _domCache = cache ; } public DOMCache getDOMCache ( ) { return ( _domCache ) ; } public SerializationHandler openOutputHandler ( String filename , boolean append ) throws TransletException { try { final TransletOutputHandlerFactory factory = TransletOutputHandlerFactory . newInstance ( ) ; factory . setEncoding ( _encoding ) ; factory . setOutputMethod ( _method ) ; factory . setWriter ( new FileWriter ( filename , append ) ) ; factory . setOutputType ( TransletOutputHandlerFactory . STREAM ) ; final SerializationHandler handler = factory . getSerializationHandler ( ) ; transferOutputSettings ( handler ) ; handler . startDocument ( ) ; return handler ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } public SerializationHandler openOutputHandler ( String filename ) throws TransletException { return openOutputHandler ( filename , false ) ; } public void closeOutputHandler ( SerializationHandler handler ) { try { handler . endDocument ( ) ; handler . close ( ) ; } catch ( Exception e ) { } } public abstract void transform ( DOM document , DTMAxisIterator iterator , SerializationHandler handler ) throws TransletException ; public final void transform ( DOM document , SerializationHandler handler ) throws TransletException { transform ( document , document . getIterator ( ) , handler ) ; } public final void characters ( final String string , SerializationHandler handler ) throws TransletException { if ( string != null ) { try { handler . characters ( string ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } } public void addCdataElement ( String name ) { if ( _cdata == null ) { _cdata = new Vector ( ) ; } int lastColon = name . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { String uri = name . substring ( 0 , lastColon ) ; String localName = name . substring ( lastColon + 1 ) ; _cdata . addElement ( uri ) ; _cdata . addElement ( localName ) ; } else { _cdata . addElement ( null ) ; _cdata . addElement ( name ) ; } } protected void transferOutputSettings ( SerializationHandler handler ) { if ( _method != null ) { if ( _method . equals ( "xml" ) ) { if ( _standalone != null ) { handler . setStandalone ( _standalone ) ; } if ( _omitHeader ) { handler . setOmitXMLDeclaration ( true ) ; } handler . setCdataSectionElements ( _cdata ) ; if ( _version != null ) { handler . setVersion ( _version ) ; } handler . setIndent ( _indent ) ; if ( _doctypeSystem != null ) { handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; } } else if ( _method . equals ( "html" ) ) { handler . setIndent ( _indent ) ; handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; if ( _mediaType != null ) { handler . setMediaType ( _mediaType ) ; } } } else { handler . setCdataSectionElements ( _cdata ) ; if ( _version != null ) { handler . setVersion ( _version ) ; } if ( _standalone != null ) { handler . setStandalone ( _standalone ) ; } if ( _omitHeader ) { handler . setOmitXMLDeclaration ( true ) ; } handler . setIndent ( _indent ) ; handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; } } private Hashtable _auxClasses = null ; public void addAuxiliaryClass ( Class auxClass ) { if ( _auxClasses == null ) _auxClasses = new Hashtable ( ) ; _auxClasses . put ( auxClass . getName ( ) , auxClass ) ; } public Class getAuxiliaryClass ( String className ) { if ( _auxClasses == null ) return null ; return ( ( Class ) _auxClasses . get ( className ) ) ; } public String [ ] getNamesArray ( ) { return namesArray ; } public String [ ] getNamespaceArray ( ) { return namespaceArray ; } public boolean hasIdCall ( ) { return _hasIdCall ; } } 	1
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncGenerateId extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int which = getArg0AsNode ( xctxt ) ; if ( DTM . NULL != which ) { return new XString ( "N" + Integer . toHexString ( which ) . toUpperCase ( ) ) ; } else return XString . EMPTYSTRING ; } } 	1
package org . apache . xml . dtm ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . XMLStringFactory ; public abstract class DTMManager { private static final String defaultPropName = "org.apache.xml.dtm.DTMManager" ; private static String defaultClassName = "org.apache.xml.dtm.ref.DTMManagerDefault" ; protected XMLStringFactory m_xsf = null ; protected DTMManager ( ) { } public XMLStringFactory getXMLStringFactory ( ) { return m_xsf ; } public void setXMLStringFactory ( XMLStringFactory xsf ) { m_xsf = xsf ; } public static DTMManager newInstance ( XMLStringFactory xsf ) throws DTMConfigurationException { DTMManager factoryImpl = null ; try { factoryImpl = ( DTMManager ) FactoryFinder . find ( defaultPropName , defaultClassName ) ; } catch ( FactoryFinder . ConfigurationError e ) { throw new DTMConfigurationException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DEFAULT_IMPL , null ) ) ; } if ( factoryImpl == null ) { throw new DTMConfigurationException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DEFAULT_IMPL , null ) ) ; } factoryImpl . setXMLStringFactory ( xsf ) ; return factoryImpl ; } public abstract DTM getDTM ( javax . xml . transform . Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) ; public abstract DTM getDTM ( int nodeHandle ) ; public abstract int getDTMHandleFromNode ( org . w3c . dom . Node node ) ; public abstract DTM createDocumentFragment ( ) ; public abstract boolean release ( DTM dtm , boolean shouldHardDelete ) ; public abstract DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) ; public abstract DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) ; public abstract DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) ; public abstract DTMIterator createDTMIterator ( int node ) ; public static boolean m_incremental = false ; public synchronized static boolean getIncremental ( ) { return m_incremental ; } public synchronized static void setIncremental ( boolean incremental ) { m_incremental = incremental ; } private static boolean debug ; static { try { debug = System . getProperty ( "dtm.debug" ) != null ; } catch ( SecurityException ex ) { } } public static final int IDENT_DTM_NODE_BITS = 16 ; public static final int IDENT_NODE_DEFAULT = ( 1 << IDENT_DTM_NODE_BITS ) - 1 ; public static final int IDENT_DTM_DEFAULT = ~ IDENT_NODE_DEFAULT ; public static final int IDENT_MAX_DTMS = ( IDENT_DTM_DEFAULT > > > IDENT_DTM_NODE_BITS ) + 1 ; public abstract int getDTMIdentity ( DTM dtm ) ; public int getDTMIdentityMask ( ) { return IDENT_DTM_DEFAULT ; } public int getNodeIdentityMask ( ) { return IDENT_NODE_DEFAULT ; } } 	0
package org . apache . xalan . xsltc ; public class ProcessorVersion { private static int MAJOR = 1 ; private static int MINOR = 0 ; private static int DELTA = 0 ; public static void main ( String [ ] args ) { System . out . println ( "XSLTC version " + MAJOR + "." + MINOR + ( ( DELTA > 0 ) ? ( "." + DELTA ) : ( "" ) ) ) ; } } 	0
package org . apache . xpath . objects ; public class XBooleanStatic extends XBoolean { boolean m_val ; public XBooleanStatic ( boolean b ) { super ( b ) ; m_val = b ; } public boolean equals ( XObject obj2 ) { try { return m_val == obj2 . bool ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1
package org . apache . xalan . transformer ; public interface TransformerClient { void setTransformState ( TransformState ts ) ; } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncStartsWith extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . xstr ( ) . startsWith ( m_arg1 . execute ( xctxt ) . xstr ( ) ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	1
package org . apache . xalan . lib . sql ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMDefaultBaseIterators ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . XMLString ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; public class DTMDocument extends DTMDefaultBaseIterators { public interface CharacterNodeHandler { public void characters ( Node node ) throws org . xml . sax . SAXException ; } private boolean DEBUG = false ; protected static final String S_NAMESPACE = "http://xml.apache.org/xalan/SQLExtension" ; protected static final String S_ATTRIB_NOT_SUPPORTED = "Not Supported" ; protected static final String S_ISTRUE = "true" ; protected static final String S_ISFALSE = "false" ; protected static final String S_DOCUMENT = "#root" ; protected static final String S_TEXT_NODE = "#text" ; protected static final String S_ELEMENT_NODE = "#element" ; protected int m_Document_TypeID = 0 ; protected int m_TextNode_TypeID = 0 ; protected ObjectArray m_ObjectArray = new ObjectArray ( ) ; protected SuballocatedIntVector m_attribute ; protected int m_DocumentIdx ; public DTMDocument ( DTMManager mgr , int ident ) { super ( mgr , null , ident , null , mgr . getXMLStringFactory ( ) , true ) ; m_attribute = new SuballocatedIntVector ( DEFAULT_BLOCKSIZE ) ; } private int allocateNodeObject ( Object o ) { m_size ++ ; return m_ObjectArray . append ( o ) ; } protected int addElementWithData ( Object o , int level , int extendedType , int parent , int prevsib ) { int elementIdx = addElement ( level , extendedType , parent , prevsib ) ; int data = allocateNodeObject ( o ) ; m_firstch . setElementAt ( data , elementIdx ) ; m_exptype . setElementAt ( m_TextNode_TypeID , data ) ; m_parent . setElementAt ( elementIdx , data ) ; m_prevsib . setElementAt ( DTM . NULL , data ) ; m_nextsib . setElementAt ( DTM . NULL , data ) ; m_attribute . setElementAt ( DTM . NULL , data ) ; m_firstch . setElementAt ( DTM . NULL , data ) ; return elementIdx ; } protected int addElement ( int level , int extendedType , int parent , int prevsib ) { int node = DTM . NULL ; try { node = allocateNodeObject ( S_ELEMENT_NODE ) ; m_exptype . setElementAt ( extendedType , node ) ; m_nextsib . setElementAt ( DTM . NULL , node ) ; m_prevsib . setElementAt ( prevsib , node ) ; m_parent . setElementAt ( parent , node ) ; m_firstch . setElementAt ( DTM . NULL , node ) ; m_attribute . setElementAt ( DTM . NULL , node ) ; if ( prevsib != DTM . NULL ) { if ( m_nextsib . elementAt ( prevsib ) != DTM . NULL ) m_nextsib . setElementAt ( m_nextsib . elementAt ( prevsib ) , node ) ; m_nextsib . setElementAt ( node , prevsib ) ; } if ( ( parent != DTM . NULL ) && ( m_prevsib . elementAt ( node ) == DTM . NULL ) ) { m_firstch . setElementAt ( node , parent ) ; } } catch ( Exception e ) { error ( "Error in addElement: " + e . getMessage ( ) ) ; } return node ; } protected int addAttributeToNode ( Object o , int extendedType , int pnode ) { int attrib = DTM . NULL ; int prevsib = DTM . NULL ; int lastattrib = DTM . NULL ; int value = DTM . NULL ; try { attrib = allocateNodeObject ( o ) ; m_attribute . setElementAt ( DTM . NULL , attrib ) ; m_exptype . setElementAt ( extendedType , attrib ) ; m_nextsib . setElementAt ( DTM . NULL , attrib ) ; m_prevsib . setElementAt ( DTM . NULL , attrib ) ; m_parent . setElementAt ( pnode , attrib ) ; m_firstch . setElementAt ( DTM . NULL , attrib ) ; if ( m_attribute . elementAt ( pnode ) != DTM . NULL ) { lastattrib = m_attribute . elementAt ( pnode ) ; m_nextsib . setElementAt ( lastattrib , attrib ) ; m_prevsib . setElementAt ( attrib , lastattrib ) ; } m_attribute . setElementAt ( attrib , pnode ) ; } catch ( Exception e ) { error ( "Error in addAttributeToNode: " + e . getMessage ( ) ) ; } return attrib ; } protected void cloneAttributeFromNode ( int toNode , int fromNode ) { try { if ( m_attribute . elementAt ( toNode ) != DTM . NULL ) { error ( "Cloneing Attributes, where from Node already had addtibures assigned" ) ; } m_attribute . setElementAt ( m_attribute . elementAt ( fromNode ) , toNode ) ; } catch ( Exception e ) { error ( "Cloning attributes" ) ; } } public int getFirstAttribute ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstAttribute(" + parm1 + ")" ) ; int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( nodeIdx != DTM . NULL ) { int attribIdx = m_attribute . elementAt ( nodeIdx ) ; return makeNodeHandle ( attribIdx ) ; } else return DTM . NULL ; } public String getNodeValue ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeValue(" + parm1 + ")" ) ; try { Object o = m_ObjectArray . getAt ( makeNodeIdentity ( parm1 ) ) ; if ( o != null && o != S_ELEMENT_NODE ) { return o . toString ( ) ; } else { return "" ; } } catch ( Exception e ) { error ( "Getting String Value" ) ; return null ; } } public XMLString getStringValue ( int nodeHandle ) { int nodeIdx = makeNodeIdentity ( nodeHandle ) ; if ( DEBUG ) System . out . println ( "getStringValue(" + nodeIdx + ")" ) ; Object o = m_ObjectArray . getAt ( nodeIdx ) ; if ( o == S_ELEMENT_NODE ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( nodeIdx , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return m_xstrf . newstr ( s ) ; } else if ( o != null ) { return m_xstrf . newstr ( o . toString ( ) ) ; } else return ( m_xstrf . emptystr ( ) ) ; } protected void getNodeData ( int nodeIdx , FastStringBuffer buf ) { for ( int child = _firstch ( nodeIdx ) ; child != DTM . NULL ; child = _nextsib ( child ) ) { Object o = m_ObjectArray . getAt ( child ) ; if ( o == S_ELEMENT_NODE ) getNodeData ( child , buf ) ; else if ( o != null ) buf . append ( o . toString ( ) ) ; } } public int getNextAttribute ( int parm1 ) { int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( DEBUG ) System . out . println ( "getNextAttribute(" + nodeIdx + ")" ) ; if ( nodeIdx != DTM . NULL ) return makeNodeHandle ( m_nextsib . elementAt ( nodeIdx ) ) ; else return DTM . NULL ; } protected int getNumberOfNodes ( ) { if ( DEBUG ) System . out . println ( "getNumberOfNodes()" ) ; return m_size ; } protected boolean nextNode ( ) { if ( DEBUG ) System . out . println ( "nextNode()" ) ; return false ; } protected void createExpandedNameTable ( ) { m_Document_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DOCUMENT , DTM . DOCUMENT_NODE ) ; m_TextNode_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_TEXT_NODE , DTM . TEXT_NODE ) ; } public void dumpDTM ( ) { try { File f = new File ( "DTMDump.txt" ) ; System . err . println ( "Dumping... " + f . getAbsolutePath ( ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( f ) ) ; while ( nextNode ( ) ) { } int nRecords = m_size ; ps . println ( "Total nodes: " + nRecords ) ; for ( int i = 0 ; i < nRecords ; i ++ ) { ps . println ( "=========== " + i + " ===========" ) ; ps . println ( "NodeName: " + getNodeName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NodeNameX: " + getNodeNameX ( makeNodeHandle ( i ) ) ) ; ps . println ( "LocalName: " + getLocalName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NamespaceURI: " + getNamespaceURI ( makeNodeHandle ( i ) ) ) ; ps . println ( "Prefix: " + getPrefix ( makeNodeHandle ( i ) ) ) ; int exTypeID = getExpandedTypeID ( makeNodeHandle ( i ) ) ; ps . println ( "Expanded Type ID: " + Integer . toHexString ( exTypeID ) ) ; int type = getNodeType ( makeNodeHandle ( i ) ) ; String typestring ; switch ( type ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTRIBUTE_NODE" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA_SECTION_NODE" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT_NODE" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOCUMENT_FRAGMENT_NODE" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT_NODE" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY_NODE" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENTITY_REFERENCE_NODE" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE_NODE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION_NODE" ; break ; case DTM . NULL : typestring = "NULL" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PROCESSING_INSTRUCTION_NODE" ; break ; case DTM . TEXT_NODE : typestring = "TEXT_NODE" ; break ; default : typestring = "Unknown!" ; break ; } ps . println ( "Type: " + typestring ) ; int firstChild = _firstch ( i ) ; if ( DTM . NULL == firstChild ) ps . println ( "First child: DTM.NULL" ) ; else if ( NOTPROCESSED == firstChild ) ps . println ( "First child: NOTPROCESSED" ) ; else ps . println ( "First child: " + firstChild ) ; int prevSibling = _prevsib ( i ) ; if ( DTM . NULL == prevSibling ) ps . println ( "Prev sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == prevSibling ) ps . println ( "Prev sibling: NOTPROCESSED" ) ; else ps . println ( "Prev sibling: " + prevSibling ) ; int nextSibling = _nextsib ( i ) ; if ( DTM . NULL == nextSibling ) ps . println ( "Next sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == nextSibling ) ps . println ( "Next sibling: NOTPROCESSED" ) ; else ps . println ( "Next sibling: " + nextSibling ) ; int parent = _parent ( i ) ; if ( DTM . NULL == parent ) ps . println ( "Parent: DTM.NULL" ) ; else if ( NOTPROCESSED == parent ) ps . println ( "Parent: NOTPROCESSED" ) ; else ps . println ( "Parent: " + parent ) ; int level = _level ( i ) ; ps . println ( "Level: " + level ) ; ps . println ( "Node Value: " + getNodeValue ( i ) ) ; ps . println ( "String Value: " + getStringValue ( i ) ) ; ps . println ( "First Attribute Node: " + m_attribute . elementAt ( i ) ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } } protected static void dispatchNodeData ( Node node , ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } protected int getNextNodeIdentity ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextNodeIdenty(" + parm1 + ")" ) ; return DTM . NULL ; } public int getAttributeNode ( int parm1 , String parm2 , String parm3 ) { if ( DEBUG ) { System . out . println ( "getAttributeNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return DTM . NULL ; } public String getLocalName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public String getNodeName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public boolean isAttributeSpecified ( int parm1 ) { if ( DEBUG ) System . out . println ( "isAttributeSpecified(" + parm1 + ")" ) ; return false ; } public String getUnparsedEntityURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "getUnparsedEntityURI(" + parm1 + ")" ) ; return "" ; } public DTDHandler getDTDHandler ( ) { if ( DEBUG ) System . out . println ( "getDTDHandler()" ) ; return null ; } public String getPrefix ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrefix(" + parm1 + ")" ) ; return "" ; } public EntityResolver getEntityResolver ( ) { if ( DEBUG ) System . out . println ( "getEntityResolver()" ) ; return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD_PubId()" ) ; return "" ; } public LexicalHandler getLexicalHandler ( ) { if ( DEBUG ) System . out . println ( "getLexicalHandler()" ) ; return null ; } public boolean needsTwoThreads ( ) { if ( DEBUG ) System . out . println ( "needsTwoThreads()" ) ; return false ; } public ContentHandler getContentHandler ( ) { if ( DEBUG ) System . out . println ( "getContentHandler()" ) ; return null ; } public void dispatchToEvents ( int parm1 , ContentHandler parm2 ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispathcToEvents(" + parm1 + "," + parm2 + ")" ) ; } return ; } public String getNamespaceURI ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceURI(" + parm1 + ")" ) ; return "" ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispatchCharacterEvents(" + nodeHandle + "," + ch + "," + normalize + ")" ) ; } if ( normalize ) { XMLString str = getStringValue ( nodeHandle ) ; str = str . fixWhiteSpace ( true , true , false ) ; str . dispatchCharactersEvents ( ch ) ; } else { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; dispatchNodeData ( node , ch , 0 ) ; } } public boolean supportsPreStripping ( ) { if ( DEBUG ) System . out . println ( "supportsPreStripping()" ) ; return super . supportsPreStripping ( ) ; } protected int _exptype ( int parm1 ) { if ( DEBUG ) System . out . println ( "_exptype(" + parm1 + ")" ) ; return super . _exptype ( parm1 ) ; } protected SuballocatedIntVector findNamespaceContext ( int parm1 ) { if ( DEBUG ) System . out . println ( "SuballocatedIntVector(" + parm1 + ")" ) ; return super . findNamespaceContext ( parm1 ) ; } protected int _prevsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_prevsib(" + parm1 + ")" ) ; return super . _prevsib ( parm1 ) ; } protected short _type ( int parm1 ) { if ( DEBUG ) System . out . println ( "_type(" + parm1 + ")" ) ; return super . _type ( parm1 ) ; } public Node getNode ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNode(" + parm1 + ")" ) ; return super . getNode ( parm1 ) ; } public int getPreviousSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrevSib(" + parm1 + ")" ) ; return super . getPreviousSibling ( parm1 ) ; } public String getDocumentStandalone ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDOcStandAlone(" + parm1 + ")" ) ; return super . getDocumentStandalone ( parm1 ) ; } public String getNodeNameX ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeNameX(" + parm1 + ")" ) ; return getNodeName ( parm1 ) ; } public void setFeature ( String parm1 , boolean parm2 ) { if ( DEBUG ) { System . out . println ( "setFeature(" + parm1 + "," + parm2 + ")" ) ; } super . setFeature ( parm1 , parm2 ) ; } protected int _parent ( int parm1 ) { if ( DEBUG ) System . out . println ( "_parent(" + parm1 + ")" ) ; return super . _parent ( parm1 ) ; } protected void indexNode ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "indexNode(" + parm1 + "," + parm2 + ")" ) ; super . indexNode ( parm1 , parm2 ) ; } protected boolean getShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "getShouldStripWS()" ) ; return super . getShouldStripWhitespace ( ) ; } protected void popShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "popShouldStripWS()" ) ; super . popShouldStripWhitespace ( ) ; } public boolean isNodeAfter ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "isNodeAfter(" + parm1 + "," + parm2 + ")" ) ; return super . isNodeAfter ( parm1 , parm2 ) ; } public int getNamespaceType ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceType(" + parm1 + ")" ) ; return super . getNamespaceType ( parm1 ) ; } protected int _level ( int parm1 ) { if ( DEBUG ) System . out . println ( "_level(" + parm1 + ")" ) ; return super . _level ( parm1 ) ; } protected void pushShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "push_ShouldStripWS(" + parm1 + ")" ) ; super . pushShouldStripWhitespace ( parm1 ) ; } public String getDocumentVersion ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocVer(" + parm1 + ")" ) ; return super . getDocumentVersion ( parm1 ) ; } public boolean isSupported ( String parm1 , String parm2 ) { if ( DEBUG ) System . out . println ( "isSupported(" + parm1 + "," + parm2 + ")" ) ; return super . isSupported ( parm1 , parm2 ) ; } protected void setShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "set_ShouldStripWS(" + parm1 + ")" ) ; super . setShouldStripWhitespace ( parm1 ) ; } protected void ensureSizeOfIndex ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "ensureSizeOfIndex(" + parm1 + "," + parm2 + ")" ) ; super . ensureSizeOfIndex ( parm1 , parm2 ) ; } protected void ensureSize ( int parm1 ) { if ( DEBUG ) System . out . println ( "ensureSize(" + parm1 + ")" ) ; } public String getDocumentEncoding ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocumentEncoding(" + parm1 + ")" ) ; return super . getDocumentEncoding ( parm1 ) ; } public void appendChild ( int parm1 , boolean parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "appendChild(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } super . appendChild ( parm1 , parm2 , parm3 ) ; } public short getLevel ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLevel(" + parm1 + ")" ) ; return super . getLevel ( parm1 ) ; } public String getDocumentBaseURI ( ) { if ( DEBUG ) System . out . println ( "getDocBaseURI()" ) ; return super . getDocumentBaseURI ( ) ; } public int getNextNamespaceNode ( int parm1 , int parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "getNextNamesapceNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . getNextNamespaceNode ( parm1 , parm2 , parm3 ) ; } public void appendTextChild ( String parm1 ) { if ( DEBUG ) System . out . println ( "appendTextChild(" + parm1 + ")" ) ; super . appendTextChild ( parm1 ) ; } protected int findGTE ( int [ ] parm1 , int parm2 , int parm3 , int parm4 ) { if ( DEBUG ) { System . out . println ( "findGTE(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . findGTE ( parm1 , parm2 , parm3 , parm4 ) ; } public int getFirstNamespaceNode ( int parm1 , boolean parm2 ) { if ( DEBUG ) System . out . println ( "getFirstNamespaceNode()" ) ; return super . getFirstNamespaceNode ( parm1 , parm2 ) ; } public int getStringValueChunkCount ( int parm1 ) { if ( DEBUG ) System . out . println ( "getStringChunkCount(" + parm1 + ")" ) ; return super . getStringValueChunkCount ( parm1 ) ; } public int getLastChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLastChild(" + parm1 + ")" ) ; return super . getLastChild ( parm1 ) ; } public boolean hasChildNodes ( int parm1 ) { if ( DEBUG ) System . out . println ( "hasChildNodes(" + parm1 + ")" ) ; return super . hasChildNodes ( parm1 ) ; } public short getNodeType ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNodeType(" + parm1 + ") " ) ; int exID = getExpandedTypeID ( parm1 ) ; String name = getLocalNameFromExpandedNameID ( exID ) ; System . out . println ( ".. Node name [" + name + "]" + "[" + getNodeType ( parm1 ) + "]" ) ; DEBUG = true ; } return super . getNodeType ( parm1 ) ; } public boolean isCharacterElementContentWhitespace ( int parm1 ) { if ( DEBUG ) System . out . println ( "isCharacterElementContentWhitespace(" + parm1 + ")" ) ; return super . isCharacterElementContentWhitespace ( parm1 ) ; } public int getFirstChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstChild(" + parm1 + ")" ) ; return super . getFirstChild ( parm1 ) ; } public String getDocumentSystemIdentifier ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocSysID(" + parm1 + ")" ) ; return super . getDocumentSystemIdentifier ( parm1 ) ; } protected void declareNamespaceInContext ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "declareNamespaceContext(" + parm1 + "," + parm2 + ")" ) ; super . declareNamespaceInContext ( parm1 , parm2 ) ; } public String getNamespaceFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNamespaceFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getNamespaceFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getNamespaceFromExpandedNameID ( parm1 ) ; } public String getLocalNameFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalNameFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getLocalNameFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getLocalNameFromExpandedNameID ( parm1 ) ; } public int getExpandedTypeID ( int parm1 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID(" + parm1 + ")" ) ; return super . getExpandedTypeID ( parm1 ) ; } public int getDocument ( ) { if ( DEBUG ) System . out . println ( "getDocument()" ) ; return super . getDocument ( ) ; } protected int findInSortedSuballocatedIntVector ( SuballocatedIntVector parm1 , int parm2 ) { if ( DEBUG ) { System . out . println ( "findInSortedSubAlloctedVector(" + parm1 + "," + parm2 + ")" ) ; } return super . findInSortedSuballocatedIntVector ( parm1 , parm2 ) ; } public boolean isDocumentAllDeclarationsProcessed ( int parm1 ) { if ( DEBUG ) System . out . println ( "isDocumentAllDeclProc(" + parm1 + ")" ) ; return super . isDocumentAllDeclarationsProcessed ( parm1 ) ; } protected void error ( String parm1 ) { if ( DEBUG ) System . out . println ( "error(" + parm1 + ")" ) ; super . error ( parm1 ) ; } protected int _firstch ( int parm1 ) { if ( DEBUG ) System . out . println ( "_firstch(" + parm1 + ")" ) ; return super . _firstch ( parm1 ) ; } public int getOwnerDocument ( int parm1 ) { if ( DEBUG ) System . out . println ( "getOwnerDoc(" + parm1 + ")" ) ; return super . getOwnerDocument ( parm1 ) ; } protected int _nextsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_nextSib(" + parm1 + ")" ) ; return super . _nextsib ( parm1 ) ; } public int getNextSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextSibling(" + parm1 + ")" ) ; return super . getNextSibling ( parm1 ) ; } public boolean getDocumentAllDeclarationsProcessed ( ) { if ( DEBUG ) System . out . println ( "getDocAllDeclProc()" ) ; return super . getDocumentAllDeclarationsProcessed ( ) ; } public int getParent ( int parm1 ) { if ( DEBUG ) System . out . println ( "getParent(" + parm1 + ")" ) ; return super . getParent ( parm1 ) ; } public int getExpandedTypeID ( String parm1 , String parm2 , int parm3 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID()" ) ; return super . getExpandedTypeID ( parm1 , parm2 , parm3 ) ; } public void setDocumentBaseURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "setDocBaseURI()" ) ; super . setDocumentBaseURI ( parm1 ) ; } public char [ ] getStringValueChunk ( int parm1 , int parm2 , int [ ] parm3 ) { if ( DEBUG ) { System . out . println ( "getStringChunkValue(" + parm1 + "," + parm2 + ")" ) ; } return super . getStringValueChunk ( parm1 , parm2 , parm3 ) ; } public DTMAxisTraverser getAxisTraverser ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxixTraverser(" + parm1 + ")" ) ; return super . getAxisTraverser ( parm1 ) ; } public DTMAxisIterator getTypedAxisIterator ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "getTypedAxisIterator(" + parm1 + "," + parm2 + ")" ) ; return super . getTypedAxisIterator ( parm1 , parm2 ) ; } public DTMAxisIterator getAxisIterator ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxisIterator(" + parm1 + ")" ) ; return super . getAxisIterator ( parm1 ) ; } public int getElementById ( String parm1 ) { if ( DEBUG ) System . out . println ( "getElementByID(" + parm1 + ")" ) ; return DTM . NULL ; } public DeclHandler getDeclHandler ( ) { if ( DEBUG ) System . out . println ( "getDeclHandler()" ) ; return null ; } public ErrorHandler getErrorHandler ( ) { if ( DEBUG ) System . out . println ( "getErrorHandler()" ) ; return null ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD-SID()" ) ; return null ; } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class String extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { return ( XString ) right . xstr ( ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import java . util . ArrayList ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . FilterGenerator ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NumberType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Predicate extends Expression implements Closure { private Expression _exp = null ; private boolean _nthPositionFilter = false ; private boolean _nthDescendant = false ; private boolean _canOptimize = true ; private int _ptype = - 1 ; private String _className = null ; private ArrayList _closureVars = null ; private Closure _parentClosure = null ; public Predicate ( Expression exp ) { ( _exp = exp ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _exp . setParser ( parser ) ; } public boolean isNthDescendant ( ) { return _nthDescendant ; } public boolean isNthPositionFilter ( ) { return _nthPositionFilter ; } public void dontOptimize ( ) { _canOptimize = false ; } public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { if ( _parentClosure == null ) { SyntaxTreeNode node = getParent ( ) ; do { if ( node instanceof Closure ) { _parentClosure = ( Closure ) node ; break ; } if ( node instanceof TopLevelElement ) { break ; } node = node . getParent ( ) ; } while ( node != null ) ; } return _parentClosure ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; Closure parentClosure = getParentClosure ( ) ; if ( parentClosure != null ) { parentClosure . addVariable ( variableRef ) ; } } } public int getPosType ( ) { if ( _ptype == - 1 ) { SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof StepPattern ) { _ptype = ( ( StepPattern ) parent ) . getNodeType ( ) ; } else if ( parent instanceof AbsoluteLocationPath ) { AbsoluteLocationPath path = ( AbsoluteLocationPath ) parent ; Expression exp = path . getPath ( ) ; if ( exp instanceof Step ) { _ptype = ( ( Step ) exp ) . getNodeType ( ) ; } } else if ( parent instanceof VariableRefBase ) { final VariableRefBase ref = ( VariableRefBase ) parent ; final VariableBase var = ref . getVariable ( ) ; final Expression exp = var . getExpression ( ) ; if ( exp instanceof Step ) { _ptype = ( ( Step ) exp ) . getNodeType ( ) ; } } else if ( parent instanceof Step ) { _ptype = ( ( Step ) parent ) . getNodeType ( ) ; } } return _ptype ; } public boolean parentIsPattern ( ) { return ( getParent ( ) instanceof Pattern ) ; } public Expression getExpr ( ) { return _exp ; } public String toString ( ) { if ( isNthPositionFilter ( ) ) return "pred([" + _exp + "]," + getPosType ( ) + ")" ; else return "pred(" + _exp + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type texp = _exp . typeCheck ( stable ) ; if ( texp instanceof ReferenceType ) { _exp = new CastExpr ( _exp , texp = Type . Real ) ; } if ( texp instanceof ResultTreeType ) { _exp = new CastExpr ( _exp , Type . Boolean ) ; _exp = new CastExpr ( _exp , Type . Real ) ; texp = _exp . typeCheck ( stable ) ; } if ( texp instanceof NumberType ) { if ( texp instanceof IntType == false ) { _exp = new CastExpr ( _exp , Type . Int ) ; } SyntaxTreeNode parent = getParent ( ) ; if ( ( _exp instanceof LastCall ) || ( parent instanceof Pattern ) || ( parent instanceof FilterExpr ) ) { if ( parent instanceof Pattern && ! ( _exp instanceof LastCall ) ) { _nthPositionFilter = _canOptimize ; } else if ( parent instanceof FilterExpr ) { FilterExpr filter = ( FilterExpr ) parent ; Expression fexp = filter . getExpr ( ) ; if ( fexp instanceof KeyCall ) _canOptimize = false ; else if ( fexp instanceof VariableRefBase ) _canOptimize = false ; else if ( fexp instanceof ParentLocationPath ) _canOptimize = false ; else if ( fexp instanceof UnionPathExpr ) _canOptimize = false ; else if ( _exp . hasPositionCall ( ) && _exp . hasLastCall ( ) ) _canOptimize = false ; else if ( filter . getParent ( ) instanceof FilterParentPath ) _canOptimize = false ; if ( _canOptimize ) _nthPositionFilter = true ; } if ( _nthPositionFilter ) { return _type = Type . NodeSet ; } else { final QName position = getParser ( ) . getQNameIgnoreDefaultNs ( "position" ) ; final PositionCall positionCall = new PositionCall ( position ) ; positionCall . setParser ( getParser ( ) ) ; positionCall . setParent ( this ) ; _exp = new EqualityExpr ( EqualityExpr . EQ , positionCall , _exp ) ; if ( _exp . typeCheck ( stable ) != Type . Boolean ) { _exp = new CastExpr ( _exp , Type . Boolean ) ; } return _type = Type . Boolean ; } } else { if ( ( parent != null ) && ( parent instanceof Step ) ) { parent = parent . getParent ( ) ; if ( ( parent != null ) && ( parent instanceof AbsoluteLocationPath ) ) { _nthDescendant = true ; return _type = Type . NodeSet ; } } _nthPositionFilter = true ; return _type = Type . NodeSet ; } } else if ( texp instanceof BooleanType ) { if ( _exp . hasPositionCall ( ) ) _nthPositionFilter = true ; } else { _exp = new CastExpr ( _exp , Type . Boolean ) ; } _nthPositionFilter = false ; return _type = Type . Boolean ; } private void compileFilter ( ClassGenerator classGen , MethodGenerator methodGen ) { TestGenerator testGen ; LocalVariableGen local ; FilterGenerator filterGen ; _className = getXSLTC ( ) . getHelperClassName ( ) ; filterGen = new FilterGenerator ( _className , "java.lang.Object" , toString ( ) , ACC_PUBLIC | ACC_SUPER , new String [ ] { CURRENT_NODE_LIST_FILTER } , classGen . getStylesheet ( ) ) ; final ConstantPoolGen cpg = filterGen . getConstantPool ( ) ; final int length = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableBase var = ( ( VariableRefBase ) _closureVars . get ( i ) ) . getVariable ( ) ; filterGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; } final InstructionList il = new InstructionList ( ) ; testGen = new TestGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , Util . getJCRefType ( TRANSLET_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) } , new String [ ] { "node" , "position" , "last" , "current" , "translet" , "iterator" } , "test" , _className , il , cpg ) ; local = testGen . addLocalVariable ( "document" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; final String className = classGen . getClassName ( ) ; il . append ( filterGen . loadTranslet ( ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , DOM_FIELD , DOM_INTF_SIG ) ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; testGen . setDomIndex ( local . getIndex ( ) ) ; _exp . translate ( filterGen , testGen ) ; il . append ( IRETURN ) ; testGen . stripAttributes ( true ) ; testGen . setMaxLocals ( ) ; testGen . setMaxStack ( ) ; testGen . removeNOPs ( ) ; filterGen . addEmptyConstructor ( ACC_PUBLIC ) ; filterGen . addMethod ( testGen . getMethod ( ) ) ; getXSLTC ( ) . dumpClass ( filterGen . getJavaClass ( ) ) ; } public boolean isBooleanTest ( ) { return ( _exp instanceof BooleanExpr ) ; } public boolean isNodeValueTest ( ) { if ( ! _canOptimize ) return false ; return ( getStep ( ) != null && getCompareValue ( ) != null ) ; } private Expression _value = null ; private Step _step = null ; public Expression getCompareValue ( ) { if ( _value != null ) return _value ; if ( _exp == null ) return null ; if ( _exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr ) _exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; Type tleft = left . getType ( ) ; Type tright = right . getType ( ) ; if ( left instanceof CastExpr ) left = ( ( CastExpr ) left ) . getExpr ( ) ; if ( right instanceof CastExpr ) right = ( ( CastExpr ) right ) . getExpr ( ) ; try { if ( ( tleft == Type . String ) && ( ! ( left instanceof Step ) ) ) _value = exp . getLeft ( ) ; if ( left instanceof VariableRefBase ) _value = new CastExpr ( left , Type . String ) ; if ( _value != null ) return _value ; } catch ( TypeCheckError e ) { } try { if ( ( tright == Type . String ) && ( ! ( right instanceof Step ) ) ) _value = exp . getRight ( ) ; if ( right instanceof VariableRefBase ) _value = new CastExpr ( right , Type . String ) ; if ( _value != null ) return _value ; } catch ( TypeCheckError e ) { } } return null ; } public Step getStep ( ) { if ( _step != null ) return _step ; if ( _exp == null ) return null ; if ( _exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr ) _exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; if ( left instanceof CastExpr ) left = ( ( CastExpr ) left ) . getExpr ( ) ; if ( left instanceof Step ) _step = ( Step ) left ; if ( right instanceof CastExpr ) right = ( ( CastExpr ) right ) . getExpr ( ) ; if ( right instanceof Step ) _step = ( Step ) right ; } return _step ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _nthPositionFilter || _nthDescendant ) { _exp . translate ( classGen , methodGen ) ; } else if ( isNodeValueTest ( ) && ( getParent ( ) instanceof Step ) ) { _value . translate ( classGen , methodGen ) ; il . append ( new CHECKCAST ( cpg . addClass ( STRING_CLASS ) ) ) ; il . append ( new PUSH ( cpg , ( ( EqualityExpr ) _exp ) . getOp ( ) ) ) ; } else { translateFilter ( classGen , methodGen ) ; } } public void translateFilter ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; compileFilter ( classGen , methodGen ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( _className , "<init>" , "()V" ) ) ) ; final int length = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableRefBase varRef = ( VariableRefBase ) _closureVars . get ( i ) ; VariableBase var = varRef . getVariable ( ) ; Type varType = var . getType ( ) ; il . append ( DUP ) ; Closure variableClosure = _parentClosure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } else { il . append ( var . loadInstruction ( ) ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( _className , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } } } 	1
package org . apache . xml . dtm ; public interface DTMIterator { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public DTM getDTM ( int nodeHandle ) ; public DTMManager getDTMManager ( ) ; public int getRoot ( ) ; public void setRoot ( int nodeHandle , Object environment ) ; public void reset ( ) ; public int getWhatToShow ( ) ; public boolean getExpandEntityReferences ( ) ; public int nextNode ( ) ; public int previousNode ( ) ; public void detach ( ) ; public void allowDetachToRelease ( boolean allowRelease ) ; public int getCurrentNode ( ) ; public boolean isFresh ( ) ; public void setShouldCacheNodes ( boolean b ) ; public boolean isMutable ( ) ; public int getCurrentPos ( ) ; public void runTo ( int index ) ; public void setCurrentPos ( int i ) ; public int item ( int index ) ; public void setItem ( int node , int index ) ; public int getLength ( ) ; public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException ; public Object clone ( ) throws CloneNotSupportedException ; public boolean isDocOrdered ( ) ; public int getAxis ( ) ; } 	0
package org . apache . xml . utils ; public class StringBufferPool { private static ObjectPool m_stringBufPool = new ObjectPool ( org . apache . xml . utils . FastStringBuffer . class ) ; public synchronized static FastStringBuffer get ( ) { return ( FastStringBuffer ) m_stringBufPool . getInstance ( ) ; } public synchronized static void free ( FastStringBuffer sb ) { sb . setLength ( 0 ) ; m_stringBufPool . freeInstance ( sb ) ; } } 	1
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPathContext ; public class AVTPartSimple extends AVTPart { private String m_val ; public AVTPartSimple ( String val ) { m_val = val ; } public String getSimpleString ( ) { return m_val ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } public void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) { buf . append ( m_val ) ; } public void callVisitors ( XSLTVisitor visitor ) { } } 	1
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . compiler . SourceLoader ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . runtime . TransletLoader ; import org . xml . sax . InputSource ; import org . xml . sax . XMLFilter ; import org . xml . sax . XMLReader ; public class TransformerFactoryImpl extends SAXTransformerFactory implements SourceLoader , ErrorListener { public final static String TRANSLET_NAME = "translet-name" ; public final static String DESTINATION_DIRECTORY = "destination-directory" ; public final static String PACKAGE_NAME = "package-name" ; public final static String JAR_NAME = "jar-name" ; public final static String GENERATE_TRANSLET = "generate-translet" ; public final static String AUTO_TRANSLET = "auto-translet" ; public final static String USE_CLASSPATH = "use-classpath" ; public final static String DEBUG = "debug" ; public final static String ENABLE_INLINING = "enable-inlining" ; public final static String INDENT_NUMBER = "indent-number" ; private ErrorListener _errorListener = this ; private URIResolver _uriResolver = null ; protected static String DEFAULT_TRANSLET_NAME = "GregorSamsa" ; private String _transletName = DEFAULT_TRANSLET_NAME ; private String _destinationDirectory = null ; private String _packageName = null ; private String _jarFileName = null ; private Hashtable _piParams = null ; static ThreadLocal _xmlReader = new ThreadLocal ( ) ; private static class PIParamWrapper { public String _media = null ; public String _title = null ; public String _charset = null ; public PIParamWrapper ( String media , String title , String charset ) { _media = media ; _title = title ; _charset = charset ; } } private boolean _debug = false ; private boolean _enableInlining = false ; private boolean _generateTranslet = false ; private boolean _autoTranslet = false ; private boolean _useClasspath = false ; private int _indentNumber = - 1 ; private SAXParserFactory _parserFactory = null ; public TransformerFactoryImpl ( ) { } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ERROR_LISTENER_NULL_ERR , "TransformerFactory" ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _errorListener = listener ; } public ErrorListener getErrorListener ( ) { return _errorListener ; } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( TRANSLET_NAME ) ) { return _transletName ; } else if ( name . equals ( GENERATE_TRANSLET ) ) { return new Boolean ( _generateTranslet ) ; } else if ( name . equals ( AUTO_TRANSLET ) ) { return new Boolean ( _autoTranslet ) ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( name . equals ( TRANSLET_NAME ) && value instanceof String ) { _transletName = ( String ) value ; return ; } else if ( name . equals ( DESTINATION_DIRECTORY ) && value instanceof String ) { _destinationDirectory = ( String ) value ; return ; } else if ( name . equals ( PACKAGE_NAME ) && value instanceof String ) { _packageName = ( String ) value ; return ; } else if ( name . equals ( JAR_NAME ) && value instanceof String ) { _jarFileName = ( String ) value ; return ; } else if ( name . equals ( GENERATE_TRANSLET ) ) { if ( value instanceof Boolean ) { _generateTranslet = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _generateTranslet = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( AUTO_TRANSLET ) ) { if ( value instanceof Boolean ) { _autoTranslet = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _autoTranslet = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( USE_CLASSPATH ) ) { if ( value instanceof Boolean ) { _useClasspath = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _useClasspath = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( DEBUG ) ) { if ( value instanceof Boolean ) { _debug = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _debug = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( ENABLE_INLINING ) ) { if ( value instanceof Boolean ) { _enableInlining = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _enableInlining = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( INDENT_NUMBER ) ) { if ( value instanceof String ) { try { _indentNumber = Integer . parseInt ( ( String ) value ) ; return ; } catch ( NumberFormatException e ) { } } else if ( value instanceof Integer ) { _indentNumber = ( ( Integer ) value ) . intValue ( ) ; return ; } } final ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public boolean getFeature ( String name ) { String [ ] features = { DOMSource . FEATURE , DOMResult . FEATURE , SAXSource . FEATURE , SAXResult . FEATURE , StreamSource . FEATURE , StreamResult . FEATURE } ; for ( int i = 0 ; i < features . length ; i ++ ) { if ( name . equals ( features [ i ] ) ) { return true ; } } return false ; } public URIResolver getURIResolver ( ) { return _uriResolver ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { if ( _piParams == null ) { _piParams = new Hashtable ( ) ; } _piParams . put ( source , new PIParamWrapper ( media , title , charset ) ) ; return source ; } public Transformer newTransformer ( ) throws TransformerConfigurationException { TransformerImpl result = new TransformerImpl ( new Properties ( ) , _indentNumber , this ) ; if ( _uriResolver != null ) { result . setURIResolver ( _uriResolver ) ; } return result ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { final Templates templates = newTemplates ( source ) ; final Transformer transformer = templates . newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return ( transformer ) ; } private void passWarningsToListener ( Vector messages ) throws TransformerException { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerConfigurationException ( message ) ) ; } } private void passErrorsToListener ( Vector messages ) { try { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerException ( message ) ) ; } } catch ( TransformerException e ) { } } private Class loadTranslet ( String name ) throws ClassNotFoundException { try { TransletLoader loader = new TransletLoader ( ) ; return loader . loadTranslet ( name ) ; } catch ( ClassNotFoundException e ) { return Class . forName ( name ) ; } } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { if ( _useClasspath ) { String transletName = getTransletBaseName ( source ) ; if ( _packageName != null ) transletName = _packageName + "." + transletName ; try { final Class clazz = loadTranslet ( transletName ) ; final Translet translet = ( Translet ) clazz . newInstance ( ) ; resetTransientAttributes ( ) ; return new TemplatesImpl ( translet , transletName , null , _indentNumber , this ) ; } catch ( ClassNotFoundException cnfe ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , transletName ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( Exception e ) { ErrorMsg err = new ErrorMsg ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } if ( _autoTranslet ) { byte [ ] [ ] bytecodes = null ; String transletClassName = getTransletBaseName ( source ) ; if ( _packageName != null ) transletClassName = _packageName + "." + transletClassName ; if ( _jarFileName != null ) bytecodes = getBytecodesFromJar ( source , transletClassName ) ; else bytecodes = getBytecodesFromClasses ( source , transletClassName ) ; if ( bytecodes != null ) { if ( _debug ) { if ( _jarFileName != null ) System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_WITH_JAR_STR , transletClassName , _jarFileName ) ) ; else System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , transletClassName ) ) ; } resetTransientAttributes ( ) ; return new TemplatesImpl ( bytecodes , transletClassName , null , _indentNumber , this ) ; } } final XSLTC xsltc = new XSLTC ( ) ; if ( _debug ) xsltc . setDebug ( true ) ; if ( _enableInlining ) xsltc . setTemplateInlining ( true ) ; xsltc . init ( ) ; if ( _uriResolver != null ) { xsltc . setSourceLoader ( this ) ; } if ( ( _piParams != null ) && ( _piParams . get ( source ) != null ) ) { PIParamWrapper p = ( PIParamWrapper ) _piParams . get ( source ) ; if ( p != null ) { xsltc . setPIParameters ( p . _media , p . _title , p . _charset ) ; } } int outputType = XSLTC . BYTEARRAY_OUTPUT ; if ( _generateTranslet || _autoTranslet ) { xsltc . setClassName ( getTransletBaseName ( source ) ) ; if ( _destinationDirectory != null ) xsltc . setDestDirectory ( _destinationDirectory ) ; else { String xslName = getStylesheetFileName ( source ) ; if ( xslName != null ) { File xslFile = new File ( xslName ) ; String xslDir = xslFile . getParent ( ) ; if ( xslDir != null ) xsltc . setDestDirectory ( xslDir ) ; } } if ( _packageName != null ) xsltc . setPackageName ( _packageName ) ; if ( _jarFileName != null ) { xsltc . setJarFileName ( _jarFileName ) ; outputType = XSLTC . BYTEARRAY_AND_JAR_OUTPUT ; } else outputType = XSLTC . BYTEARRAY_AND_FILE_OUTPUT ; } final InputSource input = Util . getInputSource ( xsltc , source ) ; byte [ ] [ ] bytecodes = xsltc . compile ( null , input , outputType ) ; final String transletName = xsltc . getClassName ( ) ; if ( ( _generateTranslet || _autoTranslet ) && bytecodes != null && _jarFileName != null ) { try { xsltc . outputToJar ( ) ; } catch ( java . io . IOException e ) { } } resetTransientAttributes ( ) ; if ( _errorListener != this ) { try { passWarningsToListener ( xsltc . getWarnings ( ) ) ; } catch ( TransformerException e ) { throw new TransformerConfigurationException ( e ) ; } } else { xsltc . printWarnings ( ) ; } if ( bytecodes == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_COMPILE_ERR ) ; TransformerConfigurationException exc = new TransformerConfigurationException ( err . toString ( ) ) ; if ( _errorListener != null ) { passErrorsToListener ( xsltc . getErrors ( ) ) ; try { _errorListener . fatalError ( exc ) ; } catch ( TransformerException te ) { } } else { xsltc . printErrors ( ) ; } throw exc ; } return new TemplatesImpl ( bytecodes , transletName , xsltc . getOutputProperties ( ) , _indentNumber , this ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { final TemplatesHandlerImpl handler = new TemplatesHandlerImpl ( _indentNumber , this ) ; if ( _uriResolver != null ) { handler . setURIResolver ( _uriResolver ) ; } return handler ; } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( src ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { final Transformer transformer = templates . newTransformer ( ) ; final TransformerImpl internal = ( TransformerImpl ) transformer ; return new TransformerHandlerImpl ( internal ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new org . apache . xalan . xsltc . trax . TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException e1 ) { if ( _errorListener != null ) { try { _errorListener . fatalError ( e1 ) ; return null ; } catch ( TransformerException e2 ) { new TransformerConfigurationException ( e2 ) ; } } throw e1 ; } } public void error ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void fatalError ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void warning ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_MSG , e . getMessageAndLocation ( ) ) ) ; } } public InputSource loadSource ( String href , String context , XSLTC xsltc ) { try { if ( _uriResolver != null ) { final Source source = _uriResolver . resolve ( href , context ) ; if ( source != null ) { return Util . getInputSource ( xsltc , source ) ; } } } catch ( TransformerException e ) { } return null ; } public synchronized XMLReader getXMLReader ( ) throws Exception { if ( _parserFactory == null ) { _parserFactory = SAXParserFactory . newInstance ( ) ; _parserFactory . setNamespaceAware ( true ) ; } XMLReader result = ( XMLReader ) _xmlReader . get ( ) ; if ( result == null ) { _xmlReader . set ( result = _parserFactory . newSAXParser ( ) . getXMLReader ( ) ) ; } return result ; } private void resetTransientAttributes ( ) { _transletName = DEFAULT_TRANSLET_NAME ; _destinationDirectory = null ; _packageName = null ; _jarFileName = null ; } private byte [ ] [ ] getBytecodesFromClasses ( Source source , String fullClassName ) { if ( fullClassName == null ) return null ; String xslFileName = getStylesheetFileName ( source ) ; File xslFile = null ; if ( xslFileName != null ) xslFile = new File ( xslFileName ) ; final String transletName ; int lastDotIndex = fullClassName . lastIndexOf ( '.' ) ; if ( lastDotIndex > 0 ) transletName = fullClassName . substring ( lastDotIndex + 1 ) ; else transletName = fullClassName ; String transletPath = fullClassName . replace ( '.' , '/' ) ; if ( _destinationDirectory != null ) { transletPath = _destinationDirectory + "/" + transletPath + ".class" ; } else { if ( xslFile != null && xslFile . getParent ( ) != null ) transletPath = xslFile . getParent ( ) + "/" + transletPath + ".class" ; else transletPath = transletPath + ".class" ; } File transletFile = new File ( transletPath ) ; if ( ! transletFile . exists ( ) ) return null ; if ( xslFile != null && xslFile . exists ( ) ) { long xslTimestamp = xslFile . lastModified ( ) ; long transletTimestamp = transletFile . lastModified ( ) ; if ( transletTimestamp < xslTimestamp ) return null ; } Vector bytecodes = new Vector ( ) ; int fileLength = ( int ) transletFile . length ( ) ; if ( fileLength > 0 ) { FileInputStream input = null ; try { input = new FileInputStream ( transletFile ) ; } catch ( FileNotFoundException e ) { return null ; } byte [ ] bytes = new byte [ fileLength ] ; try { readFromInputStream ( bytes , input , fileLength ) ; input . close ( ) ; } catch ( IOException e ) { return null ; } bytecodes . addElement ( bytes ) ; } else return null ; String transletParentDir = transletFile . getParent ( ) ; if ( transletParentDir == null ) transletParentDir = System . getProperty ( "user.dir" ) ; File transletParentFile = new File ( transletParentDir ) ; final String transletAuxPrefix = transletName + "$" ; File [ ] auxfiles = transletParentFile . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return ( name . endsWith ( ".class" ) && name . startsWith ( transletAuxPrefix ) ) ; } } ) ; for ( int i = 0 ; i < auxfiles . length ; i ++ ) { File auxfile = auxfiles [ i ] ; int auxlength = ( int ) auxfile . length ( ) ; if ( auxlength > 0 ) { FileInputStream auxinput = null ; try { auxinput = new FileInputStream ( auxfile ) ; } catch ( FileNotFoundException e ) { continue ; } byte [ ] bytes = new byte [ auxlength ] ; try { readFromInputStream ( bytes , auxinput , auxlength ) ; auxinput . close ( ) ; } catch ( IOException e ) { continue ; } bytecodes . addElement ( bytes ) ; } } final int count = bytecodes . size ( ) ; if ( count > 0 ) { final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ( byte [ ] ) bytecodes . elementAt ( i ) ; } return result ; } else return null ; } private byte [ ] [ ] getBytecodesFromJar ( Source source , String fullClassName ) { String xslFileName = getStylesheetFileName ( source ) ; File xslFile = null ; if ( xslFileName != null ) xslFile = new File ( xslFileName ) ; String jarPath = null ; if ( _destinationDirectory != null ) jarPath = _destinationDirectory + "/" + _jarFileName ; else { if ( xslFile != null && xslFile . getParent ( ) != null ) jarPath = xslFile . getParent ( ) + "/" + _jarFileName ; else jarPath = _jarFileName ; } File file = new File ( jarPath ) ; if ( ! file . exists ( ) ) return null ; if ( xslFile != null && xslFile . exists ( ) ) { long xslTimestamp = xslFile . lastModified ( ) ; long transletTimestamp = file . lastModified ( ) ; if ( transletTimestamp < xslTimestamp ) return null ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; } catch ( IOException e ) { return null ; } String transletPath = fullClassName . replace ( '.' , '/' ) ; String transletAuxPrefix = transletPath + "$" ; String transletFullName = transletPath + ".class" ; Vector bytecodes = new Vector ( ) ; Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entry . getSize ( ) > 0 && ( entryName . equals ( transletFullName ) || ( entryName . endsWith ( ".class" ) && entryName . startsWith ( transletAuxPrefix ) ) ) ) { try { InputStream input = jarFile . getInputStream ( entry ) ; int size = ( int ) entry . getSize ( ) ; byte [ ] bytes = new byte [ size ] ; readFromInputStream ( bytes , input , size ) ; input . close ( ) ; bytecodes . addElement ( bytes ) ; } catch ( IOException e ) { return null ; } } } final int count = bytecodes . size ( ) ; if ( count > 0 ) { final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ( byte [ ] ) bytecodes . elementAt ( i ) ; } return result ; } else return null ; } private void readFromInputStream ( byte [ ] bytes , InputStream input , int size ) throws IOException { int n = 0 ; int offset = 0 ; int length = size ; while ( length > 0 && ( n = input . read ( bytes , offset , length ) ) > 0 ) { offset = offset + n ; length = length - n ; } } private String getTransletBaseName ( Source source ) { String transletBaseName = null ; if ( ! _transletName . equals ( DEFAULT_TRANSLET_NAME ) ) return _transletName ; else { String systemId = source . getSystemId ( ) ; if ( systemId != null ) { String baseName = Util . baseName ( systemId ) ; if ( baseName != null ) { baseName = Util . noExtName ( baseName ) ; transletBaseName = Util . toJavaName ( baseName ) ; } } } return ( transletBaseName != null ) ? transletBaseName : DEFAULT_TRANSLET_NAME ; } private String getStylesheetFileName ( Source source ) { String systemId = source . getSystemId ( ) ; if ( systemId != null ) { File file = new File ( systemId ) ; if ( file . exists ( ) ) return systemId ; else { URL url = null ; try { url = new URL ( systemId ) ; } catch ( MalformedURLException e ) { return null ; } if ( "file" . equals ( url . getProtocol ( ) ) ) return url . getFile ( ) ; else return null ; } } else return null ; } } 	1
package org . apache . xml . utils ; public class SuballocatedIntVector { protected int m_blocksize ; protected int m_SHIFT , m_MASK ; protected static final int NUMBLOCKS_DEFAULT = 32 ; protected int m_numblocks = NUMBLOCKS_DEFAULT ; protected int m_map [ ] [ ] ; protected int m_firstFree = 0 ; protected int m_map0 [ ] ; protected int m_buildCache [ ] ; protected int m_buildCacheStartIndex ; public SuballocatedIntVector ( ) { this ( 2048 ) ; } public SuballocatedIntVector ( int blocksize , int numblocks ) { for ( m_SHIFT = 0 ; 0 != ( blocksize >>>= 1 ) ; ++ m_SHIFT ) ; m_blocksize = 1 << m_SHIFT ; m_MASK = m_blocksize - 1 ; m_numblocks = numblocks ; m_map0 = new int [ m_blocksize ] ; m_map = new int [ numblocks ] [ ] ; m_map [ 0 ] = m_map0 ; m_buildCache = m_map0 ; m_buildCacheStartIndex = 0 ; } public SuballocatedIntVector ( int blocksize ) { this ( blocksize , NUMBLOCKS_DEFAULT ) ; } public int size ( ) { return m_firstFree ; } public void setSize ( int sz ) { if ( m_firstFree > sz ) m_firstFree = sz ; } public void addElement ( int value ) { int indexRelativeToCache = m_firstFree - m_buildCacheStartIndex ; if ( indexRelativeToCache >= 0 && indexRelativeToCache < m_blocksize ) { m_buildCache [ indexRelativeToCache ] = value ; ++ m_firstFree ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; m_buildCache = block ; m_buildCacheStartIndex = m_firstFree - offset ; ++ m_firstFree ; } } private void addElements ( int value , int numberOfElements ) { if ( m_firstFree + numberOfElements < m_blocksize ) for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map0 [ m_firstFree ++ ] = value ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; m_firstFree += numberOfElements ; while ( numberOfElements > 0 ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberOfElements ) ? m_blocksize - offset : numberOfElements ; numberOfElements -= copied ; while ( copied -- > 0 ) block [ offset ++ ] = value ; ++ index ; offset = 0 ; } } } private void addElements ( int numberOfElements ) { int newlen = m_firstFree + numberOfElements ; if ( newlen > m_blocksize ) { int index = m_firstFree > > > m_SHIFT ; int newindex = ( m_firstFree + numberOfElements ) > > > m_SHIFT ; for ( int i = index + 1 ; i <= newindex ; ++ i ) m_map [ i ] = new int [ m_blocksize ] ; } m_firstFree = newlen ; } private void insertElementAt ( int value , int at ) { if ( at == m_firstFree ) addElement ( value ) ; else if ( at > m_firstFree ) { int index = at > > > m_SHIFT ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int offset = at & m_MASK ; block [ offset ] = value ; m_firstFree = offset + 1 ; } else { int index = at > > > m_SHIFT ; int maxindex = m_firstFree > > > m_SHIFT ; ++ m_firstFree ; int offset = at & m_MASK ; int push ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; int [ ] block = m_map [ index ] ; if ( null == block ) { push = 0 ; block = m_map [ index ] = new int [ m_blocksize ] ; } else { push = block [ m_blocksize - 1 ] ; System . arraycopy ( block , offset , block , offset + 1 , copylen ) ; } block [ offset ] = value ; value = push ; offset = 0 ; ++ index ; } } } public void removeAllElements ( ) { m_firstFree = 0 ; m_buildCache = m_map0 ; m_buildCacheStartIndex = 0 ; } private boolean removeElement ( int s ) { int at = indexOf ( s , 0 ) ; if ( at < 0 ) return false ; removeElementAt ( at ) ; return true ; } private void removeElementAt ( int at ) { if ( at < m_firstFree ) { int index = at > > > m_SHIFT ; int maxindex = m_firstFree > > > m_SHIFT ; int offset = at & m_MASK ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; else System . arraycopy ( block , offset + 1 , block , offset , copylen ) ; if ( index < maxindex ) { int [ ] next = m_map [ index + 1 ] ; if ( next != null ) block [ m_blocksize - 1 ] = ( next != null ) ? next [ 0 ] : 0 ; } else block [ m_blocksize - 1 ] = 0 ; offset = 0 ; ++ index ; } } -- m_firstFree ; } public void setElementAt ( int value , int at ) { if ( at < m_blocksize ) m_map0 [ at ] = value ; else { int index = at > > > m_SHIFT ; int offset = at & m_MASK ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; } if ( at >= m_firstFree ) m_firstFree = at + 1 ; } public int elementAt ( int i ) { if ( i < m_blocksize ) return m_map0 [ i ] ; return m_map [ i > > > m_SHIFT ] [ i & m_MASK ] ; } private boolean contains ( int s ) { return ( indexOf ( s , 0 ) >= 0 ) ; } public int indexOf ( int elem , int index ) { if ( index >= m_firstFree ) return - 1 ; int bindex = index > > > m_SHIFT ; int boffset = index & m_MASK ; int maxindex = m_firstFree > > > m_SHIFT ; int [ ] block ; for ( ; bindex < maxindex ; ++ bindex ) { block = m_map [ bindex ] ; if ( block != null ) for ( int offset = boffset ; offset < m_blocksize ; ++ offset ) if ( block [ offset ] == elem ) return offset + bindex * m_blocksize ; boffset = 0 ; } int maxoffset = m_firstFree & m_MASK ; block = m_map [ maxindex ] ; for ( int offset = boffset ; offset < maxoffset ; ++ offset ) if ( block [ offset ] == elem ) return offset + maxindex * m_blocksize ; return - 1 ; } public int indexOf ( int elem ) { return indexOf ( elem , 0 ) ; } private int lastIndexOf ( int elem ) { int boffset = m_firstFree & m_MASK ; for ( int index = m_firstFree > > > m_SHIFT ; index >= 0 ; -- index ) { int [ ] block = m_map [ index ] ; if ( block != null ) for ( int offset = boffset ; offset >= 0 ; -- offset ) if ( block [ offset ] == elem ) return offset + index * m_blocksize ; boffset = 0 ; } return - 1 ; } public final int [ ] getMap0 ( ) { return m_map0 ; } public final int [ ] [ ] getMap ( ) { return m_map ; } } 	1
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathExpression { public Object evaluate ( Node contextNode , short type , Object result ) throws XPathException , DOMException ; } 	0
package org . apache . xml . utils ; public class NSInfo { public NSInfo ( boolean hasProcessedNS , boolean hasXMLNSAttrs ) { m_hasProcessedNS = hasProcessedNS ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_namespace = null ; m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED ; } public NSInfo ( boolean hasProcessedNS , boolean hasXMLNSAttrs , int ancestorHasXMLNSAttrs ) { m_hasProcessedNS = hasProcessedNS ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_ancestorHasXMLNSAttrs = ancestorHasXMLNSAttrs ; m_namespace = null ; } public NSInfo ( String namespace , boolean hasXMLNSAttrs ) { m_hasProcessedNS = true ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_namespace = namespace ; m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED ; } public String m_namespace ; public boolean m_hasXMLNSAttrs ; public boolean m_hasProcessedNS ; public int m_ancestorHasXMLNSAttrs ; public static final int ANCESTORXMLNSUNPROCESSED = 0 ; public static final int ANCESTORHASXMLNS = 1 ; public static final int ANCESTORNOXMLNS = 2 ; } 	1
package org . apache . xalan . xsltc . compiler ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . InvokeInstruction ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . MultiHashtable ; import org . apache . xalan . xsltc . compiler . util . ObjectType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . TransletLoader ; class FunctionCall extends Expression { private QName _fname ; private final Vector _arguments ; private final static Vector EMPTY_ARG_LIST = new Vector ( 0 ) ; protected final static String EXT_XSLTC = TRANSLET_URI ; protected final static String JAVA_EXT_XSLTC = EXT_XSLTC + "/java" ; protected final static String EXT_XALAN = "http://xml.apache.org/xalan" ; protected final static String JAVA_EXT_XALAN = "http://xml.apache.org/xalan/java" ; protected final static String JAVA_EXT_XALAN_OLD = "http://xml.apache.org/xslt/java" ; protected final static String EXSLT_COMMON = "http://exslt.org/common" ; protected final static String EXSLT_MATH = "http://exslt.org/math" ; protected final static String EXSLT_SETS = "http://exslt.org/sets" ; protected final static String EXSLT_DATETIME = "http://exslt.org/dates-and-times" ; protected final static String EXSLT_STRINGS = "http://exslt.org/strings" ; protected final static int NAMESPACE_FORMAT_JAVA = 0 ; protected final static int NAMESPACE_FORMAT_CLASS = 1 ; protected final static int NAMESPACE_FORMAT_PACKAGE = 2 ; protected final static int NAMESPACE_FORMAT_CLASS_OR_PACKAGE = 3 ; private int _namespace_format = NAMESPACE_FORMAT_JAVA ; Expression _thisArgument = null ; private String _className ; private Class _clazz ; private Method _chosenMethod ; private Constructor _chosenConstructor ; private MethodType _chosenMethodType ; private boolean unresolvedExternal ; private boolean _isExtConstructor = false ; private boolean _isStatic = false ; private static final MultiHashtable _internal2Java = new MultiHashtable ( ) ; private static final Hashtable _java2Internal = new Hashtable ( ) ; private static final Hashtable _extensionNamespaceTable = new Hashtable ( ) ; private static final Hashtable _extensionFunctionTable = new Hashtable ( ) ; static class JavaType { public Class type ; public int distance ; public JavaType ( Class type , int distance ) { this . type = type ; this . distance = distance ; } public boolean equals ( Object query ) { return query . equals ( type ) ; } } static { try { final Class objectClass = Class . forName ( "java.lang.Object" ) ; final Class stringClass = Class . forName ( "java.lang.String" ) ; final Class nodeClass = Class . forName ( "org.w3c.dom.Node" ) ; final Class nodeListClass = Class . forName ( "org.w3c.dom.NodeList" ) ; _internal2Java . put ( Type . Boolean , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . Boolean , new JavaType ( java . lang . Boolean . class , 1 ) ) ; _internal2Java . put ( Type . Boolean , new JavaType ( Boolean . TYPE , 0 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( objectClass , 8 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Character . TYPE , 7 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Byte . TYPE , 6 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Short . TYPE , 5 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Integer . TYPE , 0 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( java . lang . Integer . class , 1 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Long . TYPE , 2 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Float . TYPE , 3 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Double . TYPE , 4 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( objectClass , 8 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Character . TYPE , 7 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Byte . TYPE , 6 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Short . TYPE , 5 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Integer . TYPE , 4 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Long . TYPE , 3 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Float . TYPE , 2 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( java . lang . Double . class , 1 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Double . TYPE , 0 ) ) ; _internal2Java . put ( Type . String , new JavaType ( objectClass , 1 ) ) ; _internal2Java . put ( Type . String , new JavaType ( stringClass , 0 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeClass , 0 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeListClass , 1 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( stringClass , 3 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( Integer . TYPE , 10 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( stringClass , 3 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( stringClass , 3 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( Double . TYPE , 4 ) ) ; _internal2Java . put ( Type . Reference , new JavaType ( objectClass , 0 ) ) ; _java2Internal . put ( Boolean . TYPE , Type . Boolean ) ; _java2Internal . put ( Void . TYPE , Type . Void ) ; _java2Internal . put ( Character . TYPE , Type . Real ) ; _java2Internal . put ( Byte . TYPE , Type . Real ) ; _java2Internal . put ( Short . TYPE , Type . Real ) ; _java2Internal . put ( Integer . TYPE , Type . Real ) ; _java2Internal . put ( Long . TYPE , Type . Real ) ; _java2Internal . put ( Float . TYPE , Type . Real ) ; _java2Internal . put ( Double . TYPE , Type . Real ) ; _java2Internal . put ( stringClass , Type . String ) ; _java2Internal . put ( objectClass , Type . Reference ) ; _java2Internal . put ( nodeListClass , Type . NodeSet ) ; _java2Internal . put ( nodeClass , Type . NodeSet ) ; _extensionNamespaceTable . put ( EXT_XALAN , "org.apache.xalan.lib.Extensions" ) ; _extensionNamespaceTable . put ( EXSLT_COMMON , "org.apache.xalan.lib.ExsltCommon" ) ; _extensionNamespaceTable . put ( EXSLT_MATH , "org.apache.xalan.lib.ExsltMath" ) ; _extensionNamespaceTable . put ( EXSLT_SETS , "org.apache.xalan.lib.ExsltSets" ) ; _extensionNamespaceTable . put ( EXSLT_DATETIME , "org.apache.xalan.lib.ExsltDatetime" ) ; _extensionNamespaceTable . put ( EXSLT_STRINGS , "org.apache.xalan.lib.ExsltStrings" ) ; _extensionFunctionTable . put ( EXSLT_COMMON + ":nodeSet" , "nodeset" ) ; _extensionFunctionTable . put ( EXSLT_COMMON + ":objectType" , "objectType" ) ; _extensionFunctionTable . put ( EXT_XALAN + ":nodeset" , "nodeset" ) ; } catch ( ClassNotFoundException e ) { System . err . println ( e ) ; } } public FunctionCall ( QName fname , Vector arguments ) { _fname = fname ; _arguments = arguments ; _type = null ; } public FunctionCall ( QName fname ) { this ( fname , EMPTY_ARG_LIST ) ; } public String getName ( ) { return ( _fname . toString ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _arguments != null ) { final int n = _arguments . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public String getClassNameFromUri ( String uri ) { String className = ( String ) _extensionNamespaceTable . get ( uri ) ; if ( className != null ) return className ; else { if ( uri . startsWith ( JAVA_EXT_XSLTC ) ) { int length = JAVA_EXT_XSLTC . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else if ( uri . startsWith ( JAVA_EXT_XALAN ) ) { int length = JAVA_EXT_XALAN . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else if ( uri . startsWith ( JAVA_EXT_XALAN_OLD ) ) { int length = JAVA_EXT_XALAN_OLD . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else { int index = uri . lastIndexOf ( '/' ) ; return ( index > 0 ) ? uri . substring ( index + 1 ) : uri ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) return _type ; final String namespace = _fname . getNamespace ( ) ; String local = _fname . getLocalPart ( ) ; if ( isExtension ( ) ) { _fname = new QName ( null , null , local ) ; return typeCheckStandard ( stable ) ; } else if ( isStandard ( ) ) { return typeCheckStandard ( stable ) ; } else { try { _className = getClassNameFromUri ( namespace ) ; final int pos = local . lastIndexOf ( '.' ) ; if ( pos > 0 ) { _isStatic = true ; if ( _className != null && _className . length ( ) > 0 ) { _namespace_format = NAMESPACE_FORMAT_PACKAGE ; _className = _className + "." + local . substring ( 0 , pos ) ; } else { _namespace_format = NAMESPACE_FORMAT_JAVA ; _className = local . substring ( 0 , pos ) ; } _fname = new QName ( namespace , null , local . substring ( pos + 1 ) ) ; } else { if ( _className != null && _className . length ( ) > 0 ) { try { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( _className ) ; _namespace_format = NAMESPACE_FORMAT_CLASS ; } catch ( ClassNotFoundException e ) { _namespace_format = NAMESPACE_FORMAT_PACKAGE ; } } else _namespace_format = NAMESPACE_FORMAT_JAVA ; if ( local . indexOf ( '-' ) > 0 ) { local = replaceDash ( local ) ; } String extFunction = ( String ) _extensionFunctionTable . get ( namespace + ":" + local ) ; if ( extFunction != null ) { _fname = new QName ( null , null , extFunction ) ; return typeCheckStandard ( stable ) ; } else _fname = new QName ( namespace , null , local ) ; } return typeCheckExternal ( stable ) ; } catch ( TypeCheckError e ) { ErrorMsg errorMsg = e . getErrorMsg ( ) ; if ( errorMsg == null ) { final String name = _fname . getLocalPart ( ) ; errorMsg = new ErrorMsg ( ErrorMsg . METHOD_NOT_FOUND_ERR , name ) ; } getParser ( ) . reportError ( ERROR , errorMsg ) ; return _type = Type . Void ; } } } public Type typeCheckStandard ( SymbolTable stable ) throws TypeCheckError { _fname . clearNamespace ( ) ; final int n = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; final MethodType args = new MethodType ( Type . Void , argsType ) ; final MethodType ptype = lookupPrimop ( stable , _fname . getLocalPart ( ) , args ) ; if ( ptype != null ) { for ( int i = 0 ; i < n ; i ++ ) { final Type argType = ( Type ) ptype . argsType ( ) . elementAt ( i ) ; final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; if ( ! argType . identicalTo ( exp . getType ( ) ) ) { try { _arguments . setElementAt ( new CastExpr ( exp , argType ) , i ) ; } catch ( TypeCheckError e ) { throw new TypeCheckError ( this ) ; } } } _chosenMethodType = ptype ; return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public Type typeCheckConstructor ( SymbolTable stable ) throws TypeCheckError { final Vector constructors = findConstructors ( ) ; if ( constructors == null ) { throw new TypeCheckError ( ErrorMsg . CONSTRUCTOR_NOT_FOUND , _className ) ; } final int nConstructors = constructors . size ( ) ; final int nArgs = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestConstrDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nConstructors ; i ++ ) { final Constructor constructor = ( Constructor ) constructors . elementAt ( i ) ; final Class [ ] paramTypes = constructor . getParameterTypes ( ) ; Class extType = null ; int currConstrDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currConstrDistance += ( ( JavaType ) match ) . distance ; } else if ( intType instanceof ObjectType ) { ObjectType objectType = ( ObjectType ) intType ; if ( objectType . getJavaClass ( ) == extType ) continue ; else if ( extType . isAssignableFrom ( objectType . getJavaClass ( ) ) ) currConstrDistance += 1 ; else { currConstrDistance = Integer . MAX_VALUE ; break ; } } else { currConstrDistance = Integer . MAX_VALUE ; break ; } } if ( j == nArgs && currConstrDistance < bestConstrDistance ) { _chosenConstructor = constructor ; _isExtConstructor = true ; bestConstrDistance = currConstrDistance ; if ( _clazz != null ) _type = new ObjectType ( _clazz ) ; else _type = new ObjectType ( _className ) ; } } if ( _type != null ) { return _type ; } throw new TypeCheckError ( ErrorMsg . ARGUMENT_CONVERSION_ERR , getMethodSignature ( argsType ) ) ; } public Type typeCheckExternal ( SymbolTable stable ) throws TypeCheckError { int nArgs = _arguments . size ( ) ; final String name = _fname . getLocalPart ( ) ; if ( _fname . getLocalPart ( ) . equals ( "new" ) ) { return typeCheckConstructor ( stable ) ; } else { boolean hasThisArgument = false ; if ( nArgs == 0 ) _isStatic = true ; if ( ! _isStatic ) { if ( _namespace_format == NAMESPACE_FORMAT_JAVA || _namespace_format == NAMESPACE_FORMAT_PACKAGE ) hasThisArgument = true ; Expression firstArg = ( Expression ) _arguments . elementAt ( 0 ) ; Type firstArgType = ( Type ) firstArg . typeCheck ( stable ) ; if ( _namespace_format == NAMESPACE_FORMAT_CLASS && firstArgType instanceof ObjectType && _clazz != null && _clazz . isAssignableFrom ( ( ( ObjectType ) firstArgType ) . getJavaClass ( ) ) ) hasThisArgument = true ; if ( hasThisArgument ) { _thisArgument = ( Expression ) _arguments . elementAt ( 0 ) ; _arguments . remove ( 0 ) ; nArgs -- ; if ( firstArgType instanceof ObjectType ) { _className = ( ( ObjectType ) firstArgType ) . getJavaClassName ( ) ; } else throw new TypeCheckError ( ErrorMsg . NO_JAVA_FUNCT_THIS_REF , name ) ; } } else if ( _className . length ( ) == 0 ) { final Parser parser = getParser ( ) ; if ( parser != null ) { reportWarning ( this , parser , ErrorMsg . FUNCTION_RESOLVE_ERR , _fname . toString ( ) ) ; } unresolvedExternal = true ; return _type = Type . Int ; } } final Vector methods = findMethods ( ) ; if ( methods == null ) { throw new TypeCheckError ( ErrorMsg . METHOD_NOT_FOUND_ERR , _className + "." + name ) ; } Class extType = null ; final int nMethods = methods . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestMethodDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nMethods ; i ++ ) { final Method method = ( Method ) methods . elementAt ( i ) ; final Class [ ] paramTypes = method . getParameterTypes ( ) ; int currMethodDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currMethodDistance += ( ( JavaType ) match ) . distance ; } else { if ( intType instanceof ReferenceType ) { currMethodDistance += 1 ; } else if ( intType instanceof ObjectType ) { ObjectType object = ( ObjectType ) intType ; if ( extType . getName ( ) . equals ( object . getJavaClassName ( ) ) ) currMethodDistance += 0 ; else if ( extType . isAssignableFrom ( object . getJavaClass ( ) ) ) currMethodDistance += 1 ; else { currMethodDistance = Integer . MAX_VALUE ; break ; } } else { currMethodDistance = Integer . MAX_VALUE ; break ; } } } if ( j == nArgs ) { extType = method . getReturnType ( ) ; _type = ( Type ) _java2Internal . get ( extType ) ; if ( _type == null ) { _type = new ObjectType ( extType ) ; } if ( _type != null && currMethodDistance < bestMethodDistance ) { _chosenMethod = method ; bestMethodDistance = currMethodDistance ; } } } if ( _chosenMethod != null && _thisArgument == null && ! Modifier . isStatic ( _chosenMethod . getModifiers ( ) ) ) { throw new TypeCheckError ( ErrorMsg . NO_JAVA_FUNCT_THIS_REF , getMethodSignature ( argsType ) ) ; } if ( _type != null ) { if ( _type == Type . NodeSet ) { getXSLTC ( ) . setMultiDocument ( true ) ; } return _type ; } throw new TypeCheckError ( ErrorMsg . ARGUMENT_CONVERSION_ERR , getMethodSignature ( argsType ) ) ; } public Vector typeCheckArgs ( SymbolTable stable ) throws TypeCheckError { final Vector result = new Vector ( ) ; final Enumeration e = _arguments . elements ( ) ; while ( e . hasMoreElements ( ) ) { final Expression exp = ( Expression ) e . nextElement ( ) ; result . addElement ( exp . typeCheck ( stable ) ) ; } return result ; } protected final Expression argument ( int i ) { return ( Expression ) _arguments . elementAt ( i ) ; } protected final Expression argument ( ) { return argument ( 0 ) ; } protected final int argumentCount ( ) { return _arguments . size ( ) ; } protected final void setArgument ( int i , Expression exp ) { _arguments . setElementAt ( exp , i ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { Type type = Type . Boolean ; if ( _chosenMethodType != null ) type = _chosenMethodType . resultType ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; translate ( classGen , methodGen ) ; if ( ( type instanceof BooleanType ) || ( type instanceof IntType ) ) { _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = argumentCount ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index ; if ( isStandard ( ) || isExtension ( ) ) { for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; } final String name = _fname . toString ( ) . replace ( '-' , '_' ) + "F" ; String args = Constants . EMPTYSTRING ; if ( name . equals ( "sumF" ) ) { args = DOM_INTF_SIG ; il . append ( methodGen . loadDOM ( ) ) ; } else if ( name . equals ( "normalize_spaceF" ) ) { if ( _chosenMethodType . toSignature ( args ) . equals ( "()Ljava/lang/String;" ) ) { args = "I" + DOM_INTF_SIG ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; } } index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , name , _chosenMethodType . toSignature ( args ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( unresolvedExternal ) { index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "unresolved_externalF" , "(Ljava/lang/String;)V" ) ; il . append ( new PUSH ( cpg , _fname . toString ( ) ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( _isExtConstructor ) { final String clazz = _chosenConstructor . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenConstructor . getParameterTypes ( ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( InstructionConstants . DUP ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( "V" ) ; index = cpg . addMethodref ( clazz , "<init>" , buffer . toString ( ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; ( Type . Object ) . translateFrom ( classGen , methodGen , _chosenConstructor . getDeclaringClass ( ) ) ; } else { final String clazz = _chosenMethod . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenMethod . getParameterTypes ( ) ; if ( _thisArgument != null ) { _thisArgument . translate ( classGen , methodGen ) ; } for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( getSignature ( _chosenMethod . getReturnType ( ) ) ) ; index = cpg . addMethodref ( clazz , _fname . getLocalPart ( ) , buffer . toString ( ) ) ; il . append ( _thisArgument != null ? ( InvokeInstruction ) new INVOKEVIRTUAL ( index ) : ( InvokeInstruction ) new INVOKESTATIC ( index ) ) ; _type . translateFrom ( classGen , methodGen , _chosenMethod . getReturnType ( ) ) ; } } public String toString ( ) { return "funcall(" + _fname + ", " + _arguments + ')' ; } public boolean isStandard ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace == null ) || ( namespace . equals ( Constants . EMPTYSTRING ) ) ; } public boolean isExtension ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace != null ) && ( namespace . equals ( EXT_XSLTC ) ) ; } private Vector findMethods ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; if ( _className != null && _className . length ( ) > 0 ) { final int nArgs = _arguments . size ( ) ; try { if ( _clazz == null ) { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( _className ) ; if ( _clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } final String methodName = _fname . getLocalPart ( ) ; final Method [ ] methods = _clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final int mods = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && methods [ i ] . getName ( ) . equals ( methodName ) && methods [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( methods [ i ] ) ; } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } return result ; } private Vector findConstructors ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; final int nArgs = _arguments . size ( ) ; try { if ( _clazz == null ) { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( _className ) ; if ( _clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } final Constructor [ ] constructors = _clazz . getConstructors ( ) ; for ( int i = 0 ; i < constructors . length ; i ++ ) { final int mods = constructors [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && constructors [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( constructors [ i ] ) ; } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } return result ; } static final String getSignature ( Class clazz ) { if ( clazz . isArray ( ) ) { final StringBuffer sb = new StringBuffer ( ) ; Class cl = clazz ; while ( cl . isArray ( ) ) { sb . append ( "[" ) ; cl = cl . getComponentType ( ) ; } sb . append ( getSignature ( cl ) ) ; return sb . toString ( ) ; } else if ( clazz . isPrimitive ( ) ) { if ( clazz == Integer . TYPE ) { return "I" ; } else if ( clazz == Byte . TYPE ) { return "B" ; } else if ( clazz == Long . TYPE ) { return "J" ; } else if ( clazz == Float . TYPE ) { return "F" ; } else if ( clazz == Double . TYPE ) { return "D" ; } else if ( clazz == Short . TYPE ) { return "S" ; } else if ( clazz == Character . TYPE ) { return "C" ; } else if ( clazz == Boolean . TYPE ) { return "Z" ; } else if ( clazz == Void . TYPE ) { return "V" ; } else { final String name = clazz . toString ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . UNKNOWN_SIG_TYPE_ERR , name ) ; throw new Error ( err . toString ( ) ) ; } } else { return "L" + clazz . getName ( ) . replace ( '.' , '/' ) + ';' ; } } static final String getSignature ( Method meth ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = meth . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ')' ) . append ( getSignature ( meth . getReturnType ( ) ) ) . toString ( ) ; } static final String getSignature ( Constructor cons ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = cons . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ")V" ) . toString ( ) ; } private String getMethodSignature ( Vector argsType ) { final StringBuffer buf = new StringBuffer ( _className ) ; buf . append ( '.' ) . append ( _fname . getLocalPart ( ) ) . append ( '(' ) ; int nArgs = argsType . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { final Type intType = ( Type ) argsType . elementAt ( i ) ; buf . append ( intType . toString ( ) ) ; if ( i < nArgs - 1 ) buf . append ( ", " ) ; } buf . append ( ')' ) ; return buf . toString ( ) ; } protected static String replaceDash ( String name ) { char dash = '-' ; StringBuffer buff = new StringBuffer ( "" ) ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( i > 0 && name . charAt ( i - 1 ) == dash ) buff . append ( Character . toUpperCase ( name . charAt ( i ) ) ) ; else if ( name . charAt ( i ) != dash ) buff . append ( name . charAt ( i ) ) ; } return buff . toString ( ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ElementAvailableCall extends FunctionCall { public ElementAvailableCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argument ( ) instanceof LiteralExpr ) { return _type = Type . Boolean ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . NEED_LITERAL_ERR , "element-available" , this ) ; throw new TypeCheckError ( err ) ; } public Object evaluateAtCompileTime ( ) { return getResult ( ) ? Boolean . TRUE : Boolean . FALSE ; } public boolean getResult ( ) { try { final LiteralExpr arg = ( LiteralExpr ) argument ( ) ; final String qname = arg . getValue ( ) ; final int index = qname . indexOf ( ':' ) ; final String localName = ( index > 0 ) ? qname . substring ( index + 1 ) : qname ; return getParser ( ) . elementSupported ( arg . getNamespace ( ) , localName ) ; } catch ( ClassCastException e ) { return false ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final boolean result = getResult ( ) ; methodGen . getInstructionList ( ) . append ( new PUSH ( cpg , result ) ) ; } } 	0
package org . apache . xpath ; import javax . xml . transform . SourceLocator ; public interface ExpressionNode extends SourceLocator { public void exprSetParent ( ExpressionNode n ) ; public ExpressionNode exprGetParent ( ) ; public void exprAddChild ( ExpressionNode n , int i ) ; public ExpressionNode exprGetChild ( int i ) ; public int exprGetNumChildren ( ) ; } 	0
package org . apache . xpath . axes ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public abstract class LocPathIterator extends PredicatedNodeTest implements Cloneable , DTMIterator , java . io . Serializable , PathComponent { protected LocPathIterator ( ) { } protected LocPathIterator ( PrefixResolver nscontext ) { setLocPathIterator ( this ) ; m_prefixResolver = nscontext ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { this ( compiler , opPos , analysis , true ) ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { setLocPathIterator ( this ) ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , javax . xml . transform . TransformerException { try { stream . defaultReadObject ( ) ; m_clones = new IteratorPool ( this ) ; } catch ( ClassNotFoundException cnfe ) { throw new javax . xml . transform . TransformerException ( cnfe ) ; } } public void setEnvironment ( Object environment ) { } public DTM getDTM ( int nodeHandle ) { return m_execContext . getDTM ( nodeHandle ) ; } public DTMManager getDTMManager ( ) { return m_execContext . getDTMManager ( ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; return iter ; } public void executeCharsToContentHandler ( XPathContext xctxt , org . xml . sax . ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { LocPathIterator clone = ( LocPathIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; clone . setRoot ( current , xctxt ) ; int node = clone . nextNode ( ) ; DTM dtm = clone . getDTM ( node ) ; clone . detach ( ) ; if ( node != DTM . NULL ) { dtm . dispatchCharactersEvents ( node , handler , false ) ; } } public DTMIterator asIterator ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( contextNode , xctxt ) ; return iter ; } public boolean isNodesetExpr ( ) { return true ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator iter = ( DTMIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; iter . setRoot ( current , xctxt ) ; int next = iter . nextNode ( ) ; iter . detach ( ) ; return next ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( asNode ( xctxt ) != DTM . NULL ) ; } public void setIsTopLevel ( boolean b ) { m_isTopLevel = b ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public void setRoot ( int context , Object environment ) { m_context = context ; XPathContext xctxt = ( XPathContext ) environment ; m_execContext = xctxt ; m_cdtm = xctxt . getDTM ( context ) ; m_currentContextNode = context ; if ( null == m_prefixResolver ) m_prefixResolver = xctxt . getNamespaceContext ( ) ; m_lastFetched = DTM . NULL ; m_foundLast = false ; m_pos = 0 ; m_length = - 1 ; if ( m_isTopLevel ) this . m_stackFrame = xctxt . getVarStack ( ) . getStackFrame ( ) ; } protected void setNextPosition ( int next ) { assertion ( false , "setNextPosition not supported in this iterator!" ) ; } public final int getCurrentPos ( ) { return m_pos ; } public void setShouldCacheNodes ( boolean b ) { assertion ( false , "setShouldCacheNodes not supported by this iterater!" ) ; } public boolean isMutable ( ) { return false ; } public void setCurrentPos ( int i ) { assertion ( false , "setCurrentPos not supported by this iterator!" ) ; } public void incrementCurrentPos ( ) { m_pos ++ ; } public int size ( ) { assertion ( false , "size() not supported by this iterator!" ) ; return 0 ; } public int item ( int index ) { assertion ( false , "item(int index) not supported by this iterator!" ) ; return 0 ; } public void setItem ( int node , int index ) { assertion ( false , "setItem not supported by this iterator!" ) ; } public int getLength ( ) { boolean isPredicateTest = ( this == m_execContext . getSubContextList ( ) ) ; int predCount = getPredicateCount ( ) ; if ( - 1 != m_length && isPredicateTest && m_predicateIndex < 1 ) return m_length ; if ( m_foundLast ) return m_pos ; int pos = ( m_predicateIndex >= 0 ) ? getProximityPosition ( ) : m_pos ; LocPathIterator clone ; try { clone = ( LocPathIterator ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } if ( predCount > 0 && isPredicateTest ) { clone . m_predCount = m_predicateIndex ; } int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { pos ++ ; } if ( isPredicateTest && m_predicateIndex < 1 ) m_length = pos ; return pos ; } public boolean isFresh ( ) { return ( m_pos == 0 ) ; } public int previousNode ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_ITERATE , null ) ) ; } public int getWhatToShow ( ) { return DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ; } public DTMFilter getFilter ( ) { return null ; } public int getRoot ( ) { return m_context ; } public boolean getExpandEntityReferences ( ) { return true ; } protected boolean m_allowDetach = true ; public void allowDetachToRelease ( boolean allowRelease ) { m_allowDetach = allowRelease ; } public void detach ( ) { if ( m_allowDetach ) { m_execContext = null ; m_cdtm = null ; m_length = - 1 ; m_pos = 0 ; m_lastFetched = DTM . NULL ; m_context = DTM . NULL ; m_currentContextNode = DTM . NULL ; m_clones . freeInstance ( this ) ; } } public void reset ( ) { assertion ( false , "This iterator can not reset!" ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { LocPathIterator clone ; clone = ( LocPathIterator ) m_clones . getInstanceOrThrow ( ) ; clone . m_execContext = m_execContext ; clone . m_cdtm = m_cdtm ; clone . m_context = m_context ; clone . m_currentContextNode = m_currentContextNode ; clone . m_stackFrame = m_stackFrame ; return clone ; } public abstract int nextNode ( ) ; protected int returnNextNode ( int nextNode ) { if ( DTM . NULL != nextNode ) { m_pos ++ ; } m_lastFetched = nextNode ; if ( DTM . NULL == nextNode ) m_foundLast = true ; return nextNode ; } public int getCurrentNode ( ) { return m_lastFetched ; } public void runTo ( int index ) { if ( m_foundLast || ( ( index >= 0 ) && ( index <= getCurrentPos ( ) ) ) ) return ; int n ; if ( - 1 == index ) { while ( DTM . NULL != ( n = nextNode ( ) ) ) ; } else { while ( DTM . NULL != ( n = nextNode ( ) ) ) { if ( getCurrentPos ( ) >= index ) break ; } } } public final boolean getFoundLast ( ) { return m_foundLast ; } public final XPathContext getXPathContext ( ) { return m_execContext ; } public final int getContext ( ) { return m_context ; } public final int getCurrentContextNode ( ) { return m_currentContextNode ; } public final void setCurrentContextNode ( int n ) { m_currentContextNode = n ; } public final PrefixResolver getPrefixResolver ( ) { if ( null == m_prefixResolver ) { m_prefixResolver = ( PrefixResolver ) getExpressionOwner ( ) ; } return m_prefixResolver ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitLocationPath ( owner , this ) ) { visitor . visitStep ( owner , this ) ; callPredicateVisitors ( visitor ) ; } } transient protected IteratorPool m_clones = new IteratorPool ( this ) ; transient protected DTM m_cdtm ; transient int m_stackFrame = - 1 ; private boolean m_isTopLevel = false ; transient public int m_lastFetched = DTM . NULL ; transient protected int m_context = DTM . NULL ; transient protected int m_currentContextNode = DTM . NULL ; transient protected int m_pos = 0 ; transient protected int m_length = - 1 ; private PrefixResolver m_prefixResolver ; transient protected XPathContext m_execContext ; public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } public int getLastPos ( XPathContext xctxt ) { return getLength ( ) ; } } 	1
package org . apache . xml . utils ; public class SerializableLocatorImpl implements org . xml . sax . Locator , java . io . Serializable { public SerializableLocatorImpl ( ) { } public SerializableLocatorImpl ( org . xml . sax . Locator locator ) { setPublicId ( locator . getPublicId ( ) ) ; setSystemId ( locator . getSystemId ( ) ) ; setLineNumber ( locator . getLineNumber ( ) ) ; setColumnNumber ( locator . getColumnNumber ( ) ) ; } public String getPublicId ( ) { return publicId ; } public String getSystemId ( ) { return systemId ; } public int getLineNumber ( ) { return lineNumber ; } public int getColumnNumber ( ) { return columnNumber ; } public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setSystemId ( String systemId ) { this . systemId = systemId ; } public void setLineNumber ( int lineNumber ) { this . lineNumber = lineNumber ; } public void setColumnNumber ( int columnNumber ) { this . columnNumber = columnNumber ; } private String publicId ; private String systemId ; private int lineNumber ; private int columnNumber ; } 	0
package org . apache . xalan . xsltc . runtime . output ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . Writer ; class WriterOutputBuffer implements OutputBuffer { private static final int KB = 1024 ; private static int BUFFER_SIZE = 4 * KB ; static { final String osName = System . getProperty ( "os.name" ) ; if ( osName . equalsIgnoreCase ( "solaris" ) ) { BUFFER_SIZE = 32 * KB ; } } private Writer _writer ; public WriterOutputBuffer ( Writer writer ) { _writer = new BufferedWriter ( writer , BUFFER_SIZE ) ; } public String close ( ) { try { _writer . flush ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return "" ; } public OutputBuffer append ( String s ) { try { _writer . write ( s ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } public OutputBuffer append ( char [ ] s , int from , int to ) { try { _writer . write ( s , from , to ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } public OutputBuffer append ( char ch ) { try { _writer . write ( ch ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } } 	0
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . utils . IntVector ; import org . w3c . dom . Node ; public class DTMAxisIterNodeList extends DTMNodeListBase { private DTM m_dtm ; private DTMAxisIterator m_iter ; private IntVector m_cachedNodes ; private int m_last = - 1 ; private DTMAxisIterNodeList ( ) { } public DTMAxisIterNodeList ( DTM dtm , DTMAxisIterator dtmAxisIterator ) { if ( dtmAxisIterator == null ) { m_last = 0 ; } else { m_cachedNodes = new IntVector ( ) ; m_dtm = dtm ; } m_iter = dtmAxisIterator ; } public DTMAxisIterator getDTMAxisIterator ( ) { return m_iter ; } public Node item ( int index ) { if ( m_iter != null ) { int node ; int count = m_cachedNodes . size ( ) ; if ( count > index ) { node = m_cachedNodes . elementAt ( index ) ; return m_dtm . getNode ( node ) ; } else if ( m_last == - 1 ) { while ( ( ( node = m_iter . next ( ) ) != DTMAxisIterator . END ) && count <= index ) { m_cachedNodes . addElement ( node ) ; count ++ ; } if ( node == DTMAxisIterator . END ) { m_last = count ; } else { return m_dtm . getNode ( node ) ; } } } return null ; } public int getLength ( ) { if ( m_last == - 1 ) { int node ; while ( ( node = m_iter . next ( ) ) != DTMAxisIterator . END ) { m_cachedNodes . addElement ( node ) ; } m_last = m_cachedNodes . size ( ) ; } return m_last ; } } 	0
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class EmptySerializer implements SerializationHandler { protected static final String ERR = "EmptySerializer method not over-ridden" ; private static void throwUnimplementedException ( ) { return ; } public ContentHandler asContentHandler ( ) throws IOException { throwUnimplementedException ( ) ; return null ; } public void setContentHandler ( ContentHandler ch ) { throwUnimplementedException ( ) ; } public void close ( ) { throwUnimplementedException ( ) ; } public Properties getOutputFormat ( ) { throwUnimplementedException ( ) ; return null ; } public OutputStream getOutputStream ( ) { throwUnimplementedException ( ) ; return null ; } public Writer getWriter ( ) { throwUnimplementedException ( ) ; return null ; } public boolean reset ( ) { throwUnimplementedException ( ) ; return false ; } public void serialize ( Node node ) throws IOException { throwUnimplementedException ( ) ; } public void setCdataSectionElements ( Vector URI_and_localNames ) { throwUnimplementedException ( ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { throwUnimplementedException ( ) ; return false ; } public void setIndent ( boolean indent ) { throwUnimplementedException ( ) ; } public void setIndentAmount ( int spaces ) { throwUnimplementedException ( ) ; } public void setOutputFormat ( Properties format ) { throwUnimplementedException ( ) ; } public void setOutputStream ( OutputStream output ) { throwUnimplementedException ( ) ; } public void setVersion ( String version ) { throwUnimplementedException ( ) ; } public void setWriter ( Writer writer ) { throwUnimplementedException ( ) ; } public void setTransformer ( Transformer transformer ) { throwUnimplementedException ( ) ; } public Transformer getTransformer ( ) { throwUnimplementedException ( ) ; return null ; } public void flushPending ( ) { throwUnimplementedException ( ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { throwUnimplementedException ( ) ; } public void addAttributes ( Attributes atts ) throws SAXException { throwUnimplementedException ( ) ; } public void addAttribute ( String name , String value ) { throwUnimplementedException ( ) ; } public void characters ( String chars ) throws SAXException { throwUnimplementedException ( ) ; } public void endElement ( String elemName ) throws SAXException { throwUnimplementedException ( ) ; } public void startDocument ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String qName ) throws SAXException { throwUnimplementedException ( ) ; } public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException { throwUnimplementedException ( ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { throwUnimplementedException ( ) ; return false ; } public void entityReference ( String entityName ) throws SAXException { throwUnimplementedException ( ) ; } public NamespaceMappings getNamespaceMappings ( ) { throwUnimplementedException ( ) ; return null ; } public String getPrefix ( String uri ) { throwUnimplementedException ( ) ; return null ; } public String getNamespaceURI ( String name , boolean isElement ) { throwUnimplementedException ( ) ; return null ; } public String getNamespaceURIFromPrefix ( String prefix ) { throwUnimplementedException ( ) ; return null ; } public void setDocumentLocator ( Locator arg0 ) { throwUnimplementedException ( ) ; } public void endDocument ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startPrefixMapping ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void endPrefixMapping ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { throwUnimplementedException ( ) ; } public void endElement ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void characters ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void skippedEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void comment ( String comment ) throws SAXException { throwUnimplementedException ( ) ; } public void startDTD ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void endDTD ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void endEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void startCDATA ( ) throws SAXException { throwUnimplementedException ( ) ; } public void endCDATA ( ) throws SAXException { throwUnimplementedException ( ) ; } public void comment ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public String getDoctypePublic ( ) { throwUnimplementedException ( ) ; return null ; } public String getDoctypeSystem ( ) { throwUnimplementedException ( ) ; return null ; } public String getEncoding ( ) { throwUnimplementedException ( ) ; return null ; } public boolean getIndent ( ) { throwUnimplementedException ( ) ; return false ; } public int getIndentAmount ( ) { throwUnimplementedException ( ) ; return 0 ; } public String getMediaType ( ) { throwUnimplementedException ( ) ; return null ; } public boolean getOmitXMLDeclaration ( ) { throwUnimplementedException ( ) ; return false ; } public String getStandalone ( ) { throwUnimplementedException ( ) ; return null ; } public String getVersion ( ) { throwUnimplementedException ( ) ; return null ; } public void setCdataSectionElements ( Hashtable h ) throws Exception { throwUnimplementedException ( ) ; } public void setDoctype ( String system , String pub ) { throwUnimplementedException ( ) ; } public void setDoctypePublic ( String doctype ) { throwUnimplementedException ( ) ; } public void setDoctypeSystem ( String doctype ) { throwUnimplementedException ( ) ; } public void setEncoding ( String encoding ) { throwUnimplementedException ( ) ; } public void setMediaType ( String mediatype ) { throwUnimplementedException ( ) ; } public void setOmitXMLDeclaration ( boolean b ) { throwUnimplementedException ( ) ; } public void setStandalone ( String standalone ) { throwUnimplementedException ( ) ; } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { throwUnimplementedException ( ) ; } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void warning ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void error ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void fatalError ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public DOMSerializer asDOMSerializer ( ) throws IOException { throwUnimplementedException ( ) ; return null ; } public void setNamespaceMappings ( NamespaceMappings mappings ) { throwUnimplementedException ( ) ; } public void setSourceLocator ( SourceLocator locator ) { throwUnimplementedException ( ) ; } } 	0
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class DTMAxisIteratorBase implements DTMAxisIterator { protected int _last = - 1 ; protected int _position = 0 ; protected int _markedNode ; protected int _startNode = DTMAxisIterator . END ; protected boolean _includeSelf = false ; protected boolean _isRestartable = true ; public int getStartNode ( ) { return _startNode ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; return this ; } public DTMAxisIterator includeSelf ( ) { _includeSelf = true ; return this ; } public int getLast ( ) { if ( _last == - 1 ) { final int temp = _position ; setMark ( ) ; reset ( ) ; do { _last ++ ; } while ( next ( ) != END ) ; gotoMark ( ) ; _position = temp ; } return _last ; } public int getPosition ( ) { return _position == 0 ? 1 : _position ; } public boolean isReverse ( ) { return false ; } public DTMAxisIterator cloneIterator ( ) { try { final DTMAxisIteratorBase clone = ( DTMAxisIteratorBase ) super . clone ( ) ; return clone ; } catch ( CloneNotSupportedException e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } protected final int returnNode ( final int node ) { _position ++ ; return node ; } protected final DTMAxisIterator resetPosition ( ) { _position = 0 ; return this ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; } public int getNodeByPosition ( int position ) { if ( position > 0 ) { final int pos = isReverse ( ) ? getLast ( ) - position + 1 : position ; int node ; while ( ( node = next ( ) ) != DTMAxisIterator . END ) { if ( pos == getPosition ( ) ) { return node ; } } } return END ; } } 	1
package org . apache . xml . dtm . ref ; import java . util . Hashtable ; public class CustomStringPool extends DTMStringPool { final Hashtable m_stringToInt = new Hashtable ( ) ; public static final int NULL = - 1 ; public CustomStringPool ( ) { super ( ) ; } public void removeAllElements ( ) { m_intToString . removeAllElements ( ) ; if ( m_stringToInt != null ) m_stringToInt . clear ( ) ; } public String indexToString ( int i ) throws java . lang . ArrayIndexOutOfBoundsException { return ( String ) m_intToString . elementAt ( i ) ; } public int stringToIndex ( String s ) { if ( s == null ) return NULL ; Integer iobj = ( Integer ) m_stringToInt . get ( s ) ; if ( iobj == null ) { m_intToString . addElement ( s ) ; iobj = new Integer ( m_intToString . size ( ) ) ; m_stringToInt . put ( s , iobj ) ; } return iobj . intValue ( ) ; } } 	0
package org . apache . xpath ; import java . io . IOException ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class SourceTreeManager { private Vector m_sourceTree = new Vector ( ) ; public void reset ( ) { m_sourceTree = new Vector ( ) ; } URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } public String findURIFromDoc ( int owner ) { int n = m_sourceTree . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SourceTree sTree = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( owner == sTree . m_root ) return sTree . m_url ; } return null ; } public Source resolveURI ( String base , String urlString , SourceLocator locator ) throws TransformerException , IOException { Source source = null ; if ( null != m_uriResolver ) { source = m_uriResolver . resolve ( urlString , base ) ; } if ( null == source ) { String uri = SystemIDResolver . getAbsoluteURI ( urlString , base ) ; source = new StreamSource ( uri ) ; } return source ; } public void removeDocumentFromCache ( int n ) { if ( DTM . NULL == n ) return ; for ( int i = m_sourceTree . size ( ) - 1 ; i >= 0 ; -- i ) { SourceTree st = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( st != null && st . m_root == n ) { m_sourceTree . removeElementAt ( i ) ; return ; } } } public void putDocumentInCache ( int n , Source source ) { int cachedNode = getNode ( source ) ; if ( DTM . NULL != cachedNode ) { if ( ! ( cachedNode == n ) ) throw new RuntimeException ( "Programmer's Error!  " + "putDocumentInCache found reparse of doc: " + source . getSystemId ( ) ) ; return ; } if ( null != source . getSystemId ( ) ) { m_sourceTree . addElement ( new SourceTree ( n , source . getSystemId ( ) ) ) ; } } public int getNode ( Source source ) { String url = source . getSystemId ( ) ; if ( null == url ) return DTM . NULL ; int n = m_sourceTree . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SourceTree sTree = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( url . equals ( sTree . m_url ) ) return sTree . m_root ; } return DTM . NULL ; } public int getSourceTree ( String base , String urlString , SourceLocator locator , XPathContext xctxt ) throws TransformerException { try { Source source = this . resolveURI ( base , urlString , locator ) ; return getSourceTree ( source , locator , xctxt ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , locator , ioe ) ; } } public int getSourceTree ( Source source , SourceLocator locator , XPathContext xctxt ) throws TransformerException { int n = getNode ( source ) ; if ( DTM . NULL != n ) return n ; n = parseToNode ( source , locator , xctxt ) ; if ( DTM . NULL != n ) putDocumentInCache ( n , source ) ; return n ; } public int parseToNode ( Source source , SourceLocator locator , XPathContext xctxt ) throws TransformerException { try { Object xowner = xctxt . getOwnerObject ( ) ; DTM dtm ; if ( null != xowner && xowner instanceof org . apache . xml . dtm . DTMWSFilter ) { dtm = xctxt . getDTM ( source , false , ( org . apache . xml . dtm . DTMWSFilter ) xowner , false , true ) ; } else { dtm = xctxt . getDTM ( source , false , null , false , true ) ; } return dtm . getDocument ( ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , locator , e ) ; } } public static XMLReader getXMLReader ( Source inputSource , SourceLocator locator ) throws TransformerException { try { XMLReader reader = ( inputSource instanceof SAXSource ) ? ( ( SAXSource ) inputSource ) . getXMLReader ( ) : null ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } return reader ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se . getMessage ( ) , locator , se ) ; } } } 	0
package org . apache . xalan . xsltc . compiler ; class IllegalCharException extends Exception { public IllegalCharException ( String s ) { super ( s ) ; } } 	0
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMDOMException ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public class DTMNodeProxy implements Node , Document , Text , Element , Attr , ProcessingInstruction , Comment , DocumentFragment { public DTM dtm ; int node ; static final DOMImplementation implementation = new DTMNodeProxyImplementation ( ) ; public DTMNodeProxy ( DTM dtm , int node ) { this . dtm = dtm ; this . node = node ; } public final DTM getDTM ( ) { return dtm ; } public final int getDTMNodeNumber ( ) { return node ; } public final boolean equals ( Node node ) { try { DTMNodeProxy dtmp = ( DTMNodeProxy ) node ; return ( dtmp . node == this . node ) && ( dtmp . dtm == this . dtm ) ; } catch ( ClassCastException cce ) { return false ; } } public final boolean equals ( Object node ) { try { return equals ( ( Node ) node ) ; } catch ( ClassCastException cce ) { return false ; } } public final boolean sameNodeAs ( Node other ) { if ( ! ( other instanceof DTMNodeProxy ) ) return false ; DTMNodeProxy that = ( DTMNodeProxy ) other ; return this . dtm == that . dtm && this . node == that . node ; } public final String getNodeName ( ) { return dtm . getNodeName ( node ) ; } public final String getTarget ( ) { return dtm . getNodeName ( node ) ; } public final String getLocalName ( ) { return dtm . getLocalName ( node ) ; } public final String getPrefix ( ) { return dtm . getPrefix ( node ) ; } public final void setPrefix ( String prefix ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final String getNamespaceURI ( ) { return dtm . getNamespaceURI ( node ) ; } public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; } public final boolean isSupported ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; } public final String getNodeValue ( ) throws DOMException { return dtm . getNodeValue ( node ) ; } public final String getStringValue ( ) throws DOMException { return dtm . getStringValue ( node ) . toString ( ) ; } public final void setNodeValue ( String nodeValue ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final short getNodeType ( ) { return ( short ) dtm . getNodeType ( node ) ; } public final Node getParentNode ( ) { if ( getNodeType ( ) == Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getOwnerNode ( ) { int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final NodeList getChildNodes ( ) { return new DTMChildIterNodeList ( dtm , node ) ; } public final Node getFirstChild ( ) { int newnode = dtm . getFirstChild ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getLastChild ( ) { int newnode = dtm . getLastChild ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getPreviousSibling ( ) { int newnode = dtm . getPreviousSibling ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getNextSibling ( ) { if ( dtm . getNodeType ( node ) == Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getNextSibling ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final NamedNodeMap getAttributes ( ) { return new DTMNamedNodeMap ( dtm , node ) ; } public boolean hasAttribute ( String name ) { return DTM . NULL != dtm . getAttributeNode ( node , null , name ) ; } public boolean hasAttributeNS ( String name , String x ) { return DTM . NULL != dtm . getAttributeNode ( node , x , name ) ; } public final Document getOwnerDocument ( ) { return ( Document ) ( dtm . getNode ( dtm . getOwnerDocument ( node ) ) ) ; } public final Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node removeChild ( Node oldChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node appendChild ( Node newChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final boolean hasChildNodes ( ) { return ( DTM . NULL != dtm . getFirstChild ( node ) ) ; } public final Node cloneNode ( boolean deep ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final DocumentType getDoctype ( ) { return null ; } public final DOMImplementation getImplementation ( ) { return implementation ; } public final Element getDocumentElement ( ) { int dochandle = dtm . getDocument ( ) ; int elementhandle = DTM . NULL ; for ( int kidhandle = dtm . getFirstChild ( dochandle ) ; kidhandle != DTM . NULL ; kidhandle = dtm . getNextSibling ( kidhandle ) ) { switch ( dtm . getNodeType ( kidhandle ) ) { case Node . ELEMENT_NODE : if ( elementhandle != DTM . NULL ) { elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; } else elementhandle = kidhandle ; break ; case Node . COMMENT_NODE : case Node . PROCESSING_INSTRUCTION_NODE : case Node . DOCUMENT_TYPE_NODE : break ; default : elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; break ; } } if ( elementhandle == DTM . NULL ) throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; else return ( Element ) ( dtm . getNode ( elementhandle ) ) ; } public final Element createElement ( String tagName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final DocumentFragment createDocumentFragment ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Text createTextNode ( String data ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Comment createComment ( String data ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final CDATASection createCDATASection ( String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr createAttribute ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final EntityReference createEntityReference ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final NodeList getElementsByTagName ( String tagname ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Node importNode ( Node importedNode , boolean deep ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Element getElementById ( String elementId ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Text splitText ( int offset ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getData ( ) throws DOMException { return dtm . getNodeValue ( node ) ; } public final void setData ( String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final int getLength ( ) { return dtm . getNodeValue ( node ) . length ( ) ; } public final String substringData ( int offset , int count ) throws DOMException { return getData ( ) . substring ( offset , offset + count ) ; } public final void appendData ( String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void insertData ( int offset , String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void deleteData ( int offset , int count ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void replaceData ( int offset , int count , String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getTagName ( ) { return dtm . getNodeName ( node ) ; } public final String getAttribute ( String name ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; Node node = map . getNamedItem ( name ) ; return ( null == node ) ? null : node . getNodeValue ( ) ; } public final void setAttribute ( String name , String value ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void removeAttribute ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr getAttributeNode ( String name ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; return ( Attr ) map . getNamedItem ( name ) ; } public final Attr setAttributeNode ( Attr newAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean hasAttributes ( ) { return DTM . NULL != dtm . getFirstAttribute ( node ) ; } public final void normalize ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getAttributeNS ( String namespaceURI , String localName ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; Node node = map . getNamedItemNS ( namespaceURI , localName ) ; return ( null == node ) ? null : node . getNodeValue ( ) ; } public final void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr getAttributeNodeNS ( String namespaceURI , String localName ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getName ( ) { return dtm . getNodeName ( node ) ; } public final boolean getSpecified ( ) { return true ; } public final String getValue ( ) { return dtm . getNodeValue ( node ) ; } public final void setValue ( String value ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Element getOwnerElement ( ) { if ( getNodeType ( ) != Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : ( Element ) ( dtm . getNode ( newnode ) ) ; } public Node adoptNode ( Node source ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public String getEncoding ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setEncoding ( String encoding ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean getStandalone ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setStandalone ( boolean standalone ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean getStrictErrorChecking ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setStrictErrorChecking ( boolean strictErrorChecking ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public String getVersion ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setVersion ( String version ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } static class DTMNodeProxyImplementation implements DOMImplementation { public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public Document createDocument ( String namespaceURI , String qualfiedName , DocumentType doctype ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean hasFeature ( String feature , String version ) { if ( ( "CORE" . equals ( feature . toUpperCase ( ) ) || "XML" . equals ( feature . toUpperCase ( ) ) ) && ( "1.0" . equals ( version ) || "2.0" . equals ( version ) ) ) return true ; return false ; } } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . FieldGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . bcel . generic . TargetLostException ; import org . apache . bcel . util . InstructionFinder ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . dtm . DTM ; public final class Stylesheet extends SyntaxTreeNode { private String _version ; private QName _name ; private String _systemId ; private Stylesheet _parentStylesheet ; private Vector _globals = new Vector ( ) ; private Boolean _hasLocalParams = null ; private String _className ; private final Vector _templates = new Vector ( ) ; private int _nextModeSerial = 1 ; private final Hashtable _modes = new Hashtable ( ) ; private final Hashtable _extensions = new Hashtable ( ) ; public Stylesheet _importedFrom = null ; public Stylesheet _includedFrom = null ; private int _importPrecedence = 1 ; private Mode _defaultMode ; private boolean _multiDocument = false ; private boolean _callsNodeset = false ; private Hashtable _keys = new Hashtable ( ) ; private boolean _numberFormattingUsed = false ; private boolean _simplified = false ; private SourceLoader _loader = null ; private boolean _templateInlining = true ; private boolean _forwardReference = false ; private boolean _hasIdCall = false ; private Properties _outputProperties = null ; public void setForwardReference ( ) { _forwardReference = true ; } public boolean getTemplateInlining ( ) { return _templateInlining ; } public void setTemplateInlining ( boolean flag ) { _templateInlining = flag ; } public boolean isSimplified ( ) { return ( _simplified ) ; } public void setSimplified ( ) { _simplified = true ; } public void setHasIdCall ( boolean flag ) { _hasIdCall = flag ; } public void setOutputProperty ( String key , String value ) { if ( _outputProperties == null ) { _outputProperties = new Properties ( ) ; } _outputProperties . setProperty ( key , value ) ; } public void setOutputProperties ( Properties props ) { _outputProperties = props ; } public Properties getOutputProperties ( ) { return _outputProperties ; } public void setMultiDocument ( boolean flag ) { _multiDocument = flag ; } public boolean isMultiDocument ( ) { return _multiDocument ; } public void setCallsNodeset ( boolean flag ) { if ( flag ) setMultiDocument ( flag ) ; _callsNodeset = flag ; } public boolean callsNodeset ( ) { return _callsNodeset ; } public void numberFormattingUsed ( ) { _numberFormattingUsed = true ; } public void setImportPrecedence ( final int precedence ) { _importPrecedence = precedence ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { SyntaxTreeNode child = ( SyntaxTreeNode ) elements . nextElement ( ) ; if ( child instanceof Include ) { Stylesheet included = ( ( Include ) child ) . getIncludedStylesheet ( ) ; if ( included != null && included . _includedFrom == this ) { included . setImportPrecedence ( precedence ) ; } } } if ( _importedFrom != null ) { if ( _importedFrom . getImportPrecedence ( ) < precedence ) { final Parser parser = getParser ( ) ; final int nextPrecedence = parser . getNextImportPrecedence ( ) ; _importedFrom . setImportPrecedence ( nextPrecedence ) ; } } else if ( _includedFrom != null ) { if ( _includedFrom . getImportPrecedence ( ) != precedence ) _includedFrom . setImportPrecedence ( precedence ) ; } } public int getImportPrecedence ( ) { return _importPrecedence ; } public boolean checkForLoop ( String systemId ) { if ( _systemId != null && _systemId . equals ( systemId ) ) { return true ; } if ( _parentStylesheet != null ) return _parentStylesheet . checkForLoop ( systemId ) ; return false ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _name = makeStylesheetName ( "__stylesheet_" ) ; } public void setParentStylesheet ( Stylesheet parent ) { _parentStylesheet = parent ; } public Stylesheet getParentStylesheet ( ) { return _parentStylesheet ; } public void setImportingStylesheet ( Stylesheet parent ) { _importedFrom = parent ; } public void setIncludingStylesheet ( Stylesheet parent ) { _includedFrom = parent ; } public void setSystemId ( String systemId ) { _systemId = systemId ; } public String getSystemId ( ) { return _systemId ; } public void setSourceLoader ( SourceLoader loader ) { _loader = loader ; } public SourceLoader getSourceLoader ( ) { return _loader ; } private QName makeStylesheetName ( String prefix ) { return getParser ( ) . getQName ( prefix + getXSLTC ( ) . nextStylesheetSerial ( ) ) ; } public boolean hasGlobals ( ) { return _globals . size ( ) > 0 ; } public boolean hasLocalParams ( ) { if ( _hasLocalParams == null ) { final int n = _templates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Template template = ( Template ) _templates . elementAt ( i ) ; if ( template . hasParams ( ) ) { _hasLocalParams = new Boolean ( true ) ; return true ; } } _hasLocalParams = new Boolean ( false ) ; return false ; } else { return _hasLocalParams . booleanValue ( ) ; } } protected void addPrefixMapping ( String prefix , String uri ) { if ( prefix . equals ( EMPTYSTRING ) && uri . equals ( XHTML_URI ) ) return ; super . addPrefixMapping ( prefix , uri ) ; } private void extensionURI ( String prefixes , SymbolTable stable ) { if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri = lookupNamespace ( prefix ) ; if ( uri != null ) { _extensions . put ( uri , prefix ) ; } } } } public boolean isExtension ( String uri ) { return ( _extensions . get ( uri ) != null ) ; } public void excludeExtensionPrefixes ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; final String excludePrefixes = getAttribute ( "exclude-result-prefixes" ) ; final String extensionPrefixes = getAttribute ( "extension-element-prefixes" ) ; stable . excludeURI ( Constants . XSLT_URI ) ; stable . excludeNamespaces ( excludePrefixes ) ; stable . excludeNamespaces ( extensionPrefixes ) ; extensionURI ( extensionPrefixes , stable ) ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; addPrefixMapping ( "xml" , "http://www.w3.org/XML/1998/namespace" ) ; final Stylesheet sheet = stable . addStylesheet ( _name , this ) ; if ( sheet != null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . MULTIPLE_STYLESHEET_ERR , this ) ; parser . reportError ( Constants . ERROR , err ) ; } if ( _simplified ) { stable . excludeURI ( XSLT_URI ) ; Template template = new Template ( ) ; template . parseSimplified ( this , parser ) ; } else { parseOwnChildren ( parser ) ; } } public final void parseOwnChildren ( Parser parser ) { final Vector contents = getContents ( ) ; final int count = contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ( child instanceof VariableBase ) || ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } } for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! ( child instanceof VariableBase ) && ! ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } if ( ! _templateInlining && ( child instanceof Template ) ) { Template template = ( Template ) child ; String name = "template$dot$" + template . getPosition ( ) ; template . setName ( parser . getQName ( name ) ) ; } } } public void processModes ( ) { if ( _defaultMode == null ) _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; _defaultMode . processPatterns ( _keys ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . processPatterns ( _keys ) ; } } private void compileModes ( ClassGenerator classGen ) { _defaultMode . compileApplyTemplates ( classGen ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . compileApplyTemplates ( classGen ) ; } } public Mode getMode ( QName modeName ) { if ( modeName == null ) { if ( _defaultMode == null ) { _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; } return _defaultMode ; } else { Mode mode = ( Mode ) _modes . get ( modeName ) ; if ( mode == null ) { final String suffix = Integer . toString ( _nextModeSerial ++ ) ; _modes . put ( modeName , mode = new Mode ( modeName , this , suffix ) ) ; } return mode ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . typeCheck ( stable ) ; } return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translate ( ) ; } private void addDOMField ( ClassGenerator classGen ) { final FieldGen fgen = new FieldGen ( ACC_PUBLIC , Util . getJCRefType ( DOM_INTF_SIG ) , DOM_FIELD , classGen . getConstantPool ( ) ) ; classGen . addField ( fgen . getField ( ) ) ; } public void translate ( ) { Output lastOutputElement = null ; _className = getXSLTC ( ) . getClassName ( ) ; final ClassGenerator classGen = new ClassGenerator ( _className , TRANSLET_CLASS , Constants . EMPTYSTRING , ACC_PUBLIC | ACC_SUPER , null , this ) ; addDOMField ( classGen ) ; compileTransform ( classGen ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object element = elements . nextElement ( ) ; if ( element instanceof Template ) { final Template template = ( Template ) element ; _templates . addElement ( template ) ; getMode ( template . getModeName ( ) ) . addTemplate ( template ) ; } else if ( element instanceof AttributeSet ) { ( ( AttributeSet ) element ) . translate ( classGen , null ) ; } else if ( element instanceof Output ) { Output output = ( Output ) element ; if ( output . enabled ( ) ) lastOutputElement = output ; } else { } } processModes ( ) ; compileModes ( classGen ) ; compileConstructor ( classGen , lastOutputElement ) ; if ( ! getParser ( ) . errorsFound ( ) ) { getXSLTC ( ) . dumpClass ( classGen . getJavaClass ( ) ) ; } } private void compileConstructor ( ClassGenerator classGen , Output output ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , null , null , "<init>" , _className , il , cpg ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( TRANSLET_CLASS , "<init>" , "()V" ) ) ) ; final Vector names = getXSLTC ( ) . getNamesIndex ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , names . size ( ) ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , name ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; final Vector namespaces = getXSLTC ( ) . getNamespaceIndex ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , namespaces . size ( ) ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < namespaces . size ( ) ; i ++ ) { final String ns = ( String ) namespaces . elementAt ( i ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , ns ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; if ( _hasIdCall ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , Boolean . TRUE ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , HASIDCALL_INDEX , HASIDCALL_INDEX_SIG ) ) ) ; } if ( output != null ) { output . translate ( classGen , constructor ) ; } if ( _numberFormattingUsed ) DecimalFormatting . translateDefaultDFS ( classGen , constructor ) ; il . append ( RETURN ) ; constructor . stripAttributes ( true ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; classGen . addMethod ( constructor . getMethod ( ) ) ; } private String compileTopLevel ( ClassGenerator classGen , Enumeration elements ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator toplevel = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "topLevel" , _className , il , classGen . getConstantPool ( ) ) ; toplevel . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = toplevel . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final int setFilter = cpg . addInterfaceMethodref ( DOM_INTF , "setFilter" , "(Lorg/apache/xalan/xsltc/StripFilter;)V" ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; _globals = resolveReferences ( _globals ) ; final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . translate ( classGen , toplevel ) ; } Vector whitespaceRules = new Vector ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof DecimalFormatting ) { ( ( DecimalFormatting ) element ) . translate ( classGen , toplevel ) ; } else if ( element instanceof Whitespace ) { whitespaceRules . addAll ( ( ( Whitespace ) element ) . getRules ( ) ) ; } } if ( whitespaceRules . size ( ) > 0 ) { Whitespace . translateRules ( whitespaceRules , classGen ) ; } if ( classGen . containsMethod ( STRIP_SPACE , STRIP_SPACE_PARAMS ) != null ) { il . append ( toplevel . loadDOM ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEINTERFACE ( setFilter , 2 ) ) ; } il . append ( RETURN ) ; toplevel . stripAttributes ( true ) ; toplevel . setMaxLocals ( ) ; toplevel . setMaxStack ( ) ; toplevel . removeNOPs ( ) ; classGen . addMethod ( toplevel . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; } private Vector resolveReferences ( Vector input ) { for ( int i = 0 ; i < input . size ( ) ; i ++ ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; final int depSize = ( dep != null ) ? dep . size ( ) : 0 ; for ( int j = 0 ; j < depSize ; j ++ ) { final VariableBase depVar = ( VariableBase ) dep . elementAt ( j ) ; if ( ! input . contains ( depVar ) ) { input . addElement ( depVar ) ; } } } Vector result = new Vector ( ) ; while ( input . size ( ) > 0 ) { boolean changed = false ; for ( int i = 0 ; i < input . size ( ) ; ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; if ( dep == null || result . containsAll ( dep ) ) { result . addElement ( var ) ; input . remove ( i ) ; changed = true ; } else { i ++ ; } } if ( ! changed ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CIRCULAR_VARIABLE_ERR , input . toString ( ) , this ) ; getParser ( ) . reportError ( Constants . ERROR , err ) ; return ( result ) ; } } return result ; } private String compileBuildKeys ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , org . apache . bcel . generic . Type . INT } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME , "current" } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator buildKeys = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "buildKeys" , _className , il , classGen . getConstantPool ( ) ) ; buildKeys . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof Key ) { final Key key = ( Key ) element ; key . translate ( classGen , buildKeys ) ; _keys . put ( key . getName ( ) , key ) ; } } il . append ( RETURN ) ; buildKeys . stripAttributes ( true ) ; buildKeys . setMaxLocals ( ) ; buildKeys . setMaxStack ( ) ; buildKeys . removeNOPs ( ) ; classGen . addMethod ( buildKeys . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + "I)V" ) ; } private void compileTransform ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator transf = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "transform" , _className , il , classGen . getConstantPool ( ) ) ; transf . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = transf . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( getClassName ( ) , "applyTemplates" , applyTemplatesSig ) ; final int domField = cpg . addFieldref ( getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( isMultiDocument ( ) ) { il . append ( new NEW ( cpg . addClass ( MULTI_DOM_CLASS ) ) ) ; il . append ( DUP ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , "makeDOMAdapter" , "(" + DOM_INTF_SIG + ")" + DOM_ADAPTER_SIG ) ) ) ; if ( isMultiDocument ( ) ) { final int init = cpg . addMethodref ( MULTI_DOM_CLASS , "<init>" , "(" + DOM_INTF_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } il . append ( new PUTFIELD ( domField ) ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadHandler ( ) ) ; final int index = cpg . addMethodref ( TRANSLET_CLASS , "transferOutputSettings" , "(" + OUTPUT_HANDLER_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; final Enumeration toplevel = elements ( ) ; if ( ( _globals . size ( ) > 0 ) || ( toplevel . hasMoreElements ( ) ) ) { final String topLevelSig = compileTopLevel ( classGen , toplevel ) ; final int topLevelIdx = cpg . addMethodref ( getClassName ( ) , "topLevel" , topLevelSig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( topLevelIdx ) ) ; } final String keySig = compileBuildKeys ( classGen ) ; final int keyIdx = cpg . addMethodref ( getClassName ( ) , "buildKeys" , keySig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new INVOKEVIRTUAL ( keyIdx ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( transf . startDocument ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( transf . endDocument ( ) ) ; il . append ( RETURN ) ; transf . stripAttributes ( true ) ; transf . setMaxLocals ( ) ; transf . setMaxStack ( ) ; transf . removeNOPs ( ) ; classGen . addMethod ( transf . getMethod ( ) ) ; } private void peepHoleOptimization ( MethodGenerator methodGen ) { final String pattern = "`ALOAD'`POP'`Instruction'" ; final InstructionList il = methodGen . getInstructionList ( ) ; final InstructionFinder find = new InstructionFinder ( il ) ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { il . delete ( match [ 0 ] , match [ 1 ] ) ; } catch ( TargetLostException e ) { } } } public int addParam ( Param param ) { _globals . addElement ( param ) ; return _globals . size ( ) - 1 ; } public int addVariable ( Variable global ) { _globals . addElement ( global ) ; return _globals . size ( ) - 1 ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Stylesheet" ) ; displayContents ( indent + IndentIncrement ) ; } public String getNamespace ( String prefix ) { return lookupNamespace ( prefix ) ; } public String getClassName ( ) { return _className ; } public Vector getTemplates ( ) { return _templates ; } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Mod extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) % right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) % m_right . num ( xctxt ) ) ; } } 	0
package org . apache . xml . serializer ; import java . util . Hashtable ; import org . xml . sax . Attributes ; import org . xml . sax . helpers . AttributesImpl ; public class AttributesImplSerializer extends AttributesImpl { private Hashtable m_indexFromQName = new Hashtable ( ) ; public int getIndex ( String qname ) { int index ; Integer i = ( Integer ) m_indexFromQName . get ( qname ) ; if ( i == null ) index = - 1 ; else index = i . intValue ( ) ; return index ; } public void addAttribute ( String uri , String local , String qname , String type , String val ) { int index = super . getLength ( ) ; super . addAttribute ( uri , local , qname , type , val ) ; Integer i = new Integer ( index ) ; m_indexFromQName . put ( qname , i ) ; } public void clear ( ) { m_indexFromQName . clear ( ) ; super . clear ( ) ; } public void setAttributes ( Attributes atts ) { super . setAttributes ( atts ) ; int numAtts = atts . getLength ( ) ; for ( int i = 0 ; i < numAtts ; i ++ ) { String qName = atts . getQName ( i ) ; int index = super . getIndex ( qName ) ; Integer io = new Integer ( index ) ; m_indexFromQName . put ( qName , io ) ; } } } 	0
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XNodeSetForDOM extends XNodeSet { Object m_origObj ; public XNodeSetForDOM ( Node node , DTMManager dtmMgr ) { m_dtmMgr = dtmMgr ; m_origObj = node ; int dtmHandle = dtmMgr . getDTMHandleFromNode ( node ) ; m_obj = new NodeSetDTM ( dtmMgr ) ; ( ( NodeSetDTM ) m_obj ) . addNode ( dtmHandle ) ; } public XNodeSetForDOM ( XNodeSet val ) { super ( val ) ; if ( val instanceof XNodeSetForDOM ) m_origObj = ( ( XNodeSetForDOM ) val ) . m_origObj ; } public XNodeSetForDOM ( NodeList nodeList , XPathContext xctxt ) { m_dtmMgr = xctxt . getDTMManager ( ) ; m_origObj = nodeList ; org . apache . xpath . NodeSetDTM nsdtm = new org . apache . xpath . NodeSetDTM ( nodeList , xctxt ) ; m_last = nsdtm . getLength ( ) ; m_obj = nsdtm ; } public XNodeSetForDOM ( NodeIterator nodeIter , XPathContext xctxt ) { m_dtmMgr = xctxt . getDTMManager ( ) ; m_origObj = nodeIter ; org . apache . xpath . NodeSetDTM nsdtm = new org . apache . xpath . NodeSetDTM ( nodeIter , xctxt ) ; m_last = nsdtm . getLength ( ) ; m_obj = nsdtm ; } public Object object ( ) { return m_origObj ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { return ( m_origObj instanceof NodeIterator ) ? ( NodeIterator ) m_origObj : super . nodeset ( ) ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { return ( m_origObj instanceof NodeList ) ? ( NodeList ) m_origObj : super . nodelist ( ) ; } } 	0
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; public final class VoidType extends Type { protected VoidType ( ) { } public String toString ( ) { return "void" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "V" ; } public org . apache . bcel . generic . Type toJCType ( ) { return null ; } public Instruction POP ( ) { return NOP ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( classGen . getConstantPool ( ) , "" ) ) ; } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( ! clazz . getName ( ) . equals ( "void" ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncNumber extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsNumber ( xctxt ) ) ; } } 	1
package org . apache . xpath . patterns ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public class UnionPattern extends Expression { private StepPattern [ ] m_patterns ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { for ( int i = 0 ; i < m_patterns . length ; i ++ ) { m_patterns [ i ] . fixupVariables ( vars , globalsSize ) ; } } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_patterns ) { int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( m_patterns [ i ] . canTraverseOutsideSubtree ( ) ) return true ; } } return false ; } public void setPatterns ( StepPattern [ ] patterns ) { m_patterns = patterns ; if ( null != patterns ) { for ( int i = 0 ; i < patterns . length ; i ++ ) { patterns [ i ] . exprSetParent ( this ) ; } } } public StepPattern [ ] getPatterns ( ) { return m_patterns ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject bestScore = null ; int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { XObject score = m_patterns [ i ] . execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) { if ( null == bestScore ) bestScore = score ; else if ( score . num ( ) > bestScore . num ( ) ) bestScore = score ; } } if ( null == bestScore ) { bestScore = NodeTest . SCORE_NONE ; } return bestScore ; } class UnionPathPartOwner implements ExpressionOwner { int m_index ; UnionPathPartOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_patterns [ m_index ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( UnionPattern . this ) ; m_patterns [ m_index ] = ( StepPattern ) exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitUnionPattern ( owner , this ) ; if ( null != m_patterns ) { int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { m_patterns [ i ] . callVisitors ( new UnionPathPartOwner ( i ) , visitor ) ; } } } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; UnionPattern up = ( UnionPattern ) expr ; if ( null != m_patterns ) { int n = m_patterns . length ; if ( ( null == up . m_patterns ) || ( up . m_patterns . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_patterns [ i ] . deepEquals ( up . m_patterns [ i ] ) ) return false ; } } else if ( up . m_patterns != null ) return false ; return true ; } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class FilterExpr extends Expression { private Expression _primary ; private final Vector _predicates ; public FilterExpr ( Expression primary , Vector predicates ) { _primary = primary ; _predicates = predicates ; primary . setParent ( this ) ; } protected Expression getExpr ( ) { if ( _primary instanceof CastExpr ) return ( ( CastExpr ) _primary ) . getExpr ( ) ; else return _primary ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _primary . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public String toString ( ) { return "filter-expr(" + _primary + ", " + _predicates + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type ptype = _primary . typeCheck ( stable ) ; if ( ptype instanceof NodeSetType == false ) { if ( ptype instanceof ReferenceType ) { _primary = new CastExpr ( _primary , Type . NodeSet ) ; } else { throw new TypeCheckError ( this ) ; } } int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Expression pred = ( Expression ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _predicates . size ( ) > 0 ) { translatePredicates ( classGen , methodGen ) ; } else { _primary . translate ( classGen , methodGen ) ; _primary . startResetIterator ( classGen , methodGen ) ; } } public void translatePredicates ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _predicates . size ( ) == 0 ) { translate ( classGen , methodGen ) ; } else { final int initCNLI = cpg . addMethodref ( CURRENT_NODE_LIST_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + "Z" + CURRENT_NODE_LIST_FILTER_SIG + NODE_SIG + TRANSLET_SIG + ")V" ) ; Predicate predicate = ( Predicate ) _predicates . lastElement ( ) ; _predicates . remove ( predicate ) ; if ( predicate . isNthPositionFilter ( ) ) { final int start = cpg . addInterfaceMethodref ( NODE_ITERATOR , "setStartNode" , "(I)" + NODE_ITERATOR_SIG ) ; final int reset = cpg . addInterfaceMethodref ( NODE_ITERATOR , "reset" , "()" + NODE_ITERATOR_SIG ) ; translatePredicates ( classGen , methodGen ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( start , 2 ) ) ; il . append ( new INVOKEINTERFACE ( reset , 1 ) ) ; final int sngl = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "getSingleNode" , "(" + NODE_ITERATOR_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( sngl ) ) ; } else { il . append ( new NEW ( cpg . addClass ( CURRENT_NODE_LIST_ITERATOR ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; il . append ( ICONST_1 ) ; predicate . translate ( classGen , methodGen ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKESPECIAL ( initCNLI ) ) ; } } } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public class Operation extends Expression implements ExpressionOwner { protected Expression m_left ; protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_left . fixupVariables ( vars , globalsSize ) ; m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_left && m_left . canTraverseOutsideSubtree ( ) ) return true ; if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setLeftRight ( Expression l , Expression r ) { m_left = l ; m_right = r ; l . exprSetParent ( this ) ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; XObject result = operate ( left , right ) ; left . detach ( ) ; right . detach ( ) ; return result ; } public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return null ; } public Expression getLeftOperand ( ) { return m_left ; } public Expression getRightOperand ( ) { return m_right ; } class LeftExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_left ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Operation . this ) ; m_left = exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitBinaryOperation ( owner , this ) ) { m_left . callVisitors ( new LeftExprOwner ( ) , visitor ) ; m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_left . deepEquals ( ( ( Operation ) expr ) . m_left ) ) return false ; if ( ! m_right . deepEquals ( ( ( Operation ) expr ) . m_right ) ) return false ; return true ; } } 	0
package org . apache . xalan . xsltc . runtime ; import java . text . DecimalFormat ; import java . text . FieldPosition ; import java . text . MessageFormat ; import java . text . NumberFormat ; import java . util . Locale ; import java . util . ResourceBundle ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . dom . DOMSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . dom . AbsoluteIterator ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xalan . xsltc . dom . DOMAdapter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . MultiDOM ; import org . apache . xalan . xsltc . dom . SingletonIterator ; import org . apache . xalan . xsltc . dom . StepIterator ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . apache . xml . serializer . SerializationHandler ; public final class BasisLibrary implements Operators { private final static String EMPTYSTRING = "" ; public static int countF ( DTMAxisIterator iterator ) { return ( iterator . getLast ( ) ) ; } public static int positionF ( DTMAxisIterator iterator ) { return iterator . isReverse ( ) ? iterator . getLast ( ) - iterator . getPosition ( ) + 1 : iterator . getPosition ( ) ; } public static double sumF ( DTMAxisIterator iterator , DOM dom ) { try { double result = 0.0 ; int node ; while ( ( node = iterator . next ( ) ) != DTMAxisIterator . END ) { result += Double . parseDouble ( dom . getStringValueX ( node ) ) ; } return result ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static String stringF ( int node , DOM dom ) { return dom . getStringValueX ( node ) ; } public static String stringF ( Object obj , DOM dom ) { if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else { return obj . toString ( ) ; } } public static String stringF ( Object obj , int node , DOM dom ) { if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else if ( obj instanceof Double ) { Double d = ( Double ) obj ; final String result = d . toString ( ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( obj != null ) return obj . toString ( ) ; else return stringF ( node , dom ) ; } } public static double numberF ( int node , DOM dom ) { return stringToReal ( dom . getStringValueX ( node ) ) ; } public static double numberF ( Object obj , DOM dom ) { if ( obj instanceof Double ) { return ( ( Double ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ? 1.0 : 0.0 ; } else if ( obj instanceof String ) { return stringToReal ( ( String ) obj ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; return stringToReal ( dom . getStringValueX ( iter . reset ( ) . next ( ) ) ) ; } else if ( obj instanceof Node ) { return stringToReal ( dom . getStringValueX ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof DOM ) { return stringToReal ( ( ( DOM ) obj ) . getStringValue ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; return 0.0 ; } } public static boolean booleanF ( Object obj ) { if ( obj instanceof Double ) { final double temp = ( ( Double ) obj ) . doubleValue ( ) ; return temp != 0.0 && ! Double . isNaN ( temp ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) != 0 ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else if ( obj instanceof String ) { return ! ( ( String ) obj ) . equals ( EMPTYSTRING ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; return iter . reset ( ) . next ( ) != DTMAxisIterator . END ; } else if ( obj instanceof Node ) { return true ; } else if ( obj instanceof DOM ) { String temp = ( ( DOM ) obj ) . getStringValue ( ) ; return ! temp . equals ( EMPTYSTRING ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; } return false ; } public static String substringF ( String value , double start ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; if ( Double . isNaN ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( istart < 1 ) istart = 0 ; return value . substring ( istart ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substringF ( String value , double start , double length ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; int isum = istart + ( int ) Math . round ( length ) ; if ( Double . isInfinite ( length ) ) isum = Integer . MAX_VALUE ; if ( Double . isNaN ( start ) || Double . isNaN ( length ) ) return ( EMPTYSTRING ) ; if ( Double . isInfinite ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( isum < 0 ) return ( EMPTYSTRING ) ; if ( istart < 0 ) istart = 0 ; if ( isum > strlen ) return value . substring ( istart ) ; else return value . substring ( istart , isum ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substring_afterF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( index + substring . length ( ) ) ; else return EMPTYSTRING ; } public static String substring_beforeF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( 0 , index ) ; else return EMPTYSTRING ; } public static String translateF ( String value , String from , String to ) { final int tol = to . length ( ) ; final int froml = from . length ( ) ; final int valuel = value . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int j , i = 0 ; i < valuel ; i ++ ) { final char ch = value . charAt ( i ) ; for ( j = 0 ; j < froml ; j ++ ) { if ( ch == from . charAt ( j ) ) { if ( j < tol ) result . append ( to . charAt ( j ) ) ; break ; } } if ( j == froml ) result . append ( ch ) ; } return result . toString ( ) ; } public static String normalize_spaceF ( int node , DOM dom ) { return normalize_spaceF ( dom . getStringValueX ( node ) ) ; } public static String normalize_spaceF ( String value ) { int i = 0 , n = value . length ( ) ; StringBuffer result = new StringBuffer ( ) ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) i ++ ; while ( true ) { while ( i < n && ! isWhiteSpace ( value . charAt ( i ) ) ) { result . append ( value . charAt ( i ++ ) ) ; } if ( i == n ) break ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) { i ++ ; } if ( i < n ) result . append ( ' ' ) ; } return result . toString ( ) ; } public static String generate_idF ( int node ) { if ( node > 0 ) return "N" + node ; else return EMPTYSTRING ; } public static String getLocalName ( String value ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . lastIndexOf ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; } public static void unresolved_externalF ( String name ) { runTimeError ( EXTERNAL_FUNC_ERR , name ) ; } public static String namespace_uriF ( DTMAxisIterator iter , DOM dom ) { return namespace_uriF ( iter . next ( ) , dom ) ; } public static String system_propertyF ( String name ) { if ( name . equals ( "xsl:version" ) ) return ( "1.0" ) ; if ( name . equals ( "xsl:vendor" ) ) return ( "Apache Software Foundation (Xalan XSLTC)" ) ; if ( name . equals ( "xsl:vendor-url" ) ) return ( "http://xml.apache.org/xalan-j" ) ; runTimeError ( INVALID_ARGUMENT_ERR , name , "system-property()" ) ; return ( EMPTYSTRING ) ; } public static String namespace_uriF ( int node , DOM dom ) { final String value = dom . getNodeName ( node ) ; final int colon = value . lastIndexOf ( ':' ) ; if ( colon >= 0 ) return value . substring ( 0 , colon ) ; else return EMPTYSTRING ; } public static String objectTypeF ( Object obj ) { if ( obj instanceof String ) return "string" ; else if ( obj instanceof Boolean ) return "boolean" ; else if ( obj instanceof Number ) return "number" ; else if ( obj instanceof DOM ) return "RTF" ; else if ( obj instanceof DTMAxisIterator ) return "node-set" ; else return "unknown" ; } public static DTMAxisIterator nodesetF ( Object obj ) { if ( obj instanceof DOM ) { final DOM dom = ( DOM ) obj ; return new SingletonIterator ( dom . getDocument ( ) , true ) ; } else if ( obj instanceof DTMAxisIterator ) { return ( DTMAxisIterator ) obj ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "node-set" , className ) ; return null ; } } private static boolean isWhiteSpace ( char ch ) { return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' ; } private static boolean compareStrings ( String lstring , String rstring , int op , DOM dom ) { switch ( op ) { case EQ : return lstring . equals ( rstring ) ; case NE : return ! lstring . equals ( rstring ) ; case GT : return numberF ( lstring , dom ) > numberF ( rstring , dom ) ; case LT : return numberF ( lstring , dom ) < numberF ( rstring , dom ) ; case GE : return numberF ( lstring , dom ) >= numberF ( rstring , dom ) ; case LE : return numberF ( lstring , dom ) <= numberF ( rstring , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; return false ; } } public static boolean compare ( DTMAxisIterator left , DTMAxisIterator right , int op , DOM dom ) { int lnode ; left . reset ( ) ; while ( ( lnode = left . next ( ) ) != DTMAxisIterator . END ) { final String lvalue = dom . getStringValueX ( lnode ) ; int rnode ; right . reset ( ) ; while ( ( rnode = right . next ( ) ) != DTMAxisIterator . END ) { if ( lnode == rnode ) { if ( op == EQ ) { return true ; } else if ( op == NE ) { continue ; } } if ( compareStrings ( lvalue , dom . getStringValueX ( rnode ) , op , dom ) ) { return true ; } } } return false ; } public static boolean compare ( int node , DTMAxisIterator iterator , int op , DOM dom ) { int rnode ; String value ; switch ( op ) { case EQ : rnode = iterator . next ( ) ; if ( rnode != DTMAxisIterator . END ) { value = dom . getStringValueX ( node ) ; do { if ( node == rnode || value . equals ( dom . getStringValueX ( rnode ) ) ) { return true ; } } while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) ; } break ; case NE : rnode = iterator . next ( ) ; if ( rnode != DTMAxisIterator . END ) { value = dom . getStringValueX ( node ) ; do { if ( node != rnode && ! value . equals ( dom . getStringValueX ( rnode ) ) ) { return true ; } } while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) ; } break ; case LT : while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) { if ( rnode > node ) return true ; } break ; case GT : while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) { if ( rnode < node ) return true ; } break ; } return ( false ) ; } public static boolean compare ( DTMAxisIterator left , final double rnumber , final int op , DOM dom ) { int node ; switch ( op ) { case EQ : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) == rnumber ) return true ; } break ; case NE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) != rnumber ) return true ; } break ; case GT : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) > rnumber ) return true ; } break ; case LT : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) < rnumber ) return true ; } break ; case GE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) >= rnumber ) return true ; } break ; case LE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) <= rnumber ) return true ; } break ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } return false ; } public static boolean compare ( DTMAxisIterator left , final String rstring , int op , DOM dom ) { int node ; while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( compareStrings ( dom . getStringValueX ( node ) , rstring , op , dom ) ) { return true ; } } return false ; } public static boolean compare ( Object left , Object right , int op , DOM dom ) { boolean result = false ; boolean hasSimpleArgs = hasSimpleType ( left ) && hasSimpleType ( right ) ; if ( op != EQ && op != NE ) { if ( left instanceof Node || right instanceof Node ) { if ( left instanceof Boolean ) { right = new Boolean ( booleanF ( right ) ) ; hasSimpleArgs = true ; } if ( right instanceof Boolean ) { left = new Boolean ( booleanF ( left ) ) ; hasSimpleArgs = true ; } } if ( hasSimpleArgs ) { switch ( op ) { case GT : return numberF ( left , dom ) > numberF ( right , dom ) ; case LT : return numberF ( left , dom ) < numberF ( right , dom ) ; case GE : return numberF ( left , dom ) >= numberF ( right , dom ) ; case LE : return numberF ( left , dom ) <= numberF ( right , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } } } if ( hasSimpleArgs ) { if ( left instanceof Boolean || right instanceof Boolean ) { result = booleanF ( left ) == booleanF ( right ) ; } else if ( left instanceof Double || right instanceof Double || left instanceof Integer || right instanceof Integer ) { result = numberF ( left , dom ) == numberF ( right , dom ) ; } else { result = stringF ( left , dom ) . equals ( stringF ( right , dom ) ) ; } if ( op == Operators . NE ) { result = ! result ; } } else { if ( left instanceof Node ) { left = new SingletonIterator ( ( ( Node ) left ) . node ) ; } if ( right instanceof Node ) { right = new SingletonIterator ( ( ( Node ) right ) . node ) ; } if ( hasSimpleType ( left ) || left instanceof DOM && right instanceof DTMAxisIterator ) { final Object temp = right ; right = left ; left = temp ; } if ( left instanceof DOM ) { if ( right instanceof Boolean ) { result = ( ( Boolean ) right ) . booleanValue ( ) ; return result == ( op == Operators . EQ ) ; } final String sleft = ( ( DOM ) left ) . getStringValue ( ) ; if ( right instanceof Number ) { result = ( ( Number ) right ) . doubleValue ( ) == stringToReal ( sleft ) ; } else if ( right instanceof String ) { result = sleft . equals ( ( String ) right ) ; } else if ( right instanceof DOM ) { result = sleft . equals ( ( ( DOM ) right ) . getStringValue ( ) ) ; } if ( op == Operators . NE ) { result = ! result ; } return result ; } DTMAxisIterator iter = ( ( DTMAxisIterator ) left ) . reset ( ) ; if ( right instanceof DTMAxisIterator ) { result = compare ( iter , ( DTMAxisIterator ) right , op , dom ) ; } else if ( right instanceof String ) { result = compare ( iter , ( String ) right , op , dom ) ; } else if ( right instanceof Number ) { final double temp = ( ( Number ) right ) . doubleValue ( ) ; result = compare ( iter , temp , op , dom ) ; } else if ( right instanceof Boolean ) { boolean temp = ( ( Boolean ) right ) . booleanValue ( ) ; result = ( iter . reset ( ) . next ( ) != DTMAxisIterator . END ) == temp ; } else if ( right instanceof DOM ) { result = compare ( iter , ( ( DOM ) right ) . getStringValue ( ) , op , dom ) ; } else if ( right == null ) { return ( false ) ; } else { final String className = right . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "compare()" ) ; } } return result ; } public static boolean testLanguage ( String testLang , DOM dom , int node ) { String nodeLang = dom . getLanguage ( node ) ; if ( nodeLang == null ) return ( false ) ; else nodeLang = nodeLang . toLowerCase ( ) ; testLang = testLang . toLowerCase ( ) ; if ( testLang . length ( ) == 2 ) { return ( nodeLang . startsWith ( testLang ) ) ; } else { return ( nodeLang . equals ( testLang ) ) ; } } private static boolean hasSimpleType ( Object obj ) { return obj instanceof Boolean || obj instanceof Double || obj instanceof Integer || obj instanceof String || obj instanceof Node || obj instanceof DOM ; } public static double stringToReal ( String s ) { try { return Double . valueOf ( s ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static int stringToInt ( String s ) { try { return Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { return ( - 1 ) ; } } private static double lowerBounds = 0.001 ; private static double upperBounds = 10000000 ; private static DecimalFormat defaultFormatter ; private static String defaultPattern = "" ; static { NumberFormat f = NumberFormat . getInstance ( Locale . getDefault ( ) ) ; f . setMaximumFractionDigits ( Integer . MAX_VALUE ) ; defaultFormatter = ( f instanceof DecimalFormat ) ? ( DecimalFormat ) f : new DecimalFormat ( ) ; defaultFormatter . setGroupingUsed ( false ) ; } public static String realToString ( double d ) { final double m = Math . abs ( d ) ; if ( ( m >= lowerBounds ) && ( m < upperBounds ) ) { final String result = Double . toString ( d ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( Double . isNaN ( d ) || Double . isInfinite ( d ) ) return ( Double . toString ( d ) ) ; return formatNumber ( d , defaultPattern , defaultFormatter ) ; } } public static int realToInt ( double d ) { return ( int ) d ; } private static FieldPosition _fieldPosition = new FieldPosition ( 0 ) ; public static String formatNumber ( double number , String pattern , DecimalFormat formatter ) { if ( formatter == null ) { formatter = defaultFormatter ; } try { StringBuffer result = new StringBuffer ( ) ; if ( pattern != defaultPattern ) { formatter . applyLocalizedPattern ( pattern ) ; } String localizedPattern = formatter . toPattern ( ) ; int index = localizedPattern . indexOf ( '.' ) ; if ( index >= 1 && localizedPattern . charAt ( index - 1 ) == '#' ) { StringBuffer newpattern = new StringBuffer ( ) ; newpattern . append ( localizedPattern . substring ( 0 , index - 1 ) ) ; newpattern . append ( "0" ) ; newpattern . append ( localizedPattern . substring ( index ) ) ; formatter . applyLocalizedPattern ( newpattern . toString ( ) ) ; } else if ( index == 0 ) { StringBuffer newpattern = new StringBuffer ( ) ; newpattern . append ( "0" ) ; newpattern . append ( localizedPattern ) ; formatter . applyLocalizedPattern ( newpattern . toString ( ) ) ; } formatter . format ( number , result , _fieldPosition ) ; return ( result . toString ( ) ) ; } catch ( IllegalArgumentException e ) { runTimeError ( FORMAT_NUMBER_ERR , Double . toString ( number ) , pattern ) ; return ( EMPTYSTRING ) ; } } public static DTMAxisIterator referenceToNodeSet ( Object obj ) { if ( obj instanceof Node ) { return ( new SingletonIterator ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof DTMAxisIterator ) { return ( ( ( DTMAxisIterator ) obj ) . cloneIterator ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static NodeList referenceToNodeList ( Object obj , DOM dom ) { if ( obj instanceof Node || obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = referenceToNodeSet ( obj ) ; return dom . makeNodeList ( iter ) ; } else if ( obj instanceof DOM ) { dom = ( DOM ) obj ; return dom . makeNodeList ( DTMDefaultBase . ROOTNODE ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static org . w3c . dom . Node referenceToNode ( Object obj , DOM dom ) { if ( obj instanceof Node || obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = referenceToNodeSet ( obj ) ; return dom . makeNode ( iter ) ; } else if ( obj instanceof DOM ) { dom = ( DOM ) obj ; DTMAxisIterator iter = dom . getChildren ( DTMDefaultBase . ROOTNODE ) ; return dom . makeNode ( iter ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static DTMAxisIterator node2Iterator ( org . w3c . dom . Node node , Translet translet , DOM dom ) { final org . w3c . dom . Node inNode = node ; org . w3c . dom . NodeList nodelist = new org . w3c . dom . NodeList ( ) { public int getLength ( ) { return 1 ; } public org . w3c . dom . Node item ( int index ) { if ( index == 0 ) return inNode ; else return null ; } } ; return nodeList2Iterator ( nodelist , translet , dom ) ; } private static void copyNodes ( org . w3c . dom . NodeList nodeList , org . w3c . dom . Document doc , org . w3c . dom . Node parent ) { final int size = nodeList . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { org . w3c . dom . Node curr = nodeList . item ( i ) ; int nodeType = curr . getNodeType ( ) ; String value = null ; try { value = curr . getNodeValue ( ) ; } catch ( DOMException ex ) { runTimeError ( RUN_TIME_INTERNAL_ERR , ex . getMessage ( ) ) ; return ; } String nodeName = curr . getNodeName ( ) ; org . w3c . dom . Node newNode = null ; switch ( nodeType ) { case org . w3c . dom . Node . ATTRIBUTE_NODE : newNode = doc . createAttributeNS ( curr . getNamespaceURI ( ) , nodeName ) ; break ; case org . w3c . dom . Node . CDATA_SECTION_NODE : newNode = doc . createCDATASection ( value ) ; break ; case org . w3c . dom . Node . COMMENT_NODE : newNode = doc . createComment ( value ) ; break ; case org . w3c . dom . Node . DOCUMENT_FRAGMENT_NODE : newNode = doc . createDocumentFragment ( ) ; break ; case org . w3c . dom . Node . DOCUMENT_NODE : newNode = doc . createElementNS ( null , "__document__" ) ; copyNodes ( curr . getChildNodes ( ) , doc , newNode ) ; break ; case org . w3c . dom . Node . DOCUMENT_TYPE_NODE : break ; case org . w3c . dom . Node . ELEMENT_NODE : org . w3c . dom . Element element = doc . createElementNS ( curr . getNamespaceURI ( ) , nodeName ) ; if ( curr . hasAttributes ( ) ) { org . w3c . dom . NamedNodeMap attributes = curr . getAttributes ( ) ; for ( int k = 0 ; k < attributes . getLength ( ) ; k ++ ) { org . w3c . dom . Node attr = attributes . item ( k ) ; element . setAttribute ( attr . getNodeName ( ) , attr . getNodeValue ( ) ) ; } } copyNodes ( curr . getChildNodes ( ) , doc , element ) ; newNode = element ; break ; case org . w3c . dom . Node . ENTITY_NODE : break ; case org . w3c . dom . Node . ENTITY_REFERENCE_NODE : newNode = doc . createEntityReference ( nodeName ) ; break ; case org . w3c . dom . Node . NOTATION_NODE : break ; case org . w3c . dom . Node . PROCESSING_INSTRUCTION_NODE : newNode = doc . createProcessingInstruction ( nodeName , value ) ; break ; case org . w3c . dom . Node . TEXT_NODE : newNode = doc . createTextNode ( value ) ; break ; } try { parent . appendChild ( newNode ) ; } catch ( DOMException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return ; } } } public static DTMAxisIterator nodeList2Iterator ( org . w3c . dom . NodeList nodeList , Translet translet , DOM dom ) { DocumentBuilderFactory dfac = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docbldr = null ; try { docbldr = dfac . newDocumentBuilder ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return null ; } Document doc = docbldr . newDocument ( ) ; org . w3c . dom . Node topElementNode = doc . appendChild ( doc . createElementNS ( "" , "__top__" ) ) ; copyNodes ( nodeList , doc , topElementNode ) ; if ( dom instanceof MultiDOM ) { final MultiDOM multiDOM = ( MultiDOM ) dom ; DTMDefaultBase dtm = ( DTMDefaultBase ) ( ( DOMAdapter ) multiDOM . getMain ( ) ) . getDOMImpl ( ) ; DTMManager dtmManager = dtm . getManager ( ) ; SAXImpl idom = ( SAXImpl ) dtmManager . getDTM ( new DOMSource ( doc ) , false , null , true , false ) ; DOMAdapter domAdapter = new DOMAdapter ( idom , translet . getNamesArray ( ) , translet . getNamespaceArray ( ) ) ; multiDOM . addDOMAdapter ( domAdapter ) ; DTMAxisIterator iter1 = idom . getAxisIterator ( Axis . CHILD ) ; DTMAxisIterator iter2 = idom . getAxisIterator ( Axis . CHILD ) ; DTMAxisIterator iter = new AbsoluteIterator ( new StepIterator ( iter1 , iter2 ) ) ; iter . setStartNode ( DTMDefaultBase . ROOTNODE ) ; return iter ; } else { runTimeError ( RUN_TIME_INTERNAL_ERR , "nodeList2Iterator()" ) ; return null ; } } public static DOM referenceToResultTree ( Object obj ) { try { return ( ( DOM ) obj ) ; } catch ( IllegalArgumentException e ) { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static DTMAxisIterator getSingleNode ( DTMAxisIterator iterator ) { int node = iterator . next ( ) ; return ( new SingletonIterator ( node ) ) ; } private static char [ ] _characterArray = new char [ 32 ] ; public static void copy ( Object obj , SerializationHandler handler , int node , DOM dom ) { try { if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; dom . copy ( iter . reset ( ) , handler ) ; } else if ( obj instanceof Node ) { dom . copy ( ( ( Node ) obj ) . node , handler ) ; } else if ( obj instanceof DOM ) { DOM newDom = ( DOM ) obj ; newDom . copy ( newDom . getDocument ( ) , handler ) ; } else { String string = obj . toString ( ) ; final int length = string . length ( ) ; if ( length > _characterArray . length ) _characterArray = new char [ length ] ; string . getChars ( 0 , length , _characterArray , 0 ) ; handler . characters ( _characterArray , 0 , length ) ; } } catch ( SAXException e ) { runTimeError ( RUN_TIME_COPY_ERR ) ; } } public static String startXslElement ( String qname , String namespace , SerializationHandler handler , DOM dom , int node ) { try { String prefix ; final int index = qname . indexOf ( ':' ) ; if ( index > 0 ) { prefix = qname . substring ( 0 , index ) ; if ( namespace == null || namespace . length ( ) == 0 ) { namespace = dom . lookupNamespace ( node , prefix ) ; } handler . startElement ( namespace , qname . substring ( index + 1 ) , qname ) ; handler . namespaceAfterStartElement ( prefix , namespace ) ; } else { if ( namespace != null && namespace . length ( ) > 0 ) { prefix = generatePrefix ( ) ; qname = prefix + ':' + qname ; handler . startElement ( namespace , qname , qname ) ; handler . namespaceAfterStartElement ( prefix , namespace ) ; } else { handler . startElement ( null , null , qname ) ; } } } catch ( SAXException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } return qname ; } public static String getPrefix ( String qname ) { final int index = qname . indexOf ( ':' ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : null ; } private static int prefixIndex = 0 ; public static String generatePrefix ( ) { return ( "ns" + prefixIndex ++ ) ; } public static final String RUN_TIME_INTERNAL_ERR = "RUN_TIME_INTERNAL_ERR" ; public static final String RUN_TIME_COPY_ERR = "RUN_TIME_COPY_ERR" ; public static final String DATA_CONVERSION_ERR = "DATA_CONVERSION_ERR" ; public static final String EXTERNAL_FUNC_ERR = "EXTERNAL_FUNC_ERR" ; public static final String EQUALITY_EXPR_ERR = "EQUALITY_EXPR_ERR" ; public static final String INVALID_ARGUMENT_ERR = "INVALID_ARGUMENT_ERR" ; public static final String FORMAT_NUMBER_ERR = "FORMAT_NUMBER_ERR" ; public static final String ITERATOR_CLONE_ERR = "ITERATOR_CLONE_ERR" ; public static final String AXIS_SUPPORT_ERR = "AXIS_SUPPORT_ERR" ; public static final String TYPED_AXIS_SUPPORT_ERR = "TYPED_AXIS_SUPPORT_ERR" ; public static final String STRAY_ATTRIBUTE_ERR = "STRAY_ATTRIBUTE_ERR" ; public static final String STRAY_NAMESPACE_ERR = "STRAY_NAMESPACE_ERR" ; public static final String NAMESPACE_PREFIX_ERR = "NAMESPACE_PREFIX_ERR" ; public static final String DOM_ADAPTER_INIT_ERR = "DOM_ADAPTER_INIT_ERR" ; public static final String PARSER_DTD_SUPPORT_ERR = "PARSER_DTD_SUPPORT_ERR" ; public static final String NAMESPACES_SUPPORT_ERR = "NAMESPACES_SUPPORT_ERR" ; public static final String CANT_RESOLVE_RELATIVE_URI_ERR = "CANT_RESOLVE_RELATIVE_URI_ERR" ; protected static ResourceBundle m_bundle ; public final static String ERROR_MESSAGES_KEY = "error-messages" ; static { String resource = "org.apache.xalan.xsltc.runtime.ErrorMessages" ; m_bundle = ResourceBundle . getBundle ( resource ) ; } public static void runTimeError ( String code ) { throw new RuntimeException ( m_bundle . getString ( code ) ) ; } public static void runTimeError ( String code , Object [ ] args ) { final String message = MessageFormat . format ( m_bundle . getString ( code ) , args ) ; throw new RuntimeException ( message ) ; } public static void runTimeError ( String code , Object arg0 ) { runTimeError ( code , new Object [ ] { arg0 } ) ; } public static void runTimeError ( String code , Object arg0 , Object arg1 ) { runTimeError ( code , new Object [ ] { arg0 , arg1 } ) ; } public static void consoleOutput ( String msg ) { System . out . println ( msg ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } } 	1
package org . apache . xalan . xsltc ; public interface StripFilter { public boolean stripSpace ( DOM dom , int node , int type ) ; } 	0
package org . apache . xalan . serialize ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputStream ( OutputStream output ) ; public OutputStream getOutputStream ( ) ; public void setWriter ( Writer writer ) ; public Writer getWriter ( ) ; public void setOutputFormat ( Properties format ) ; public Properties getOutputFormat ( ) ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; public boolean reset ( ) ; } 	0
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . sax . SAXResult ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLFilterImpl ; import org . xml . sax . helpers . XMLReaderFactory ; public class TrAXFilter extends XMLFilterImpl { private Templates _templates ; private TransformerHandlerImpl _transformer ; public TrAXFilter ( Templates templates ) throws TransformerConfigurationException { _templates = templates ; _transformer = new TransformerHandlerImpl ( ( TransformerImpl ) templates . newTransformer ( ) ) ; } private void createParent ( ) throws SAXException { XMLReader parent = null ; try { SAXParserFactory pfactory = SAXParserFactory . newInstance ( ) ; pfactory . setNamespaceAware ( true ) ; SAXParser saxparser = pfactory . newSAXParser ( ) ; parent = saxparser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { throw new SAXException ( e ) ; } catch ( FactoryConfigurationError e ) { throw new SAXException ( e . toString ( ) ) ; } if ( parent == null ) { parent = XMLReaderFactory . createXMLReader ( ) ; } setParent ( parent ) ; } public void parse ( InputSource input ) throws SAXException , IOException { if ( getParent ( ) == null ) { try { createParent ( ) ; } catch ( SAXException e ) { throw new SAXException ( e . toString ( ) ) ; } } getParent ( ) . parse ( input ) ; } public void parse ( String systemId ) throws SAXException , IOException { parse ( new InputSource ( systemId ) ) ; } public void setContentHandler ( ContentHandler handler ) { _transformer . setResult ( new SAXResult ( handler ) ) ; if ( getParent ( ) == null ) { try { createParent ( ) ; } catch ( SAXException e ) { return ; } } getParent ( ) . setContentHandler ( _transformer ) ; } public void setErrorListener ( ErrorListener handler ) { } } 	0
package org . apache . xml . utils ; import java . util . Stack ; import java . util . StringTokenizer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Element ; public class QName implements java . io . Serializable { protected String _localName ; protected String _namespaceURI ; protected String _prefix ; public static final String S_XMLNAMESPACEURI = "http://www.w3.org/XML/1998/namespace" ; private int m_hashCode ; public QName ( ) { } public QName ( String namespaceURI , String localName ) { this ( namespaceURI , localName , false ) ; } public QName ( String namespaceURI , String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = namespaceURI ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String namespaceURI , String prefix , String localName ) { this ( namespaceURI , prefix , localName , false ) ; } public QName ( String namespaceURI , String prefix , String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } if ( ( null != prefix ) && ( ! XMLChar . isValidNCName ( prefix ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_PREFIX_INVALID , null ) ) ; } } _namespaceURI = namespaceURI ; _prefix = prefix ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String localName ) { this ( localName , false ) ; } public QName ( String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = null ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , Stack namespaces ) { this ( qname , namespaces , false ) ; } public QName ( String qname , Stack namespaces , boolean validate ) { String namespace = null ; String prefix = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { prefix = qname . substring ( 0 , indexOfNSSep ) ; if ( prefix . equals ( "xml" ) ) { namespace = S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { return ; } else { int depth = namespaces . size ( ) ; for ( int i = depth - 1 ; i >= 0 ; i -- ) { NameSpace ns = ( NameSpace ) namespaces . elementAt ( i ) ; while ( null != ns ) { if ( ( null != ns . m_prefix ) && prefix . equals ( ns . m_prefix ) ) { namespace = ns . m_uri ; i = - 1 ; break ; } ns = ns . m_next ; } } } if ( null == namespace ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = namespace ; _prefix = prefix ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , Element namespaceContext , PrefixResolver resolver ) { this ( qname , namespaceContext , resolver , false ) ; } public QName ( String qname , Element namespaceContext , PrefixResolver resolver , boolean validate ) { _namespaceURI = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { if ( null != namespaceContext ) { String prefix = qname . substring ( 0 , indexOfNSSep ) ; _prefix = prefix ; if ( prefix . equals ( "xml" ) ) { _namespaceURI = S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { return ; } else { _namespaceURI = resolver . getNamespaceForPrefix ( prefix , namespaceContext ) ; } if ( null == _namespaceURI ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } else { } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , PrefixResolver resolver ) { this ( qname , resolver , false ) ; } public QName ( String qname , PrefixResolver resolver , boolean validate ) { String prefix = null ; _namespaceURI = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { prefix = qname . substring ( 0 , indexOfNSSep ) ; if ( prefix . equals ( "xml" ) ) { _namespaceURI = S_XMLNAMESPACEURI ; } else { _namespaceURI = resolver . getNamespaceForPrefix ( prefix ) ; } if ( null == _namespaceURI ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } m_hashCode = toString ( ) . hashCode ( ) ; _prefix = prefix ; } public String getNamespaceURI ( ) { return _namespaceURI ; } public String getPrefix ( ) { return _prefix ; } public String getLocalName ( ) { return _localName ; } public String toString ( ) { return _prefix != null ? ( _prefix + ":" + _localName ) : ( _namespaceURI != null ? ( "{" + _namespaceURI + "}" + _localName ) : _localName ) ; } public String toNamespacedString ( ) { return ( _namespaceURI != null ? ( "{" + _namespaceURI + "}" + _localName ) : _localName ) ; } public String getNamespace ( ) { return getNamespaceURI ( ) ; } public String getLocalPart ( ) { return getLocalName ( ) ; } public int hashCode ( ) { return m_hashCode ; } public boolean equals ( String ns , String localPart ) { String thisnamespace = getNamespaceURI ( ) ; return getLocalName ( ) . equals ( localPart ) && ( ( ( null != thisnamespace ) && ( null != ns ) ) ? thisnamespace . equals ( ns ) : ( ( null == thisnamespace ) && ( null == ns ) ) ) ; } public boolean equals ( Object object ) { if ( object == this ) return true ; if ( object instanceof QName ) { QName qname = ( QName ) object ; String thisnamespace = getNamespaceURI ( ) ; String thatnamespace = qname . getNamespaceURI ( ) ; return getLocalName ( ) . equals ( qname . getLocalName ( ) ) && ( ( ( null != thisnamespace ) && ( null != thatnamespace ) ) ? thisnamespace . equals ( thatnamespace ) : ( ( null == thisnamespace ) && ( null == thatnamespace ) ) ) ; } else return false ; } public static QName getQNameFromString ( String name ) { StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; QName qname ; String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) qname = new QName ( null , s1 ) ; else qname = new QName ( s1 , s2 ) ; return qname ; } public static boolean isXMLNSDecl ( String attRawName ) { return ( attRawName . startsWith ( "xmlns" ) && ( attRawName . equals ( "xmlns" ) || attRawName . startsWith ( "xmlns:" ) ) ) ; } public static String getPrefixFromXMLNSDecl ( String attRawName ) { int index = attRawName . indexOf ( ':' ) ; return ( index >= 0 ) ? attRawName . substring ( index + 1 ) : "" ; } public static String getLocalPart ( String qname ) { int index = qname . indexOf ( ':' ) ; return ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } public static String getPrefixPart ( String qname ) { int index = qname . indexOf ( ':' ) ; return ( index >= 0 ) ? qname . substring ( 0 , index ) : "" ; } } 	1
package org . apache . xml . serializer ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ContentHandler ; public abstract class SerializerFactory { private static Hashtable m_formats = new Hashtable ( ) ; public static Serializer getSerializer ( Properties format ) { Serializer ser = null ; try { Class cls ; String method = format . getProperty ( OutputKeys . METHOD ) ; if ( method == null ) throw new IllegalArgumentException ( "The output format has a null method name" ) ; String className ; className = format . getProperty ( OutputPropertiesFactory . S_KEY_CONTENT_HANDLER ) ; if ( null == className ) { throw new IllegalArgumentException ( "The output format must have a '" + OutputPropertiesFactory . S_KEY_CONTENT_HANDLER + "' property!" ) ; } cls = Class . forName ( className ) ; Object obj = cls . newInstance ( ) ; if ( obj instanceof SerializationHandler ) { ser = ( Serializer ) cls . newInstance ( ) ; ser . setOutputFormat ( format ) ; } else { if ( obj instanceof ContentHandler ) { className = SerializerConstants . DEFAULT_SAX_SERIALIZER ; cls = Class . forName ( className ) ; SerializationHandler sh = ( SerializationHandler ) cls . newInstance ( ) ; sh . setContentHandler ( ( ContentHandler ) obj ) ; sh . setOutputFormat ( format ) ; ser = sh ; } else { throw new Exception ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SERIALIZER_NOT_CONTENTHANDLER , new Object [ ] { className } ) ) ; } } } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return ser ; } } 	1
package org . apache . xalan . xsltc . runtime ; import org . xml . sax . SAXException ; import org . apache . xml . serializer . EmptySerializer ; public final class StringValueHandler extends EmptySerializer { private StringBuffer _buffer = new StringBuffer ( ) ; private String _str = null ; private static final String EMPTY_STR = "" ; private boolean m_escaping = false ; private int _nestedLevel = 0 ; public void characters ( char [ ] ch , int off , int len ) throws SAXException { if ( _nestedLevel > 0 ) return ; if ( _str != null ) { _buffer . append ( _str ) ; _str = null ; } _buffer . append ( ch , off , len ) ; } public String getValue ( ) { if ( _buffer . length ( ) != 0 ) { String result = _buffer . toString ( ) ; _buffer . setLength ( 0 ) ; return result ; } else { String result = _str ; _str = null ; return ( result != null ) ? result : EMPTY_STR ; } } public void characters ( String characters ) throws SAXException { if ( _nestedLevel > 0 ) return ; if ( _str == null && _buffer . length ( ) == 0 ) { _str = characters ; } else { if ( _str != null ) { _buffer . append ( _str ) ; _str = null ; } _buffer . append ( characters ) ; } } public void startElement ( String qname ) throws SAXException { _nestedLevel ++ ; } public void endElement ( String qname ) throws SAXException { _nestedLevel -- ; } public boolean setEscaping ( boolean bool ) { boolean oldEscaping = m_escaping ; m_escaping = bool ; return bool ; } public String getValueOfPI ( ) { final String value = getValue ( ) ; if ( value . indexOf ( "?>" ) > 0 ) { final int n = value . length ( ) ; final StringBuffer valueOfPI = new StringBuffer ( ) ; for ( int i = 0 ; i < n ; ) { final char ch = value . charAt ( i ++ ) ; if ( ch == '?' && value . charAt ( i ) == '>' ) { valueOfPI . append ( "? >" ) ; i ++ ; } else { valueOfPI . append ( ch ) ; } } return valueOfPI . toString ( ) ; } return value ; } } 	0
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprIteratorSimple extends LocPathIterator { private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public FilterExprIteratorSimple ( ) { super ( null ) ; } public FilterExprIteratorSimple ( Expression expr ) { super ( null ) ; m_expr = expr ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_exprObj = executeFilterExpr ( context , m_execContext , getPrefixResolver ( ) , getIsTopLevel ( ) , m_stackFrame , m_expr ) ; } public static XNodeSet executeFilterExpr ( int context , XPathContext xctxt , PrefixResolver prefixResolver , boolean isTopLevel , int stackFrame , Expression expr ) throws org . apache . xml . utils . WrappedRuntimeException { PrefixResolver savedResolver = xctxt . getNamespaceContext ( ) ; XNodeSet result = null ; try { xctxt . pushCurrentNode ( context ) ; xctxt . setNamespaceContext ( prefixResolver ) ; if ( isTopLevel ) { VariableStack vars = xctxt . getVarStack ( ) ; int savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( stackFrame ) ; result = ( org . apache . xpath . objects . XNodeSet ) expr . execute ( xctxt ) ; result . setShouldCacheNodes ( true ) ; vars . setStackFrame ( savedStart ) ; } else result = ( org . apache . xpath . objects . XNodeSet ) expr . execute ( xctxt ) ; } catch ( javax . xml . transform . TransformerException se ) { throw new org . apache . xml . utils . WrappedRuntimeException ( se ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . setNamespaceContext ( savedResolver ) ; } return result ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; if ( null != m_exprObj ) { m_lastFetched = next = m_exprObj . nextNode ( ) ; } else m_lastFetched = next = DTM . NULL ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public void detach ( ) { if ( m_allowDetach ) { super . detach ( ) ; m_exprObj . detach ( ) ; m_exprObj = null ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprIteratorSimple . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprIteratorSimple fet = ( FilterExprIteratorSimple ) expr ; if ( ! m_expr . deepEquals ( fet . m_expr ) ) return false ; return true ; } public int getAxis ( ) { if ( null != m_exprObj ) return m_exprObj . getAxis ( ) ; else return Axis . FILTEREDLIST ; } } 	0
package org . apache . xml . serializer ; import java . io . Writer ; import java . io . OutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . xml . serializer . DOMSerializer ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputStream ( OutputStream output ) ; public OutputStream getOutputStream ( ) ; public void setWriter ( Writer writer ) ; public Writer getWriter ( ) ; public void setOutputFormat ( Properties format ) ; public Properties getOutputFormat ( ) ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; public boolean reset ( ) ; } 	0
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xpath . res . XPATHErrorResources ; public class XStringForFSB extends XString { int m_start ; int m_length ; protected String m_strCache = null ; protected int m_hash = 0 ; public XStringForFSB ( FastStringBuffer val , int start , int length ) { super ( val ) ; m_start = start ; m_length = length ; if ( null == val ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , null ) ) ; } private XStringForFSB ( String val ) { super ( val ) ; throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FSB_CANNOT_TAKE_STRING , null ) ) ; } public FastStringBuffer fsb ( ) { return ( ( FastStringBuffer ) m_obj ) ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( str ( ) ) ; } public boolean hasString ( ) { return ( null != m_strCache ) ; } public Object object ( ) { return str ( ) ; } public String str ( ) { if ( null == m_strCache ) { m_strCache = fsb ( ) . getString ( m_start , m_length ) ; } return m_strCache ; } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXcharacters ( ch , m_start , m_length ) ; } public void dispatchAsComment ( org . xml . sax . ext . LexicalHandler lh ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXComment ( lh , m_start , m_length ) ; } public int length ( ) { return m_length ; } public char charAt ( int index ) { return fsb ( ) . charAt ( m_start + index ) ; } public void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { int n = srcEnd - srcBegin ; if ( n > m_length ) n = m_length ; if ( n > ( dst . length - dstBegin ) ) n = ( dst . length - dstBegin ) ; int end = srcBegin + m_start + n ; int d = dstBegin ; FastStringBuffer fsb = fsb ( ) ; for ( int i = srcBegin + m_start ; i < end ; i ++ ) { dst [ d ++ ] = fsb . charAt ( i ) ; } } public boolean equals ( XMLString obj2 ) { if ( this == obj2 ) { return true ; } int n = m_length ; if ( n == obj2 . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != obj2 . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( XObject obj2 ) { if ( this == obj2 ) { return true ; } if ( obj2 . getType ( ) == XObject . CLASS_NUMBER ) return obj2 . equals ( this ) ; String str = obj2 . str ( ) ; int n = m_length ; if ( n == str . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != str . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( String anotherString ) { int n = m_length ; if ( n == anotherString . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != anotherString . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( Object obj2 ) { if ( null == obj2 ) return false ; if ( obj2 instanceof XNumber ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XNodeSet ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XStringForFSB ) return equals ( ( XMLString ) this ) ; else return equals ( obj2 . toString ( ) ) ; } public boolean equalsIgnoreCase ( String anotherString ) { return ( m_length == anotherString . length ( ) ) ? str ( ) . equalsIgnoreCase ( anotherString ) : false ; } public int compareTo ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = fsb . charAt ( i ) ; char c2 = xstr . charAt ( j ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int compareToIgnoreCase ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = Character . toLowerCase ( fsb . charAt ( i ) ) ; char c2 = Character . toLowerCase ( xstr . charAt ( j ) ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int hashCode ( ) { return super . hashCode ( ) ; } public boolean startsWith ( XMLString prefix , int toffset ) { FastStringBuffer fsb = fsb ( ) ; int to = m_start + toffset ; int tlim = m_start + m_length ; int po = 0 ; int pc = prefix . length ( ) ; if ( ( toffset < 0 ) || ( toffset > m_length - pc ) ) { return false ; } while ( -- pc >= 0 ) { if ( fsb . charAt ( to ) != prefix . charAt ( po ) ) { return false ; } to ++ ; po ++ ; } return true ; } public boolean startsWith ( XMLString prefix ) { return startsWith ( prefix , 0 ) ; } public int indexOf ( int ch ) { return indexOf ( ch , 0 ) ; } public int indexOf ( int ch , int fromIndex ) { int max = m_start + m_length ; FastStringBuffer fsb = fsb ( ) ; if ( fromIndex < 0 ) { fromIndex = 0 ; } else if ( fromIndex >= m_length ) { return - 1 ; } for ( int i = m_start + fromIndex ; i < max ; i ++ ) { if ( fsb . charAt ( i ) == ch ) { return i - m_start ; } } return - 1 ; } public XMLString substring ( int beginIndex ) { int len = m_length - beginIndex ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString substring ( int beginIndex , int endIndex ) { int len = endIndex - beginIndex ; if ( len > m_length ) len = m_length ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString concat ( String str ) { return new XString ( str ( ) . concat ( str ) ) ; } public XMLString trim ( ) { return fixWhiteSpace ( true , true , false ) ; } private static boolean isSpace ( char ch ) { return XMLCharacterRecognizer . isWhiteSpace ( ch ) ; } public XMLString fixWhiteSpace ( boolean trimHead , boolean trimTail , boolean doublePunctuationSpaces ) { int end = m_length + m_start ; char [ ] buf = new char [ m_length ] ; FastStringBuffer fsb = fsb ( ) ; boolean edit = false ; int d = 0 ; boolean pres = false ; for ( int s = m_start ; s < end ; s ++ ) { char c = fsb . charAt ( s ) ; if ( isSpace ( c ) ) { if ( ! pres ) { if ( ' ' != c ) { edit = true ; } buf [ d ++ ] = ' ' ; if ( doublePunctuationSpaces && ( d != 0 ) ) { char prevChar = buf [ d - 1 ] ; if ( ! ( ( prevChar == '.' ) || ( prevChar == '!' ) || ( prevChar == '?' ) ) ) { pres = true ; } } else { pres = true ; } } else { edit = true ; pres = true ; } } else { buf [ d ++ ] = c ; pres = false ; } } if ( trimTail && 1 <= d && ' ' == buf [ d - 1 ] ) { edit = true ; d -- ; } int start = 0 ; if ( trimHead && 0 < d && ' ' == buf [ 0 ] ) { edit = true ; start ++ ; } XMLStringFactory xsf = XMLStringFactoryImpl . getFactory ( ) ; return edit ? xsf . newstr ( buf , start , d - start ) : this ; } public double toDouble ( ) { if ( m_length == 0 ) return Double . NaN ; int i ; char c ; String valueString = fsb ( ) . getString ( m_start , m_length ) ; for ( i = 0 ; i < m_length ; i ++ ) if ( ! XMLCharacterRecognizer . isWhiteSpace ( valueString . charAt ( i ) ) ) break ; if ( valueString . charAt ( i ) == '-' ) i ++ ; for ( ; i < m_length ; i ++ ) { c = valueString . charAt ( i ) ; if ( c != '.' && ( c < '0' || c > '9' ) ) break ; } for ( ; i < m_length ; i ++ ) if ( ! XMLCharacterRecognizer . isWhiteSpace ( valueString . charAt ( i ) ) ) break ; if ( i != m_length ) return Double . NaN ; try { return new Double ( valueString ) . doubleValue ( ) ; } catch ( NumberFormatException nfe ) { return Double . NaN ; } } } 	0
package org . apache . xml . utils . synthetic ; import java . io . IOException ; public class JavaUtils { private static boolean cantLoadCompiler = false ; private static boolean debug = false ; public static void setDebug ( boolean newDebug ) { debug = newDebug ; } public static boolean JDKcompile ( String fileName , String classPath ) { String moreClassPath = System . getProperty ( "org.apache.xml.utils.synthetic.moreclasspath" , "" ) . trim ( ) ; if ( moreClassPath . length ( ) > 0 ) classPath = moreClassPath + ';' + classPath ; if ( debug ) { System . err . println ( "JavaEngine: Compiling " + fileName ) ; System . err . println ( "JavaEngine: Classpath is " + classPath ) ; } String code_option = debug ? "-g" : "-O" ; if ( ! cantLoadCompiler ) { String args [ ] = { code_option , "-classpath" , classPath , fileName } ; } String javac_command = System . getProperty ( "org.apache.xml.utils.synthetic.javac" , "javac" ) ; String args [ ] = { javac_command , code_option , "-classpath" , classPath , fileName } ; try { Process p = java . lang . Runtime . getRuntime ( ) . exec ( args ) ; int compileOK = waitHardFor ( p ) ; return compileOK == 0 ; } catch ( IOException e ) { System . err . println ( "ERROR: IO exception during exec(javac)." ) ; } catch ( SecurityException e ) { System . err . println ( "ERROR: Unable to create subprocess to exec(javac)." ) ; } return false ; } static int waitHardFor ( java . lang . Process p ) { boolean done = false ; while ( ! done ) try { p . waitFor ( ) ; done = true ; } catch ( InterruptedException e ) { System . err . println ( "(Compiler process wait interrupted and resumed)" ) ; } int ev = p . exitValue ( ) ; return ev ; } } 	1
package org . apache . xalan ; public class Version { public static String getVersion ( ) { return getProduct ( ) + " " + getImplementationLanguage ( ) + " " + getMajorVersionNum ( ) + "." + getReleaseVersionNum ( ) + "." + ( ( getDevelopmentVersionNum ( ) > 0 ) ? ( "D" + getDevelopmentVersionNum ( ) ) : ( "" + getMaintenanceVersionNum ( ) ) ) ; } public static void main ( String argv [ ] ) { System . out . println ( getVersion ( ) ) ; } public static String getProduct ( ) { return "Xalan" ; } public static String getImplementationLanguage ( ) { return "Java" ; } public static int getMajorVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . VERSION ; } public static int getReleaseVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . RELEASE ; } public static int getMaintenanceVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . MAINTENANCE ; } public static int getDevelopmentVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . DEVELOPMENT ; } } 	1
package org . apache . xpath . objects ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; public class XMLStringFactoryImpl extends XMLStringFactory { private static XMLStringFactory m_xstringfactory = new XMLStringFactoryImpl ( ) ; public static XMLStringFactory getFactory ( ) { return m_xstringfactory ; } public XMLString newstr ( String string ) { return new XString ( string ) ; } public XMLString newstr ( FastStringBuffer fsb , int start , int length ) { return new XStringForFSB ( fsb , start , length ) ; } public XMLString newstr ( char [ ] string , int start , int length ) { return new XStringForChars ( string , start , length ) ; } public XMLString emptystr ( ) { return XString . EMPTYSTRING ; } } 	1
package org . apache . xpath . operations ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class VariableSafeAbsRef extends Variable { public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { XNodeSet xns = ( XNodeSet ) super . execute ( xctxt , destructiveOK ) ; DTMManager dtmMgr = xctxt . getDTMManager ( ) ; int context = xctxt . getContextNode ( ) ; if ( dtmMgr . getDTM ( xns . getRoot ( ) ) . getDocument ( ) != dtmMgr . getDTM ( context ) . getDocument ( ) ) { Expression expr = ( Expression ) xns . getContainedIter ( ) ; xns = ( XNodeSet ) expr . asIterator ( xctxt , context ) ; } return xns ; } } 	0
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; public class ElemAttributeSet extends ElemUse { public QName m_qname = null ; public void setName ( QName name ) { m_qname = name ; } public QName getName ( ) { return m_qname ; } public int getXSLToken ( ) { return Constants . ELEMNAME_DEFINEATTRIBUTESET ; } public String getNodeName ( ) { return Constants . ELEMNAME_ATTRIBUTESET_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( transformer . isRecursiveAttrSet ( this ) ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_XSLATTRSET_USED_ITSELF , new Object [ ] { m_qname . getLocalPart ( ) } ) ) ; } transformer . pushElemAttributeSet ( this ) ; super . execute ( transformer ) ; ElemAttribute attr = ( ElemAttribute ) getFirstChildElem ( ) ; while ( null != attr ) { attr . execute ( transformer ) ; attr = ( ElemAttribute ) attr . getNextSiblingElem ( ) ; } transformer . popElemAttributeSet ( ) ; } public ElemTemplateElement appendChildElem ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_ATTRIBUTE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeAttributeSets ( this ) ; } } 	1
package org . apache . xml . utils ; public interface PrefixResolver { String getNamespaceForPrefix ( String prefix ) ; String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) ; public String getBaseIdentifier ( ) ; public boolean handlesNullPrefixes ( ) ; } 	1
package org . apache . xalan . transformer ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; public class CountersTable extends Hashtable { public CountersTable ( ) { } Vector getCounters ( ElemNumber numberElem ) { Vector counters = ( Vector ) this . get ( numberElem ) ; return ( null == counters ) ? putElemNumber ( numberElem ) : counters ; } Vector putElemNumber ( ElemNumber numberElem ) { Vector counters = new Vector ( ) ; this . put ( numberElem , counters ) ; return counters ; } transient private NodeSetDTM m_newFound ; void appendBtoFList ( NodeSetDTM flist , NodeSetDTM blist ) { int n = blist . size ( ) ; for ( int i = ( n - 1 ) ; i >= 0 ; i -- ) { flist . addElement ( blist . item ( i ) ) ; } } transient int m_countersMade = 0 ; public int countNode ( XPathContext support , ElemNumber numberElem , int node ) throws TransformerException { int count = 0 ; Vector counters = getCounters ( numberElem ) ; int nCounters = counters . size ( ) ; int target = numberElem . getTargetNode ( support , node ) ; if ( DTM . NULL != target ) { for ( int i = 0 ; i < nCounters ; i ++ ) { Counter counter = ( Counter ) counters . elementAt ( i ) ; count = counter . getPreviouslyCounted ( support , target ) ; if ( count > 0 ) return count ; } count = 0 ; if ( m_newFound == null ) m_newFound = new NodeSetDTM ( support . getDTMManager ( ) ) ; for ( ; DTM . NULL != target ; target = numberElem . getPreviousNode ( support , target ) ) { if ( 0 != count ) { for ( int i = 0 ; i < nCounters ; i ++ ) { Counter counter = ( Counter ) counters . elementAt ( i ) ; int cacheLen = counter . m_countNodes . size ( ) ; if ( ( cacheLen > 0 ) && ( counter . m_countNodes . elementAt ( cacheLen - 1 ) == target ) ) { count += ( cacheLen + counter . m_countNodesStartCount ) ; if ( cacheLen > 0 ) appendBtoFList ( counter . m_countNodes , m_newFound ) ; m_newFound . removeAllElements ( ) ; return count ; } } } m_newFound . addElement ( target ) ; count ++ ; } Counter counter = new Counter ( numberElem , new NodeSetDTM ( support . getDTMManager ( ) ) ) ; m_countersMade ++ ; appendBtoFList ( counter . m_countNodes , m_newFound ) ; m_newFound . removeAllElements ( ) ; counters . addElement ( counter ) ; } return count ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class CallTemplate extends Instruction { private QName _name ; public void display ( int indent ) { indent ( indent ) ; System . out . print ( "CallTemplate" ) ; Util . println ( " name " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public boolean hasWithParams ( ) { return elementCount ( ) > 0 ; } public void parseContents ( Parser parser ) { _name = parser . getQNameIgnoreDefaultNs ( getAttribute ( "name" ) ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Template template = stable . lookupTemplate ( _name ) ; if ( template != null ) { typeCheckContents ( stable ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . TEMPLATE_UNDEF_ERR , _name , this ) ; throw new TypeCheckError ( err ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Stylesheet stylesheet = classGen . getStylesheet ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { final int push = cpg . addMethodref ( TRANSLET_CLASS , PUSH_PARAM_FRAME , PUSH_PARAM_FRAME_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( push ) ) ; translateContents ( classGen , methodGen ) ; } final String className = stylesheet . getClassName ( ) ; String methodName = Util . escape ( _name . toString ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( className , methodName , "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + NODE_SIG + ")V" ) ) ) ; if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { final int pop = cpg . addMethodref ( TRANSLET_CLASS , POP_PARAM_FRAME , POP_PARAM_FRAME_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( pop ) ) ; } } } 	1
package org . apache . xalan . xsltc ; import org . apache . xml . dtm . DTM ; public interface NodeIterator extends Cloneable { public static final int END = DTM . NULL ; public int next ( ) ; public NodeIterator reset ( ) ; public int getLast ( ) ; public int getPosition ( ) ; public void setMark ( ) ; public void gotoMark ( ) ; public NodeIterator setStartNode ( int node ) ; public boolean isReverse ( ) ; public NodeIterator cloneIterator ( ) ; public void setRestartable ( boolean isRestartable ) ; } 	0
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class NameBase extends FunctionCall { private Expression _param = null ; private Type _paramType = Type . Node ; public NameBase ( QName fname ) { super ( fname ) ; } public NameBase ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _param = argument ( 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { switch ( argumentCount ( ) ) { case 0 : _paramType = Type . Node ; break ; case 1 : _paramType = _param . typeCheck ( stable ) ; break ; default : throw new TypeCheckError ( this ) ; } if ( ( _paramType != Type . NodeSet ) && ( _paramType != Type . Node ) && ( _paramType != Type . Reference ) ) { throw new TypeCheckError ( this ) ; } return ( _type = Type . String ) ; } public Type getType ( ) { return _type ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; } else if ( _paramType == Type . Node ) { _param . translate ( classGen , methodGen ) ; } else if ( _paramType == Type . Reference ) { _param . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeSet" , "(" + OBJECT_SIG + ")" + NODE_ITERATOR_SIG ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; } else { _param . translate ( classGen , methodGen ) ; _param . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . nextNode ( ) ) ; } } } 	0
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . IFLE ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . IF_ICMPGE ; import org . apache . bcel . generic . IF_ICMPGT ; import org . apache . bcel . generic . IF_ICMPLE ; import org . apache . bcel . generic . IF_ICMPLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; public final class BooleanType extends Type { protected BooleanType ( ) { } public String toString ( ) { return "boolean" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Z" ; } public boolean isSimple ( ) { return true ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . BOOLEAN ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final BranchHandle falsec = il . append ( new IFEQ ( null ) ) ; il . append ( new PUSH ( cpg , "true" ) ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( new PUSH ( cpg , "false" ) ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { methodGen . getInstructionList ( ) . append ( I2D ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( BOOLEAN_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( BOOLEAN_CLASS , "<init>" , "(Z)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz == java . lang . Boolean . TYPE ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else if ( clazz . isAssignableFrom ( java . lang . Boolean . class ) ) { translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { translateTo ( classGen , methodGen , clazz ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( BOOLEAN_CLASS ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( BOOLEAN_CLASS , BOOLEAN_VALUE , BOOLEAN_VALUE_SIG ) ) ) ; } public Instruction LOAD ( int slot ) { return new ILOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ISTORE ( slot ) ; } public BranchInstruction GT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGT ( null ) : ( BranchInstruction ) new IF_ICMPGT ( null ) ; } public BranchInstruction GE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGE ( null ) : ( BranchInstruction ) new IF_ICMPGE ( null ) ; } public BranchInstruction LT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLT ( null ) : ( BranchInstruction ) new IF_ICMPLT ( null ) ; } public BranchInstruction LE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLE ( null ) : ( BranchInstruction ) new IF_ICMPLE ( null ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionConstants ; public interface Constants extends InstructionConstants { public final int INTERNAL = 0 ; public final int UNSUPPORTED = 1 ; public final int FATAL = 2 ; public final int ERROR = 3 ; public final int WARNING = 4 ; public static final String EMPTYSTRING = "" ; public static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static final String TRANSLET_INTF = "org.apache.xalan.xsltc.Translet" ; public static final String TRANSLET_INTF_SIG = "Lorg/apache/xalan/xsltc/Translet;" ; public static final String ATTRIBUTES_SIG = "Lorg/apache/xalan/xsltc/runtime/Attributes;" ; public static final String NODE_ITERATOR_SIG = "Lorg/apache/xml/dtm/DTMAxisIterator;" ; public static final String DOM_INTF_SIG = "Lorg/apache/xalan/xsltc/DOM;" ; public static final String DOM_IMPL_CLASS = "org/apache/xalan/xsltc/DOM" ; public static final String SAX_IMPL_CLASS = "org/apache/xalan/xsltc/DOM/SAXImpl" ; public static final String DOM_IMPL_SIG = "Lorg/apache/xalan/xsltc/dom/SAXImpl;" ; public static final String SAX_IMPL_SIG = "Lorg/apache/xalan/xsltc/dom/SAXImpl;" ; public static final String DOM_ADAPTER_CLASS = "org/apache/xalan/xsltc/dom/DOMAdapter" ; public static final String DOM_ADAPTER_SIG = "Lorg/apache/xalan/xsltc/dom/DOMAdapter;" ; public static final String MULTI_DOM_CLASS = "org.apache.xalan.xsltc.dom.MultiDOM" ; public static final String MULTI_DOM_SIG = "Lorg/apache/xalan/xsltc/dom/MultiDOM;" ; public static final String STRING = "java.lang.String" ; public static final int ACC_PUBLIC = org . apache . bcel . Constants . ACC_PUBLIC ; public static final int ACC_SUPER = org . apache . bcel . Constants . ACC_SUPER ; public static final int ACC_FINAL = org . apache . bcel . Constants . ACC_FINAL ; public static final int ACC_PRIVATE = org . apache . bcel . Constants . ACC_PRIVATE ; public static final int ACC_PROTECTED = org . apache . bcel . Constants . ACC_PROTECTED ; public static final int ACC_STATIC = org . apache . bcel . Constants . ACC_STATIC ; public static final String STRING_SIG = "Ljava/lang/String;" ; public static final String STRING_BUFFER_SIG = "Ljava/lang/StringBuffer;" ; public static final String OBJECT_SIG = "Ljava/lang/Object;" ; public static final String DOUBLE_SIG = "Ljava/lang/Double;" ; public static final String INTEGER_SIG = "Ljava/lang/Integer;" ; public static final String COLLATOR_CLASS = "java/text/Collator" ; public static final String COLLATOR_SIG = "Ljava/text/Collator;" ; public static final String NODE = "int" ; public static final String NODE_ITERATOR = "org.apache.xml.dtm.DTMAxisIterator" ; public static final String NODE_ITERATOR_BASE = "org.apache.xml.dtm.ref.DTMAxisIteratorBase" ; public static final String SORT_ITERATOR = "org.apache.xalan.xsltc.dom.SortingIterator" ; public static final String SORT_ITERATOR_SIG = "Lorg.apache.xalan.xsltc.dom.SortingIterator;" ; public static final String FORWARD_POSITION_ITERATOR = "org.apache.xalan.xsltc.dom.ForwardPositionIterator" ; public static final String NODE_SORT_RECORD = "org.apache.xalan.xsltc.dom.NodeSortRecord" ; public static final String NODE_SORT_FACTORY = "org/apache/xalan/xsltc/dom/NodeSortRecordFactory" ; public static final String NODE_SORT_RECORD_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecord;" ; public static final String NODE_SORT_FACTORY_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecordFactory;" ; public static final String LOCALE_CLASS = "java.util.Locale" ; public static final String LOCALE_SIG = "Ljava/util/Locale;" ; public static final String STRING_VALUE_HANDLER = "org.apache.xalan.xsltc.runtime.StringValueHandler" ; public static final String STRING_VALUE_HANDLER_SIG = "Lorg/apache/xalan/xsltc/runtime/StringValueHandler;" ; public static final String OUTPUT_HANDLER = "org/apache/xml/serializer/SerializationHandler" ; public static final String OUTPUT_HANDLER_SIG = "Lorg/apache/xml/serializer/SerializationHandler;" ; public static final String FILTER_INTERFACE = "org.apache.xalan.xsltc.dom.Filter" ; public static final String FILTER_INTERFACE_SIG = "Lorg/apache/xalan/xsltc/dom/Filter;" ; public static final String UNION_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.UnionIterator" ; public static final String STEP_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.StepIterator" ; public static final String NTH_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.NthIterator" ; public static final String ABSOLUTE_ITERATOR = "org.apache.xalan.xsltc.dom.AbsoluteIterator" ; public static final String DUP_FILTERED_ITERATOR = "org.apache.xalan.xsltc.dom.DupFilterIterator" ; public static final String CURRENT_NODE_LIST_ITERATOR = "org.apache.xalan.xsltc.dom.CurrentNodeListIterator" ; public static final String CURRENT_NODE_LIST_FILTER = "org.apache.xalan.xsltc.dom.CurrentNodeListFilter" ; public static final String CURRENT_NODE_LIST_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListIterator;" ; public static final String CURRENT_NODE_LIST_FILTER_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListFilter;" ; public static final String FILTER_STEP_ITERATOR = "org.apache.xalan.xsltc.dom.FilteredStepIterator" ; public static final String FILTER_ITERATOR = "org.apache.xalan.xsltc.dom.FilterIterator" ; public static final String SINGLETON_ITERATOR = "org.apache.xalan.xsltc.dom.SingletonIterator" ; public static final String MATCHING_ITERATOR = "org.apache.xalan.xsltc.dom.MatchingIterator" ; public static final String NODE_SIG = "I" ; public static final String GET_PARENT = "getParent" ; public static final String GET_PARENT_SIG = "(" + NODE_SIG + ")" + NODE_SIG ; public static final String NEXT_SIG = "()" + NODE_SIG ; public static final String NEXT = "next" ; public static final String NEXTID = "nextNodeID" ; public static final String MAKE_NODE = "makeNode" ; public static final String MAKE_NODE_LIST = "makeNodeList" ; public static final String GET_UNPARSED_ENTITY_URI = "getUnparsedEntityURI" ; public static final String STRING_TO_REAL = "stringToReal" ; public static final String STRING_TO_REAL_SIG = "(" + STRING_SIG + ")D" ; public static final String STRING_TO_INT = "stringToInt" ; public static final String STRING_TO_INT_SIG = "(" + STRING_SIG + ")I" ; public static final String XSLT_PACKAGE = "org.apache.xalan.xsltc" ; public static final String COMPILER_PACKAGE = XSLT_PACKAGE + ".compiler" ; public static final String RUNTIME_PACKAGE = XSLT_PACKAGE + ".runtime" ; public static final String TRANSLET_CLASS = RUNTIME_PACKAGE + ".AbstractTranslet" ; public static final String TRANSLET_SIG = "Lorg/apache/xalan/xsltc/runtime/AbstractTranslet;" ; public static final String UNION_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/UnionIterator;" ; public static final String TRANSLET_OUTPUT_SIG = "Lorg/apache/xml/serializer/SerializationHandler;" ; public static final String MAKE_NODE_SIG = "(I)Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_LIST_SIG = "(I)Lorg/w3c/dom/NodeList;" ; public static final String MAKE_NODE_LIST_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/NodeList;" ; public static final String STREAM_XML_OUTPUT = "org.apache.xml.serializer.ToXMLStream" ; public static final String OUTPUT_BASE = "org.apache.xml.serializer.SerializerBase" ; public static final String LOAD_DOCUMENT_CLASS = "org.apache.xalan.xsltc.dom.LoadDocument" ; public static final String KEY_INDEX_CLASS = "org/apache/xalan/xsltc/dom/KeyIndex" ; public static final String KEY_INDEX_SIG = "Lorg/apache/xalan/xsltc/dom/KeyIndex;" ; public static final String DOM_INTF = "org.apache.xalan.xsltc.DOM" ; public static final String DOM_IMPL = "org.apache.xalan.xsltc.dom.SAXImpl" ; public static final String SAX_IMPL = "org.apache.xalan.xsltc.dom.SAXImpl" ; public static final String STRING_CLASS = "java.lang.String" ; public static final String OBJECT_CLASS = "java.lang.Object" ; public static final String BOOLEAN_CLASS = "java.lang.Boolean" ; public static final String STRING_BUFFER_CLASS = "java.lang.StringBuffer" ; public static final String STRING_WRITER = "java.io.StringWriter" ; public static final String WRITER_SIG = "Ljava/io/Writer;" ; public static final String TRANSLET_OUTPUT_BASE = "org.apache.xalan.xsltc.TransletOutputBase" ; public static final String TRANSLET_OUTPUT_INTERFACE = "org.apache.xml.serializer.SerializationHandler" ; public static final String BASIS_LIBRARY_CLASS = "org.apache.xalan.xsltc.runtime.BasisLibrary" ; public static final String ATTRIBUTE_LIST_IMPL_CLASS = "org.apache.xalan.xsltc.runtime.AttributeListImpl" ; public static final String DOUBLE_CLASS = "java.lang.Double" ; public static final String INTEGER_CLASS = "java.lang.Integer" ; public static final String RUNTIME_NODE_CLASS = "org.apache.xalan.xsltc.runtime.Node" ; public static final String MATH_CLASS = "java.lang.Math" ; public static final String BOOLEAN_VALUE = "booleanValue" ; public static final String BOOLEAN_VALUE_SIG = "()Z" ; public static final String INT_VALUE = "intValue" ; public static final String INT_VALUE_SIG = "()I" ; public static final String DOUBLE_VALUE = "doubleValue" ; public static final String DOUBLE_VALUE_SIG = "()D" ; public static final String NODE_PNAME = "node" ; public static final String TRANSLET_OUTPUT_PNAME = "handler" ; public static final String ITERATOR_PNAME = "iterator" ; public static final String DOCUMENT_PNAME = "document" ; public static final String TRANSLET_PNAME = "translet" ; public static final String GET_NODE_NAME = "getNodeNameX" ; public static final String CHARACTERSW = "characters" ; public static final String GET_CHILDREN = "getChildren" ; public static final String GET_TYPED_CHILDREN = "getTypedChildren" ; public static final String CHARACTERS = "characters" ; public static final String APPLY_TEMPLATES = "applyTemplates" ; public static final String GET_NODE_TYPE = "getNodeType" ; public static final String GET_NODE_VALUE = "getStringValueX" ; public static final String GET_ELEMENT_VALUE = "getElementValue" ; public static final String GET_ATTRIBUTE_VALUE = "getAttributeValue" ; public static final String HAS_ATTRIBUTE = "hasAttribute" ; public static final String ADD_ITERATOR = "addIterator" ; public static final String SET_START_NODE = "setStartNode" ; public static final String RESET = "reset" ; public static final String ATTR_SET_SIG = "(" + TRANSLET_OUTPUT_SIG + NODE_ITERATOR_SIG + ")V" ; public static final String GET_NODE_NAME_SIG = "(" + NODE_SIG + ")" + STRING_SIG ; public static final String CHARACTERSW_SIG = "(" + STRING_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String CHARACTERS_SIG = "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String GET_CHILDREN_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String GET_TYPED_CHILDREN_SIG = "(I)" + NODE_ITERATOR_SIG ; public static final String GET_NODE_TYPE_SIG = "()S" ; public static final String GET_NODE_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ELEMENT_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ATTRIBUTE_VALUE_SIG = "(II)" + STRING_SIG ; public static final String HAS_ATTRIBUTE_SIG = "(II)Z" ; public static final String GET_ITERATOR_SIG = "()" + NODE_ITERATOR_SIG ; public static final String NAMES_INDEX = "namesArray" ; public static final String NAMES_INDEX_SIG = "[" + STRING_SIG ; public static final String NAMESPACE_INDEX = "namespaceArray" ; public static final String NAMESPACE_INDEX_SIG = "[" + STRING_SIG ; public static final String HASIDCALL_INDEX = "_hasIdCall" ; public static final String HASIDCALL_INDEX_SIG = "Z" ; public static final String DOM_FIELD = "_dom" ; public static final String FORMAT_SYMBOLS_FIELD = "format_symbols" ; public static final String ITERATOR_FIELD_SIG = NODE_ITERATOR_SIG ; public static final String NODE_FIELD = "node" ; public static final String NODE_FIELD_SIG = "I" ; public static final String EMPTYATTR_FIELD = "EmptyAttributes" ; public static final String ATTRIBUTE_LIST_FIELD = "attributeList" ; public static final String CLEAR_ATTRIBUTES = "clear" ; public static final String ADD_ATTRIBUTE = "addAttribute" ; public static final String ATTRIBUTE_LIST_IMPL_SIG = "Lorg/apache/xalan/xsltc/runtime/AttributeListImpl;" ; public static final String CLEAR_ATTRIBUTES_SIG = "()" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ATTRIBUTE_SIG = "(" + STRING_SIG + STRING_SIG + ")" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + ")" + UNION_ITERATOR_SIG ; public static final String ORDER_ITERATOR = "orderNodes" ; public static final String ORDER_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I)" + NODE_ITERATOR_SIG ; public static final String SET_START_NODE_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String NODE_COUNTER = "org.apache.xalan.xsltc.dom.NodeCounter" ; public static final String NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/NodeCounter;" ; public static final String DEFAULT_NODE_COUNTER = "org.apache.xalan.xsltc.dom.DefaultNodeCounter" ; public static final String DEFAULT_NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/DefaultNodeCounter;" ; public static final String TRANSLET_FIELD = "translet" ; public static final String TRANSLET_FIELD_SIG = TRANSLET_SIG ; public static final String RESET_SIG = "()" + NODE_ITERATOR_SIG ; public static final String GET_PARAMETER = "getParameter" ; public static final String ADD_PARAMETER = "addParameter" ; public static final String PUSH_PARAM_FRAME = "pushParamFrame" ; public static final String PUSH_PARAM_FRAME_SIG = "()V" ; public static final String POP_PARAM_FRAME = "popParamFrame" ; public static final String POP_PARAM_FRAME_SIG = "()V" ; public static final String GET_PARAMETER_SIG = "(" + STRING_SIG + ")" + OBJECT_SIG ; public static final String ADD_PARAMETER_SIG = "(" + STRING_SIG + OBJECT_SIG + "Z)" + OBJECT_SIG ; public static final String STRIP_SPACE = "stripSpace" ; public static final String STRIP_SPACE_INTF = "org/apache/xalan/xsltc/StripFilter" ; public static final String STRIP_SPACE_SIG = "Lorg/apache/xalan/xsltc/StripFilter;" ; public static final String STRIP_SPACE_PARAMS = "(Lorg/apache/xalan/xsltc/DOM;II)Z" ; public static final String GET_NODE_VALUE_ITERATOR = "getNodeValueIterator" ; public static final String GET_NODE_VALUE_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I" + STRING_SIG + "Z)" + NODE_ITERATOR_SIG ; public static final String GET_UNPARSED_ENTITY_URI_SIG = "(" + STRING_SIG + ")" + STRING_SIG ; public static final int POSITION_INDEX = 2 ; public static final int LAST_INDEX = 3 ; public static final String XMLNS_PREFIX = "xmlns" ; public static final String XMLNS_STRING = "xmlns:" ; public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; public static final String XSLT_URI = "http://www.w3.org/1999/XSL/Transform" ; public static final String XHTML_URI = "http://www.w3.org/1999/xhtml" ; public static final String TRANSLET_URI = "http://xml.apache.org/xalan/xsltc" ; public static final String REDIRECT_URI = "http://xml.apache.org/xalan/redirect" ; public static final String FALLBACK_CLASS = "org.apache.xalan.xsltc.compiler.Fallback" ; public static final int RTF_INITIAL_SIZE = 32 ; } 	1
package org . apache . xalan . xsltc . runtime . output ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . xsltc . trax . SAX2DOM ; import org . apache . xml . serializer . ToHTMLSAXHandler ; import org . apache . xml . serializer . ToHTMLStream ; import org . apache . xml . serializer . ToTextSAXHandler ; import org . apache . xml . serializer . ToTextStream ; import org . apache . xml . serializer . ToUnknownStream ; import org . apache . xml . serializer . ToXMLSAXHandler ; import org . apache . xml . serializer . ToXMLStream ; import org . apache . xml . serializer . SerializationHandler ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; public class TransletOutputHandlerFactory { public static final int STREAM = 0 ; public static final int SAX = 1 ; public static final int DOM = 2 ; private String _encoding = "utf-8" ; private String _method = null ; private int _outputType = STREAM ; private OutputStream _ostream = System . out ; private Writer _writer = null ; private Node _node = null ; private int _indentNumber = - 1 ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; static public TransletOutputHandlerFactory newInstance ( ) { return new TransletOutputHandlerFactory ( ) ; } public void setOutputType ( int outputType ) { _outputType = outputType ; } public void setEncoding ( String encoding ) { if ( encoding != null ) { _encoding = encoding ; } } public void setOutputMethod ( String method ) { _method = method ; } public void setOutputStream ( OutputStream ostream ) { _ostream = ostream ; } public void setWriter ( Writer writer ) { _writer = writer ; } public void setHandler ( ContentHandler handler ) { _handler = handler ; } public void setLexicalHandler ( LexicalHandler lex ) { _lexHandler = lex ; } public void setNode ( Node node ) { _node = node ; } public Node getNode ( ) { return ( _handler instanceof SAX2DOM ) ? ( ( SAX2DOM ) _handler ) . getDOM ( ) : null ; } public void setIndentNumber ( int value ) { _indentNumber = value ; } public SerializationHandler getSerializationHandler ( ) throws IOException , ParserConfigurationException { SerializationHandler result = null ; switch ( _outputType ) { case STREAM : if ( _method == null ) { result = new ToUnknownStream ( ) ; } else if ( _method . equalsIgnoreCase ( "xml" ) ) { result = new ToXMLStream ( ) ; } else if ( _method . equalsIgnoreCase ( "html" ) ) { result = new ToHTMLStream ( ) ; } else if ( _method . equalsIgnoreCase ( "text" ) ) { result = new ToTextStream ( ) ; } if ( result != null && _indentNumber >= 0 ) { result . setIndentAmount ( _indentNumber ) ; } result . setEncoding ( _encoding ) ; if ( _writer != null ) { result . setWriter ( _writer ) ; } else { result . setOutputStream ( _ostream ) ; } return result ; case DOM : _handler = ( _node != null ) ? new SAX2DOM ( _node ) : new SAX2DOM ( ) ; _lexHandler = ( LexicalHandler ) _handler ; case SAX : if ( _method == null ) { _method = "xml" ; } if ( _method . equalsIgnoreCase ( "xml" ) ) { if ( _lexHandler == null ) { result = new ToXMLSAXHandler ( _handler , _encoding ) ; } else { result = new ToXMLSAXHandler ( _handler , _lexHandler , _encoding ) ; } } else if ( _method . equalsIgnoreCase ( "html" ) ) { if ( _lexHandler == null ) { result = new ToHTMLSAXHandler ( _handler , _encoding ) ; } else { result = new ToHTMLSAXHandler ( _handler , _lexHandler , _encoding ) ; } } else if ( _method . equalsIgnoreCase ( "text" ) ) { if ( _lexHandler == null ) { result = new ToTextSAXHandler ( _handler , _encoding ) ; } else { result = new ToTextSAXHandler ( _handler , _lexHandler , _encoding ) ; } } return result ; } return null ; } } 	0
package org . apache . xml . utils . synthetic ; import org . apache . xml . utils . synthetic . reflection . Method ; public class TestDriver { public static int sampleField = 32 ; private boolean inTest = false ; public static void main ( String [ ] args ) { try { System . out . println ( "Proxying java.awt.Frame..." ) ; Class myC = Class . forName ( "java.awt.Frame" ) ; myC . toSource ( System . out , 0 ) ; System . out . println ( "\nProxying org.apache.xml.utils.synthetic.TestDriver..." ) ; myC = Class . forName ( "com.ibm.org.apache.xml.utils.synthetic.TestDriver" ) ; myC . toSource ( System . out , 0 ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "Couldn't proxy: " ) ; e . printStackTrace ( ) ; } try { System . out . println ( "\nBuild a new beast..." ) ; Class myC = Class . declareClass ( "com.ibm.org.apache.xml.utils.synthetic.BuildMe" ) ; Class inner = myC . declareInnerClass ( "island" ) ; inner . addExtends ( Class . forName ( "java.lang.String" ) ) ; Method m = inner . declareMethod ( "getValue" ) ; m . setReturnType ( Class . forName ( "java.lang.String" ) ) ; m . getBody ( ) . append ( "return toString();" ) ; myC . toSource ( System . out , 0 ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( SynthesisException e ) { e . printStackTrace ( ) ; } catch ( IllegalStateException e ) { System . out . println ( "Unwritten function: " + e ) ; e . printStackTrace ( ) ; } } public static void dumpClass ( Class C ) { System . out . println ( "toString(): " + C ) ; System . out . println ( "\tisPrimitive(): " + C . isPrimitive ( ) ) ; System . out . println ( "\tisInterface(): " + C . isInterface ( ) ) ; System . out . println ( "\tisInstance(\"foo\"): " + C . isInstance ( "foo" ) ) ; System . out . println ( "\tisArray(): " + C . isArray ( ) ) ; System . out . println ( "\tgetRealClass(): " + C . getRealClass ( ) ) ; } public void quickcheck ( ) { Inner a = new Inner ( ) ; a . setTest ( ! a . getTest ( ) ) ; } private class Inner { public boolean getTest ( ) { return inTest ; } public void setTest ( boolean test ) { inTest = test ; } } } 	1
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionHandler ; import org . apache . xalan . extensions . ExtensionsTable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; public class ElemExtensionCall extends ElemLiteralResult { String m_extns ; String m_lang ; String m_srcURL ; String m_scriptSrc ; ElemExtensionDecl m_decl = null ; public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONCALL ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_extns = this . getNamespace ( ) ; m_decl = getElemExtensionDecl ( sroot , m_extns ) ; if ( m_decl == null ) sroot . getExtensionNamespacesManager ( ) . registerExtension ( m_extns ) ; } private ElemExtensionDecl getElemExtensionDecl ( StylesheetRoot stylesheet , String namespace ) { ElemExtensionDecl decl = null ; int n = stylesheet . getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Stylesheet imported = stylesheet . getGlobalImport ( i ) ; for ( ElemTemplateElement child = imported . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_EXTENSIONDECL == child . getXSLToken ( ) ) { decl = ( ElemExtensionDecl ) child ; String prefix = decl . getPrefix ( ) ; String declNamespace = child . getNamespaceForPrefix ( prefix ) ; if ( namespace . equals ( declNamespace ) ) { return decl ; } } } } return null ; } public void executeFallbacks ( TransformerImpl transformer ) throws TransformerException { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) { try { transformer . pushElemTemplateElement ( child ) ; ( ( ElemFallback ) child ) . executeFallback ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } } } public boolean hasFallbackChildren ( ) { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) return true ; } return false ; } public void execute ( TransformerImpl transformer ) throws TransformerException { try { transformer . getResultTreeHandler ( ) . flushPending ( ) ; ExtensionsTable etable = transformer . getExtensionsTable ( ) ; ExtensionHandler nsh = etable . get ( m_extns ) ; if ( null == nsh ) { if ( hasFallbackChildren ( ) ) { executeFallbacks ( transformer ) ; } else { TransformerException te = new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CALL_TO_EXT_FAILED , new Object [ ] { getNodeName ( ) } ) ) ; transformer . getErrorListener ( ) . fatalError ( te ) ; } return ; } try { nsh . processElement ( this . getLocalName ( ) , this , transformer , getStylesheet ( ) , this ) ; } catch ( Exception e ) { if ( hasFallbackChildren ( ) ) executeFallbacks ( transformer ) ; else { if ( e instanceof TransformerException ) { TransformerException te = ( TransformerException ) e ; if ( null == te . getLocator ( ) ) te . setLocator ( this ) ; transformer . getErrorListener ( ) . fatalError ( te ) ; } else if ( e instanceof RuntimeException ) { transformer . getErrorListener ( ) . fatalError ( new TransformerException ( e ) ) ; } else { transformer . getErrorListener ( ) . warning ( new TransformerException ( e ) ) ; } } } } catch ( TransformerException e ) { transformer . getErrorListener ( ) . fatalError ( e ) ; } } public String getAttribute ( String rawName ) { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { return avt . getSimpleString ( ) ; } return null ; } public String getAttribute ( String rawName , org . w3c . dom . Node sourceNode , TransformerImpl transformer ) throws TransformerException { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { XPathContext xctxt = transformer . getXPathContext ( ) ; return avt . evaluate ( xctxt , xctxt . getDTMHandleFromNode ( sourceNode ) , this ) ; } return null ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitExtensionElement ( this ) ; } } 	1
package org . apache . xml . utils . res ; public class XResources_zh_TW extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "alphabet" , new char [ ] { 0xff21 , 0xff22 , 0xff23 , 0xff24 , 0xff25 , 0xff26 , 0xff27 , 0xff28 , 0xff29 , 0xff2a , 0xff2b , 0xff2c , 0xff2d , 0xff2e , 0xff2f , 0xff30 , 0xff31 , 0xff32 , 0xff33 , 0xff34 , 0xff35 , 0xff36 , 0xff37 , 0xff38 , 0xff39 , 0xff3a } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ ] { 0x96f6 } } , { "multiplier" , new long [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x5104 , 0x842c , 0x4edf , 0x4f70 , 0x62fe } } , { "digits" , new char [ ] { 0x58f9 , 0x8cb3 , 0x53c3 , 0x8086 , 0x4f0d , 0x9678 , 0x67d2 , 0x634c , 0x7396 } } , { "tables" , new String [ ] { "digits" } } } ; } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ProcessingInstruction extends Instruction { private AttributeValue _name ; public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; _name = AttributeValue . create ( this , name , parser ) ; if ( name . equals ( "xml" ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_PI_ERR , "xml" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _name . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; _name . translate ( classGen , methodGen ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValueOfPI" , "()" + STRING_SIG ) ) ) ; final int processingInstruction = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "processingInstruction" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( processingInstruction , 3 ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	1
package org . apache . xml . utils ; public class StringToIntTable { public static final int INVALID_KEY = - 10000 ; private int m_blocksize ; private String m_map [ ] ; private int m_values [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToIntTable ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; m_values = new int [ m_blocksize ] ; } public StringToIntTable ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; m_values = new int [ m_blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final void put ( String key , int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; int newValues [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_values , 0 , newValues , 0 , m_firstFree + 1 ) ; m_values = newValues ; } m_map [ m_firstFree ] = key ; m_values [ m_firstFree ] = value ; m_firstFree ++ ; } public final int get ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final int getIgnoreCase ( String key ) { if ( null == key ) return INVALID_KEY ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equalsIgnoreCase ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final boolean contains ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return true ; } return false ; } public final String [ ] keys ( ) { String [ ] keysArr = new String [ m_firstFree ] ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { keysArr [ i ] = m_map [ i ] ; } return keysArr ; } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Equals extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . equals ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; boolean result = left . equals ( right ) ? true : false ; left . detach ( ) ; right . detach ( ) ; return result ; } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; final class LastCall extends FunctionCall { public LastCall ( QName fname ) { super ( fname ) ; } public boolean hasPositionCall ( ) { return true ; } public boolean hasLastCall ( ) { return true ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( methodGen instanceof CompareGenerator ) { il . append ( ( ( CompareGenerator ) methodGen ) . loadLastNode ( ) ) ; } else if ( methodGen instanceof TestGenerator ) { il . append ( new ILOAD ( LAST_INDEX ) ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final int getLast = cpg . addInterfaceMethodref ( NODE_ITERATOR , "getLast" , "()I" ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKEINTERFACE ( getLast , 1 ) ) ; } } } 	0
package org . apache . xml . dtm . ref ; import java . util . BitSet ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class CoroutineManager { BitSet m_activeIDs = new BitSet ( ) ; static final int m_unreasonableId = 1024 ; Object m_yield = null ; final static int NOBODY = - 1 ; final static int ANYBODY = - 1 ; int m_nextCoroutine = NOBODY ; public synchronized int co_joinCoroutineSet ( int coroutineID ) { if ( coroutineID >= 0 ) { if ( coroutineID >= m_unreasonableId || m_activeIDs . get ( coroutineID ) ) return - 1 ; } else { coroutineID = 0 ; while ( coroutineID < m_unreasonableId ) { if ( m_activeIDs . get ( coroutineID ) ) ++ coroutineID ; else break ; } if ( coroutineID >= m_unreasonableId ) return - 1 ; } m_activeIDs . set ( coroutineID ) ; return coroutineID ; } public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; } public synchronized Object co_resume ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; notify ( ) ; while ( m_nextCoroutine != thisCoroutine || m_nextCoroutine == ANYBODY || m_nextCoroutine == NOBODY ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } if ( m_nextCoroutine == NOBODY ) { co_exit ( thisCoroutine ) ; throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_CO_EXIT , null ) ) ; } return m_yield ; } public synchronized void co_exit ( int thisCoroutine ) { m_activeIDs . clear ( thisCoroutine ) ; m_nextCoroutine = NOBODY ; notify ( ) ; } public synchronized void co_exit_to ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; m_activeIDs . clear ( thisCoroutine ) ; notify ( ) ; } } 	1
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncStringLength extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsString ( xctxt ) . length ( ) ) ; } } 	1
package org . apache . xalan . xsltc . dom ; import java . text . CollationKey ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . xsltc . CollatorFactory ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; public abstract class NodeSortRecord { public static int COMPARE_STRING = 0 ; public static int COMPARE_NUMERIC = 1 ; public static int COMPARE_ASCENDING = 0 ; public static int COMPARE_DESCENDING = 1 ; protected static final Locale DEFAULT_LOCALE = Locale . getDefault ( ) ; protected Locale _locale = Locale . getDefault ( ) ; protected static final Collator DEFAULT_COLLATOR = Collator . getInstance ( ) ; protected Collator _collator = DEFAULT_COLLATOR ; protected CollatorFactory _collatorFactory ; protected int _levels = 1 ; protected int [ ] _compareType ; protected int [ ] _sortOrder ; private AbstractTranslet _translet = null ; private DOM _dom = null ; private int _node ; private int _last = 0 ; private int _scanned = 0 ; private Object [ ] _values ; public NodeSortRecord ( int node ) { _node = node ; if ( _locale != DEFAULT_LOCALE ) { _collator = Collator . getInstance ( _locale ) ; } } public NodeSortRecord ( ) { this ( 0 ) ; } public final void initialize ( int node , int last , DOM dom , AbstractTranslet translet , int [ ] order , int [ ] type , NodeSortRecordFactory nsrFactory ) throws TransletException { _dom = dom ; _node = node ; _last = last ; _translet = translet ; _scanned = 0 ; _levels = order . length ; _sortOrder = order ; _compareType = type ; _values = new Object [ _levels ] ; String colFactClassname = System . getProperty ( "org.apache.xalan.xsltc.COLLATOR_FACTORY" ) ; if ( colFactClassname != null ) { try { Object candObj = nsrFactory . loadTranslet ( colFactClassname ) ; _collatorFactory = ( CollatorFactory ) candObj ; } catch ( ClassNotFoundException e ) { throw new TransletException ( e ) ; } } else { _collatorFactory = new CollatorFactoryBase ( ) ; } _collator = _collatorFactory . getCollator ( _locale ) ; } public final int getNode ( ) { return _node ; } public final int compareDocOrder ( NodeSortRecord other ) { return _node - other . _node ; } private final CollationKey stringValue ( int level ) { if ( _scanned <= level ) { final String str = extractValueFromDOM ( _dom , _node , level , _translet , _last ) ; final CollationKey key = _collator . getCollationKey ( str ) ; _values [ _scanned ++ ] = key ; return ( key ) ; } return ( ( CollationKey ) _values [ level ] ) ; } private final Double numericValue ( int level ) { if ( _scanned <= level ) { final String str = extractValueFromDOM ( _dom , _node , level , _translet , _last ) ; Double num ; try { num = new Double ( str ) ; } catch ( NumberFormatException e ) { num = new Double ( Double . NEGATIVE_INFINITY ) ; } _values [ _scanned ++ ] = num ; return ( num ) ; } return ( ( Double ) _values [ level ] ) ; } public int compareTo ( NodeSortRecord other ) { int cmp , level ; for ( level = 0 ; level < _levels ; level ++ ) { if ( _compareType [ level ] == COMPARE_NUMERIC ) { final Double our = numericValue ( level ) ; final Double their = other . numericValue ( level ) ; cmp = our . compareTo ( their ) ; } else { final CollationKey our = stringValue ( level ) ; final CollationKey their = other . stringValue ( level ) ; cmp = our . compareTo ( their ) ; } if ( cmp != 0 ) { return _sortOrder [ level ] == COMPARE_DESCENDING ? 0 - cmp : cmp ; } } return ( _node - other . _node ) ; } public Collator getCollator ( ) { return _collator ; } public abstract String extractValueFromDOM ( DOM dom , int current , int level , AbstractTranslet translet , int last ) ; } 	1
package org . apache . xml . utils ; public class IntVector implements Cloneable { protected int m_blocksize ; protected int m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public IntVector ( ) { m_blocksize = 32 ; m_mapSize = m_blocksize ; m_map = new int [ m_blocksize ] ; } public IntVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public IntVector ( int blocksize , int increaseSize ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public IntVector ( IntVector v ) { m_map = new int [ v . m_mapSize ] ; m_mapSize = v . m_mapSize ; m_firstFree = v . m_firstFree ; m_blocksize = v . m_blocksize ; System . arraycopy ( v . m_map , 0 , m_map , 0 , m_firstFree ) ; } public final int size ( ) { return m_firstFree ; } public final void setSize ( int sz ) { m_firstFree = sz ; } public final void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void addElements ( int value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } } public final void addElements ( int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_firstFree += numberOfElements ; } public final void insertElementAt ( int value , int at ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public final void removeAllElements ( ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = java . lang . Integer . MIN_VALUE ; } m_firstFree = 0 ; } public final boolean removeElement ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + 1 ) < m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return true ; } } return false ; } public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; } public final void setElementAt ( int value , int index ) { m_map [ index ] = value ; } public final int elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) return true ; } return false ; } public final int indexOf ( int elem , int index ) { for ( int i = index ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int indexOf ( int elem ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int lastIndexOf ( int elem ) { for ( int i = ( m_firstFree - 1 ) ; i >= 0 ; i -- ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public Object clone ( ) throws CloneNotSupportedException { return new IntVector ( this ) ; } } 	1
package org . apache . xalan . lib ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ExsltMath extends ExsltBase { private static String PI = "3.1415926535897932384626433832795028841971693993751" ; private static String E = "2.71828182845904523536028747135266249775724709369996" ; private static String SQRRT2 = "1.41421356237309504880168872420969807856967187537694" ; private static String LN2 = "0.69314718055994530941723212145817656807550013436025" ; private static String LN10 = "2.302585092994046" ; private static String LOG2E = "1.4426950408889633" ; private static String SQRT1_2 = "0.7071067811865476" ; public static double max ( NodeList nl ) { if ( nl == null || nl . getLength ( ) == 0 ) return Double . NaN ; double m = - Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( Double . isNaN ( d ) ) return Double . NaN ; else if ( d > m ) m = d ; } return m ; } public static double min ( NodeList nl ) { if ( nl == null || nl . getLength ( ) == 0 ) return Double . NaN ; double m = Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( Double . isNaN ( d ) ) return Double . NaN ; else if ( d < m ) m = d ; } return m ; } public static NodeList highest ( NodeList nl ) { double maxValue = max ( nl ) ; NodeSet highNodes = new NodeSet ( ) ; highNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( maxValue ) ) return highNodes ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( d == maxValue ) highNodes . addElement ( n ) ; } return highNodes ; } public static NodeList lowest ( NodeList nl ) { double minValue = min ( nl ) ; NodeSet lowNodes = new NodeSet ( ) ; lowNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( minValue ) ) return lowNodes ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( d == minValue ) lowNodes . addElement ( n ) ; } return lowNodes ; } public static double abs ( double num ) { return Math . abs ( num ) ; } public static double acos ( double num ) { return Math . acos ( num ) ; } public static double asin ( double num ) { return Math . asin ( num ) ; } public static double atan ( double num ) { return Math . atan ( num ) ; } public static double atan2 ( double num1 , double num2 ) { return Math . atan2 ( num1 , num2 ) ; } public static double cos ( double num ) { return Math . cos ( num ) ; } public static double exp ( double num ) { return Math . exp ( num ) ; } public static double log ( double num ) { return Math . log ( num ) ; } public static double power ( double num1 , double num2 ) { return Math . pow ( num1 , num2 ) ; } public static double random ( ) { return Math . random ( ) ; } public static double sin ( double num ) { return Math . sin ( num ) ; } public static double sqrt ( double num ) { return Math . sqrt ( num ) ; } public static double tan ( double num ) { return Math . tan ( num ) ; } public static double constant ( String name , double precision ) { String value = null ; if ( name . equals ( "PI" ) ) value = PI ; else if ( name . equals ( "E" ) ) value = E ; else if ( name . equals ( "SQRRT2" ) ) value = SQRRT2 ; else if ( name . equals ( "LN2" ) ) value = LN2 ; else if ( name . equals ( "LN10" ) ) value = LN10 ; else if ( name . equals ( "LOG2E" ) ) value = LOG2E ; else if ( name . equals ( "SQRT1_2" ) ) value = SQRT1_2 ; if ( value != null ) { int bits = new Double ( precision ) . intValue ( ) ; if ( bits <= value . length ( ) ) value = value . substring ( 0 , bits ) ; return new Double ( value ) . doubleValue ( ) ; } else return Double . NaN ; } } 	1
