package org . apache . camel . component . irc ; import org . apache . commons . logging . Log ; import org . schwering . irc . lib . IRCEventAdapter ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcErrorLogger extends IRCEventAdapter { private Log log ; public IrcErrorLogger ( Log log ) { this . log = log ; } @ Override public void onRegistered ( ) { super . onRegistered ( ) ; log . info ( "onRegistered" ) ; } @ Override public void onDisconnected ( ) { super . onDisconnected ( ) ; log . info ( "onDisconnected" ) ; } @ Override public void onMode ( String string , IRCUser ircUser , IRCModeParser ircModeParser ) { super . onMode ( string , ircUser , ircModeParser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.ircModeParser = " + ircModeParser ) ; } @ Override public void onMode ( IRCUser ircUser , String string , String string1 ) { super . onMode ( ircUser , string , string1 ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.string1 = " + string1 ) ; } @ Override public void onPing ( String string ) { super . onPing ( string ) ; log . info ( "onPing.string = " + string ) ; } @ Override public void onError ( String string ) { log . info ( "onError.string = " + string ) ; } @ Override public void onError ( int i , String string ) { super . onError ( i , string ) ; log . error ( "onError.i = " + i ) ; log . error ( "onError.string = " + string ) ; } @ Override public void unknown ( String string , String string1 , String string2 , String string3 ) { super . unknown ( string , string1 , string2 , string3 ) ; log . error ( "unknown.string = " + string ) ; log . error ( "unknown.string1 = " + string1 ) ; log . error ( "unknown.string2 = " + string2 ) ; log . error ( "unknown.string3 = " + string3 ) ; } } 	0	['9', '0', '0', '5', '24', '0', '1', '4', '9', '0', '213', '1', '1', '0', '0.37037037', '0', '0', '22.55555556', '1', '0.8889', '0']
package org . apache . camel ; import java . util . Map ; public interface ProducerTemplate < E extends Exchange > extends Service { E send ( E exchange ) ; E send ( Processor processor ) ; Object sendBody ( Object body ) ; Object sendBodyAndHeader ( Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) ; E send ( String endpointUri , E exchange ) ; E send ( String endpointUri , Processor processor ) ; E send ( String endpointUri , ExchangePattern pattern , Processor processor ) ; E send ( Endpoint < E > endpoint , E exchange ) ; E send ( Endpoint < E > endpoint , Processor processor ) ; E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) ; Object sendBody ( Endpoint < E > endpoint , Object body ) ; Object sendBody ( String endpointUri , Object body ) ; Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) ; Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) ; Object sendBodyAndHeader ( String endpointUri , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) ; Object sendBodyAndHeaders ( Endpoint endpoint , Object body , Map < String , Object > headers ) ; E request ( Endpoint < E > endpoint , Processor processor ) ; Object requestBody ( Endpoint < E > endpoint , Object body ) ; Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) ; E request ( String endpoint , Processor processor ) ; Object requestBody ( String endpoint , Object body ) ; Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) ; } 	1	['27', '1', '0', '6', '27', '351', '1', '5', '27', '2', '27', '0', '0', '0', '0.412037037', '0', '0', '0', '1', '1', '3']
package org . apache . camel . impl ; import java . util . Hashtable ; import javax . naming . Context ; import javax . naming . InitialContext ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Registry ; public class JndiRegistry implements Registry { private Context context ; public JndiRegistry ( ) { } public JndiRegistry ( Context context ) { this . context = context ; } public < T > T lookup ( String name , Class < T > type ) { Object value = lookup ( name ) ; return type . cast ( value ) ; } public Object lookup ( String name ) { try { return getContext ( ) . lookup ( name ) ; } catch ( NameNotFoundException e ) { return null ; } catch ( NamingException e ) { throw new RuntimeCamelException ( e ) ; } } public void bind ( String s , Object o ) { try { getContext ( ) . bind ( s , o ) ; } catch ( NamingException e ) { throw new RuntimeCamelException ( e ) ; } } public void close ( ) throws NamingException { getContext ( ) . close ( ) ; } public Context getContext ( ) throws NamingException { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( Context context ) { this . context = context ; } protected Context createContext ( ) throws NamingException { Hashtable properties = new Hashtable ( System . getProperties ( ) ) ; return new InitialContext ( properties ) ; } } 	0	['9', '1', '0', '3', '18', '30', '1', '2', '8', '0.375', '82', '1', '0', '0', '0.355555556', '0', '0', '8', '1', '0.7778', '0']
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TryProcessor extends ServiceSupport implements Processor { private static final Log LOG = LogFactory . getLog ( TryProcessor . class ) ; private final Processor tryProcessor ; private final List < CatchProcessor > catchClauses ; private final Processor finallyProcessor ; public TryProcessor ( Processor tryProcessor , List < CatchProcessor > catchClauses , Processor finallyProcessor ) { this . tryProcessor = tryProcessor ; this . catchClauses = catchClauses ; this . finallyProcessor = finallyProcessor ; } public String toString ( ) { String finallyText = ( finallyProcessor == null ) ? "" : " Finally {" + finallyProcessor + "}" ; return "Try {" + tryProcessor + "} " + catchClauses + finallyText ; } public void process ( Exchange exchange ) throws Exception { Throwable e = null ; try { tryProcessor . process ( exchange ) ; e = exchange . getException ( ) ; if ( e != null && DeadLetterChannel . isFailureHandled ( exchange ) ) { e = null ; } } catch ( Exception ex ) { e = ex ; exchange . setException ( e ) ; } if ( e != null ) { try { DeadLetterChannel . setFailureHandled ( exchange , true ) ; handleException ( exchange , e ) ; } catch ( Exception ex ) { throw ex ; } catch ( Throwable ex ) { throw new RuntimeCamelException ( ex ) ; } finally { handleAll ( exchange ) ; } } else { handleAll ( exchange ) ; } } private void handleAll ( Exchange exchange ) { if ( finallyProcessor != null ) { DeadLetterChannel . setFailureHandled ( exchange , true ) ; try { finallyProcessor . process ( exchange ) ; } catch ( Exception e2 ) { LOG . warn ( "Caught exception in finally block while handling other exception: " + e2 , e2 ) ; } } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void handleException ( Exchange exchange , Throwable e ) throws Throwable { for ( CatchProcessor catchClause : catchClauses ) { if ( catchClause . catches ( e ) ) { exchange . setException ( e ) ; try { catchClause . process ( exchange ) ; } catch ( Exception e1 ) { LOG . warn ( "Caught exception inside catch clause: " + e1 , e1 ) ; throw e1 ; } return ; } } if ( finallyProcessor == null ) { throw e ; } } } 	1	['8', '2', '0', '10', '28', '0', '1', '9', '3', '0.357142857', '224', '1', '3', '0.684210526', '0.371428571', '1', '1', '26.5', '2', '1', '9']
package org . apache . camel . component . cxf ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . cxf . endpoint . EndpointImpl ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . endpoint . ServerImpl ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . transport . ChainInitiationObserver ; import org . apache . cxf . wsdl11 . WSDLServiceFactory ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . Bus ; import org . apache . cxf . interceptor . AttachmentInInterceptor ; import org . apache . cxf . interceptor . StaxInInterceptor ; import org . apache . cxf . binding . AbstractBindingFactory ; import org . apache . cxf . binding . soap . interceptor . ReadHeadersInterceptor ; import org . apache . cxf . binding . soap . interceptor . MustUnderstandInterceptor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class CxfSoapConsumer implements Consumer { private static final Log LOG = LogFactory . getLog ( CxfSoapConsumer . class ) ; private final CxfSoapEndpoint endpoint ; private final Consumer consumer ; private EndpointImpl ep ; private MessageObserver chain ; private Server server ; public CxfSoapConsumer ( CxfSoapEndpoint endpoint , Processor processor ) throws Exception { this . endpoint = endpoint ; Processor soapProcessor = new AsyncProcessorDecorator ( processor , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapConsumerIn ( exchange ) ; } } , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapConsumerOut ( exchange ) ; } } ) ; this . consumer = endpoint . getInnerEndpoint ( ) . createConsumer ( soapProcessor ) ; WSDLServiceFactory factory = new WSDLServiceFactory ( getBus ( ) , endpoint . getDefinition ( ) , endpoint . getService ( ) ) ; Service cxfService = factory . create ( ) ; EndpointInfo ei = cxfService . getServiceInfos ( ) . iterator ( ) . next ( ) . getEndpoints ( ) . iterator ( ) . next ( ) ; ei . setAddress ( "local://" + ei . getService ( ) . getName ( ) . toString ( ) + "/" + ei . getName ( ) . getLocalPart ( ) ) ; ei . getBinding ( ) . setProperty ( AbstractBindingFactory . DATABINDING_DISABLED , Boolean . TRUE ) ; cxfService . getInInterceptors ( ) . add ( new ReadHeadersInterceptor ( getBus ( ) ) ) ; cxfService . getInInterceptors ( ) . add ( new MustUnderstandInterceptor ( ) ) ; cxfService . getInInterceptors ( ) . add ( new AttachmentInInterceptor ( ) ) ; cxfService . getInInterceptors ( ) . add ( new StaxInInterceptor ( ) ) ; cxfService . getInInterceptors ( ) . add ( new ReadHeadersInterceptor ( getBus ( ) ) ) ; ep = new EndpointImpl ( getBus ( ) , cxfService , ei ) ; chain = new ChainInitiationObserver ( ep , getBus ( ) ) ; server = new ServerImpl ( getBus ( ) , ep , null , chain ) ; } public void start ( ) throws Exception { server . start ( ) ; consumer . start ( ) ; } public void stop ( ) throws Exception { server . stop ( ) ; consumer . stop ( ) ; } protected Bus getBus ( ) { return endpoint . getBus ( ) ; } protected void processSoapConsumerIn ( Exchange exchange ) throws Exception { LOG . info ( "processSoapConsumerIn: " + exchange ) ; } protected void processSoapConsumerOut ( Exchange exchange ) throws Exception { LOG . info ( "processSoapConsumerOut: " + exchange ) ; } } 	0	['7', '1', '0', '27', '50', '7', '3', '27', '3', '0.805555556', '198', '1', '3', '0', '0.416666667', '0', '0', '26.42857143', '1', '0.7143', '0']
package org . apache . camel . builder . xml ; import org . apache . camel . util . ObjectHelper ; public class Namespaces { public static final String DEFAULT_NAMESPACE = "http://activemq.apache.org/camel/schema/spring" ; public static final String IN_NAMESPACE = "http://camel.apache.org/xml/in/" ; public static final String OUT_NAMESPACE = "http://camel.apache.org/xml/out/" ; public static final String SYSTEM_PROPERTIES_NAMESPACE = "http://camel.apache.org/xml/variables/system-properties" ; public static final String ENVIRONMENT_VARIABLES = "http://camel.apache.org/xml/variables/environment-variables" ; public static final String EXCHANGE_PROPERTY = "http://camel.apache.org/xml/variables/exchange-property" ; private Namespaces ( ) { } public static boolean isMatchingNamespaceOrEmptyNamespace ( String namespaceURI , String expectedNamespace ) { return ObjectHelper . isNullOrBlank ( namespaceURI ) || namespaceURI . equals ( expectedNamespace ) ; } } 	1	['2', '1', '0', '2', '5', '1', '1', '1', '1', '2', '22', '0', '0', '0', '0.5', '0', '0', '7', '3', '1.5', '2']
package org . apache . camel . component . cxf ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . AsyncCallback ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; public class AsyncProcessorDecorator implements AsyncProcessor { private final AsyncProcessor processor ; private final Processor before ; private final Processor after ; public AsyncProcessorDecorator ( Processor processor , Processor before , Processor after ) { this . processor = AsyncProcessorTypeConverter . convert ( processor ) ; this . before = before ; this . after = after ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { try { before . process ( exchange ) ; } catch ( Throwable t ) { exchange . setException ( t ) ; callback . done ( true ) ; return true ; } return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { try { after . process ( exchange ) ; callback . done ( doneSynchronously ) ; } catch ( Throwable t ) { exchange . setException ( t ) ; } } } ) ; } } 	0	['4', '1', '0', '9', '12', '2', '3', '7', '3', '0.666666667', '52', '1', '3', '0', '0.4', '0', '0', '11.25', '1', '0.75', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; public class SedaEndpoint extends DefaultEndpoint < Exchange > { private final class SedaProducer extends DefaultProducer implements AsyncProcessor { private SedaProducer ( Endpoint endpoint ) { super ( endpoint ) ; } public void process ( Exchange exchange ) { queue . add ( exchange . copy ( ) ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { queue . add ( exchange . copy ( ) ) ; callback . done ( true ) ; return true ; } } private BlockingQueue < Exchange > queue ; public SedaEndpoint ( String endpointUri , Component component , BlockingQueue < Exchange > queue ) { super ( endpointUri , component ) ; this . queue = queue ; } public SedaEndpoint ( String uri , SedaComponent component ) { this ( uri , component , component . createQueue ( ) ) ; } public Producer createProducer ( ) throws Exception { return new SedaProducer ( this ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new SedaConsumer ( this , processor ) ; } public BlockingQueue < Exchange > getQueue ( ) { return queue ; } public boolean isSingleton ( ) { return true ; } } 	1	['7', '2', '0', '11', '11', '15', '4', '10', '6', '0.5', '44', '1', '0', '0.772727273', '0.265306122', '0', '0', '5.142857143', '1', '0.7143', '2']
package org . apache . camel . component . cxf . interceptors ; import java . util . ResourceBundle ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . interceptor . MessageSenderInterceptor ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class DOMOutInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( DOMOutInterceptor . class ) ; private final XMLMessageOutInterceptor xmlInterceptor = new XMLMessageOutInterceptor ( ) ; private final SoapMessageOutInterceptor soapInterceptor = new SoapMessageOutInterceptor ( ) ; public DOMOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; this . addBefore ( MessageSenderInterceptor . class . getName ( ) ) ; } public boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { if ( message instanceof XMLMessage ) { xmlInterceptor . handleMessage ( ( XMLMessage ) message ) ; } else if ( message instanceof SoapMessage ) { soapInterceptor . handleMessage ( ( SoapMessage ) message ) ; } else { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NOT_SUPPORTED_MESSAGE" , LOG , message . getClass ( ) . getName ( ) ) ) ; } } } 	0	['4', '0', '0', '10', '17', '2', '1', '9', '3', '0.666666667', '71', '1', '2', '0', '0.833333333', '0', '0', '16', '1', '0.5', '0']
package org . apache . camel . model ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . ChoiceProcessor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . util . CollectionStringBuffer ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; @ XmlRootElement ( name = "choice" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ChoiceType extends ProcessorType < ChoiceType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < WhenType > whenClauses = new ArrayList < WhenType > ( ) ; @ XmlElement ( required = false ) private OtherwiseType otherwise ; @ Override public String toString ( ) { return "Choice[ " + getWhenClauses ( ) + " " + getOtherwise ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; for ( WhenType whenClaus : whenClauses ) { filters . add ( whenClaus . createProcessor ( routeContext ) ) ; } Processor otherwiseProcessor = null ; if ( otherwise != null ) { otherwiseProcessor = otherwise . createProcessor ( routeContext ) ; } return new ChoiceProcessor ( filters , otherwiseProcessor ) ; } public ChoiceType when ( Predicate predicate ) { getWhenClauses ( ) . add ( new WhenType ( predicate ) ) ; return this ; } public OtherwiseType otherwise ( ) { OtherwiseType answer = new OtherwiseType ( ) ; setOtherwise ( answer ) ; return answer ; } @ Override public String getLabel ( ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; List < WhenType > list = getWhenClauses ( ) ; for ( WhenType whenType : list ) { buffer . append ( whenType . getLabel ( ) ) ; } return buffer . toString ( ) ; } public List < WhenType > getWhenClauses ( ) { return whenClauses ; } public void setWhenClauses ( List < WhenType > whenClauses ) { this . whenClauses = whenClauses ; } public List < ProcessorType < ? > > getOutputs ( ) { if ( otherwise != null ) { return otherwise . getOutputs ( ) ; } else if ( whenClauses . isEmpty ( ) ) { return Collections . EMPTY_LIST ; } else { WhenType when = whenClauses . get ( whenClauses . size ( ) - 1 ) ; return when . getOutputs ( ) ; } } public OtherwiseType getOtherwise ( ) { return otherwise ; } public void setOtherwise ( OtherwiseType otherwise ) { this . otherwise = otherwise ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } } 	1	['13', '2', '0', '12', '37', '42', '4', '9', '13', '0.611111111', '175', '1', '1', '0.885714286', '0.276923077', '1', '4', '12.23076923', '3', '1.1538', '6']
package org . apache . camel . component . file . strategy ; import java . io . File ; public class DefaultFileRenamer implements FileRenamer { private static final boolean ON_WINDOWS = System . getProperty ( "os.name" ) . startsWith ( "Windows" ) ; private String namePrefix ; private String namePostfix ; public DefaultFileRenamer ( ) { } public DefaultFileRenamer ( String namePrefix , String namePostfix ) { this . namePrefix = namePrefix ; this . namePostfix = namePostfix ; } public File renameFile ( File file ) { File parent = file . getParentFile ( ) ; String name = renameFileName ( file ) ; if ( ON_WINDOWS && ( name . indexOf ( ":" ) >= 0 || name . startsWith ( "//" ) ) ) { return new File ( name ) ; } return new File ( parent , name ) ; } public String getNamePostfix ( ) { return namePostfix ; } public void setNamePostfix ( String namePostfix ) { this . namePostfix = namePostfix ; } public String getNamePrefix ( ) { return namePrefix ; } public void setNamePrefix ( String namePrefix ) { this . namePrefix = namePrefix ; } protected String renameFileName ( File file ) { StringBuffer buffer = new StringBuffer ( ) ; if ( namePrefix != null ) { buffer . append ( namePrefix ) ; } buffer . append ( file . getName ( ) ) ; if ( namePostfix != null ) { buffer . append ( namePostfix ) ; } return buffer . toString ( ) ; } } 	0	['9', '1', '0', '3', '20', '12', '2', '1', '7', '0.625', '100', '1', '0', '0', '0.541666667', '0', '0', '9.777777778', '4', '1.2222', '0']
package org . apache . camel . management ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . rmi . RemoteException ; import java . rmi . registry . LocateRegistry ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . management . InstanceAlreadyExistsException ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . MBeanServerFactory ; import javax . management . NotCompliantMBeanException ; import javax . management . ObjectInstance ; import javax . management . ObjectName ; import javax . management . modelmbean . InvalidTargetObjectTypeException ; import javax . management . modelmbean . ModelMBeanInfo ; import javax . management . modelmbean . RequiredModelMBean ; import javax . management . remote . JMXConnectorServer ; import javax . management . remote . JMXConnectorServerFactory ; import javax . management . remote . JMXServiceURL ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jmx . export . annotation . AnnotationJmxAttributeSource ; import org . springframework . jmx . export . assembler . MetadataMBeanInfoAssembler ; public class InstrumentationAgentImpl extends ServiceSupport implements InstrumentationAgent , CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( InstrumentationAgentImpl . class ) ; public static final String SYSTEM_PROPERTY_JMX = "org.apache.camel.jmx" ; public static final String DEFAULT_DOMAIN = "org.apache.camel" ; public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 1099 ; private MBeanServer server ; private CamelContext context ; private Set < ObjectName > mbeans = new HashSet < ObjectName > ( ) ; private MetadataMBeanInfoAssembler assembler ; private JMXConnectorServer cs ; private boolean jmxEnabled = false ; private String jmxDomainName = null ; private int jmxConnectorPort = 0 ; private CamelNamingStrategy namingStrategy ; public InstrumentationAgentImpl ( ) { assembler = new MetadataMBeanInfoAssembler ( ) ; assembler . setAttributeSource ( new AnnotationJmxAttributeSource ( ) ) ; namingStrategy = new CamelNamingStrategy ( ) ; } public CamelContext getCamelContext ( ) { return context ; } public void setCamelContext ( CamelContext camelContext ) { context = camelContext ; } public void setMBeanServer ( MBeanServer server ) { this . server = server ; jmxEnabled = true ; } public MBeanServer getMBeanServer ( ) { if ( server == null ) { server = ManagementFactory . getPlatformMBeanServer ( ) ; } return server ; } public void register ( Object obj , ObjectName name ) throws JMException { register ( obj , name , false ) ; } public void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { try { registerMBeanWithServer ( obj , name , forceRegistration ) ; } catch ( NotCompliantMBeanException e ) { ModelMBeanInfo mbi = null ; mbi = assembler . getMBeanInfo ( obj , name . toString ( ) ) ; RequiredModelMBean mbean = ( RequiredModelMBean ) server . instantiate ( RequiredModelMBean . class . getName ( ) ) ; mbean . setModelMBeanInfo ( mbi ) ; try { mbean . setManagedResource ( obj , "ObjectReference" ) ; } catch ( InvalidTargetObjectTypeException itotex ) { throw new JMException ( itotex . getMessage ( ) ) ; } registerMBeanWithServer ( mbean , name , forceRegistration ) ; } } public void unregister ( ObjectName name ) throws JMException { server . unregisterMBean ( name ) ; } public CamelNamingStrategy getNamingStrategy ( ) { return namingStrategy ; } public void setNamingStrategy ( CamelNamingStrategy namingStrategy ) { this . namingStrategy = namingStrategy ; } protected void doStart ( ) throws Exception { ObjectHelper . notNull ( context , "camelContext" ) ; if ( getMBeanServer ( ) == null ) { createMBeanServer ( ) ; } if ( jmxDomainName == null ) { jmxDomainName = System . getProperty ( SYSTEM_PROPERTY_JMX + ".domain" ) ; if ( jmxDomainName == null || jmxDomainName . length ( ) == 0 ) { jmxDomainName = DEFAULT_DOMAIN ; } } configureDomainName ( ) ; LOG . debug ( "Starting JMX agent on server: " + getMBeanServer ( ) ) ; if ( context instanceof DefaultCamelContext ) { DefaultCamelContext dc = ( DefaultCamelContext ) context ; InstrumentationLifecycleStrategy ls = new InstrumentationLifecycleStrategy ( this ) ; dc . setLifecycleStrategy ( ls ) ; ls . onContextCreate ( context ) ; } } protected void doStop ( ) throws Exception { Object [ ] mBeans = mbeans . toArray ( ) ; int caught = 0 ; for ( Object name : mBeans ) { mbeans . remove ( ( ObjectName ) name ) ; try { unregister ( ( ObjectName ) name ) ; } catch ( JMException jmex ) { LOG . info ( "Exception unregistering MBean" , jmex ) ; caught ++ ; } } if ( caught > 0 ) { LOG . warn ( "A number of " + caught + " exceptions caught while unregistering MBeans during stop operation.  " + "See INFO log for details." ) ; } } private void registerMBeanWithServer ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { ObjectInstance instance = null ; try { instance = server . registerMBean ( obj , name ) ; } catch ( InstanceAlreadyExistsException e ) { if ( forceRegistration ) { server . unregisterMBean ( name ) ; instance = server . registerMBean ( obj , name ) ; } else { throw e ; } } if ( instance != null ) { mbeans . add ( name ) ; } } public void enableJmx ( String domainName , int port ) { jmxEnabled = true ; jmxDomainName = domainName ; configureDomainName ( ) ; jmxConnectorPort = port ; } protected void configureDomainName ( ) { if ( jmxDomainName != null ) { namingStrategy . setDomainName ( jmxDomainName ) ; } } protected void createMBeanServer ( ) { String hostName = DEFAULT_HOST ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { if ( ! jmxEnabled ) { jmxEnabled = null != System . getProperty ( SYSTEM_PROPERTY_JMX ) ; if ( ! jmxEnabled ) { return ; } } if ( jmxConnectorPort <= 0 ) { String portKey = SYSTEM_PROPERTY_JMX + ".port" ; String portValue = System . getProperty ( portKey ) ; if ( portValue != null && portValue . length ( ) > 0 ) { try { jmxConnectorPort = Integer . parseInt ( portValue ) ; } catch ( NumberFormatException nfe ) { LOG . info ( "Invalid port number specified via System property [" + portKey + "=" + portValue + "].  Using default: " + DEFAULT_PORT ) ; jmxConnectorPort = DEFAULT_PORT ; } } } try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException uhe ) { LOG . info ( "Cannot determine host name.  Using default: " + DEFAULT_PORT , uhe ) ; hostName = DEFAULT_HOST ; } } else { jmxDomainName = jmxDomainName != null ? jmxDomainName : DEFAULT_DOMAIN ; jmxConnectorPort = jmxConnectorPort > 0 ? jmxConnectorPort : DEFAULT_PORT ; hostName = DEFAULT_HOST ; } if ( ! jmxEnabled ) { return ; } List servers = MBeanServerFactory . findMBeanServer ( jmxDomainName ) ; if ( servers . size ( ) == 0 ) { server = MBeanServerFactory . createMBeanServer ( jmxDomainName ) ; } else { server = ( MBeanServer ) servers . get ( 0 ) ; } try { createJmxConnector ( hostName ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not create and start jmx connector." , ioe ) ; } } protected void createJmxConnector ( String host ) throws IOException { if ( jmxConnectorPort > 0 ) { try { LocateRegistry . createRegistry ( jmxConnectorPort ) ; } catch ( RemoteException ex ) { LocateRegistry . getRegistry ( jmxConnectorPort ) ; } JMXServiceURL url = new JMXServiceURL ( "service:jmx:rmi:///jndi/rmi://" + host + ":" + jmxConnectorPort + "/jmxrmi" ) ; cs = JMXConnectorServerFactory . newJMXConnectorServer ( url , null , server ) ; Thread connectorThread = new Thread ( ) { public void run ( ) { try { cs . start ( ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not start jmx connector thread." , ioe ) ; } } } ; connectorThread . setName ( "JMX Connector Thread [" + url + "]" ) ; connectorThread . start ( ) ; LOG . info ( "Jmx connector thread started on " + url ) ; } } } 	1	['20', '2', '1', '16', '74', '68', '2', '15', '11', '0.864661654', '537', '0.714285714', '3', '0.419354839', '0.173684211', '1', '1', '25.15', '12', '1.55', '4']
package org . apache . camel . processor . resequencer ; import java . util . LinkedList ; import java . util . List ; import java . util . Timer ; import java . util . TimerTask ; public class Timeout extends TimerTask { private List < TimeoutHandler > timeoutHandlers ; private Timer timer ; private long timeout ; public Timeout ( Timer timer , long timeout ) { this . timeoutHandlers = new LinkedList < TimeoutHandler > ( ) ; this . timeout = timeout ; this . timer = timer ; } public List < TimeoutHandler > getTimeoutHandlers ( ) { return timeoutHandlers ; } public void addTimeoutHandler ( TimeoutHandler handler ) { timeoutHandlers . add ( handler ) ; } public void addTimeoutHandlerFirst ( TimeoutHandler handler ) { timeoutHandlers . add ( 0 , handler ) ; } public void clearTimeoutHandlers ( ) { this . timeoutHandlers . clear ( ) ; } public void schedule ( ) { timer . schedule ( this , timeout ) ; } @ Override public void run ( ) { for ( TimeoutHandler observer : timeoutHandlers ) { observer . timeout ( this ) ; } } } 	0	['7', '2', '0', '3', '17', '0', '3', '1', '7', '0.611111111', '66', '1', '0', '0.333333333', '0.392857143', '0', '0', '8', '2', '1', '0']
package org . apache . camel ; public class CamelExchangeException extends CamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final Exchange exchange ; public CamelExchangeException ( String message , Exchange exchange ) { super ( message + " on the exchange: " + exchange ) ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } } 	1	['2', '4', '6', '8', '7', '0', '6', '2', '2', '1', '23', '1', '1', '0.944444444', '0.666666667', '0', '0', '9.5', '1', '0.5', '1']
package org . apache . camel . component . file . remote ; import java . io . IOException ; import java . io . InputStream ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . commons . net . ftp . FTPClient ; public class FtpProducer extends RemoteFileProducer < RemoteFileExchange > { FtpEndpoint endpoint ; private final FTPClient client ; public FtpProducer ( FtpEndpoint endpoint , FTPClient client ) { super ( endpoint ) ; this . endpoint = endpoint ; this . client = client ; } public void process ( Exchange exchange ) throws Exception { process ( endpoint . createExchange ( exchange ) ) ; } public void process ( RemoteFileExchange exchange ) throws Exception { InputStream payload = exchange . getIn ( ) . getBody ( InputStream . class ) ; final String endpointFile = endpoint . getConfiguration ( ) . getFile ( ) ; client . changeWorkingDirectory ( endpointFile ) ; String fileName = createFileName ( exchange . getIn ( ) , endpoint . getConfiguration ( ) ) ; buildDirectory ( client , fileName . substring ( 0 , fileName . lastIndexOf ( '/' ) ) ) ; final boolean success = client . storeFile ( fileName , payload ) ; if ( ! success ) { throw new RuntimeCamelException ( "error sending file" ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { client . disconnect ( ) ; super . doStop ( ) ; } protected static boolean buildDirectory ( FTPClient ftpClient , String dirName ) throws IOException { boolean atLeastOneSuccess = false ; final StringBuilder sb = new StringBuilder ( dirName . length ( ) ) ; final String [ ] dirs = dirName . split ( "\\/" ) ; for ( String dir : dirs ) { sb . append ( '/' ) . append ( dir ) ; final boolean success = ftpClient . makeDirectory ( sb . toString ( ) ) ; System . out . println ( sb . toString ( ) + " = " + success ) ; if ( ! atLeastOneSuccess && success ) { atLeastOneSuccess = true ; } } return atLeastOneSuccess ; } } 	0	['6', '4', '0', '9', '31', '5', '1', '9', '3', '0.5', '143', '0.5', '1', '0.8', '0.305555556', '1', '1', '22.5', '1', '0.8333', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlRootElement ( name = "when" ) public class WhenType < Type extends ProcessorType > extends ExpressionNode { public WhenType ( ) { } public WhenType ( Predicate predicate ) { super ( predicate ) ; } public WhenType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "When[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1	['6', '3', '0', '8', '15', '15', '2', '6', '6', '2', '42', '0', '0', '0.971428571', '0.416666667', '2', '3', '6', '1', '0.5', '2']
package org . apache . camel . component . mail ; import javax . mail . MessagingException ; public class MessageHeaderAccessException extends RuntimeMailException { private static final long serialVersionUID = - 3996286386119163309L ; private final String propertyName ; public MessageHeaderAccessException ( String propertyName , MessagingException e ) { super ( "Error accessing header: " + propertyName , e ) ; this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0	['2', '5', '0', '2', '6', '0', '1', '1', '2', '1', '22', '1', '0', '0.944444444', '0.666666667', '0', '0', '9', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Throttler ; @ XmlRootElement ( name = "throttler" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThrottlerType extends ProcessorType { @ XmlAttribute private Long maximumRequestsPerPeriod ; @ XmlAttribute private long timePeriodMillis = 1000 ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; public ThrottlerType ( ) { } public ThrottlerType ( long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } @ Override public String toString ( ) { return "Throttler[" + getMaximumRequestsPerPeriod ( ) + " request per " + getTimePeriodMillis ( ) + " millis -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return "" + getMaximumRequestsPerPeriod ( ) + " per " + getTimePeriodMillis ( ) + " (ms)" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new Throttler ( childProcessor , maximumRequestsPerPeriod , timePeriodMillis ) ; } public ThrottlerType timePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; return this ; } public Long getMaximumRequestsPerPeriod ( ) { return maximumRequestsPerPeriod ; } public void setMaximumRequestsPerPeriod ( Long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } public long getTimePeriodMillis ( ) { return timePeriodMillis ; } public void setTimePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType > outputs ) { this . outputs = outputs ; } } 	1	['14', '2', '0', '4', '25', '31', '1', '4', '14', '0.634615385', '140', '1', '0', '0.885714286', '0.3', '1', '4', '8.714285714', '1', '0.8571', '3']
package org . apache . camel . component . jms ; import javax . jms . Message ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; public class JmsEndpoint extends DefaultEndpoint < JmsExchange > { private JmsBinding binding ; private String destination ; private final boolean pubSubDomain ; private String selector ; private JmsConfiguration configuration ; public JmsEndpoint ( String uri , JmsComponent component , String destination , boolean pubSubDomain , JmsConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; this . destination = destination ; this . pubSubDomain = pubSubDomain ; } public JmsProducer createProducer ( ) throws Exception { JmsOperations template = createJmsOperations ( ) ; return createProducer ( template ) ; } public JmsProducer createProducer ( JmsOperations template ) throws Exception { if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setPubSubDomain ( pubSubDomain ) ; jmsTemplate . setDefaultDestinationName ( destination ) ; } return new JmsProducer ( this , template ) ; } public JmsConsumer createConsumer ( Processor processor ) throws Exception { AbstractMessageListenerContainer listenerContainer = configuration . createMessageListenerContainer ( ) ; return createConsumer ( processor , listenerContainer ) ; } public JmsConsumer createConsumer ( Processor processor , AbstractMessageListenerContainer listenerContainer ) throws Exception { listenerContainer . setDestinationName ( destination ) ; listenerContainer . setPubSubDomain ( pubSubDomain ) ; if ( selector != null ) { listenerContainer . setMessageSelector ( selector ) ; } return new JmsConsumer ( this , processor , listenerContainer ) ; } @ Override public PollingConsumer < JmsExchange > createPollingConsumer ( ) throws Exception { JmsOperations template = createJmsOperations ( ) ; return new JmsPollingConsumer ( this , template ) ; } @ Override public JmsExchange createExchange ( ExchangePattern pattern ) { return new JmsExchange ( getContext ( ) , pattern , getBinding ( ) ) ; } public JmsExchange createExchange ( Message message ) { return new JmsExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , message ) ; } public JmsBinding getBinding ( ) { if ( binding == null ) { binding = new JmsBinding ( ) ; } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public String getDestination ( ) { return destination ; } public JmsConfiguration getConfiguration ( ) { return configuration ; } public String getSelector ( ) { return selector ; } public void setSelector ( String selector ) { this . selector = selector ; } public boolean isSingleton ( ) { return false ; } protected JmsOperations createJmsOperations ( ) { return configuration . createJmsOperations ( pubSubDomain , destination ) ; } } 	0	['19', '2', '0', '22', '32', '133', '7', '19', '18', '0.644444444', '174', '1', '2', '0.485714286', '0.157894737', '1', '1', '7.894736842', '2', '1', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . getProcessor ( ) . process ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	1	['7', '2', '0', '7', '25', '0', '1', '6', '5', '0.166666667', '153', '1', '1', '0.684210526', '0.357142857', '1', '1', '20.57142857', '4', '1.2857', '2']
package org . apache . camel . component . cxf . phase ; import java . util . List ; import java . util . SortedSet ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . phase . PhaseManager ; public abstract class AbstractPhaseManagerImpl implements PhaseManager { private SortedSet < Phase > inPhases ; private SortedSet < Phase > outPhases ; public AbstractPhaseManagerImpl ( ) { inPhases = createInPhases ( ) ; outPhases = createOutPhases ( ) ; } public SortedSet < Phase > getInPhases ( ) { return inPhases ; } public SortedSet < Phase > getOutPhases ( ) { return outPhases ; } protected abstract SortedSet < Phase > createInPhases ( ) ; protected abstract SortedSet < Phase > createOutPhases ( ) ; } 	0	['5', '1', '3', '4', '6', '6', '3', '1', '3', '0.75', '24', '1', '0', '0', '1', '0', '0', '3.4', '1', '0.8', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class TopicLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; for ( Processor processor : list ) { Exchange copy = copyExchangeStrategy ( processor , exchange ) ; processor . process ( copy ) ; } } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	1	['3', '2', '0', '4', '10', '3', '1', '3', '2', '2', '32', '0', '0', '0.6', '0.666666667', '0', '0', '9.666666667', '1', '0.6667', '2']
package org . apache . camel . util ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . converter . AnnotationTypeConverterLoader ; import org . apache . camel . impl . converter . TypeConverterRegistry ; public class ReportingTypeConverterLoader extends AnnotationTypeConverterLoader { private List < TypeMapping > typeMappings = new ArrayList < TypeMapping > ( ) ; private static final Comparator < TypeMapping > COMPARE_LAST_LOADED_FIRST = new Comparator < TypeMapping > ( ) { public int compare ( TypeMapping t1 , TypeMapping t2 ) { if ( ObjectHelper . equals ( t1 . fromType , t2 . fromType ) ) { return ObjectHelper . equals ( t1 . toType , t2 . toType ) ? t1 . index - t2 . index : ObjectHelper . compare ( getTypeName ( t1 . toType ) , getTypeName ( t2 . toType ) ) ; } return ObjectHelper . compare ( getTypeName ( t1 . fromType ) , getTypeName ( t2 . fromType ) ) ; } } ; public TypeMapping [ ] getTypeConversions ( ) { Collections . sort ( typeMappings , COMPARE_LAST_LOADED_FIRST ) ; return typeMappings . toArray ( new TypeMapping [ typeMappings . size ( ) ] ) ; } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { TypeMapping mapping = new TypeMapping ( toType , fromType , typeConverter . getClass ( ) , method ) ; typeMappings . add ( mapping ) ; } static private String getTypeName ( Class type ) { return type != null ? type . getName ( ) : null ; } public static class TypeMapping { private static int counter = 0 ; Class toType ; Class fromType ; Class converterType ; Method method ; int index = 0 ; public TypeMapping ( Class toType , Class fromType , Class converterType , Method method ) { this . toType = toType ; this . fromType = fromType ; this . converterType = converterType ; this . method = method ; this . index = counter ++ ; } public Class getFromType ( ) { return fromType ; } public Class getToType ( ) { return toType ; } public Class getConverterType ( ) { return converterType ; } public Method getMethod ( ) { return method ; } public int getIndex ( ) { return index ; } @ Override public boolean equals ( Object object ) { if ( object instanceof TypeMapping ) { TypeMapping that = ( TypeMapping ) object ; return this . index == that . index ; } return false ; } @ Override public int hashCode ( ) { int answer = toType . hashCode ( ) ; if ( fromType != null ) { answer *= 37 + fromType . hashCode ( ) ; } return answer ; } @ Override public String toString ( ) { return "[" + fromType . getSimpleName ( ) + "=>" + toType . getSimpleName ( ) + "]" ; } } } 	0	['6', '2', '0', '5', '16', '7', '1', '5', '2', '0.7', '59', '1', '0', '0.6', '0.36', '1', '1', '8.5', '2', '0.8333', '0']
package org . apache . camel . language . simple ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . language . IllegalSyntaxException ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class SimpleLanguage implements Language { public static Expression simple ( String expression ) { SimpleLanguage language = new SimpleLanguage ( ) ; return language . createExpression ( expression ) ; } public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { if ( expression . indexOf ( "${" ) >= 0 ) { return createComplexExpression ( expression ) ; } return createSimpleExpression ( expression ) ; } protected Expression < Exchange > createComplexExpression ( String expression ) { List < Expression > results = new ArrayList < Expression > ( ) ; int pivot = 0 ; int size = expression . length ( ) ; while ( pivot < size ) { int idx = expression . indexOf ( "${" , pivot ) ; if ( idx < 0 ) { results . add ( createConstantExpression ( expression , pivot , size ) ) ; break ; } else { if ( pivot < idx ) { results . add ( createConstantExpression ( expression , pivot , idx ) ) ; } pivot = idx + 2 ; int endIdx = expression . indexOf ( "}" , pivot ) ; if ( endIdx < 0 ) { throw new IllegalArgumentException ( "Expecting } but found end of string for simple expression: " + expression ) ; } String simpleText = expression . substring ( pivot , endIdx ) ; Expression simpleExpression = createSimpleExpression ( simpleText ) ; results . add ( simpleExpression ) ; pivot = endIdx + 1 ; } } return ExpressionBuilder . concatExpression ( results , expression ) ; } protected Expression createConstantExpression ( String expression , int start , int end ) { return ExpressionBuilder . constantExpression ( expression . substring ( start , end ) ) ; } protected Expression < Exchange > createSimpleExpression ( String expression ) { if ( ObjectHelper . isEqualToAny ( expression , "body" , "in.body" ) ) { return ExpressionBuilder . bodyExpression ( ) ; } else if ( ObjectHelper . equals ( expression , "out.body" ) ) { return ExpressionBuilder . outBodyExpression ( ) ; } String remainder = ifStartsWithReturnRemainder ( "in.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "header." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "headers." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "in.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . headerExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "out.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "out.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . outHeaderExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "property." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "sys." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } throw new IllegalSyntaxException ( this , expression ) ; } protected String ifStartsWithReturnRemainder ( String prefix , String text ) { if ( text . startsWith ( prefix ) ) { String remainder = text . substring ( prefix . length ( ) ) ; if ( remainder . length ( ) > 0 ) { return remainder ; } } return null ; } } 	1	['8', '1', '0', '7', '32', '28', '0', '7', '4', '2', '237', '0', '0', '0', '0.625', '0', '0', '28.625', '11', '3', '2']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "ruby" ) public class RubyExpression extends ExpressionType { public RubyExpression ( ) { } public RubyExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "ruby" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . util . ObjectHelper ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; public abstract class DefaultEndpoint < E extends Exchange > implements Endpoint < E > { private String endpointUri ; private CamelContext context ; private Component component ; private ScheduledExecutorService executorService ; private ExchangePattern exchangePattern = ExchangePattern . InOnly ; protected DefaultEndpoint ( String endpointUri , Component component ) { this ( endpointUri , component . getCamelContext ( ) ) ; this . component = component ; } protected DefaultEndpoint ( String endpointUri , CamelContext context ) { this . endpointUri = endpointUri ; this . context = context ; } public int hashCode ( ) { return endpointUri . hashCode ( ) * 37 + 1 ; } @ Override public boolean equals ( Object object ) { if ( object instanceof DefaultEndpoint ) { DefaultEndpoint that = ( DefaultEndpoint ) object ; return ObjectHelper . equals ( this . endpointUri , that . endpointUri ) ; } return false ; } @ Override public String toString ( ) { return "Endpoint[" + endpointUri + "]" ; } public String getEndpointUri ( ) { return endpointUri ; } public CamelContext getContext ( ) { return context ; } public Component getComponent ( ) { return component ; } public synchronized ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { Component c = getComponent ( ) ; if ( c != null && c instanceof DefaultComponent ) { DefaultComponent dc = ( DefaultComponent ) c ; executorService = dc . getExecutorService ( ) ; } if ( executorService == null ) { executorService = createExecutorService ( ) ; } } return executorService ; } public synchronized void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } public PollingConsumer < E > createPollingConsumer ( ) throws Exception { return new EventDrivenPollingConsumer < E > ( this ) ; } public E convertTo ( Class < E > type , Exchange exchange ) { if ( type . isInstance ( exchange ) ) { return type . cast ( exchange ) ; } return getContext ( ) . getExchangeConverter ( ) . convertTo ( type , exchange ) ; } public E createExchange ( Exchange exchange ) { Class < E > exchangeType = getExchangeType ( ) ; if ( exchangeType != null ) { if ( exchangeType . isInstance ( exchange ) ) { return exchangeType . cast ( exchange ) ; } } E answer = createExchange ( ) ; answer . copyFrom ( exchange ) ; return answer ; } public Class < E > getExchangeType ( ) { Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { return ( Class < E > ) argumentType ; } } } return null ; } public E createExchange ( ) { return createExchange ( getExchangePattern ( ) ) ; } public E createExchange ( ExchangePattern pattern ) { return ( E ) new DefaultExchange ( getContext ( ) , pattern ) ; } public ExchangePattern getExchangePattern ( ) { return exchangePattern ; } public void setExchangePattern ( ExchangePattern exchangePattern ) { this . exchangePattern = exchangePattern ; } protected ScheduledThreadPoolExecutor createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( 10 ) ; } } 	1	['19', '1', '15', '32', '38', '139', '21', '11', '16', '0.822222222', '216', '1', '3', '0', '0.175438596', '1', '1', '10.10526316', '5', '1.4737', '4']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface Converter { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . impl ; import java . util . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Route ; import org . apache . camel . Service ; public class DefaultLifecycleStrategy implements LifecycleStrategy { public void onContextCreate ( CamelContext context ) { } public void onEndpointAdd ( Endpoint endpoint ) { } public void onServiceAdd ( CamelContext context , Service service ) { } public void onRoutesAdd ( Collection < Route > routes ) { } public void beforeStartRouteType ( CamelContext context , RouteType routeType ) { } } 	1	['6', '1', '0', '6', '7', '15', '1', '5', '6', '2', '14', '0', '0', '0', '0.361111111', '0', '0', '1.333333333', '1', '0.8333', '4']
package org . apache . camel . processor . validation ; import java . io . File ; import java . io . IOException ; import java . net . URL ; import javax . xml . XMLConstants ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . validation . Schema ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import org . xml . sax . SAXException ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class ValidatingProcessor implements Processor { private Schema schema ; private ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler ( ) ; private String schemaLanguage = XMLConstants . W3C_XML_SCHEMA_NS_URI ; private Source schemaSource ; private SchemaFactory schemaFactory ; private URL schemaUrl ; private File schemaFile ; public void process ( Exchange exchange ) throws Exception { Schema schema = getSchema ( ) ; Validator validator = schema . newValidator ( ) ; Source source = exchange . getIn ( ) . getBody ( DOMSource . class ) ; if ( source == null ) { throw new NoXmlBodyValidationException ( exchange ) ; } errorHandler . reset ( ) ; validator . setErrorHandler ( errorHandler ) ; DOMResult result = new DOMResult ( ) ; validator . validate ( source , result ) ; errorHandler . handleErrors ( exchange , schema , result ) ; } public Schema getSchema ( ) throws IOException , SAXException { if ( schema == null ) { schema = createSchema ( ) ; } return schema ; } public void setSchema ( Schema schema ) { this . schema = schema ; } public String getSchemaLanguage ( ) { return schemaLanguage ; } public void setSchemaLanguage ( String schemaLanguage ) { this . schemaLanguage = schemaLanguage ; } public Source getSchemaSource ( ) throws IOException { if ( schemaSource == null ) { schemaSource = createSchemaSource ( ) ; } return schemaSource ; } public void setSchemaSource ( Source schemaSource ) { this . schemaSource = schemaSource ; } public URL getSchemaUrl ( ) { return schemaUrl ; } public void setSchemaUrl ( URL schemaUrl ) { this . schemaUrl = schemaUrl ; } public File getSchemaFile ( ) { return schemaFile ; } public void setSchemaFile ( File schemaFile ) { this . schemaFile = schemaFile ; } public SchemaFactory getSchemaFactory ( ) { if ( schemaFactory == null ) { schemaFactory = createSchemaFactory ( ) ; } return schemaFactory ; } public void setSchemaFactory ( SchemaFactory schemaFactory ) { this . schemaFactory = schemaFactory ; } public ValidatorErrorHandler getErrorHandler ( ) { return errorHandler ; } public void setErrorHandler ( ValidatorErrorHandler errorHandler ) { this . errorHandler = errorHandler ; } protected SchemaFactory createSchemaFactory ( ) { return SchemaFactory . newInstance ( schemaLanguage ) ; } protected Source createSchemaSource ( ) throws IOException { throw new IllegalArgumentException ( "You must specify a schema, " + "schemaFile, schemaSource or schemaUrl property" ) ; } protected Schema createSchema ( ) throws SAXException , IOException { SchemaFactory factory = getSchemaFactory ( ) ; URL url = getSchemaUrl ( ) ; if ( url != null ) { return factory . newSchema ( url ) ; } File file = getSchemaFile ( ) ; if ( file != null ) { return factory . newSchema ( file ) ; } return factory . newSchema ( getSchemaSource ( ) ) ; } } 	0	['19', '1', '1', '7', '35', '137', '1', '6', '16', '0.857142857', '183', '1', '1', '0', '0.157894737', '0', '0', '8.263157895', '2', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . impl . converter . TypeConverterRegistry ; public class CachingInjector < T > { private final TypeConverterRegistry repository ; private final Class < T > type ; private T instance ; public CachingInjector ( TypeConverterRegistry repository , Class < T > type ) { this . repository = repository ; this . type = type ; } public synchronized T newInstance ( ) { if ( instance == null ) { instance = createInstance ( type ) ; } return instance ; } protected T createInstance ( Class < T > t ) { return ( T ) repository . getInjector ( ) . newInstance ( t ) ; } } 	1	['3', '1', '0', '4', '6', '0', '2', '2', '2', '0.5', '33', '1', '1', '0', '0.666666667', '0', '0', '9', '2', '1', '1']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Headers { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . processor . resequencer ; import java . util . Queue ; import java . util . Timer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ResequencerEngine < E > implements TimeoutHandler { private static final Log LOG = LogFactory . getLog ( ResequencerEngine . class ) ; private long timeout ; private int capacity ; private Queue < E > outQueue ; private Element < E > lastDelivered ; private Sequence < Element < E > > sequence ; private Timer timer ; public ResequencerEngine ( SequenceElementComparator < E > comparator ) { this ( comparator , Integer . MAX_VALUE ) ; } public ResequencerEngine ( SequenceElementComparator < E > comparator , int capacity ) { this . timer = new Timer ( "Resequencer Timer" ) ; this . sequence = createSequence ( comparator ) ; this . capacity = capacity ; this . timeout = 2000L ; this . lastDelivered = null ; } public void stop ( ) { this . timer . cancel ( ) ; } public Queue < E > getOutQueue ( ) { return outQueue ; } public void setOutQueue ( Queue < E > outQueue ) { this . outQueue = outQueue ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public synchronized void timeout ( Timeout timout ) { try { while ( deliver ( ) ) { } } catch ( RuntimeException e ) { LOG . error ( "error during delivery" , e ) ; } } public synchronized void add ( E o ) { if ( sequence . size ( ) >= capacity ) { throw new IllegalStateException ( "maximum capacity is reached" ) ; } insert ( o ) ; } public synchronized void put ( E o ) throws InterruptedException { if ( sequence . size ( ) >= capacity ) { wait ( ) ; } insert ( o ) ; } E getLastDelivered ( ) { if ( lastDelivered == null ) { return null ; } return lastDelivered . getObject ( ) ; } void setLastDelivered ( E o ) { lastDelivered = new Element < E > ( o ) ; } private void insert ( E o ) { Element < E > element = new Element < E > ( o ) ; sequence . add ( element ) ; Element < E > successor = sequence . successor ( element ) ; if ( successor != null ) { successor . cancel ( ) ; } if ( successorOfLastDelivered ( element ) ) { } else if ( sequence . predecessor ( element ) != null ) { } else { Timeout t = defineTimeout ( ) ; element . schedule ( t ) ; } while ( deliver ( ) ) { } } private boolean deliver ( ) { if ( sequence . size ( ) == 0 ) { return false ; } Element < E > element = sequence . first ( ) ; if ( element . scheduled ( ) ) { return false ; } sequence . remove ( element ) ; lastDelivered = element ; notify ( ) ; outQueue . add ( element . getObject ( ) ) ; return true ; } private boolean successorOfLastDelivered ( Element < E > element ) { if ( lastDelivered == null ) { return false ; } if ( sequence . comparator ( ) . successor ( element , lastDelivered ) ) { return true ; } return false ; } private Timeout defineTimeout ( ) { Timeout result = new Timeout ( timer , timeout ) ; result . addTimeoutHandler ( this ) ; return result ; } private static < E > Sequence < Element < E > > createSequence ( SequenceElementComparator < E > comparator ) { return new Sequence < Element < E > > ( new ElementComparator < E > ( comparator ) ) ; } } 	1	['18', '1', '0', '9', '44', '85', '1', '8', '10', '0.739495798', '242', '1', '3', '0', '0.205882353', '0', '0', '12.05555556', '5', '1.3889', '1']
package org . apache . camel . component . irc ; public class IrcBinding { public Object extractBodyFromIrc ( IrcExchange exchange , IrcMessage message ) { String type = message . getMessageType ( ) ; String text = message . getMessage ( ) ; if ( text != null ) { return text ; } else { return type ; } } } 	0	['2', '1', '0', '3', '5', '1', '3', '2', '2', '2', '17', '0', '0', '0', '0.666666667', '0', '0', '7.5', '2', '1', '0']
package org . apache . camel ; public class RuntimeCamelException extends RuntimeException { private static final long serialVersionUID = 8046489554418284257L ; public RuntimeCamelException ( ) { } public RuntimeCamelException ( String message ) { super ( message ) ; } public RuntimeCamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeCamelException ( Throwable cause ) { super ( cause ) ; } } 	1	['4', '4', '15', '49', '8', '6', '49', '0', '4', '1.333333333', '21', '1', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '1']
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . ProcessRules ; public class ProcessContext { private Exchange exchange ; private ProcessRules processRules ; private ActivityRules activityRules ; private ProcessInstance processInstance ; private ActivityState activityState ; public ProcessContext ( Exchange exchange , ActivityRules activityRules , ActivityState activityState ) { this . exchange = exchange ; this . activityRules = activityRules ; this . activityState = activityState ; this . processRules = activityRules . getProcessRules ( ) ; this . processInstance = activityState . getProcessInstance ( ) ; } public ActivityRules getActivity ( ) { return activityRules ; } public void setActivity ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public ActivityState getActivityState ( ) { return activityState ; } public void setActivityState ( ActivityState activityState ) { this . activityState = activityState ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public ProcessRules getProcessDefinition ( ) { return processRules ; } public void setProcessDefinition ( ProcessRules processRules ) { this . processRules = processRules ; } public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; } public ActivityState getActivityState ( ActivityRules activityRules ) { return getProcessInstance ( ) . getActivityState ( activityRules ) ; } public void onStarted ( ActivityState activityState ) { } public void onCompleted ( ActivityState activityState ) { } } 	0	['14', '1', '0', '6', '18', '61', '2', '5', '14', '0.830769231', '81', '1', '5', '0', '0.297619048', '0', '0', '4.428571429', '1', '0.9286', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import org . apache . camel . TypeConverter ; public class ArrayTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isArray ( ) ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; Object array = Array . newInstance ( type . getComponentType ( ) , collection . size ( ) ) ; if ( array instanceof Object [ ] ) { collection . toArray ( ( Object [ ] ) array ) ; } else { int index = 0 ; for ( Object element : collection ) { Array . set ( array , index ++ , element ) ; } } return ( T ) array ; } else if ( value != null && value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; Object answer = Array . newInstance ( type . getComponentType ( ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( answer , i , Array . get ( value , i ) ) ; } return ( T ) answer ; } } else if ( Collection . class . isAssignableFrom ( type ) ) { if ( value != null ) { if ( value instanceof Object [ ] ) { return ( T ) Arrays . asList ( ( Object [ ] ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; List answer = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { answer . add ( Array . get ( value , i ) ) ; } return ( T ) answer ; } } } return null ; } } 	1	['2', '1', '0', '2', '19', '1', '1', '1', '2', '2', '121', '0', '0', '0', '0.666666667', '0', '0', '59.5', '13', '6.5', '1']
package org . apache . camel . processor . resequencer ; class Element < E > implements TimeoutHandler { private E object ; private Timeout timeout ; public Element ( E object ) { this . object = object ; } public E getObject ( ) { return object ; } public synchronized boolean scheduled ( ) { return timeout != null ; } public synchronized void schedule ( Timeout t ) { this . timeout = t ; this . timeout . addTimeoutHandlerFirst ( this ) ; this . timeout . schedule ( ) ; } public synchronized void cancel ( ) { if ( timeout != null ) { timeout . cancel ( ) ; } timeout ( null ) ; } public synchronized void timeout ( Timeout t ) { this . timeout = null ; } } 	0	['6', '1', '0', '4', '10', '1', '2', '2', '6', '0.6', '50', '1', '1', '0', '0.5', '0', '0', '7', '2', '1.1667', '0']
package org . apache . camel . component . direct ; import java . util . ArrayList ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DirectEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private final class DirectProducer extends DefaultProducer implements AsyncProcessor { private DirectProducer ( Endpoint endpoint ) { super ( endpoint ) ; } public void process ( Exchange exchange ) throws Exception { if ( consumers . isEmpty ( ) ) { LOG . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } } public boolean process ( Exchange exchange , AsyncCallback callback ) { int size = consumers . size ( ) ; if ( size == 0 ) { LOG . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { if ( size > 1 ) { try { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } catch ( Throwable error ) { exchange . setException ( error ) ; } } else { for ( DefaultConsumer < E > consumer : consumers ) { AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( consumer . getProcessor ( ) ) ; return processor . process ( exchange , callback ) ; } } } callback . done ( true ) ; return true ; } } private static final Log LOG = LogFactory . getLog ( DirectEndpoint . class ) ; boolean allowMultipleConsumers = true ; private final CopyOnWriteArrayList < DefaultConsumer < E > > consumers = new CopyOnWriteArrayList < DefaultConsumer < E > > ( ) ; public DirectEndpoint ( String uri , DirectComponent < E > component ) { super ( uri , component ) ; } public Producer createProducer ( ) throws Exception { return new DirectProducer ( this ) ; } public Consumer < E > createConsumer ( Processor processor ) throws Exception { return new DefaultConsumer < E > ( this , processor ) { @ Override public void start ( ) throws Exception { if ( ! allowMultipleConsumers && ! consumers . isEmpty ( ) ) { throw new IllegalStateException ( "Endpoint " + getEndpointUri ( ) + " only allows 1 active consumer but you attempted to start a 2nd consumer." ) ; } consumers . add ( this ) ; super . start ( ) ; } @ Override public void stop ( ) throws Exception { super . stop ( ) ; consumers . remove ( this ) ; } } ; } public boolean isAllowMultipleConsumers ( ) { return allowMultipleConsumers ; } public void setAllowMultipleConsumers ( boolean allowMutlipleConsumers ) { this . allowMultipleConsumers = allowMutlipleConsumers ; } public boolean isSingleton ( ) { return true ; } } 	1	['9', '2', '0', '11', '14', '26', '3', '11', '6', '0.833333333', '57', '0.666666667', '1', '0.708333333', '0.229166667', '0', '0', '5', '1', '0.7778', '1']
package org . apache . camel . management ; import java . util . concurrent . atomic . AtomicLong ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "PerformanceCounter" , currencyTimeLimit = 15 ) public class PerformanceCounter extends Counter { private AtomicLong numCompleted = new AtomicLong ( 0L ) ; private long minProcessingTime = - 1L ; private long maxProcessingTime = - 1L ; private double totalProcessingTime = 0 ; @ Override @ ManagedOperation ( description = "Reset counters" ) public synchronized void reset ( ) { super . reset ( ) ; numCompleted . set ( 0L ) ; minProcessingTime = 0L ; maxProcessingTime = 0L ; totalProcessingTime = 0 ; } @ ManagedAttribute ( description = "Number of successful exchanges" ) public long getNumCompleted ( ) throws Exception { return numCompleted . get ( ) ; } @ ManagedAttribute ( description = "Number of failed exchanges" ) public long getNumFailed ( ) throws Exception { return numExchanges . get ( ) - numCompleted . get ( ) ; } @ ManagedAttribute ( description = "Min Processing Time [usec]" ) public synchronized long getMinProcessingTime ( ) throws Exception { return minProcessingTime ; } @ ManagedAttribute ( description = "Mean Processing Time [usec]" ) public synchronized long getMeanProcessingTime ( ) throws Exception { long count = numCompleted . get ( ) ; return count > 0 ? ( long ) totalProcessingTime / count : 0L ; } @ ManagedAttribute ( description = "Max Processing Time [usec]" ) public synchronized long getMaxProcessingTime ( ) throws Exception { return maxProcessingTime ; } public synchronized void completedExchange ( long time ) { increment ( ) ; numCompleted . incrementAndGet ( ) ; totalProcessingTime += time ; if ( minProcessingTime < 0 || time < minProcessingTime ) { minProcessingTime = time ; } if ( time > maxProcessingTime ) { maxProcessingTime = time ; } } public void completedExchange ( ) { numExchanges . incrementAndGet ( ) ; } } 	0	['9', '2', '0', '4', '16', '0', '3', '1', '9', '0.5625', '122', '1', '0', '0.272727273', '0.555555556', '0', '0', '12.11111111', '4', '1.2222', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class NoErrorHandlerBuilder extends ErrorHandlerBuilderSupport { public ErrorHandlerBuilder copy ( ) { return this ; } public Processor createErrorHandler ( Processor processor ) { return processor ; } } 	1	['3', '2', '0', '5', '4', '3', '2', '3', '3', '2', '10', '0', '0', '0.5', '0.666666667', '0', '0', '2.333333333', '1', '0.6667', '1']
package org . apache . camel . spring . spi ; import org . apache . camel . Processor ; import org . apache . camel . spi . Policy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . support . TransactionTemplate ; public class SpringTransactionPolicy < E > implements Policy < E > { private static final transient Log LOG = LogFactory . getLog ( SpringTransactionPolicy . class ) ; private TransactionTemplate template ; public SpringTransactionPolicy ( TransactionTemplate template ) { this . template = template ; } public Processor wrap ( Processor processor ) { final TransactionTemplate transactionTemplate = getTemplate ( ) ; if ( transactionTemplate == null ) { LOG . warn ( "No TransactionTemplate available so transactions will not be enabled!" ) ; return processor ; } TransactionInterceptor answer = new TransactionInterceptor ( transactionTemplate ) ; answer . setProcessor ( processor ) ; return answer ; } public TransactionTemplate getTemplate ( ) { return template ; } public void setTemplate ( TransactionTemplate template ) { this . template = template ; } } 	0	['5', '1', '0', '6', '10', '2', '0', '6', '4', '0.5', '44', '1', '1', '0', '0.583333333', '0', '0', '7.4', '2', '0.8', '0']
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; public enum ExchangePattern { InOnly , RobustInOnly , InOut , InOptionalOut , OutOnly , RobustOutOnly , OutIn , OutOptionalIn ; protected static final Map < String , ExchangePattern > map = new HashMap < String , ExchangePattern > ( ) ; public String getWsdlUri ( ) { switch ( this ) { case InOnly : return "http://www.w3.org/ns/wsdl/in-only" ; case InOptionalOut : return "http://www.w3.org/ns/wsdl/in-optional-out" ; case InOut : return "http://www.w3.org/ns/wsdl/in-out" ; case OutIn : return "http://www.w3.org/ns/wsdl/out-in" ; case OutOnly : return "http://www.w3.org/ns/wsdl/out-only" ; case OutOptionalIn : return "http://www.w3.org/ns/wsdl/out-optional_in" ; case RobustInOnly : return "http://www.w3.org/ns/wsdl/robust-in-only" ; case RobustOutOnly : return "http://www.w3.org/ns/wsdl/robust-out-only" ; default : throw new IllegalArgumentException ( "Unknown message exchange pattern: " + this ) ; } } public boolean isInCapable ( ) { switch ( this ) { case OutOnly : case RobustOutOnly : return true ; default : return false ; } } public boolean isOutCapable ( ) { switch ( this ) { case InOnly : case RobustInOnly : return false ; default : return true ; } } public boolean isFaultCapable ( ) { switch ( this ) { case InOnly : case OutOnly : return false ; default : return true ; } } public static ExchangePattern fromWsdlUri ( String wsdlUri ) { return map . get ( wsdlUri ) ; } static { for ( ExchangePattern mep : values ( ) ) { String uri = mep . getWsdlUri ( ) ; map . put ( uri , mep ) ; String name = uri . substring ( uri . lastIndexOf ( '/' ) ) ; map . put ( "http://www.w3.org/2004/08/wsdl/" + name , mep ) ; map . put ( "http://www.w3.org/2006/01/wsdl/" + name , mep ) ; } } } 	1	['9', '2', '0', '40', '23', '32', '39', '2', '7', '0.975', '240', '0.2', '9', '0.631578947', '0.375', '1', '1', '24.55555556', '4', '1.8889', '1']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Processor ; public interface LoadBalancer extends Processor { void addProcessor ( Processor processor ) ; void removeProcessor ( Processor processor ) ; List < Processor > getProcessors ( ) ; } 	0	['3', '1', '0', '4', '3', '3', '3', '1', '3', '2', '3', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import org . apache . camel . processor . RedeliveryPolicy ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "redeliveryPolicy" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RedeliveryPolicyType { private Integer maximumRedeliveries ; private Long initialRedeliveryDelay ; private Double backOffMultiplier ; private Boolean useExponentialBackOff ; private Double collisionAvoidanceFactor ; private Boolean useCollisionAvoidance ; public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; if ( maximumRedeliveries != null ) { answer . setMaximumRedeliveries ( maximumRedeliveries ) ; } if ( initialRedeliveryDelay != null ) { answer . setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; } if ( backOffMultiplier != null ) { answer . setBackOffMultiplier ( backOffMultiplier ) ; } if ( useExponentialBackOff != null ) { answer . setUseExponentialBackOff ( useExponentialBackOff ) ; } if ( collisionAvoidanceFactor != null ) { answer . setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; } if ( useCollisionAvoidance != null ) { answer . setUseCollisionAvoidance ( useCollisionAvoidance ) ; } return answer ; } public String toString ( ) { return "RedeliveryPolicy[maxRedeliveries: " + maximumRedeliveries + "]" ; } public RedeliveryPolicyType backOffMultiplier ( double backOffMultiplier ) { setBackOffMultiplier ( backOffMultiplier ) ; return this ; } public RedeliveryPolicyType collisionAvoidancePercent ( double collisionAvoidancePercent ) { setCollisionAvoidanceFactor ( collisionAvoidancePercent * 0.01d ) ; return this ; } public RedeliveryPolicyType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public RedeliveryPolicyType initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicyType maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicyType useCollisionAvoidance ( ) { setUseCollisionAvoidance ( true ) ; return this ; } public RedeliveryPolicyType useExponentialBackOff ( ) { setUseExponentialBackOff ( true ) ; return this ; } public Double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( Double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public Double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( Double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public Long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( Long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public Integer getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( Integer maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public Boolean getUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( Boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public Boolean getUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( Boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } } 	1	['22', '1', '0', '2', '42', '189', '1', '1', '22', '0.841269841', '182', '1', '0', '0', '0.171717172', '0', '0', '7', '7', '1.2273', '2']
package org . apache . camel . spring . remoting ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . component . bean . ProxyHelper ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . remoting . support . UrlBasedRemoteAccessor ; public class CamelProxyFactoryBean extends UrlBasedRemoteAccessor implements FactoryBean , CamelContextAware { private CamelContext camelContext ; private Endpoint endpoint ; private Object serviceProxy ; @ Override public void afterPropertiesSet ( ) { super . afterPropertiesSet ( ) ; try { if ( endpoint == null ) { if ( getServiceUrl ( ) == null || camelContext == null ) { throw new IllegalArgumentException ( "If endpoint is not specified, the serviceUrl and camelContext must be specified." ) ; } endpoint = camelContext . getEndpoint ( getServiceUrl ( ) ) ; if ( endpoint == null ) { throw new IllegalArgumentException ( "Could not resolve endpoint: " + getServiceUrl ( ) ) ; } } this . serviceProxy = ProxyHelper . createProxy ( endpoint , getServiceInterface ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } } public Class getServiceInterface ( ) { return super . getServiceInterface ( ) ; } public String getServiceUrl ( ) { return super . getServiceUrl ( ) ; } public Object getObject ( ) throws Exception { return serviceProxy ; } public Class getObjectType ( ) { return getServiceInterface ( ) ; } public boolean isSingleton ( ) { return true ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } } 	0	['11', '3', '0', '6', '22', '41', '0', '6', '11', '0.833333333', '99', '1', '2', '0.333333333', '0.393939394', '1', '1', '7.727272727', '5', '1.2727', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Processor ; public abstract class LoadBalancerSupport implements LoadBalancer { private List < Processor > processors = new CopyOnWriteArrayList < Processor > ( ) ; public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public void removeProcessor ( Processor processor ) { processors . remove ( processor ) ; } public List < Processor > getProcessors ( ) { return processors ; } } 	1	['4', '1', '2', '4', '8', '0', '2', '2', '4', '0', '28', '1', '0', '0', '0.75', '0', '0', '5.75', '1', '0.75', '1']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class Throttler extends DelayProcessorSupport { private long maximumRequestsPerPeriod ; private long timePeriodMillis ; private long startTimeMillis ; private long requestCount ; public Throttler ( Processor processor , long maximumRequestsPerPeriod ) { this ( processor , maximumRequestsPerPeriod , 1000 ) ; } public Throttler ( Processor processor , long maximumRequestsPerPeriod , long timePeriodMillis ) { super ( processor ) ; this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; this . timePeriodMillis = timePeriodMillis ; } @ Override public String toString ( ) { return "Throttler[requests: " + maximumRequestsPerPeriod + " per: " + timePeriodMillis + " (ms) to: " + getProcessor ( ) + "]" ; } public long getMaximumRequestsPerPeriod ( ) { return maximumRequestsPerPeriod ; } public void setMaximumRequestsPerPeriod ( long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } public long getTimePeriodMillis ( ) { return timePeriodMillis ; } public void setTimePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; } public long getRequestCount ( ) { return requestCount ; } public long getStartTimeMillis ( ) { return startTimeMillis ; } protected void delay ( Exchange exchange ) throws Exception { long now = currentSystemTime ( ) ; if ( startTimeMillis == 0 ) { startTimeMillis = now ; } if ( now - startTimeMillis > timePeriodMillis ) { requestCount = 1 ; startTimeMillis = now ; } else { if ( ++ requestCount > maximumRequestsPerPeriod ) { long time = startTimeMillis + timePeriodMillis ; waitUntil ( time , exchange ) ; } } } } 	0	['10', '4', '0', '4', '19', '7', '1', '3', '9', '0.666666667', '120', '1', '0', '0.789473684', '0.425', '1', '2', '10.6', '1', '0.8', '0']
package org . apache . camel . processor ; import java . util . concurrent . RejectedExecutionException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor { public static final String REDELIVERY_COUNTER = "org.apache.camel.RedeliveryCounter" ; public static final String REDELIVERED = "org.apache.camel.Redelivered" ; private class RedeliveryData { int redeliveryCounter ; long redeliveryDelay ; boolean sync = true ; RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy ; Processor failureProcessor = deadLetter ; } private static final transient Log LOG = LogFactory . getLog ( DeadLetterChannel . class ) ; private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel . class . getName ( ) + ".FAILURE_HANDLED" ; private Processor output ; private Processor deadLetter ; private AsyncProcessor outputAsync ; private RedeliveryPolicy redeliveryPolicy ; private Logger logger ; public DeadLetterChannel ( Processor output , Processor deadLetter ) { this ( output , deadLetter , new RedeliveryPolicy ( ) , DeadLetterChannel . createDefaultLogger ( ) ) ; } public DeadLetterChannel ( Processor output , Processor deadLetter , RedeliveryPolicy redeliveryPolicy , Logger logger ) { this . deadLetter = deadLetter ; this . output = output ; this . outputAsync = AsyncProcessorTypeConverter . convert ( output ) ; this . redeliveryPolicy = redeliveryPolicy ; this . logger = logger ; } public static < E extends Exchange > Logger createDefaultLogger ( ) { return new Logger ( LOG , LoggingLevel . ERROR ) ; } @ Override public String toString ( ) { return "DeadLetterChannel[" + output + ", " + deadLetter + ", " + redeliveryPolicy + "]" ; } public boolean process ( Exchange exchange , final AsyncCallback callback ) { return process ( exchange , callback , new RedeliveryData ( ) ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { while ( true ) { if ( ! isRunAllowed ( ) ) { if ( exchange . getException ( ) == null ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( data . sync ) ; return data . sync ; } if ( exchange . getException ( ) != null ) { Throwable e = exchange . getException ( ) ; exchange . setException ( null ) ; logger . log ( "On delivery attempt: " + data . redeliveryCounter + " caught: " + e , e ) ; data . redeliveryCounter = incrementRedeliveryCounter ( exchange , e ) ; ExceptionType exceptionPolicy = getExceptionPolicy ( exchange , e ) ; if ( exceptionPolicy != null ) { data . currentRedeliveryPolicy = exceptionPolicy . createRedeliveryPolicy ( data . currentRedeliveryPolicy ) ; Processor processor = exceptionPolicy . getErrorHandler ( ) ; if ( processor != null ) { data . failureProcessor = processor ; } } } if ( ! data . currentRedeliveryPolicy . shouldRedeliver ( data . redeliveryCounter ) ) { setFailureHandled ( exchange , true ) ; AsyncProcessor afp = AsyncProcessorTypeConverter . convert ( data . failureProcessor ) ; return afp . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( data . sync ) ; } } ) ; } if ( data . redeliveryCounter > 0 ) { data . redeliveryDelay = data . currentRedeliveryPolicy . getRedeliveryDelay ( data . redeliveryDelay ) ; sleep ( data . redeliveryDelay ) ; } exchange . setException ( null ) ; boolean sync = outputAsync . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } data . sync = false ; if ( exchange . getException ( ) != null ) { process ( exchange , callback , data ) ; } else { callback . done ( sync ) ; } } } ) ; if ( ! sync ) { return false ; } if ( exchange . getException ( ) == null || isFailureHandled ( exchange ) ) { callback . done ( true ) ; return true ; } } } public static boolean isFailureHandled ( Exchange exchange ) { Boolean rc = exchange . getProperty ( FAILURE_HANDLED_PROPERTY , Boolean . class ) ; return rc == null ? false : rc ; } public static void setFailureHandled ( Exchange exchange , boolean b ) { exchange . setProperty ( FAILURE_HANDLED_PROPERTY , b ? Boolean . TRUE : Boolean . FALSE ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public Processor getOutput ( ) { return output ; } public Processor getDeadLetter ( ) { return deadLetter ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } protected int incrementRedeliveryCounter ( Exchange exchange , Throwable e ) { Message in = exchange . getIn ( ) ; Integer counter = in . getHeader ( REDELIVERY_COUNTER , Integer . class ) ; int next = 1 ; if ( counter != null ) { next = counter + 1 ; } in . setHeader ( REDELIVERY_COUNTER , next ) ; in . setHeader ( REDELIVERED , true ) ; exchange . setException ( e ) ; return next ; } protected void sleep ( long redeliveryDelay ) { if ( redeliveryDelay > 0 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + redeliveryDelay + " until attempting redelivery" ) ; } try { Thread . sleep ( redeliveryDelay ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Thread interupted: " + e , e ) ; } } } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output , deadLetter ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( deadLetter , output ) ; } } 	1	['22', '3', '0', '20', '65', '151', '5', '18', '15', '0.846560847', '401', '0.777777778', '6', '0.457142857', '0.155844156', '1', '1', '16.81818182', '10', '1.5455', '7']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "el" ) public class ELExpression extends ExpressionType { public ELExpression ( ) { } public ELExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "el" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . processor . resequencer ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SequenceSender extends Thread { private static final Log LOG = LogFactory . getLog ( SequenceSender . class ) ; private static final Exchange STOP = createStopSignal ( ) ; private BlockingQueue < Exchange > queue ; private Processor processor ; public SequenceSender ( Processor processor ) { this . processor = processor ; } public void setQueue ( BlockingQueue < Exchange > queue ) { this . queue = queue ; } public void run ( ) { while ( true ) { try { Exchange exchange = queue . take ( ) ; if ( exchange == STOP ) { LOG . info ( "exit processing loop after cancellation" ) ; return ; } processor . process ( exchange ) ; } catch ( InterruptedException e ) { LOG . info ( "exit processing loop after interrupt" ) ; return ; } catch ( Exception e ) { LOG . warn ( "exception during exchange processing" ) ; } } } public void cancel ( ) throws InterruptedException { queue . put ( STOP ) ; } private static Exchange createStopSignal ( ) { return ( Exchange ) Proxy . newProxyInstance ( SequenceSender . class . getClassLoader ( ) , new Class [ ] { Exchange . class } , createStopHandler ( ) ) ; } private static InvocationHandler createStopHandler ( ) { return new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { throw new RuntimeException ( "illegal method invocation on stop signal" ) ; } } ; } } 	1	['7', '2', '0', '6', '17', '9', '1', '5', '4', '0.75', '75', '1', '3', '0.923076923', '0.333333333', '0', '0', '9.142857143', '2', '0.8571', '1']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . util . ExpressionHelper ; public class Delayer extends DelayProcessorSupport { private Expression < Exchange > timeExpression ; private long delay ; public Delayer ( Processor processor , Expression < Exchange > timeExpression , long delay ) { super ( processor ) ; this . timeExpression = timeExpression ; this . delay = delay ; } @ Override public String toString ( ) { return "Delayer[on: " + timeExpression + " delay: " + delay + " to: " + getProcessor ( ) + "]" ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } protected void delay ( Exchange exchange ) throws Exception { long time = 0 ; if ( timeExpression != null ) { Long longValue = ExpressionHelper . evaluateAsType ( timeExpression , exchange , Long . class ) ; if ( longValue != null ) { time = longValue . longValue ( ) ; } } if ( time <= 0 ) { time = defaultProcessTime ( exchange ) ; } time += delay ; waitUntil ( time , exchange ) ; } protected long defaultProcessTime ( Exchange exchange ) { return currentSystemTime ( ) ; } } 	0	['6', '4', '0', '6', '17', '0', '1', '5', '4', '0.4', '85', '1', '1', '0.857142857', '0.4', '1', '2', '12.83333333', '1', '0.8333', '0']
package org . apache . camel . spi ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import org . apache . camel . Service ; import org . apache . camel . management . CamelNamingStrategy ; public interface InstrumentationAgent extends Service { void register ( Object obj , ObjectName name ) throws JMException ; void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException ; void unregister ( ObjectName name ) throws JMException ; MBeanServer getMBeanServer ( ) ; CamelNamingStrategy getNamingStrategy ( ) ; } 	1	['5', '1', '0', '5', '5', '10', '3', '2', '5', '2', '5', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '2']
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . model . IdentifiedType ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . springframework . beans . factory . FactoryBean ; import javax . xml . bind . annotation . * ; @ XmlRootElement ( name = "endpoint" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class EndpointFactoryBean extends IdentifiedType implements FactoryBean , CamelContextAware { @ XmlAttribute private String uri ; @ XmlTransient private CamelContext context ; @ XmlTransient private Endpoint endpoint ; @ XmlTransient private boolean singleton ; public Object getObject ( ) throws Exception { if ( endpoint == null ) { endpoint = createEndpoint ( ) ; } return endpoint ; } public Class getObjectType ( ) { return Endpoint . class ; } public boolean isSingleton ( ) { return singleton ; } public CamelContext getCamelContext ( ) { return context ; } public void setCamelContext ( CamelContext context ) { this . context = context ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public void setSingleton ( boolean singleton ) { this . singleton = singleton ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } protected Endpoint createEndpoint ( ) { notNull ( context , "context" ) ; notNull ( uri , "uri" ) ; Endpoint endpoint = context . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } } 	0	['12', '2', '0', '7', '16', '46', '0', '7', '11', '0.795454545', '83', '1', '2', '0.153846154', '0.266666667', '0', '0', '5.583333333', '2', '1', '0']
package org . apache . camel . component . file ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . component . file . strategy . DefaultFileRenamer ; import org . apache . camel . component . file . strategy . DeleteFileProcessStrategy ; import org . apache . camel . component . file . strategy . FileProcessStrategy ; import org . apache . camel . component . file . strategy . FileProcessStrategySupport ; import org . apache . camel . component . file . strategy . NoOpFileProcessStrategy ; import org . apache . camel . component . file . strategy . RenameFileProcessStrategy ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileEndpoint . class ) ; private File file ; private FileProcessStrategy fileProcessStrategy ; private boolean autoCreate = true ; private boolean lock = true ; private boolean delete ; private boolean noop ; private boolean append = true ; private String moveNamePrefix ; private String moveNamePostfix ; private String [ ] excludedNamePrefixes = { "." } ; private String [ ] excludedNamePostfixes = { FileProcessStrategySupport . DEFAULT_LOCK_FILE_POSTFIX } ; private int bufferSize = 128 * 1024 ; private boolean ignoreFileNameHeader ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor file ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , file ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getContext ( ) , getExchangePattern ( ) , file ) ; } public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } public FileExchange createExchange ( ExchangePattern pattern ) { return new FileExchange ( getContext ( ) , pattern , file ) ; } public void configureMessage ( File file , Message message ) { message . setBody ( file ) ; String path = file . getPath ( ) ; String relativePath = path . substring ( path . length ( ) ) ; if ( relativePath . startsWith ( File . separator ) || relativePath . startsWith ( "/" ) ) { relativePath = relativePath . substring ( 1 ) ; } message . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } public File getFile ( ) { if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } public FileProcessStrategy getFileStrategy ( ) { if ( fileProcessStrategy == null ) { fileProcessStrategy = createFileStrategy ( ) ; LOG . debug ( "" + this + " using strategy: " + fileProcessStrategy ) ; } return fileProcessStrategy ; } public void setFileStrategy ( FileProcessStrategy fileProcessStrategy ) { this . fileProcessStrategy = fileProcessStrategy ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public boolean isLock ( ) { return lock ; } public void setLock ( boolean lock ) { this . lock = lock ; } public String getMoveNamePostfix ( ) { return moveNamePostfix ; } public void setMoveNamePostfix ( String moveNamePostfix ) { this . moveNamePostfix = moveNamePostfix ; } public String getMoveNamePrefix ( ) { return moveNamePrefix ; } public void setMoveNamePrefix ( String moveNamePrefix ) { this . moveNamePrefix = moveNamePrefix ; } public String [ ] getExcludedNamePrefixes ( ) { return excludedNamePrefixes ; } public void setExcludedNamePrefixes ( String [ ] excludedNamePrefixes ) { this . excludedNamePrefixes = excludedNamePrefixes ; } public String [ ] getExcludedNamePostfixes ( ) { return excludedNamePostfixes ; } public void setExcludedNamePostfixes ( String [ ] excludedNamePostfixes ) { this . excludedNamePostfixes = excludedNamePostfixes ; } public boolean isNoop ( ) { return noop ; } public void setNoop ( boolean noop ) { this . noop = noop ; } public boolean isAppend ( ) { return append ; } public void setAppend ( boolean append ) { this . append = append ; } public int getBufferSize ( ) { return bufferSize ; } public void setBufferSize ( int bufferSize ) { this . bufferSize = bufferSize ; } public boolean isIgnoreFileNameHeader ( ) { return ignoreFileNameHeader ; } public void setIgnoreFileNameHeader ( boolean ignoreFileNameHeader ) { this . ignoreFileNameHeader = ignoreFileNameHeader ; } protected FileProcessStrategy createFileStrategy ( ) { if ( isNoop ( ) ) { return new NoOpFileProcessStrategy ( ) ; } else if ( moveNamePostfix != null || moveNamePrefix != null ) { if ( isDelete ( ) ) { throw new IllegalArgumentException ( "You cannot set the deleteFiles property and a moveFilenamePostfix or moveFilenamePrefix" ) ; } return new RenameFileProcessStrategy ( isLock ( ) , moveNamePrefix , moveNamePostfix ) ; } else if ( isDelete ( ) ) { return new DeleteFileProcessStrategy ( isLock ( ) ) ; } else { return new RenameFileProcessStrategy ( isLock ( ) ) ; } } } 	1	['37', '3', '0', '21', '61', '598', '8', '19', '34', '0.932539683', '335', '1', '2', '0.375', '0.143939394', '1', '1', '7.675675676', '6', '1.2162', '8']
package org . apache . camel . component . cxf . spring ; import org . apache . cxf . frontend . AbstractEndpointFactory ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; public class CxfEndpointBean extends AbstractEndpointFactory { public CxfEndpointBean ( ) { setServiceFactory ( new ReflectionServiceFactoryBean ( ) ) ; } } 	0	['1', '0', '0', '5', '4', '0', '3', '2', '1', '2', '9', '0', '0', '0', '1', '0', '0', '8', '0', '0', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import java . util . Collection ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "onException" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExceptionType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElement ( name = "redeliveryPolicy" , required = false ) private RedeliveryPolicyType redeliveryPolicy ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; @ XmlTransient private Processor errorHandler ; public ExceptionType ( ) { } public ExceptionType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public ExceptionType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Exception[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { if ( redeliveryPolicy != null ) { return redeliveryPolicy . createRedeliveryPolicy ( parentPolicy ) ; } else if ( errorHandler != null ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; answer . setMaximumRedeliveries ( 0 ) ; return answer ; } return parentPolicy ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { errorHandler = routeContext . createProcessor ( this ) ; ErrorHandlerBuilder builder = routeContext . getRoute ( ) . getErrorHandlerBuilder ( ) ; builder . addErrorHandlers ( this ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public ExceptionType backOffMultiplier ( double backOffMultiplier ) { getOrCreateRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public ExceptionType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public ExceptionType collisionAvoidancePercent ( short collisionAvoidancePercent ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public ExceptionType initialRedeliveryDelay ( long initialRedeliveryDelay ) { getOrCreateRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public ExceptionType maximumRedeliveries ( int maximumRedeliveries ) { getOrCreateRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public ExceptionType useCollisionAvoidance ( ) { getOrCreateRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public ExceptionType useExponentialBackOff ( ) { getOrCreateRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } public Processor getErrorHandler ( ) { return errorHandler ; } public RedeliveryPolicyType getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicyType redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } protected RedeliveryPolicyType getOrCreateRedeliveryPolicy ( ) { if ( redeliveryPolicy == null ) { redeliveryPolicy = new RedeliveryPolicyType ( ) ; } return redeliveryPolicy ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1	['28', '2', '0', '14', '58', '302', '7', '9', '26', '0.802469136', '303', '1', '2', '0.788135593', '0.146103896', '1', '4', '9.607142857', '3', '1.0714', '3']
package org . apache . camel . component . cxf . transport ; public class CamelConstants { public static final String TEXT_MESSAGE_TYPE = "text" ; public static final String BINARY_MESSAGE_TYPE = "binary" ; public static final String CAMEL_SERVER_REQUEST_HEADERS = "org.apache.cxf.camel.server.request.headers" ; public static final String CAMEL_SERVER_RESPONSE_HEADERS = "org.apache.cxf.camel.server.response.headers" ; public static final String CAMEL_REQUEST_MESSAGE = "org.apache.cxf.camel.request.message" ; public static final String CAMEL_RESPONSE_MESSAGE = "org.apache.cxf.camel.reponse.message" ; public static final String CAMEL_CLIENT_REQUEST_HEADERS = "org.apache.cxf.camel.template.request.headers" ; public static final String CAMEL_CLIENT_RESPONSE_HEADERS = "org.apache.cxf.camel.template.response.headers" ; public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = "org.apache.cxf.camel.template.timeout" ; public static final String CAMEL_SERVER_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-server" ; public static final String CAMEL_CLIENT_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-template" ; public static final String ENDPOINT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/endpoint-config" ; public static final String SERVICE_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/service-config" ; public static final String PORT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/port-config" ; public static final String CAMEL_CLIENT_CONFIG_ID = "camel-template" ; public static final String CAMEL_SERVER_CONFIG_ID = "camel-server" ; public static final String CAMEL_REBASED_REPLY_TO = "org.apache.cxf.camel.server.replyto" ; public static final String CAMEL_CORRELATION_ID = "org.apache.cxf.camel.correlationId" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '22', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator DEFALT_ID_GENERATOR = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId = DEFALT_ID_GENERATOR . generateId ( ) ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , getBody ( ) ) ; } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object value , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T v = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; if ( v != null ) { value = v ; } } setBody ( value ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . copyFrom ( this ) ; return answer ; } public void copyFrom ( Message that ) { setMessageId ( that . getMessageId ( ) ) ; setBody ( that . getBody ( ) ) ; getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } } 	1	['14', '1', '1', '7', '26', '79', '2', '5', '12', '0.788461538', '118', '1', '2', '0', '0.256410256', '0', '0', '7.142857143', '3', '1.1429', '3']
package org . apache . camel . component . cxf . util ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; public final class UriUtils { private UriUtils ( ) { } static URL getWsdlUrl ( final URI uri ) throws MalformedURLException { URL wsdlUrl = null ; if ( uri . getScheme ( ) . equals ( CxfConstants . PROTOCOL_NAME_RES ) ) { if ( uri . getPath ( ) != null ) { String path = uri . isAbsolute ( ) ? getRelativePath ( uri ) : uri . getPath ( ) ; wsdlUrl = ClassLoaderUtils . getResource ( path , UriUtils . class ) ; } } else { wsdlUrl = new URL ( uri . getScheme ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) ) ; } return wsdlUrl ; } private static String getRelativePath ( URI uri ) { URI base = null ; try { base = new URI ( CxfConstants . PROTOCOL_NAME_RES , "" , "/" , "" ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } return base . relativize ( uri ) . getPath ( ) ; } } 	0	['3', '1', '0', '2', '15', '3', '1', '1', '0', '2', '63', '0', '0', '0', '0.5', '0', '0', '20', '1', '0.6667', '0']
package org . apache . camel . builder ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . Language ; public class ExpressionClause < T extends ProcessorType > { private T result ; private CamelContext camelContext ; public T el ( String text ) { return language ( "el" , text ) ; } public T groovy ( String text ) { return language ( "groovy" , text ) ; } public T javaScript ( String text ) { return language ( "js" , text ) ; } public T ognl ( String text ) { return language ( "ognl" , text ) ; } public T php ( String text ) { return language ( "php" , text ) ; } public T python ( String text ) { return language ( "python" , text ) ; } public T ruby ( String text ) { return language ( "ruby" , text ) ; } public T sql ( String text ) { return language ( "sql" , text ) ; } public T simple ( String text ) { return language ( "simple" , text ) ; } public T xpath ( String text ) { return language ( "xpath" , text ) ; } public T xqery ( String text ) { return language ( "xqery" , text ) ; } public T language ( String languageName , String text ) { Expression expression = createExpression ( "el" , text ) ; return result ; } protected Expression createExpression ( String languageName , String text ) { Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Could not resolve language: " + languageName ) ; } return language . createExpression ( text ) ; } } 	1	['14', '1', '0', '4', '21', '91', '0', '4', '13', '0.538461538', '105', '1', '2', '0', '0.964285714', '0', '0', '6.357142857', '2', '1', '5']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . util . ServiceHelper ; public class Interceptor extends DelegateProcessor { private Processor interceptorLogic ; public Interceptor ( ) { } public Interceptor ( Processor interceptorLogic ) { this . interceptorLogic = interceptorLogic ; } public void process ( Exchange exchange ) throws Exception { interceptorLogic . process ( exchange ) ; } public Processor getInterceptorLogic ( ) { return interceptorLogic ; } public void setInterceptorLogic ( Processor interceptorLogic ) { this . interceptorLogic = interceptorLogic ; } @ Override protected void doStart ( ) throws Exception { ServiceHelper . startService ( interceptorLogic ) ; super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { ServiceHelper . stopService ( interceptorLogic ) ; super . doStop ( ) ; } } 	0	['7', '3', '0', '7', '13', '0', '3', '4', '5', '0.166666667', '41', '1', '1', '0.807692308', '0.476190476', '1', '1', '4.714285714', '1', '0.7143', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . IOException ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class RenameFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( RenameFileProcessStrategy . class ) ; private FileRenamer renamer ; public RenameFileProcessStrategy ( ) { this ( true ) ; } public RenameFileProcessStrategy ( boolean lock ) { this ( lock , ".camel/" , "" ) ; } public RenameFileProcessStrategy ( boolean lock , String namePrefix , String namePostfix ) { this ( lock , new DefaultFileRenamer ( namePrefix , namePostfix ) ) ; } public RenameFileProcessStrategy ( boolean lock , FileRenamer renamer ) { super ( lock ) ; this . renamer = renamer ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { File newName = renamer . renameFile ( file ) ; newName . getParentFile ( ) . mkdirs ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Renaming file: " + file + " to: " + newName ) ; } boolean renamed = file . renameTo ( newName ) ; if ( ! renamed ) { throw new IOException ( "Could not rename file from: " + file + " to " + newName ) ; } super . commit ( endpoint , exchange , file ) ; } public FileRenamer getRenamer ( ) { return renamer ; } public void setRenamer ( FileRenamer renamer ) { this . renamer = renamer ; } } 	1	['8', '2', '0', '7', '23', '14', '1', '7', '7', '0.642857143', '101', '1', '2', '0.666666667', '0.326530612', '0', '0', '11.375', '1', '0.375', '1']
package org . apache . camel ; public class ResolveEndpointFailedException extends RuntimeCamelException { private final String uri ; public ResolveEndpointFailedException ( String uri , Throwable cause ) { super ( "Failed to resolve endpoint: " + uri + " due to: " + cause , cause ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	0	['2', '5', '0', '2', '7', '0', '1', '1', '2', '0', '25', '1', '0', '0.944444444', '0.666666667', '0', '0', '11', '1', '0.5', '0']
package org . apache . camel ; public class NoTypeConversionAvailableException extends RuntimeCamelException { private final Object value ; private final Class type ; public NoTypeConversionAvailableException ( Object value , Class type ) { super ( "No converter available to convert value: " + value + " to the required type: " + type . getName ( ) ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class getType ( ) { return type ; } } 	1	['3', '5', '0', '1', '9', '0', '0', '1', '3', '0.5', '33', '1', '0', '0.894736842', '0.555555556', '0', '0', '9.333333333', '1', '0.6667', '1']
package org . apache . camel . language . juel ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class JuelLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return new JuelExpression ( expression , Boolean . class ) ; } public Expression < Exchange > createExpression ( String expression ) { return new JuelExpression ( expression , Object . class ) ; } } 	0	['3', '1', '0', '4', '5', '3', '0', '4', '3', '2', '18', '0', '0', '0', '0.833333333', '0', '0', '5', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . TryProcessor ; @ XmlRootElement ( name = "try" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TryType extends OutputType < TryType > { @ XmlTransient private List < CatchType > catchClauses ; @ XmlTransient private FinallyType finallyClause ; @ XmlTransient private boolean initialized ; @ XmlTransient private List < ProcessorType < ? > > outputsWithoutCatches ; @ Override public String toString ( ) { return "Try[ " + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor tryProcessor = createOutputsProcessor ( routeContext , getOutputsWithoutCatches ( ) ) ; Processor finallyProcessor = null ; if ( finallyClause != null ) { finallyProcessor = finallyClause . createProcessor ( routeContext ) ; } List < CatchProcessor > catchProcessors = new ArrayList < CatchProcessor > ( ) ; if ( catchClauses != null ) { for ( CatchType catchClause : catchClauses ) { catchProcessors . add ( catchClause . createProcessor ( routeContext ) ) ; } } return new TryProcessor ( tryProcessor , catchProcessors , finallyProcessor ) ; } public CatchType handle ( Class < ? > exceptionType ) { CatchType answer = new CatchType ( exceptionType ) ; addOutput ( answer ) ; return answer ; } public FinallyType handleAll ( ) { FinallyType answer = new FinallyType ( ) ; addOutput ( answer ) ; return answer ; } public List < CatchType > getCatchClauses ( ) { if ( catchClauses == null ) { checkInitialized ( ) ; } return catchClauses ; } public FinallyType getFinallyClause ( ) { if ( finallyClause == null ) { checkInitialized ( ) ; } return finallyClause ; } public List < ProcessorType < ? > > getOutputsWithoutCatches ( ) { if ( outputsWithoutCatches == null ) { checkInitialized ( ) ; } return outputsWithoutCatches ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { initialized = false ; super . setOutputs ( outputs ) ; } public void addOutput ( ProcessorType output ) { initialized = false ; getOutputs ( ) . add ( output ) ; } protected void checkInitialized ( ) { if ( ! initialized ) { initialized = true ; outputsWithoutCatches = new ArrayList < ProcessorType < ? > > ( ) ; catchClauses = new ArrayList < CatchType > ( ) ; finallyClause = null ; for ( ProcessorType output : outputs ) { if ( output instanceof CatchType ) { catchClauses . add ( ( CatchType ) output ) ; } else if ( output instanceof FinallyType ) { if ( finallyClause != null ) { throw new IllegalArgumentException ( "Multiple finally clauses added: " + finallyClause + " and " + output ) ; } else { finallyClause = ( FinallyType ) output ; } } else { outputsWithoutCatches . add ( output ) ; } } } } } 	1	['11', '3', '0', '8', '30', '37', '1', '8', '10', '0.525', '212', '1', '1', '0.907407407', '0.272727273', '1', '14', '17.90909091', '6', '1.6364', '5']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; public abstract class DefaultProducer < E extends Exchange > extends ServiceSupport implements Producer < E > { private Endpoint < E > endpoint ; public DefaultProducer ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public E createExchange ( ) { return endpoint . createExchange ( ) ; } public E createExchange ( ExchangePattern pattern ) { return endpoint . createExchange ( pattern ) ; } public E createExchange ( E exchange ) { return endpoint . createExchange ( exchange ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['7', '2', '17', '22', '11', '1', '17', '5', '5', '0.333333333', '33', '1', '1', '0.684210526', '0.357142857', '1', '1', '3.571428571', '1', '0.8571', '0']
package org . apache . camel . impl . converter ; public interface TypeConverterLoader { void load ( TypeConverterRegistry registry ) throws Exception ; } 	1	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spring . spi . TransactionInterceptor ; import org . springframework . context . ApplicationContext ; import org . springframework . transaction . support . TransactionTemplate ; public abstract class SpringRouteBuilder extends RouteBuilder { private ApplicationContext applicationContext ; public TransactionInterceptor transactionInterceptor ( ) { return new TransactionInterceptor ( bean ( TransactionTemplate . class ) ) ; } public < T > T bean ( Class < T > type , String beanName ) { ApplicationContext context = getApplicationContext ( ) ; return ( T ) context . getBean ( beanName , type ) ; } public < T > T bean ( Class < T > type ) { ApplicationContext context = getApplicationContext ( ) ; String [ ] names = context . getBeanNamesForType ( type , true , true ) ; if ( names != null ) { int count = names . length ; if ( count == 1 ) { return ( T ) context . getBean ( names [ 0 ] ) ; } else if ( count > 1 ) { throw new IllegalArgumentException ( "Too many beans in the application context of type: " + type + ". Found: " + count ) ; } } throw new IllegalArgumentException ( "No bean available in the application context of type: " + type ) ; } public ApplicationContext getApplicationContext ( ) { if ( applicationContext == null ) { CamelContext camelContext = getContext ( ) ; if ( camelContext instanceof SpringCamelContext ) { SpringCamelContext springCamelContext = ( SpringCamelContext ) camelContext ; return springCamelContext . getApplicationContext ( ) ; } else { throw new IllegalArgumentException ( "This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured" ) ; } } return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } } 	0	['6', '3', '0', '6', '19', '13', '0', '6', '6', '0.4', '107', '1', '0', '0.9', '0.416666667', '0', '0', '16.66666667', '4', '1.6667', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; public interface FileProcessStrategy { boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; } 	1	['2', '1', '0', '5', '2', '1', '4', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . management ; import java . util . concurrent . atomic . AtomicLong ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Counter" , currencyTimeLimit = 15 ) public class Counter { protected AtomicLong numExchanges = new AtomicLong ( 0L ) ; @ ManagedOperation ( description = "Reset counters" ) public void reset ( ) { numExchanges . set ( 0L ) ; } @ ManagedAttribute ( description = "Total number of exchanges" ) public long getNumExchanges ( ) throws Exception { return numExchanges . get ( ) ; } public long increment ( ) { return numExchanges . incrementAndGet ( ) ; } } 	0	['4', '1', '1', '1', '9', '0', '1', '0', '4', '0', '27', '1', '0', '0', '1', '0', '0', '5.5', '1', '0.75', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ExchangeHelper ; public class MethodInfo { private Class type ; private Method method ; private final List < ParameterInfo > parameters ; private final List < ParameterInfo > bodyParameters ; private final boolean hasCustomAnnotation ; private Expression parametersExpression ; public MethodInfo ( Class type , Method method , List < ParameterInfo > parameters , List < ParameterInfo > bodyParameters , boolean hasCustomAnnotation ) { this . type = type ; this . method = method ; this . parameters = parameters ; this . bodyParameters = bodyParameters ; this . hasCustomAnnotation = hasCustomAnnotation ; this . parametersExpression = createParametersExpression ( ) ; } public String toString ( ) { return method . toString ( ) ; } public MethodInvocation createMethodInvocation ( final Object pojo , final Exchange messageExchange ) { final Object [ ] arguments = ( Object [ ] ) parametersExpression . evaluate ( messageExchange ) ; return new MethodInvocation ( ) { public Method getMethod ( ) { return method ; } public Object [ ] getArguments ( ) { return arguments ; } public Object proceed ( ) throws Throwable { return invoke ( method , pojo , arguments , messageExchange ) ; } public Object getThis ( ) { return pojo ; } public AccessibleObject getStaticPart ( ) { return method ; } } ; } public Class getType ( ) { return type ; } public Method getMethod ( ) { return method ; } public Expression getParametersExpression ( ) { return parametersExpression ; } public List < ParameterInfo > getBodyParameters ( ) { return bodyParameters ; } public Class getBodyParameterType ( ) { ParameterInfo parameterInfo = bodyParameters . get ( 0 ) ; return parameterInfo . getType ( ) ; } public boolean bodyParameterMatches ( Class bodyType ) { Class actualType = getBodyParameterType ( ) ; return actualType != null && ObjectHelper . isAssignableFrom ( bodyType , actualType ) ; } public List < ParameterInfo > getParameters ( ) { return parameters ; } public boolean hasBodyParameter ( ) { return ! bodyParameters . isEmpty ( ) ; } public boolean isHasCustomAnnotation ( ) { return hasCustomAnnotation ; } protected Object invoke ( Method mth , Object pojo , Object [ ] arguments , Exchange exchange ) throws IllegalAccessException , InvocationTargetException { return mth . invoke ( pojo , arguments ) ; } protected Expression createParametersExpression ( ) { final int size = parameters . size ( ) ; final Expression [ ] expressions = new Expression [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Expression parameterExpression = parameters . get ( i ) . getExpression ( ) ; expressions [ i ] = parameterExpression ; } return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object [ ] answer = new Object [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Object value = expressions [ i ] . evaluate ( exchange ) ; value = ExchangeHelper . convertToType ( exchange , parameters . get ( i ) . getType ( ) , value ) ; answer [ i ] = value ; } return answer ; } @ Override public String toString ( ) { return "ParametersExpression: " + Arrays . asList ( expressions ) ; } } ; } } 	1	['16', '1', '0', '8', '28', '74', '3', '7', '12', '0.844444444', '154', '1', '1', '0', '0.1875', '0', '0', '8.25', '3', '1.1875', '2']
package org . apache . camel . language . juel ; import javax . el . ELContext ; import javax . el . ExpressionFactory ; import javax . el . ValueExpression ; import de . odysseus . el . util . SimpleContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . impl . ExpressionSupport ; public class JuelExpression extends ExpressionSupport < Exchange > { private final String expression ; private final Class < ? > type ; private ExpressionFactory expressionFactory ; public JuelExpression ( String expression , Class < ? > type ) { this . expression = expression ; this . type = type ; } public static JuelExpression el ( String expression ) { return new JuelExpression ( expression , Object . class ) ; } public Object evaluate ( Exchange exchange ) { ELContext context = populateContext ( createContext ( ) , exchange ) ; ValueExpression valueExpression = getExpressionFactory ( ) . createValueExpression ( context , expression , type ) ; return valueExpression . getValue ( context ) ; } public ExpressionFactory getExpressionFactory ( ) { if ( expressionFactory == null ) { expressionFactory = ExpressionFactory . newInstance ( ) ; } return expressionFactory ; } public void setExpressionFactory ( ExpressionFactory expressionFactory ) { this . expressionFactory = expressionFactory ; } protected ELContext populateContext ( ELContext context , Exchange exchange ) { setVariable ( context , "exchange" , exchange , Exchange . class ) ; setVariable ( context , "in" , exchange . getIn ( ) , Message . class ) ; setVariable ( context , "out" , exchange . getOut ( ) , Message . class ) ; return context ; } protected void setVariable ( ELContext context , String name , Object value , Class < ? > type ) { ValueExpression valueExpression = getExpressionFactory ( ) . createValueExpression ( value , type ) ; SimpleContext simpleContext = ( SimpleContext ) context ; simpleContext . setVariable ( name , valueExpression ) ; } protected ELContext createContext ( ) { return new SimpleContext ( ) ; } protected String assertionFailureMessage ( Exchange exchange ) { return expression ; } } 	0	['9', '2', '0', '5', '18', '28', '1', '4', '5', '0.666666667', '103', '1', '0', '0.384615385', '0.317460317', '1', '2', '10.11111111', '2', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; @ XmlRootElement ( name = "otherwise" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class OtherwiseType extends OutputType { @ Override public String toString ( ) { return "Otherwise[" + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProcessor ( this ) ; } @ Override public String getLabel ( ) { return "otherwise" ; } } 	1	['4', '3', '0', '9', '11', '6', '6', '4', '4', '2', '25', '0', '0', '0.97029703', '0.625', '1', '2', '5.25', '1', '0.75', '3']
package org . apache . camel . processor . resequencer ; public interface TimeoutHandler { void timeout ( Timeout timeout ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "bean" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class BeanRef extends OutputType { @ XmlAttribute ( required = true ) private String ref ; @ XmlAttribute ( required = false ) private String method ; @ XmlAttribute ( required = false ) private Class beanType ; @ XmlTransient private Object bean ; public BeanRef ( ) { } public BeanRef ( String ref ) { this . ref = ref ; } public BeanRef ( String ref , String method ) { this . ref = ref ; this . method = method ; } @ Override public String toString ( ) { return "Bean[" + getLabel ( ) + "]" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class getBeanType ( ) { return beanType ; } public void setBeanType ( Class beanType ) { this . beanType = beanType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( bean == null ) { String reference = getRef ( ) ; if ( reference != null ) { bean = routeContext . lookup ( reference , Object . class ) ; } else { ObjectHelper . notNull ( beanType , "bean, ref or beanType" ) ; bean = CamelContextHelper . newInstance ( routeContext . getCamelContext ( ) , beanType ) ; } } BeanProcessor answer = new BeanProcessor ( bean , routeContext . getCamelContext ( ) ) ; if ( method != null ) { answer . setMethodName ( method ) ; } return answer ; } @ Override public String getLabel ( ) { if ( ref != null ) { String methodText = "" ; if ( method != null ) { methodText = " method: " + method ; } return "ref: " + ref + methodText ; } else if ( bean != null ) { return bean . toString ( ) ; } else if ( beanType != null ) { return beanType . getName ( ) ; } else { return "" ; } } } 	1	['13', '3', '0', '8', '25', '26', '1', '7', '13', '0.625', '161', '1', '0', '0.907407407', '0.307692308', '1', '2', '11.07692308', '5', '1.3077', '3']
package org . apache . camel . component . cxf . invoker ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . cxf . Bus ; import org . apache . cxf . binding . Binding ; import org . apache . cxf . endpoint . ClientImpl ; import org . apache . cxf . endpoint . ConduitSelector ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . endpoint . EndpointImpl ; import org . apache . cxf . endpoint . PreexistingConduitSelector ; import org . apache . cxf . helpers . IOUtils ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . PhaseInterceptorChain ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . transport . MessageObserver ; public class CxfClient extends ClientImpl { private static final Logger LOG = Logger . getLogger ( CxfClient . class . getName ( ) ) ; private Endpoint endpoint ; public CxfClient ( Bus b , Endpoint e ) { super ( b , e ) ; endpoint = e ; } public Object dispatch ( Object params , Map < String , Object > context , Exchange exchange ) throws Exception { Object retval = null ; InvokingContext invokingContext = exchange . get ( InvokingContext . class ) ; assert invokingContext != null ; BindingOperationInfo inBoundOp = exchange . get ( BindingOperationInfo . class ) ; BindingOperationInfo outBoundOp = null ; if ( inBoundOp != null ) { BindingInfo bi = getEndpoint ( ) . getEndpointInfo ( ) . getBinding ( ) ; outBoundOp = bi . getOperation ( inBoundOp . getOperationInfo ( ) . getName ( ) ) ; if ( outBoundOp != null && inBoundOp . isUnwrapped ( ) ) { outBoundOp = outBoundOp . getUnwrappedOperation ( ) ; } } retval = invokeWithMessageStream ( outBoundOp , params , context , invokingContext ) ; return retval ; } @ SuppressWarnings ( "unchecked" ) public Object invokeWithMessageStream ( BindingOperationInfo bi , Object param , Map < String , Object > context , InvokingContext invokingContext ) throws Exception { Object retval = null ; Map < String , Object > requestContext = null ; Map < String , Object > responseContext = null ; if ( null != context ) { requestContext = ( Map < String , Object > ) context . get ( REQUEST_CONTEXT ) ; responseContext = ( Map < String , Object > ) context . get ( RESPONSE_CONTEXT ) ; } Exchange exchange = new ExchangeImpl ( ) ; exchange . put ( MessageObserver . class , this ) ; exchange . put ( InvokingContext . class , invokingContext ) ; exchange . put ( Bus . class , bus ) ; exchange . put ( Endpoint . class , getEndpoint ( ) ) ; exchange . put ( BindingInfo . class , getEndpoint ( ) . getEndpointInfo ( ) . getBinding ( ) ) ; if ( bi != null ) { exchange . put ( BindingOperationInfo . class , bi ) ; exchange . put ( BindingMessageInfo . class , bi . getInput ( ) ) ; exchange . setOneWay ( bi . getOperationInfo ( ) . isOneWay ( ) ) ; } Message message = prepareMessage ( exchange , requestContext , param , invokingContext ) ; PhaseInterceptorChain chain = setupOutChain ( requestContext , message , invokingContext ) ; prepareConduitSelector ( message ) ; chain . doIntercept ( message ) ; Exception ex = message . getContent ( Exception . class ) ; if ( ex != null ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Exception in outgoing chain: " + ex . toString ( ) ) ; } throw ex ; } if ( ! exchange . isOneWay ( ) ) { ex = getException ( exchange ) ; if ( ex != null ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Exception in incoming chain: " + ex . toString ( ) ) ; } throw ex ; } retval = invokingContext . getResponseObject ( exchange , responseContext ) ; } return retval ; } public void onMessage ( Message message ) { Exchange exchange = message . getExchange ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "call the cxf client on message , exchange is " + exchange ) ; } if ( exchange . get ( InvokingContext . class ) == null ) { super . onMessage ( message ) ; } else { message = getEndpoint ( ) . getBinding ( ) . createMessage ( message ) ; message . put ( Message . REQUESTOR_ROLE , Boolean . TRUE ) ; message . put ( Message . INBOUND_MESSAGE , Boolean . TRUE ) ; exchange . put ( Binding . class , getEndpoint ( ) . getBinding ( ) ) ; BindingOperationInfo bi = exchange . get ( BindingOperationInfo . class ) ; if ( bi != null ) { exchange . put ( BindingMessageInfo . class , bi . getOutput ( ) ) ; } InvokingContext invokingContext = exchange . get ( InvokingContext . class ) ; assert invokingContext != null ; PhaseInterceptorChain chain = invokingContext . getResponseInInterceptorChain ( exchange ) ; message . setInterceptorChain ( chain ) ; chain . doIntercept ( message ) ; exchange . setInMessage ( message ) ; } } private Message prepareMessage ( Exchange exchange , Map < String , Object > requestContext , Object param , InvokingContext InvokingContext ) { Message message = getEndpoint ( ) . getBinding ( ) . createMessage ( ) ; message . put ( Message . REQUESTOR_ROLE , Boolean . TRUE ) ; message . put ( Message . INBOUND_MESSAGE , Boolean . FALSE ) ; if ( requestContext != null ) { message . putAll ( requestContext ) ; } if ( param != null ) { InvokingContext . setRequestOutMessageContent ( message , param ) ; } if ( null != requestContext ) { exchange . putAll ( requestContext ) ; } exchange . setOutMessage ( message ) ; return message ; } private PhaseInterceptorChain setupOutChain ( Map < String , Object > requestContext , Message message , InvokingContext invokingContext ) { if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "Build an out interceptor chain to send request to server" ) ; } Exchange exchange = message . getExchange ( ) ; PhaseInterceptorChain chain = invokingContext . getRequestOutInterceptorChain ( exchange ) ; message . setInterceptorChain ( chain ) ; modifyChain ( chain , requestContext ) ; chain . setFaultObserver ( outFaultObserver ) ; return chain ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Bus getBus ( ) { return bus ; } } 	0	['9', '0', '0', '19', '59', '16', '2', '17', '6', '0.541666667', '382', '0.666666667', '0', '0', '0.347222222', '0', '0', '41.11111111', '6', '1.7778', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; @ Converter public class ObjectConverter { private ObjectConverter ( ) { } public static boolean isCollection ( Object value ) { return value instanceof Collection || ( value != null && value . getClass ( ) . isArray ( ) ) ; } @ Converter public static Iterator iterator ( Object value ) { if ( value == null ) { return Collections . EMPTY_LIST . iterator ( ) ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { List < Object > list = Arrays . asList ( ( Object [ ] ) value ) ; return list . iterator ( ) ; } else if ( value instanceof NodeList ) { final NodeList nodeList = ( NodeList ) value ; return new Iterator < Node > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return ++ idx < nodeList . getLength ( ) ; } public Node next ( ) { return nodeList . item ( idx ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else { return Collections . singletonList ( value ) . iterator ( ) ; } } @ Converter public static boolean toBool ( Object value ) { Boolean answer = toBoolean ( value ) ; if ( answer != null ) { return answer . booleanValue ( ) ; } return false ; } @ Converter public static Boolean toBoolean ( Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ; } if ( value instanceof String ) { return "true" . equalsIgnoreCase ( value . toString ( ) ) ? Boolean . TRUE : Boolean . FALSE ; } return null ; } @ Converter public static Boolean toBoolean ( Boolean value ) { if ( value != null ) { return value . booleanValue ( ) ; } return false ; } } 	1	['6', '1', '0', '9', '18', '15', '8', '1', '5', '2', '102', '0', '0', '0', '0.333333333', '0', '0', '16', '5', '2.8333', '3']
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . dao . DataIntegrityViolationException ; import org . springframework . orm . jpa . JpaSystemException ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallback ; import org . springframework . transaction . support . TransactionTemplate ; import javax . persistence . EntityExistsException ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; public abstract class BamProcessorSupport < T > implements Processor { private static final transient Log LOG = LogFactory . getLog ( BamProcessorSupport . class ) ; private Class < T > entityType ; private Class primaryKeyType = String . class ; private Expression < Exchange > correlationKeyExpression ; private TransactionTemplate transactionTemplate ; private int maximumRetries = 30 ; public int getMaximumRetries ( ) { return maximumRetries ; } public void setMaximumRetries ( int maximumRetries ) { this . maximumRetries = maximumRetries ; } protected BamProcessorSupport ( TransactionTemplate transactionTemplate , Expression < Exchange > correlationKeyExpression ) { this . transactionTemplate = transactionTemplate ; this . correlationKeyExpression = correlationKeyExpression ; Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { this . entityType = ( Class < T > ) argumentType ; } } } if ( entityType == null ) { throw new IllegalArgumentException ( "Could not infer the entity type!" ) ; } } protected BamProcessorSupport ( TransactionTemplate transactionTemplate , Expression < Exchange > correlationKeyExpression , Class < T > entitytype ) { this . transactionTemplate = transactionTemplate ; this . entityType = entitytype ; this . correlationKeyExpression = correlationKeyExpression ; } public void process ( final Exchange exchange ) { Object entity = null ; for ( int i = 0 ; entity == null && i < maximumRetries ; i ++ ) { if ( i > 0 ) { LOG . info ( "Retry attempt due to duplicate row: " + i ) ; } entity = transactionTemplate . execute ( new TransactionCallback ( ) { public Object doInTransaction ( TransactionStatus status ) { try { Object key = getCorrelationKey ( exchange ) ; T entity = loadEntity ( exchange , key ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Correlation key: " + key + " with entity: " + entity ) ; } processEntity ( exchange , entity ) ; return entity ; } catch ( JpaSystemException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Likely exception is due to duplicate row in concurrent setting: " + e , e ) ; } LOG . info ( "Attempt to insert duplicate row due to concurrency issue, so retrying: " + e ) ; return retryDueToDuplicate ( status ) ; } catch ( DataIntegrityViolationException e ) { Throwable throwable = e . getCause ( ) ; if ( throwable instanceof EntityExistsException ) { LOG . info ( "Attempt to insert duplicate row due to concurrency issue, so retrying: " + throwable ) ; return retryDueToDuplicate ( status ) ; } return onError ( status , throwable ) ; } catch ( Throwable e ) { return onError ( status , e ) ; } } } ) ; } } public Expression < Exchange > getCorrelationKeyExpression ( ) { return correlationKeyExpression ; } public Class < T > getEntityType ( ) { return entityType ; } protected abstract void processEntity ( Exchange exchange , T entity ) throws Exception ; protected abstract T loadEntity ( Exchange exchange , Object key ) throws Exception ; protected abstract Class getKeyType ( ) ; protected Object getCorrelationKey ( Exchange exchange ) throws NoCorrelationKeyException { Object value = correlationKeyExpression . evaluate ( exchange ) ; Class keyType = getKeyType ( ) ; if ( keyType != null ) { value = ExchangeHelper . convertToType ( exchange , keyType , value ) ; } if ( value == null ) { throw new NoCorrelationKeyException ( this , exchange ) ; } return value ; } protected Object retryDueToDuplicate ( TransactionStatus status ) { status . setRollbackOnly ( ) ; return null ; } protected Object onError ( TransactionStatus status , Throwable e ) { status . setRollbackOnly ( ) ; LOG . error ( "Caught: " + e , e ) ; throw new RuntimeCamelException ( e ) ; } } 	0	['15', '1', '1', '13', '35', '59', '3', '12', '5', '0.821428571', '189', '1', '2', '0', '0.222222222', '0', '0', '11.2', '4', '1', '0']
package org . apache . camel . util ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . spi . Injector ; public class FactoryFinder { private final String path ; private final ConcurrentHashMap classMap = new ConcurrentHashMap ( ) ; public FactoryFinder ( ) { this ( "META-INF/services/org/apache/camel/" ) ; } public FactoryFinder ( String path ) { this . path = path ; } public Object newInstance ( String key ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { return newInstance ( key , ( String ) null ) ; } public Object newInstance ( String key , String propertyPrefix ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { Class clazz = findClass ( key , propertyPrefix ) ; return clazz . newInstance ( ) ; } public Object newInstance ( String key , Injector injector ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , ( String ) null ) ; } public Object newInstance ( String key , Injector injector , String propertyPrefix ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; return injector . newInstance ( type ) ; } public < T > T newInstance ( String key , Injector injector , Class < T > expectedType ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , null , expectedType ) ; } public < T > T newInstance ( String key , Injector injector , String propertyPrefix , Class < T > expectedType ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; Object value = injector . newInstance ( type ) ; if ( expectedType . isInstance ( value ) ) { return expectedType . cast ( value ) ; } else { throw new ClassCastException ( "Not instanceof " + expectedType . getName ( ) + " value: " + value ) ; } } public < T > List < T > newInstances ( String key , Injector injector , Class < T > type ) throws IOException , ClassNotFoundException { List < Class > list = findClasses ( key ) ; List < T > answer = new ArrayList < T > ( list . size ( ) ) ; answer . add ( newInstance ( key , injector , type ) ) ; return answer ; } public Class findClass ( String key ) throws ClassNotFoundException , IOException { return findClass ( key , null ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; if ( clazz == null ) { clazz = newInstance ( doFindFactoryProperies ( key ) , propertyPrefix ) ; classMap . put ( propertyPrefix + key , clazz ) ; } return clazz ; } public List < Class > findClasses ( String key ) throws ClassNotFoundException , IOException { return findClasses ( key , null ) ; } public List < Class > findClasses ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { Class type = findClass ( key , propertyPrefix ) ; return Collections . singletonList ( type ) ; } public String getPath ( ) { return path ; } private Class newInstance ( Properties properties , String propertyPrefix ) throws ClassNotFoundException , IOException { String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } Class clazz = null ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { clazz = loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { } } if ( clazz == null ) { clazz = FactoryFinder . class . getClassLoader ( ) . loadClass ( className ) ; } return clazz ; } private Properties doFindFactoryProperies ( String key ) throws IOException { String uri = path + key ; ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = getClass ( ) . getClassLoader ( ) ; } InputStream in = classLoader . getResourceAsStream ( uri ) ; if ( in == null ) { in = FactoryFinder . class . getClassLoader ( ) . getResourceAsStream ( uri ) ; if ( in == null ) { throw new NoFactoryAvailableException ( uri ) ; } } BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; } finally { try { reader . close ( ) ; } catch ( Exception ignore ) { } } } } 	1	['16', '1', '0', '6', '47', '112', '4', '2', '14', '0.6', '301', '1', '0', '0', '0.4875', '0', '0', '17.6875', '1', '0.875', '2']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Properties { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; public interface ComponentResolver < E extends Exchange > { Component < E > resolveComponent ( String name , CamelContext context ) throws Exception ; } 	1	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . IdentifiedType ; @ XmlRootElement ( name = "proxy" ) public class CamelProxyFactoryType extends IdentifiedType { @ XmlAttribute private String serviceUrl ; @ XmlAttribute private Class serviceInterface ; } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '6', '1', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel ; public class InvalidPayloadException extends CamelExchangeException { private final Class < ? > type ; public InvalidPayloadException ( Exchange exchange , Class < ? > type ) { super ( "No in body available of type: " + type . getName ( ) + NoSuchPropertyException . valueDescription ( exchange . getIn ( ) . getBody ( ) ) , exchange ) ; this . type = type ; } public Class < ? > getType ( ) { return type ; } } 	1	['2', '5', '0', '5', '10', '0', '1', '4', '2', '0', '27', '1', '0', '0.947368421', '0.666666667', '0', '0', '12', '1', '0.5', '1']
package org . apache . camel . util ; import java . util . Comparator ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionComparator < E extends Exchange > implements Comparator < E > { private final Expression < E > expression ; public ExpressionComparator ( Expression < E > expression ) { this . expression = expression ; } public int compare ( E e1 , E e2 ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; return ObjectHelper . compare ( o1 , o2 ) ; } } 	0	['3', '1', '0', '5', '6', '1', '2', '3', '3', '0', '31', '1', '1', '0', '0.5', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultUnitOfWork ; import org . apache . camel . spi . UnitOfWork ; public final class UnitOfWorkProcessor extends DelegateAsyncProcessor { public UnitOfWorkProcessor ( AsyncProcessor processor ) { super ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( exchange . getUnitOfWork ( ) == null ) { exchange . setUnitOfWork ( new DefaultUnitOfWork ( ) ) ; return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( sync ) ; exchange . getUnitOfWork ( ) . done ( exchange ) ; exchange . setUnitOfWork ( null ) ; } } ) ; } else { return processor . process ( exchange , callback ) ; } } } 	1	['2', '3', '0', '8', '8', '1', '2', '7', '2', '2', '31', '0', '0', '0.952380952', '0.625', '0', '0', '14.5', '2', '1', '1']
package org . apache . camel . component . jdbc ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . DefaultExchange ; public class JdbcComponent extends DefaultComponent < DefaultExchange > { public JdbcComponent ( ) { } public JdbcComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < DefaultExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new JdbcEndpoint ( uri , remaining , this ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; } } 	0	['5', '3', '0', '4', '10', '10', '1', '4', '2', '2', '25', '0', '0', '0.884615385', '0.4', '2', '2', '4', '1', '0.6', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; public class SerializationDataFormat implements DataFormat { public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { ObjectOutput out = IOConverter . toObjectOutput ( stream ) ; out . writeObject ( graph ) ; out . flush ( ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { ObjectInput in = IOConverter . toObjectInput ( stream ) ; return in . readObject ( ) ; } } 	1	['3', '1', '0', '4', '9', '3', '1', '3', '3', '2', '21', '0', '0', '0', '0.533333333', '0', '0', '6', '1', '0.6667', '1']
package org . apache . camel . component . validator . jing ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . XMLConstants ; import javax . xml . transform . Source ; import javax . xml . transform . sax . SAXSource ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import com . thaiopensource . relaxng . SchemaFactory ; import com . thaiopensource . util . PropertyMap ; import com . thaiopensource . util . PropertyMapBuilder ; import com . thaiopensource . validate . IncorrectSchemaException ; import com . thaiopensource . validate . Schema ; import com . thaiopensource . validate . ValidateProperty ; import com . thaiopensource . validate . Validator ; import com . thaiopensource . xml . sax . Jaxp11XMLReaderCreator ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . processor . validation . DefaultValidationErrorHandler ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . Resource ; public class JingValidator implements Processor { private static final transient Log LOG = LogFactory . getLog ( JingValidator . class ) ; private Schema schema ; private SchemaFactory schemaFactory ; private String schemaNamespace = XMLConstants . RELAXNG_NS_URI ; private Resource schemaResource ; private InputSource inputSource ; private boolean compactSyntax ; public void process ( Exchange exchange ) throws Exception { Jaxp11XMLReaderCreator xmlCreator = new Jaxp11XMLReaderCreator ( ) ; DefaultValidationErrorHandler errorHandler = new DefaultValidationErrorHandler ( ) ; PropertyMapBuilder mapBuilder = new PropertyMapBuilder ( ) ; mapBuilder . put ( ValidateProperty . XML_READER_CREATOR , xmlCreator ) ; mapBuilder . put ( ValidateProperty . ERROR_HANDLER , errorHandler ) ; PropertyMap propertyMap = mapBuilder . toPropertyMap ( ) ; Validator validator = getSchema ( ) . createValidator ( propertyMap ) ; Message in = exchange . getIn ( ) ; SAXSource saxSource = in . getBody ( SAXSource . class ) ; if ( saxSource == null ) { Source source = ExchangeHelper . getMandatoryInBody ( exchange , Source . class ) ; saxSource = ExchangeHelper . convertToMandatoryType ( exchange , SAXSource . class , source ) ; } InputSource bodyInput = saxSource . getInputSource ( ) ; XMLReader reader = xmlCreator . createXMLReader ( ) ; reader . setContentHandler ( validator . getContentHandler ( ) ) ; reader . setDTDHandler ( validator . getDTDHandler ( ) ) ; reader . setErrorHandler ( errorHandler ) ; reader . parse ( bodyInput ) ; errorHandler . handleErrors ( exchange , schema ) ; } public Schema getSchema ( ) throws IOException , IncorrectSchemaException , SAXException { if ( schema == null ) { SchemaFactory factory = getSchemaFactory ( ) ; schema = factory . createSchema ( getInputSource ( ) ) ; } return schema ; } public void setSchema ( Schema schema ) { this . schema = schema ; } public InputSource getInputSource ( ) throws IOException { if ( inputSource == null ) { Resource resource = getSchemaResource ( ) ; if ( resource == null ) { throw new IllegalArgumentException ( "No schemaResource or inputSource specified" ) ; } else { InputStream inputStream = resource . getInputStream ( ) ; if ( inputStream == null ) { throw new IllegalArgumentException ( "No inputStream available for: " + resource ) ; } inputSource = new InputSource ( inputStream ) ; } } return inputSource ; } public void setInputSource ( InputSource inputSource ) { this . inputSource = inputSource ; } public SchemaFactory getSchemaFactory ( ) { if ( schemaFactory == null ) { schemaFactory = new SchemaFactory ( ) ; schemaFactory . setCompactSyntax ( compactSyntax ) ; schemaFactory . setXMLReaderCreator ( new Jaxp11XMLReaderCreator ( ) ) ; } return schemaFactory ; } public void setSchemaFactory ( SchemaFactory schemaFactory ) { this . schemaFactory = schemaFactory ; } public Resource getSchemaResource ( ) { return schemaResource ; } public void setSchemaResource ( Resource schemaResource ) { this . schemaResource = schemaResource ; } public String getSchemaNamespace ( ) { return schemaNamespace ; } public void setSchemaNamespace ( String schemaNamespace ) { this . schemaNamespace = schemaNamespace ; } public boolean isCompactSyntax ( ) { return compactSyntax ; } public void setCompactSyntax ( boolean compactSyntax ) { this . compactSyntax = compactSyntax ; } } 	0	['15', '1', '0', '22', '47', '81', '2', '20', '14', '0.867346939', '218', '1', '1', '0', '0.1875', '0', '0', '13.06666667', '2', '0.9333', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class MulticastProcessor extends ServiceSupport implements Processor { private Collection < Processor > processors ; public MulticastProcessor ( Collection < Processor > processors ) { this . processors = processors ; } public static < E extends Exchange > Collection < Processor > toProducers ( Collection < Endpoint > endpoints ) throws Exception { Collection < Processor > answer = new ArrayList < Processor > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint . createProducer ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "Multicast" + getProcessors ( ) ; } public void process ( Exchange exchange ) throws Exception { for ( Processor producer : processors ) { Exchange copy = copyExchangeStrategy ( producer , exchange ) ; producer . process ( copy ) ; } } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	1	['8', '2', '1', '8', '23', '8', '2', '6', '5', '0.285714286', '82', '1', '0', '0.65', '0.375', '1', '1', '9.125', '1', '0.875', '5']
package org . apache . camel . language . ognl ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; public class RootObject { private final Exchange exchange ; public RootObject ( Exchange exchange ) { this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } public CamelContext getContext ( ) { return exchange . getContext ( ) ; } public Throwable getException ( ) { return exchange . getException ( ) ; } public String getExchangeId ( ) { return exchange . getExchangeId ( ) ; } public Message getFault ( ) { return exchange . getFault ( ) ; } public Message getRequest ( ) { return exchange . getIn ( ) ; } public Message getIn ( ) { return exchange . getIn ( ) ; } public Message getOut ( ) { return exchange . getOut ( ) ; } public Message getResponse ( ) { return exchange . getOut ( ) ; } public Map < String , Object > getProperties ( ) { return exchange . getProperties ( ) ; } public Object getProperty ( String name ) { return exchange . getProperty ( name ) ; } public < T > T getProperty ( String name , Class < T > type ) { return exchange . getProperty ( name , type ) ; } } 	0	['13', '1', '0', '4', '23', '0', '1', '3', '13', '0', '70', '1', '1', '0', '0.326923077', '0', '0', '4.307692308', '1', '0.9231', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import javax . naming . Context ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Processor ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . model . RouteType ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private static final transient Log LOG = LogFactory . getLog ( DefaultCamelContext . class ) ; private static final String NAME_PREFIX = "camel-" ; private static int NAME_SUFFIX = 0 ; private String name ; private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; private LanguageResolver languageResolver = new DefaultLanguageResolver ( ) ; private Registry registry ; private LifecycleStrategy lifecycleStrategy = new DefaultLifecycleStrategy ( ) ; private List < RouteType > routeDefinitions = new ArrayList < RouteType > ( ) ; public DefaultCamelContext ( ) { name = NAME_PREFIX + ++ NAME_SUFFIX ; } public DefaultCamelContext ( Context jndiContext ) { this ( new JndiRegistry ( jndiContext ) ) ; } public DefaultCamelContext ( Registry registry ) { this ( ) ; this . registry = registry ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] != null ) { String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( uri + " converted to endpoint: " + answer + " by component: " + component ) ; } } } if ( answer == null ) { answer = createEndpoint ( uri ) ; } if ( answer != null && answer . isSingleton ( ) ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; lifecycleStrategy . onEndpointAdd ( answer ) ; } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } lifecycleStrategy . onRoutesAdd ( routes ) ; if ( shouldStartRoutes ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; List < Route > routeList = builder . getRouteList ( ) ; LOG . debug ( "Adding routes from: " + builder + " routes: " + routeList ) ; addRoutes ( routeList ) ; } public void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception { this . routeDefinitions . addAll ( routeDefinitions ) ; if ( shouldStartRoutes ( ) ) { startRouteDefinitions ( routeDefinitions ) ; } } public Language resolveLanguage ( String language ) { return getLanguageResolver ( ) . resolveLanguage ( language , this ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } public LanguageResolver getLanguageResolver ( ) { return languageResolver ; } public void setLanguageResolver ( LanguageResolver languageResolver ) { this . languageResolver = languageResolver ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } public Registry getRegistry ( ) { if ( registry == null ) { registry = createRegistry ( ) ; } return registry ; } public void setRegistry ( Registry registry ) { this . registry = registry ; } public LifecycleStrategy getLifecycleStrategy ( ) { return lifecycleStrategy ; } public void setLifecycleStrategy ( LifecycleStrategy lifecycleStrategy ) { this . lifecycleStrategy = lifecycleStrategy ; } public List < RouteType > getRouteDefinitions ( ) { return routeDefinitions ; } protected void doStart ( ) throws Exception { forceLazyInitialization ( ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRouteDefinitions ( routeDefinitions ) ; startRoutes ( routes ) ; } protected void startRouteDefinitions ( Collection < RouteType > list ) throws Exception { if ( list != null ) { for ( RouteType route : list ) { lifecycleStrategy . beforeStartRouteType ( this , route ) ; route . addRoutes ( this ) ; } } } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected void forceLazyInitialization ( ) { getExchangeConverter ( ) ; getInjector ( ) ; getLanguageResolver ( ) ; getTypeConverter ( ) ; } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( getInjector ( ) ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } protected Registry createRegistry ( ) { return new JndiRegistry ( ) ; } protected Endpoint createEndpoint ( String uri ) { Object value = getRegistry ( ) . lookup ( uri ) ; if ( value instanceof Endpoint ) { return ( Endpoint ) value ; } else if ( value instanceof Processor ) { return new ProcessorEndpoint ( uri , this , ( Processor ) value ) ; } else if ( value != null ) { return convertBeanToEndpoint ( uri , value ) ; } return null ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { throw new IllegalArgumentException ( "uri: " + uri + " bean: " + bean + " could not be converted to an Endpoint" ) ; } protected boolean shouldStartRoutes ( ) { return isStarted ( ) && ! isStarting ( ) ; } } 	1	['52', '2', '1', '36', '112', '1166', '4', '33', '38', '0.91349481', '993', '1', '8', '0.213114754', '0.08875129', '1', '1', '17.76923077', '7', '1.3846', '7']
package org . apache . camel . view ; import java . io . PrintWriter ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . model . FromType ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; public class XmlGraphGenerator extends GraphGeneratorSupport { private boolean addUrl = true ; public XmlGraphGenerator ( String dir ) { super ( dir , ".xml" ) ; } protected void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) { writer . println ( "<?xml version='1.0' encoding='UTF-8'?>" ) ; writer . println ( "<Graph>" ) ; writer . println ( ) ; if ( map . size ( ) > 0 ) { writer . println ( "<Node id='root' name='Camel Routes' description='Collection of Camel Routes' nodeType='root'/>" ) ; } printRoutes ( writer , map ) ; writer . println ( ) ; writer . println ( "</Graph>" ) ; } protected void printRoutes ( PrintWriter writer , Map < String , List < RouteType > > map ) { Set < Map . Entry < String , List < RouteType > > > entries = map . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { String group = entry . getKey ( ) ; printRoutes ( writer , group , entry . getValue ( ) ) ; } } protected void printRoutes ( PrintWriter writer , String group , List < RouteType > routes ) { group = encode ( group ) ; if ( group != null ) { int idx = group . lastIndexOf ( '.' ) ; String name = group ; if ( idx > 0 && idx < group . length ( ) - 1 ) { name = group . substring ( idx + 1 ) ; } writer . println ( "<Node id='" + group + "' name='" + name + "' description='" + group + "' nodeType='group'/>" ) ; writer . println ( "<Edge fromID='root' toID='" + group + "'/>" ) ; } for ( RouteType route : routes ) { List < FromType > inputs = route . getInputs ( ) ; boolean first = true ; for ( FromType input : inputs ) { NodeData nodeData = getNodeData ( input ) ; if ( first ) { first = false ; if ( group != null ) { writer . println ( "<Edge fromID='" + group + "' toID='" + encode ( nodeData . id ) + "'/>" ) ; } } printRoute ( writer , route , nodeData ) ; } writer . println ( ) ; } } protected void printRoute ( PrintWriter writer , final RouteType route , NodeData nodeData ) { printNode ( writer , nodeData ) ; List < ProcessorType > outputs = route . getOutputs ( ) ; NodeData from = nodeData ; for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , from , output ) ; from = newData ; } } protected NodeData printNode ( PrintWriter writer , NodeData fromData , ProcessorType node ) { if ( node instanceof MulticastType ) { List < ProcessorType > outputs = node . getOutputs ( ) ; for ( ProcessorType output : outputs ) { printNode ( writer , fromData , output ) ; } return fromData ; } NodeData toData = getNodeData ( node ) ; printNode ( writer , toData ) ; if ( fromData != null ) { writer . print ( "<Edge fromID=\"" ) ; writer . print ( encode ( fromData . id ) ) ; writer . print ( "\" toID=\"" ) ; writer . print ( encode ( toData . id ) ) ; String association = toData . edgeLabel ; if ( isNullOrBlank ( association ) ) { writer . print ( "\" association=\"" ) ; writer . print ( encode ( association ) ) ; } writer . println ( "\"/>" ) ; } List < ProcessorType > outputs = toData . outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , toData , output ) ; if ( ! isMulticastNode ( node ) ) { toData = newData ; } } } return toData ; } protected void printNode ( PrintWriter writer , NodeData data ) { if ( ! data . nodeWritten ) { data . nodeWritten = true ; writer . println ( ) ; writer . print ( "<Node id=\"" ) ; writer . print ( encode ( data . id ) ) ; writer . print ( "\" name=\"" ) ; String name = data . label ; if ( isNullOrBlank ( name ) ) { name = data . tooltop ; } writer . print ( encode ( name ) ) ; writer . print ( "\" nodeType=\"" ) ; String nodeType = data . image ; if ( isNullOrBlank ( nodeType ) ) { nodeType = data . shape ; if ( isNullOrBlank ( nodeType ) ) { nodeType = "node" ; } } writer . print ( encode ( nodeType ) ) ; writer . print ( "\" description=\"" ) ; writer . print ( encode ( data . tooltop ) ) ; if ( addUrl ) { writer . print ( "\" url=\"" ) ; writer . print ( encode ( data . url ) ) ; } writer . println ( "\"/>" ) ; } } protected String encode ( String text ) { if ( text == null ) { return "" ; } return text . replaceAll ( "\"" , "&quot;" ) . replaceAll ( "<" , "&lt;" ) . replaceAll ( ">" , "&gt;" ) . replaceAll ( "&" , "&amp;" ) ; } } 	0	['8', '2', '0', '7', '33', '26', '0', '7', '1', '0.571428571', '417', '1', '0', '0.588235294', '0.390625', '1', '1', '51', '8', '3.625', '0']
package org . apache . camel . processor ; import java . util . Iterator ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class Splitter extends ServiceSupport implements Processor { private final Processor processor ; private final Expression expression ; public Splitter ( Expression expression , Processor destination ) { this . processor = destination ; this . expression = expression ; notNull ( destination , "destination" ) ; notNull ( expression , "expression" ) ; } @ Override public String toString ( ) { return "Splitter[on: " + expression + " to: " + processor + "]" ; } public void process ( Exchange exchange ) throws Exception { Object value = expression . evaluate ( exchange ) ; Iterator iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { Object part = iter . next ( ) ; Exchange newExchange = exchange . copy ( ) ; newExchange . getIn ( ) . setBody ( part ) ; processor . process ( newExchange ) ; } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } } 	1	['5', '2', '0', '9', '21', '0', '1', '8', '3', '0.25', '84', '1', '2', '0.764705882', '0.4', '1', '1', '15.4', '1', '0.8', '2']
package org . apache . camel . component . mail ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import javax . mail . Address ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import org . apache . camel . Exchange ; import org . apache . camel . converter . ObjectConverter ; public class MailBinding { public void populateMailMessage ( MailEndpoint endpoint , MimeMessage mimeMessage , Exchange exchange ) { try { appendHeadersFromCamel ( mimeMessage , exchange , exchange . getIn ( ) ) ; String destination = endpoint . getConfiguration ( ) . getDestination ( ) ; if ( destination != null ) { mimeMessage . setRecipients ( Message . RecipientType . TO , destination ) ; } if ( empty ( mimeMessage . getFrom ( ) ) ) { String from = endpoint . getConfiguration ( ) . getFrom ( ) ; mimeMessage . setFrom ( new InternetAddress ( from ) ) ; } mimeMessage . setText ( exchange . getIn ( ) . getBody ( String . class ) ) ; } catch ( Exception e ) { throw new RuntimeMailException ( "Failed to populate body due to: " + e + ". Exchange: " + exchange , e ) ; } } protected boolean empty ( Address [ ] addresses ) { return addresses == null || addresses . length == 0 ; } public Object extractBodyFromMail ( MailExchange exchange , Message message ) { try { return message . getContent ( ) ; } catch ( Exception e ) { throw new RuntimeMailException ( "Failed to extract body due to: " + e + ". Message: " + message , e ) ; } } protected void appendHeadersFromCamel ( MimeMessage mimeMessage , Exchange exchange , org . apache . camel . Message camelMessage ) throws MessagingException { Set < Map . Entry < String , Object > > entries = camelMessage . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String headerName = entry . getKey ( ) ; Object headerValue = entry . getValue ( ) ; if ( headerValue != null ) { if ( shouldOutputHeader ( camelMessage , headerName , headerValue ) ) { if ( ObjectConverter . isCollection ( headerValue ) ) { Iterator iter = ObjectConverter . iterator ( headerValue ) ; while ( iter . hasNext ( ) ) { Object value = iter . next ( ) ; mimeMessage . addHeader ( headerName , asString ( exchange , value ) ) ; } } else { mimeMessage . setHeader ( headerName , asString ( exchange , headerValue ) ) ; } } } } } protected String asString ( Exchange exchange , Object value ) { return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , value ) ; } protected boolean shouldOutputHeader ( org . apache . camel . Message camelMessage , String headerName , Object headerValue ) { return true ; } } 	0	['7', '1', '0', '11', '38', '21', '4', '9', '3', '2', '167', '0', '0', '0', '0.3', '0', '0', '22.85714286', '3', '1.4286', '0']
package org . apache . camel . model ; import org . apache . camel . model . language . ExpressionType ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . ArrayList ; import java . util . List ; @ XmlRootElement ( name = "serviceActivation" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ServiceActivationType { @ XmlAttribute private String group = "default" ; @ XmlElementRef private List < ExpressionType > uris = new ArrayList < ExpressionType > ( ) ; public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public List < ExpressionType > getUris ( ) { return uris ; } public void setUris ( List < ExpressionType > uris ) { this . uris = uris ; } } 	1	['5', '1', '0', '0', '7', '0', '0', '0', '5', '0.5', '32', '1', '0', '0', '0.466666667', '0', '0', '5', '1', '0.8', '1']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . builder . xml ; public class StreamResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StreamResultHandler ( ) ; } } 	1	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '2']
package org . apache . camel . impl ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class ScheduledPollConsumer < E extends Exchange > extends DefaultConsumer < E > implements Runnable { private static final transient Log LOG = LogFactory . getLog ( ScheduledPollConsumer . class ) ; private final ScheduledExecutorService executor ; private long initialDelay = 1000 ; private long delay = 500 ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; private boolean useFixedDelay ; private ScheduledFuture < ? > future ; public ScheduledPollConsumer ( DefaultEndpoint < E > endpoint , Processor processor ) { this ( endpoint , processor , endpoint . getExecutorService ( ) ) ; } public ScheduledPollConsumer ( Endpoint < E > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor ) ; this . executor = executor ; if ( executor == null ) { throw new IllegalArgumentException ( "A non null ScheduledExecutorService must be provided." ) ; } } public void run ( ) { LOG . debug ( "Starting to poll" ) ; try { poll ( ) ; } catch ( Exception e ) { LOG . warn ( "Caught: " + e , e ) ; } } public long getInitialDelay ( ) { return initialDelay ; } public void setInitialDelay ( long initialDelay ) { this . initialDelay = initialDelay ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } public void setTimeUnit ( TimeUnit timeUnit ) { this . timeUnit = timeUnit ; } public boolean isUseFixedDelay ( ) { return useFixedDelay ; } public void setUseFixedDelay ( boolean useFixedDelay ) { this . useFixedDelay = useFixedDelay ; } protected abstract void poll ( ) throws Exception ; @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( isUseFixedDelay ( ) ) { future = executor . scheduleWithFixedDelay ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } else { future = executor . scheduleAtFixedRate ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } } @ Override protected void doStop ( ) throws Exception { if ( future != null ) { future . cancel ( false ) ; } super . doStop ( ) ; } } 	0	['15', '3', '4', '10', '30', '79', '4', '6', '11', '0.816326531', '146', '1', '1', '0.647058824', '0.205357143', '1', '1', '8.266666667', '1', '0.8', '0']
package org . apache . camel . model ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . ObjectHelper ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; @ XmlRootElement ( name = "from" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FromType { @ XmlAttribute private String uri ; @ XmlAttribute private String ref ; @ XmlTransient private Endpoint endpoint ; public FromType ( ) { } public FromType ( String uri ) { setUri ( uri ) ; } public FromType ( Endpoint endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "From[" + getLabel ( ) + "]" ; } public String getLabel ( ) { return description ( getUri ( ) , getRef ( ) , getEndpoint ( ) ) ; } public Endpoint resolveEndpoint ( RouteContext context ) { if ( endpoint == null ) { endpoint = context . resolveEndpoint ( getUri ( ) , getRef ( ) ) ; } return endpoint ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public Object getUriOrRef ( ) { if ( ObjectHelper . isNullOrBlank ( uri ) ) { return uri ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } return ref ; } protected static String description ( String uri , String ref , Endpoint endpoint ) { if ( ref != null ) { return "ref:" + ref ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } else if ( uri != null ) { return uri ; } else { return "no uri or ref supplied!" ; } } } 	1	['14', '1', '0', '10', '21', '59', '8', '3', '13', '0.641025641', '126', '1', '1', '0', '0.375', '0', '0', '7.785714286', '4', '1.2143', '2']
package org . apache . camel . language . ognl ; import ognl . Ognl ; import ognl . OgnlContext ; import ognl . OgnlException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . impl . ExpressionSupport ; import org . apache . camel . language . ExpressionEvaluationException ; import org . apache . camel . language . IllegalSyntaxException ; import java . util . HashMap ; import java . util . Map ; public class OgnlExpression extends ExpressionSupport < Exchange > { private final String expressionString ; private final Class < ? > type ; private Object expression ; public OgnlExpression ( OgnlLanguage language , String expressionString , Class < ? > type ) { this . expressionString = expressionString ; this . type = type ; try { this . expression = Ognl . parseExpression ( expressionString ) ; } catch ( OgnlException e ) { throw new IllegalSyntaxException ( language , expressionString ) ; } } public static OgnlExpression ognl ( String expression ) { return new OgnlExpression ( new OgnlLanguage ( ) , expression , Object . class ) ; } public Object evaluate ( Exchange exchange ) { Map values = new HashMap ( ) ; populateContext ( values , exchange ) ; OgnlContext oglContext = new OgnlContext ( ) ; try { return Ognl . getValue ( expression , oglContext , new RootObject ( exchange ) ) ; } catch ( OgnlException e ) { throw new ExpressionEvaluationException ( this , exchange , e ) ; } } protected void populateContext ( Map map , Exchange exchange ) { map . put ( "exchange" , exchange ) ; map . put ( "in" , exchange . getIn ( ) ) ; map . put ( "out" , exchange . getOut ( ) ) ; } protected String assertionFailureMessage ( Exchange exchange ) { return expressionString ; } } 	0	['5', '2', '0', '12', '17', '6', '1', '12', '3', '0.583333333', '88', '1', '0', '0.555555556', '0.4', '1', '2', '16', '1', '0.8', '0']
package org . apache . camel . builder . xml ; import java . io . StringReader ; import java . util . List ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpression ; import javax . xml . xpath . XPathExpressionException ; import javax . xml . xpath . XPathFactory ; import javax . xml . xpath . XPathFactoryConfigurationException ; import javax . xml . xpath . XPathFunction ; import javax . xml . xpath . XPathFunctionException ; import javax . xml . xpath . XPathFunctionResolver ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import static org . apache . camel . builder . xml . Namespaces . DEFAULT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . isMatchingNamespaceOrEmptyNamespace ; import static org . apache . camel . converter . ObjectConverter . toBoolean ; public class XPathBuilder < E extends Exchange > implements Expression < E > , Predicate < E > { private final String text ; private XPathFactory xpathFactory ; private Class documentType = Document . class ; private QName resultType = XPathConstants . NODESET ; private String objectModelUri ; private DefaultNamespaceContext namespaceContext ; private XPathFunctionResolver functionResolver ; private XPathExpression expression ; private MessageVariableResolver variableResolver = new MessageVariableResolver ( ) ; private E exchange ; private XPathFunction bodyFunction ; private XPathFunction headerFunction ; private XPathFunction outBodyFunction ; private XPathFunction outHeaderFunction ; public XPathBuilder ( String text ) { this . text = text ; } public static XPathBuilder xpath ( String text ) { return new XPathBuilder ( text ) ; } @ Override public String toString ( ) { return "XPath: " + text ; } public boolean matches ( E exchange ) { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; return toBoolean ( booleanResult ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; if ( ! toBoolean ( booleanResult ) ) { throw new AssertionError ( this + " failed on " + exchange + " as returned <" + booleanResult + ">" ) ; } } public Object evaluate ( E exchange ) { return evaluateAs ( exchange , resultType ) ; } public XPathBuilder < E > booleanResult ( ) { resultType = XPathConstants . BOOLEAN ; return this ; } public XPathBuilder < E > nodeResult ( ) { resultType = XPathConstants . NODE ; return this ; } public XPathBuilder < E > nodeSetResult ( ) { resultType = XPathConstants . NODESET ; return this ; } public XPathBuilder < E > numberResult ( ) { resultType = XPathConstants . NUMBER ; return this ; } public XPathBuilder < E > stringResult ( ) { resultType = XPathConstants . STRING ; return this ; } public XPathBuilder < E > objectModel ( String uri ) { this . objectModelUri = uri ; return this ; } public XPathBuilder < E > functionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; return this ; } public XPathBuilder < E > namespace ( String prefix , String uri ) { getNamespaceContext ( ) . add ( prefix , uri ) ; return this ; } public XPathBuilder < E > variable ( String name , Object value ) { variableResolver . addVariable ( name , value ) ; return this ; } public XPathFactory getXPathFactory ( ) throws XPathFactoryConfigurationException { if ( xpathFactory == null ) { if ( objectModelUri != null ) { xpathFactory = XPathFactory . newInstance ( objectModelUri ) ; } xpathFactory = XPathFactory . newInstance ( ) ; } return xpathFactory ; } public void setXPathFactory ( XPathFactory xpathFactory ) { this . xpathFactory = xpathFactory ; } public Class getDocumentType ( ) { return documentType ; } public void setDocumentType ( Class documentType ) { this . documentType = documentType ; } public String getText ( ) { return text ; } public QName getResultType ( ) { return resultType ; } public void setResultType ( QName resultType ) { this . resultType = resultType ; } public DefaultNamespaceContext getNamespaceContext ( ) { if ( namespaceContext == null ) { try { DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext ( getXPathFactory ( ) ) ; populateDefaultNamespaces ( defaultNamespaceContext ) ; namespaceContext = defaultNamespaceContext ; } catch ( XPathFactoryConfigurationException e ) { throw new RuntimeExpressionException ( e ) ; } } return namespaceContext ; } public void setNamespaceContext ( DefaultNamespaceContext namespaceContext ) { this . namespaceContext = namespaceContext ; } public XPathFunctionResolver getFunctionResolver ( ) { return functionResolver ; } public void setFunctionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; } public XPathExpression getExpression ( ) throws XPathFactoryConfigurationException , XPathExpressionException { if ( expression == null ) { expression = createXPathExpression ( ) ; } return expression ; } public void setNamespacesFromDom ( Element node ) { getNamespaceContext ( ) . setNamespacesFromDom ( node ) ; } public XPathFunction getBodyFunction ( ) { if ( bodyFunction == null ) { bodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getIn ( ) . getBody ( ) ; } } ; } return bodyFunction ; } public void setBodyFunction ( XPathFunction bodyFunction ) { this . bodyFunction = bodyFunction ; } public XPathFunction getHeaderFunction ( ) { if ( headerFunction == null ) { headerFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getIn ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return headerFunction ; } public void setHeaderFunction ( XPathFunction headerFunction ) { this . headerFunction = headerFunction ; } public XPathFunction getOutBodyFunction ( ) { if ( outBodyFunction == null ) { outBodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getOut ( ) . getBody ( ) ; } } ; } return outBodyFunction ; } public void setOutBodyFunction ( XPathFunction outBodyFunction ) { this . outBodyFunction = outBodyFunction ; } public XPathFunction getOutHeaderFunction ( ) { if ( outHeaderFunction == null ) { outHeaderFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getOut ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return outHeaderFunction ; } public void setOutHeaderFunction ( XPathFunction outHeaderFunction ) { this . outHeaderFunction = outHeaderFunction ; } protected synchronized Object evaluateAs ( E exchange , QName resultType ) { this . exchange = exchange ; variableResolver . setExchange ( exchange ) ; try { Object document = getDocument ( exchange ) ; if ( resultType != null ) { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource , resultType ) ; } else { return getExpression ( ) . evaluate ( document , resultType ) ; } } else { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource ) ; } else { return getExpression ( ) . evaluate ( document ) ; } } } catch ( XPathExpressionException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } catch ( XPathFactoryConfigurationException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } } protected XPathExpression createXPathExpression ( ) throws XPathExpressionException , XPathFactoryConfigurationException { XPath xPath = getXPathFactory ( ) . newXPath ( ) ; xpathFactory = null ; xPath . setNamespaceContext ( getNamespaceContext ( ) ) ; xPath . setXPathVariableResolver ( variableResolver ) ; XPathFunctionResolver parentResolver = getFunctionResolver ( ) ; if ( parentResolver == null ) { parentResolver = xPath . getXPathFunctionResolver ( ) ; } xPath . setXPathFunctionResolver ( createDefaultFunctionResolver ( parentResolver ) ) ; return xPath . compile ( text ) ; } protected void populateDefaultNamespaces ( DefaultNamespaceContext context ) { setNamespaceIfNotPresent ( context , "in" , IN_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "out" , OUT_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "env" , Namespaces . ENVIRONMENT_VARIABLES ) ; setNamespaceIfNotPresent ( context , "system" , Namespaces . SYSTEM_PROPERTIES_NAMESPACE ) ; } protected void setNamespaceIfNotPresent ( DefaultNamespaceContext context , String prefix , String uri ) { if ( context != null ) { String current = context . getNamespaceURI ( prefix ) ; if ( current == null ) { context . add ( prefix , uri ) ; } } } protected XPathFunctionResolver createDefaultFunctionResolver ( final XPathFunctionResolver parent ) { return new XPathFunctionResolver ( ) { public XPathFunction resolveFunction ( QName qName , int argumentCount ) { XPathFunction answer = null ; if ( parent != null ) { answer = parent . resolveFunction ( qName , argumentCount ) ; } if ( answer == null ) { if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , IN_NAMESPACE ) || isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , OUT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "out-body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "out-header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } } return answer ; } } ; } protected Object getDocument ( E exchange ) { Message in = exchange . getIn ( ) ; Class type = getDocumentType ( ) ; Object answer = null ; if ( type != null ) { answer = in . getBody ( type ) ; } if ( answer == null ) { answer = in . getBody ( ) ; } if ( answer instanceof String ) { answer = new InputSource ( new StringReader ( answer . toString ( ) ) ) ; } return answer ; } } 	1	['45', '1', '0', '17', '85', '864', '8', '14', '38', '0.907467532', '523', '1', '3', '0', '0.138888889', '0', '0', '10.31111111', '4', '1.2667', '2']
package org . apache . camel . processor ; import java . util . Comparator ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ExpressionListComparator ; public class Resequencer extends BatchProcessor { public Resequencer ( Endpoint endpoint , Processor processor , Expression < Exchange > expression ) { this ( endpoint , processor , createSet ( expression ) ) ; } public Resequencer ( Endpoint endpoint , Processor processor , List < Expression > expressions ) { this ( endpoint , processor , createSet ( expressions ) ) ; } public Resequencer ( Endpoint endpoint , Processor processor , Set < Exchange > collection ) { super ( endpoint , processor , collection ) ; } @ Override public String toString ( ) { return "Resequencer[to: " + getProcessor ( ) + "]" ; } protected static Set < Exchange > createSet ( Expression < Exchange > expression ) { return createSet ( new ExpressionComparator < Exchange > ( expression ) ) ; } protected static Set < Exchange > createSet ( List < Expression > expressions ) { if ( expressions . size ( ) == 1 ) { return createSet ( expressions . get ( 0 ) ) ; } return createSet ( new ExpressionListComparator ( expressions ) ) ; } protected static Set < Exchange > createSet ( Comparator < ? super Exchange > comparator ) { return new TreeSet < Exchange > ( comparator ) ; } } 	0	['7', '3', '0', '8', '18', '21', '2', '6', '4', '2', '66', '0', '0', '0.875', '0.326530612', '0', '0', '8.428571429', '2', '0.7143', '0']
package org . apache . camel . builder . xml ; public interface ResultHandlerFactory { ResultHandler createResult ( ) ; } 	1	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . cxf . interceptors ; import java . util . ResourceBundle ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . soap . interceptor . SoapActionInInterceptor ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class DOMInInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( DOMOutInterceptor . class ) ; private final XMLMessageInInterceptor xmlInterceptor = new XMLMessageInInterceptor ( ) ; private final SoapMessageInInterceptor soapInterceptor = new SoapMessageInInterceptor ( ) ; public DOMInInterceptor ( ) { super ( Phase . READ ) ; this . addAfter ( SoapActionInInterceptor . class . getName ( ) ) ; this . addBefore ( PayloadInInterceptor . class . getName ( ) ) ; } public boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } public void handleMessage ( Message message ) throws Fault { if ( message instanceof XMLMessage ) { xmlInterceptor . handleMessage ( ( XMLMessage ) message ) ; } else if ( message instanceof SoapMessage ) { soapInterceptor . handleMessage ( ( SoapMessage ) message ) ; } else { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NOT_SUPPORTED_MESSAGE" , LOG , message . getClass ( ) . getName ( ) ) ) ; } } } 	0	['4', '0', '0', '10', '18', '2', '1', '9', '3', '0.666666667', '75', '1', '2', '0', '0.833333333', '0', '0', '17', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "sql" ) public class SqlExpression extends ExpressionType { public SqlExpression ( ) { } public SqlExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "sql" ; } } 	1	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '1']
package org . apache . camel . component . mina ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class MinaExchange extends DefaultExchange { public MinaExchange ( CamelContext camelContext , ExchangePattern pattern ) { super ( camelContext , pattern ) ; } } 	0	['1', '2', '0', '5', '2', '0', '2', '3', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . management ; import org . apache . camel . Exchange ; import org . apache . camel . processor . DelegateProcessor ; public class InstrumentationProcessor extends DelegateProcessor { private PerformanceCounter counter ; InstrumentationProcessor ( PerformanceCounter counter ) { this . counter = counter ; } public void process ( Exchange exchange ) throws Exception { long startTime = System . nanoTime ( ) ; super . process ( exchange ) ; if ( counter != null ) { if ( exchange . getException ( ) == null ) { counter . completedExchange ( ( System . nanoTime ( ) - startTime ) / 1000 ) ; } else { counter . completedExchange ( ) ; } } } } 	1	['2', '3', '0', '4', '8', '0', '1', '3', '1', '0', '33', '1', '1', '0.954545455', '0.666666667', '0', '0', '15', '1', '0.5', '3']
package org . apache . camel . builder . script ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "js" ) public @ interface JavaScript { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . Converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . CachingInjector ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . reflect . Method ; import static java . lang . reflect . Modifier . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . StringTokenizer ; public class AnnotationTypeConverterLoader implements TypeConverterLoader { public static final String META_INF_SERVICES = "META-INF/services/org/apache/camel/TypeConverter" ; private static final transient Log LOG = LogFactory . getLog ( AnnotationTypeConverterLoader . class ) ; private ResolverUtil resolver = new ResolverUtil ( ) ; private Set < Class > visitedClasses = new HashSet < Class > ( ) ; public void load ( TypeConverterRegistry registry ) throws Exception { String [ ] packageNames = findPackageNames ( ) ; resolver . findAnnotated ( Converter . class , packageNames ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class type : classes ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading converter class: " + ObjectHelper . name ( type ) ) ; } loadConverterMethods ( registry , type ) ; } } protected String [ ] findPackageNames ( ) throws IOException { Set < String > packages = new HashSet < String > ( ) ; findPackages ( packages , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; findPackages ( packages , getClass ( ) . getClassLoader ( ) ) ; return packages . toArray ( new String [ packages . size ( ) ] ) ; } protected void findPackages ( Set < String > packages , ClassLoader classLoader ) throws IOException { Enumeration < URL > resources = classLoader . getResources ( META_INF_SERVICES ) ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; if ( url != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; try { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) { continue ; } tokenize ( packages , line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Caught exception closing stream: " + e , e ) ; } } } } } protected void tokenize ( Set < String > packages , String line ) { StringTokenizer iter = new StringTokenizer ( line , "," ) ; while ( iter . hasMoreTokens ( ) ) { String name = iter . nextToken ( ) . trim ( ) ; if ( name . length ( ) > 0 ) { packages . add ( name ) ; } } } protected void loadConverterMethods ( TypeConverterRegistry registry , Class type ) { if ( visitedClasses . contains ( type ) ) { return ; } visitedClasses . add ( type ) ; try { Method [ ] methods = type . getDeclaredMethods ( ) ; CachingInjector injector = null ; for ( Method method : methods ) { Converter annotation = method . getAnnotation ( Converter . class ) ; if ( annotation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes == null || parameterTypes . length != 1 ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method should have one parameter" ) ; } else { int modifiers = method . getModifiers ( ) ; if ( isAbstract ( modifiers ) || ! isPublic ( modifiers ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method is not a public and concrete method" ) ; } else { Class toType = method . getReturnType ( ) ; if ( toType . equals ( Void . class ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method returns a void method" ) ; } else { Class fromType = parameterTypes [ 0 ] ; if ( isStatic ( modifiers ) ) { registerTypeConverter ( registry , method , toType , fromType , new StaticMethodTypeConverter ( method ) ) ; } else { if ( injector == null ) { injector = new CachingInjector ( registry , type ) ; } registerTypeConverter ( registry , method , toType , fromType , new InstanceMethodTypeConverter ( injector , method ) ) ; } } } } } } Class superclass = type . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { loadConverterMethods ( registry , superclass ) ; } } catch ( NoClassDefFoundError e ) { LOG . debug ( "Ignoring converter type: " + type . getName ( ) + " as a dependent class could not be found: " + e , e ) ; } } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { registry . addTypeConverter ( toType , fromType , typeConverter ) ; } } 	1	['8', '1', '1', '13', '64', '12', '2', '11', '2', '0.785714286', '388', '0.75', '2', '0', '0.321428571', '0', '0', '47', '11', '2.125', '5']
package org . apache . camel . builder ; import org . apache . camel . Processor ; public interface ProcessorFactory { Processor createProcessor ( ) throws Exception ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; public class PropertyEditorTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) == String . class ) { if ( toType == String . class ) { return ObjectHelper . cast ( toType , value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( toType ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return ObjectHelper . cast ( toType , editor . getValue ( ) ) ; } } else if ( toType == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( value . getClass ( ) ) ; if ( editor != null ) { editor . setValue ( value ) ; return ObjectHelper . cast ( toType , editor . getAsText ( ) ) ; } } return null ; } } 	1	['2', '1', '0', '3', '11', '1', '1', '2', '2', '2', '54', '0', '0', '0', '0.666666667', '0', '0', '26', '6', '3', '1']
package org . apache . camel . component . event ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . TopicLoadBalancer ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationEvent ; public class EventEndpoint extends DefaultEndpoint < Exchange > { private final EventComponent component ; private LoadBalancer loadBalancer ; public EventEndpoint ( String endpointUri , EventComponent component ) { super ( endpointUri , component ) ; this . component = component ; } @ Override public EventComponent getComponent ( ) { return component ; } public ApplicationContext getApplicationContext ( ) { return getComponent ( ) . getApplicationContext ( ) ; } public boolean isSingleton ( ) { return true ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { ApplicationEvent event = toApplicationEvent ( exchange ) ; getApplicationContext ( ) . publishEvent ( event ) ; } } ; } public EventConsumer createConsumer ( Processor processor ) throws Exception { return new EventConsumer ( this , processor ) ; } public void onApplicationEvent ( ApplicationEvent event ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( event ) ; try { getLoadBalancer ( ) . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public LoadBalancer getLoadBalancer ( ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( ) ; } return loadBalancer ; } public void setLoadBalancer ( LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } public synchronized void consumerStarted ( EventConsumer consumer ) { getLoadBalancer ( ) . addProcessor ( consumer . getProcessor ( ) ) ; } public synchronized void consumerStopped ( EventConsumer consumer ) { getLoadBalancer ( ) . removeProcessor ( consumer . getProcessor ( ) ) ; } protected LoadBalancer createLoadBalancer ( ) { return new TopicLoadBalancer ( ) ; } protected ApplicationEvent toApplicationEvent ( Exchange exchange ) { ApplicationEvent event = exchange . getIn ( ) . getBody ( ApplicationEvent . class ) ; if ( event == null ) { event = new CamelEvent ( this , exchange ) ; } return event ; } } 	0	['15', '2', '0', '18', '28', '101', '5', '17', '13', '0.75', '118', '1', '2', '0.548387097', '0.2', '1', '1', '6.733333333', '2', '1.0667', '0']
package org . apache . camel . impl ; import java . util . concurrent . Future ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class DefaultConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > { private Endpoint < E > endpoint ; private Processor processor ; private AsyncProcessor asyncProcessor ; private ExceptionHandler exceptionHandler ; public DefaultConsumer ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "Consumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } public AsyncProcessor getAsyncProcessor ( ) { if ( asyncProcessor == null ) { asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; } return asyncProcessor ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	1	['10', '2', '12', '22', '21', '17', '13', '9', '7', '0.777777778', '90', '1', '4', '0.590909091', '0.28', '1', '1', '7.6', '2', '1.1', '3']
package org . apache . camel . impl ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . ObjectHelper ; public class ReflectionInjector implements Injector { public < T > T newInstance ( Class < T > type ) { return ObjectHelper . newInstance ( type ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '2', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . camel . component . bean ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BeanComponent extends DefaultComponent { private static final Log LOG = LogFactory . getLog ( BeanComponent . class ) ; private ParameterMappingStrategy parameterMappingStrategy ; public BeanComponent ( ) { } public ProcessorEndpoint createEndpoint ( Object bean ) { String uri = "bean:generated:" + bean ; return createEndpoint ( bean , uri ) ; } public ProcessorEndpoint createEndpoint ( Object bean , String uri ) { BeanProcessor processor = new BeanProcessor ( bean , getCamelContext ( ) , getParameterMappingStrategy ( ) ) ; return createEndpoint ( uri , processor ) ; } public ParameterMappingStrategy getParameterMappingStrategy ( ) { if ( parameterMappingStrategy == null ) { parameterMappingStrategy = createParameterMappingStrategy ( ) ; } return parameterMappingStrategy ; } public void setParameterMappingStrategy ( ParameterMappingStrategy parameterMappingStrategy ) { this . parameterMappingStrategy = parameterMappingStrategy ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Object bean = getBean ( remaining ) ; BeanProcessor processor = new BeanProcessor ( bean , getCamelContext ( ) , getParameterMappingStrategy ( ) ) ; setProperties ( processor , parameters ) ; return createEndpoint ( uri , processor ) ; } public Object getBean ( String remaining ) throws NoBeanAvailableException { Registry registry = getCamelContext ( ) . getRegistry ( ) ; Object bean = registry . lookup ( remaining ) ; if ( bean == null ) { throw new NoBeanAvailableException ( remaining ) ; } return bean ; } protected ProcessorEndpoint createEndpoint ( String uri , BeanProcessor processor ) { ProcessorEndpoint answer = new ProcessorEndpoint ( uri , this , processor ) ; answer . setExchangePattern ( ExchangePattern . InOut ) ; return answer ; } protected ParameterMappingStrategy createParameterMappingStrategy ( ) { return BeanProcessor . createParameterMappingStrategy ( getCamelContext ( ) ) ; } } 	1	['10', '3', '0', '13', '25', '43', '0', '13', '6', '0.833333333', '116', '1', '2', '0.741935484', '0.333333333', '1', '2', '10.4', '2', '0.9', '3']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; @ XmlRootElement ( name = "longHeader" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class LongHeader extends HeaderType { @ XmlAttribute ( name = "value" ) private Long number ; public LongHeader ( ) { } public LongHeader ( String name , Long number ) { super ( name ) ; this . number = number ; } public Long getNumber ( ) { return number ; } public void setNumber ( Long number ) { this . number = number ; } public Object getValue ( ) { return getNumber ( ) ; } public void setValue ( Object value ) { if ( value instanceof Number ) { Number n = ( Number ) value ; setNumber ( n . longValue ( ) ) ; } else { throw new IllegalArgumentException ( "Value must be a Long" ) ; } } } 	0	['6', '2', '0', '2', '11', '9', '1', '1', '6', '0.2', '45', '1', '0', '0.5', '0.416666667', '0', '0', '6.333333333', '2', '0.8333', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Method ; public interface MethodInvocation { Method getMethod ( ) ; Object [ ] getArguments ( ) ; Object proceed ( ) throws Throwable ; Object getThis ( ) ; AccessibleObject getStaticPart ( ) ; } 	1	['5', '1', '0', '4', '5', '10', '4', '0', '5', '2', '5', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "javaScript" ) public class JavaScriptExpression extends ExpressionType { public JavaScriptExpression ( ) { } public JavaScriptExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "js" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . model . config ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . processor . StreamResequencer ; import org . apache . camel . processor . resequencer . DefaultExchangeComparator ; import org . apache . camel . processor . resequencer . ExpressionResultComparator ; @ XmlRootElement @ XmlAccessorType ( XmlAccessType . FIELD ) public class StreamResequencerConfig { @ XmlAttribute private Integer capacity ; @ XmlAttribute private Long timeout ; @ XmlTransient private ExpressionResultComparator < Exchange > comparator ; public StreamResequencerConfig ( ) { this ( 100 , 1000L ) ; } public StreamResequencerConfig ( int capacity , long timeout ) { this ( capacity , timeout , new DefaultExchangeComparator ( ) ) ; } public StreamResequencerConfig ( int capacity , long timeout , ExpressionResultComparator < Exchange > comparator ) { this . capacity = capacity ; this . timeout = timeout ; this . comparator = comparator ; } public static StreamResequencerConfig getDefault ( ) { return new StreamResequencerConfig ( ) ; } public int getCapacity ( ) { return capacity ; } public void setCapacity ( int capacity ) { this . capacity = capacity ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public ExpressionResultComparator < Exchange > getComparator ( ) { return comparator ; } public void setComparator ( ExpressionResultComparator < Exchange > comparator ) { this . comparator = comparator ; } } 	1	['10', '1', '0', '3', '16', '27', '1', '2', '10', '0.666666667', '69', '1', '1', '0', '0.425', '0', '0', '5.6', '1', '0.7', '1']
package org . apache . camel . converter . jaxb ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . Unmarshaller ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . IOHelper ; public class JaxbDataFormat implements DataFormat { private JAXBContext context ; private String contextPath ; private boolean prettyPrint = true ; private Marshaller marshaller ; private Unmarshaller unmarshaller ; public JaxbDataFormat ( ) { } public JaxbDataFormat ( JAXBContext context ) { this . context = context ; } public JaxbDataFormat ( String contextPath ) { this . contextPath = contextPath ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { try { getMarshaller ( ) . marshal ( graph , stream ) ; } catch ( JAXBException e ) { throw IOHelper . createIOException ( e ) ; } } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { try { return getUnmarshaller ( ) . unmarshal ( stream ) ; } catch ( JAXBException e ) { throw IOHelper . createIOException ( e ) ; } } public JAXBContext getContext ( ) throws JAXBException { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( JAXBContext context ) { this . context = context ; } public Marshaller getMarshaller ( ) throws JAXBException { if ( marshaller == null ) { marshaller = getContext ( ) . createMarshaller ( ) ; } return marshaller ; } public void setMarshaller ( Marshaller marshaller ) { this . marshaller = marshaller ; } public boolean isPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } public Unmarshaller getUnmarshaller ( ) throws JAXBException { if ( unmarshaller == null ) { unmarshaller = getContext ( ) . createUnmarshaller ( ) ; } return unmarshaller ; } public void setUnmarshaller ( Unmarshaller unmarshaller ) { this . unmarshaller = unmarshaller ; } protected JAXBContext createContext ( ) throws JAXBException { if ( contextPath != null ) { return JAXBContext . newInstance ( contextPath ) ; } else { return JAXBContext . newInstance ( ) ; } } } 	0	['14', '1', '0', '3', '22', '59', '0', '3', '13', '0.753846154', '125', '1', '0', '0', '0.178571429', '0', '0', '7.571428571', '1', '0.7857', '0']
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ProducerCache ; public class CamelTemplate < E extends Exchange > extends ServiceSupport implements ProducerTemplate < E > { private CamelContext context ; private ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public CamelTemplate ( CamelContext context ) { this . context = context ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , exchange ) ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( String endpointUri , Processor processor , AsyncCallback callback ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor , callback ) ; } public E send ( String endpointUri , ExchangePattern pattern , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , pattern , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = endpoint . createExchange ( exchange ) ; producerCache . send ( endpoint , convertedExchange ) ; return convertedExchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { return producerCache . send ( endpoint , processor , callback ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { return producerCache . send ( endpoint , pattern , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) { E result = send ( endpoint , pattern , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( Endpoint < E > endpoint , Object body ) { E result = send ( endpoint , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , body ) ; } public Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , pattern , body ) ; } public Object sendBodyAndHeader ( String endpointUri , final Object body , final String header , final Object headerValue ) { return sendBodyAndHeader ( resolveMandatoryEndpoint ( endpointUri ) , body , header , headerValue ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeaders ( String endpointUri , final Object body , final Map < String , Object > headers ) { return sendBodyAndHeaders ( resolveMandatoryEndpoint ( endpointUri ) , body , headers ) ; } public Object sendBodyAndHeaders ( Endpoint endpoint , final Object body , final Map < String , Object > headers ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public E request ( Endpoint < E > endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( Endpoint < E > endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public E request ( String endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( String endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Object sendBodyAndHeader ( Object body , String header , Object headerValue ) { return sendBodyAndHeader ( getMandatoryDefaultEndpoint ( ) , body , header , headerValue ) ; } public Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) { return sendBodyAndHeaders ( getMandatoryDefaultEndpoint ( ) , body , headers ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } protected Processor createBodyAndHeaderProcessor ( final Object body , final String header , final Object headerValue ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ; } protected Processor createSetBodyProcessor ( final Object body ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected Object extractResultBody ( E result ) { Object answer = null ; if ( result != null ) { answer = result . getOut ( ) . getBody ( ) ; if ( answer == null ) { answer = result . getIn ( ) . getBody ( ) ; } } return answer ; } } 	1	['45', '2', '0', '21', '67', '916', '8', '16', '38', '0.686363636', '461', '1', '3', '0.232142857', '0.252525253', '1', '1', '9.133333333', '5', '1.0889', '2']
package org . apache . camel . builder . script ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "beanshell" ) public @ interface BeanShell { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeleteFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( DeleteFileProcessStrategy . class ) ; public DeleteFileProcessStrategy ( ) { } public DeleteFileProcessStrategy ( boolean lockFile ) { super ( lockFile ) ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Deleting file: " + file ) ; } file . delete ( ) ; super . commit ( endpoint , exchange , file ) ; } } 	1	['4', '2', '0', '5', '15', '4', '1', '5', '3', '0.666666667', '38', '1', '1', '0.857142857', '0.466666667', '0', '0', '8.25', '1', '0.25', '1']
package org . apache . camel . component . cxf ; import org . apache . camel . * ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class CxfSoapProducer implements Producer , AsyncProcessor { private static final Log LOG = LogFactory . getLog ( CxfSoapProducer . class ) ; private final CxfSoapEndpoint endpoint ; private final Producer producer ; private final AsyncProcessor processor ; public CxfSoapProducer ( CxfSoapEndpoint endpoint ) throws Exception { this . endpoint = endpoint ; this . producer = endpoint . getInnerEndpoint ( ) . createProducer ( ) ; this . processor = new AsyncProcessorDecorator ( producer , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapProviderIn ( exchange ) ; } } , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapProviderOut ( exchange ) ; } } ) ; } public Endpoint getEndpoint ( ) { return producer . getEndpoint ( ) ; } public Exchange createExchange ( ) { return producer . createExchange ( ) ; } public Exchange createExchange ( ExchangePattern pattern ) { return producer . createExchange ( pattern ) ; } public Exchange createExchange ( Exchange exchange ) { return producer . createExchange ( exchange ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { return processor . process ( exchange , callback ) ; } public void start ( ) throws Exception { producer . start ( ) ; } public void stop ( ) throws Exception { producer . stop ( ) ; } protected void processSoapProviderIn ( Exchange exchange ) throws Exception { LOG . info ( "processSoapProviderIn: " + exchange ) ; } protected void processSoapProviderOut ( Exchange exchange ) throws Exception { LOG . info ( "processSoapProviderOut: " + exchange ) ; } } 	0	['12', '1', '0', '14', '32', '16', '3', '14', '9', '0.795454545', '104', '1', '4', '0', '0.345454545', '0', '0', '7.333333333', '1', '0.8333', '0']
package org . apache . camel . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . lang . annotation . Annotation ; import java . net . URL ; import java . net . URLDecoder ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarInputStream ; public class ResolverUtil < T > { private static final transient Log LOG = LogFactory . getLog ( ResolverUtil . class ) ; public static interface Test { boolean matches ( Class type ) ; } public static class IsA implements Test { private Class parent ; public IsA ( Class parentType ) { this . parent = parentType ; } public boolean matches ( Class type ) { return type != null && parent . isAssignableFrom ( type ) ; } @ Override public String toString ( ) { return "is assignable to " + parent . getSimpleName ( ) ; } } public static class AnnotatedWith implements Test { private Class < ? extends Annotation > annotation ; public AnnotatedWith ( Class < ? extends Annotation > annotation ) { this . annotation = annotation ; } public boolean matches ( Class type ) { return type != null && type . isAnnotationPresent ( annotation ) ; } @ Override public String toString ( ) { return "annotated with @" + annotation . getSimpleName ( ) ; } } private Set < Class < ? extends T > > matches = new HashSet < Class < ? extends T > > ( ) ; private Set < ClassLoader > classLoaders ; public Set < Class < ? extends T > > getClasses ( ) { return matches ; } public Set < ClassLoader > getClassLoaders ( ) { if ( classLoaders == null ) { classLoaders = new HashSet < ClassLoader > ( ) ; classLoaders . add ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } return classLoaders ; } public void setClassLoaders ( Set < ClassLoader > classLoaders ) { this . classLoaders = classLoaders ; } public void findImplementations ( Class parent , String ... packageNames ) { if ( packageNames == null ) { return ; } LOG . debug ( "Searching for implementations of " + parent . getName ( ) + " in packages: " + Arrays . asList ( packageNames ) ) ; Test test = new IsA ( parent ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } LOG . debug ( "Found: " + getClasses ( ) ) ; } public void findAnnotated ( Class < ? extends Annotation > annotation , String ... packageNames ) { if ( packageNames == null ) { return ; } Test test = new AnnotatedWith ( annotation ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } } public void find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; for ( ClassLoader classLoader : set ) { LOG . trace ( "Searching: " + classLoader ) ; find ( test , packageName , classLoader ) ; } } protected void find ( Test test , String packageName , ClassLoader loader ) { Enumeration < URL > urls ; try { urls = loader . getResources ( packageName ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not read package: " + packageName , ioe ) ; return ; } while ( urls . hasMoreElements ( ) ) { try { URL url = urls . nextElement ( ) ; String urlPath = url . getFile ( ) ; urlPath = URLDecoder . decode ( urlPath , "UTF-8" ) ; if ( urlPath . startsWith ( "file:" ) ) { urlPath = urlPath . substring ( 5 ) ; } if ( urlPath . indexOf ( '!' ) > 0 ) { urlPath = urlPath . substring ( 0 , urlPath . indexOf ( '!' ) ) ; } LOG . debug ( "Scanning for classes in [" + urlPath + "] matching criteria: " + test ) ; File file = new File ( urlPath ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageName , file ) ; } else { loadImplementationsInJar ( test , packageName , file ) ; } } catch ( IOException ioe ) { LOG . warn ( "could not read entries" , ioe ) ; } } } private void loadImplementationsInDirectory ( Test test , String parent , File location ) { File [ ] files = location . listFiles ( ) ; StringBuilder builder = null ; for ( File file : files ) { builder = new StringBuilder ( 100 ) ; String name = file . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; } builder . append ( parent ) . append ( "/" ) . append ( name ) ; String packageOrClass = parent == null ? name : builder . toString ( ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageOrClass , file ) ; } else if ( name . endsWith ( ".class" ) ) { addIfMatching ( test , packageOrClass ) ; } } } private void loadImplementationsInJar ( Test test , String parent , File jarfile ) { try { JarEntry entry ; JarInputStream jarStream = new JarInputStream ( new FileInputStream ( jarfile ) ) ; while ( ( entry = jarStream . getNextJarEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; } if ( ! entry . isDirectory ( ) && name . startsWith ( parent ) && name . endsWith ( ".class" ) ) { addIfMatching ( test , name ) ; } } } catch ( IOException ioe ) { LOG . error ( "Could not search jar file '" + jarfile + "' for classes matching criteria: " + test + "due to an IOException: " + ioe . getMessage ( ) ) ; } } protected void addIfMatching ( Test test , String fqn ) { try { String externalName = fqn . substring ( 0 , fqn . indexOf ( '.' ) ) . replace ( '/' , '.' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; boolean found = false ; for ( ClassLoader classLoader : set ) { LOG . trace ( "Checking to see if class " + externalName + " matches criteria [" + test + "]" ) ; try { Class type = classLoader . loadClass ( externalName ) ; if ( test . matches ( type ) ) { matches . add ( ( Class < T > ) type ) ; } found = true ; break ; } catch ( ClassNotFoundException e ) { LOG . debug ( "Could not find class '" + fqn + "' in class loader: " + classLoader + ". Reason: " + e , e ) ; } } if ( ! found ) { LOG . warn ( "Could not find class '" + fqn + "' in any class loaders: " + set ) ; } } catch ( Throwable t ) { LOG . warn ( "Could not examine class '" + fqn + "' due to a " + t . getClass ( ) . getName ( ) + " with message: " + t . getMessage ( ) ) ; } } } 	1	['12', '1', '0', '7', '62', '28', '2', '5', '7', '0.545454545', '507', '1', '1', '0', '0.329545455', '0', '0', '41', '6', '2.3333', '6']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; @ XmlRootElement ( name = "header" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class StringHeader extends HeaderType { @ XmlAttribute ( name = "value" , required = true ) private String text ; public StringHeader ( ) { } public StringHeader ( String name , String text ) { super ( name ) ; this . text = text ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } public Object getValue ( ) { return getText ( ) ; } public void setValue ( Object value ) { if ( value instanceof String ) { setText ( ( String ) value ) ; } else { throw new IllegalArgumentException ( "Value must be a String" ) ; } } } 	0	['6', '2', '0', '2', '9', '9', '1', '1', '6', '0.2', '41', '1', '0', '0.5', '0.5', '0', '0', '5.666666667', '2', '0.8333', '0']
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; import javax . xml . namespace . QName ; public class XPathLanguage implements Language { private QName resultType ; public Predicate < Exchange > createPredicate ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public Expression < Exchange > createExpression ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public QName getResultType ( ) { return resultType ; } public void setResultType ( QName resultType ) { this . resultType = resultType ; } protected void configureBuilder ( XPathBuilder builder ) { if ( resultType != null ) { builder . setResultType ( resultType ) ; } } } 	1	['6', '1', '0', '4', '9', '9', '0', '4', '5', '0.2', '41', '1', '0', '0', '0.416666667', '0', '0', '5.666666667', '2', '1', '1']
package org . apache . camel . bam ; import java . util . Date ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . TemporalRule ; import org . apache . camel . util . ObjectHelper ; public abstract class TimeExpression { private ActivityRules activityRules ; private ActivityBuilder builder ; private ActivityLifecycle lifecycle ; public TimeExpression ( ActivityBuilder builder , ActivityLifecycle lifecycle ) { this . lifecycle = lifecycle ; this . builder = builder ; this . activityRules = builder . getActivityRules ( ) ; } public boolean isActivityLifecycle ( ActivityRules activityRules , ActivityLifecycle lifecycle ) { return ObjectHelper . equals ( activityRules , this . activityRules ) && ObjectHelper . equals ( lifecycle , this . lifecycle ) ; } public TemporalRule after ( TimeExpression expression ) { TemporalRule rule = new TemporalRule ( expression , this ) ; rule . getSecond ( ) . getActivityRules ( ) . addRule ( rule ) ; return rule ; } public Date evaluate ( ProcessInstance processInstance ) { ActivityState state = processInstance . getActivityState ( activityRules ) ; if ( state != null ) { return evaluate ( processInstance , state ) ; } return null ; } public abstract Date evaluate ( ProcessInstance instance , ActivityState state ) ; public ActivityBuilder getBuilder ( ) { return builder ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ActivityLifecycle getLifecycle ( ) { return lifecycle ; } public ActivityState getActivityState ( ProcessInstance instance ) { return instance . getActivityState ( activityRules ) ; } public ActivityState getOrCreateActivityState ( ProcessInstance instance ) { return instance . getOrCreateActivityState ( activityRules ) ; } } 	0	['10', '1', '2', '9', '18', '9', '4', '7', '10', '0.666666667', '86', '1', '3', '0', '0.285714286', '0', '0', '7.3', '3', '1.2', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . ExceptionType ; import java . util . IdentityHashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; public abstract class ErrorHandlerSupport extends ServiceSupport implements ErrorHandler { private Map < Class , ExceptionType > exceptionPolicices = new IdentityHashMap < Class , ExceptionType > ( ) ; public void addExceptionPolicy ( ExceptionType exception ) { Processor processor = exception . getErrorHandler ( ) ; addChildService ( processor ) ; List < Class > list = exception . getExceptionClasses ( ) ; for ( Class exceptionType : list ) { exceptionPolicices . put ( exceptionType , exception ) ; } } protected boolean customProcessorForException ( Exchange exchange , Throwable exception ) throws Exception { ExceptionType policy = getExceptionPolicy ( exchange , exception ) ; Processor processor = policy . getErrorHandler ( ) ; if ( processor != null ) { processor . process ( exchange ) ; return true ; } return false ; } protected ExceptionType getExceptionPolicy ( Exchange exchange , Throwable exception ) { Set < Map . Entry < Class , ExceptionType > > entries = exceptionPolicices . entrySet ( ) ; for ( Map . Entry < Class , ExceptionType > entry : entries ) { Class type = entry . getKey ( ) ; if ( type . isInstance ( exception ) ) { return entry . getValue ( ) ; } } return null ; } } 	1	['4', '2', '2', '10', '19', '0', '5', '5', '2', '0', '86', '1', '0', '0.8125', '0.5625', '0', '0', '20.25', '2', '1.25', '2']
package org . apache . camel . component . irc ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . schwering . irc . lib . IRCConnection ; import org . schwering . irc . lib . IRCEventAdapter ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcConsumer extends DefaultConsumer < IrcExchange > { private static final transient Log LOG = LogFactory . getLog ( IrcConsumer . class ) ; private final IrcConfiguration configuration ; private final IrcEndpoint endpoint ; private final IRCConnection connection ; private FilteredIRCEventAdapter listener ; public IrcConsumer ( IrcEndpoint endpoint , Processor processor , IRCConnection connection ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . connection = connection ; configuration = endpoint . getConfiguration ( ) ; } @ Override protected void doStop ( ) throws Exception { String target = endpoint . getConfiguration ( ) . getTarget ( ) ; connection . doPart ( target ) ; connection . removeIRCEventListener ( listener ) ; super . doStop ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; String target = endpoint . getConfiguration ( ) . getTarget ( ) ; connection . addIRCEventListener ( new FilteredIRCEventAdapter ( target ) ) ; LOG . debug ( "joining: " + target ) ; connection . doJoin ( target ) ; } public IRCConnection getConnection ( ) { return connection ; } class FilteredIRCEventAdapter extends IRCEventAdapter { final String target ; public FilteredIRCEventAdapter ( String target ) { this . target = target ; } @ Override public void onNick ( IRCUser user , String newNick ) { if ( configuration . isOnNick ( ) ) { IrcExchange exchange = endpoint . createOnNickExchange ( user , newNick ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } @ Override public void onQuit ( IRCUser user , String msg ) { if ( configuration . isOnQuit ( ) ) { IrcExchange exchange = endpoint . createOnQuitExchange ( user , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } @ Override public void onJoin ( String channel , IRCUser user ) { if ( configuration . isOnJoin ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnJoinExchange ( channel , user ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onKick ( String channel , IRCUser user , String passiveNick , String msg ) { if ( configuration . isOnKick ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnKickExchange ( channel , user , passiveNick , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onMode ( String channel , IRCUser user , IRCModeParser modeParser ) { if ( configuration . isOnMode ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnModeExchange ( channel , user , modeParser ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onPart ( String channel , IRCUser user , String msg ) { if ( configuration . isOnPart ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnPartExchange ( channel , user , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onTopic ( String channel , IRCUser user , String topic ) { if ( configuration . isOnTopic ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnTopicExchange ( channel , user , topic ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onPrivmsg ( String target , IRCUser user , String msg ) { if ( configuration . isOnPrivmsg ( ) ) { if ( target . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnPrivmsgExchange ( target , user , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } } } 	0	['7', '3', '0', '10', '22', '0', '2', '10', '2', '0.733333333', '88', '1', '4', '0.814814815', '0.3', '1', '1', '10.85714286', '1', '0.7143', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "catch" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CatchType extends ProcessorType { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; public CatchType ( ) { } public CatchType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public CatchType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Catch[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return getExceptionClasses ( ) . toString ( ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1	['16', '2', '0', '6', '33', '62', '1', '5', '15', '0.65', '190', '1', '0', '0.877358491', '0.375', '1', '4', '10.625', '2', '0.9375', '3']
package org . apache . camel . spring ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . model . IdentifiedType ; import org . apache . camel . model . RouteContainer ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import javax . management . MBeanServer ; import javax . xml . bind . annotation . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ XmlRootElement ( name = "camelContext" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelContextFactoryBean extends IdentifiedType implements RouteContainer , FactoryBean , InitializingBean , DisposableBean , ApplicationContextAware , ApplicationListener { private static final Log LOG = LogFactory . getLog ( CamelContextFactoryBean . class ) ; @ XmlElement ( name = "package" , required = false ) private String [ ] packages = { } ; @ XmlElements ( { @ XmlElement ( name = "beanPostProcessor" , type = CamelBeanPostProcessor . class , required = false ) , @ XmlElement ( name = "proxy" , type = CamelProxyFactoryType . class , required = false ) , @ XmlElement ( name = "export" , type = CamelServiceExporterType . class , required = false ) , @ XmlElement ( name = "jmxAgent" , required = false ) } ) private List beans ; @ XmlElement ( name = "endpoint" , required = false ) private List < EndpointFactoryBean > endpoints ; @ XmlElement ( name = "route" , required = false ) private List < RouteType > routes = new ArrayList < RouteType > ( ) ; @ XmlAttribute ( required = false ) private Boolean useJmx ; @ XmlAttribute ( required = false ) private String mbeanServer ; @ XmlTransient private SpringCamelContext context ; @ XmlTransient private RouteBuilder routeBuilder ; @ XmlTransient private List < RouteBuilder > additionalBuilders = new ArrayList < RouteBuilder > ( ) ; @ XmlTransient private ApplicationContext applicationContext ; @ XmlTransient private ClassLoader contextClassLoaderOnStart ; @ XmlTransient private InstrumentationAgent instrumentationAgent ; public CamelContextFactoryBean ( ) { contextClassLoaderOnStart = Thread . currentThread ( ) . getContextClassLoader ( ) ; } public Object getObject ( ) throws Exception { return getContext ( ) ; } public Class getObjectType ( ) { return SpringCamelContext . class ; } public boolean isSingleton ( ) { return true ; } public void afterPropertiesSet ( ) throws Exception { getContext ( ) . addRouteDefinitions ( routes ) ; if ( instrumentationAgent == null && isJmxEnabled ( ) ) { SpringInstrumentationAgent agent = new SpringInstrumentationAgent ( ) ; agent . setCamelContext ( getContext ( ) ) ; String name = getMbeanServer ( ) ; if ( name != null ) { MBeanServer mbeanServer = ( MBeanServer ) getApplicationContext ( ) . getBean ( name , MBeanServer . class ) ; agent . setMBeanServer ( mbeanServer ) ; } instrumentationAgent = agent ; instrumentationAgent . start ( ) ; } LOG . debug ( "Found JAXB created routes: " + getRoutes ( ) ) ; findRouteBuiders ( ) ; installRoutes ( ) ; } public void destroy ( ) throws Exception { getContext ( ) . stop ( ) ; } public void onApplicationEvent ( ApplicationEvent event ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Publishing event: " + event ) ; } if ( event instanceof ContextRefreshedEvent ) { try { LOG . debug ( "Starting the context now!" ) ; getContext ( ) . start ( ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } public SpringCamelContext getContext ( ) throws Exception { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( SpringCamelContext context ) { this . context = context ; } public List < RouteType > getRoutes ( ) { return routes ; } public void setRoutes ( List < RouteType > routes ) { this . routes = routes ; } public RouteBuilder getRouteBuilder ( ) { return routeBuilder ; } public void setRouteBuilder ( RouteBuilder routeBuilder ) { this . routeBuilder = routeBuilder ; } public void setRouteBuilders ( RouteBuilder [ ] builders ) { for ( RouteBuilder builder : builders ) { additionalBuilders . add ( builder ) ; } } public ApplicationContext getApplicationContext ( ) { if ( applicationContext == null ) { throw new IllegalArgumentException ( "No applicationContext has been injected!" ) ; } return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String [ ] getPackages ( ) { return packages ; } public void setPackages ( String [ ] packages ) { this . packages = packages ; } public String getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( String mbeanServer ) { this . mbeanServer = mbeanServer ; } public boolean isJmxEnabled ( ) { return useJmx != null && useJmx . booleanValue ( ) ; } public Boolean getUseJmx ( ) { return useJmx ; } public void setUseJmx ( Boolean useJmx ) { this . useJmx = useJmx ; } protected SpringCamelContext createContext ( ) { SpringCamelContext ctx = new SpringCamelContext ( getApplicationContext ( ) ) ; ctx . setName ( getId ( ) ) ; return ctx ; } protected void installRoutes ( ) throws Exception { Map builders = getApplicationContext ( ) . getBeansOfType ( RouteBuilder . class , true , true ) ; if ( builders != null ) { for ( Object builder : builders . values ( ) ) { getContext ( ) . addRoutes ( ( RouteBuilder ) builder ) ; } } for ( RouteBuilder routeBuilder : additionalBuilders ) { getContext ( ) . addRoutes ( routeBuilder ) ; } if ( routeBuilder != null ) { getContext ( ) . addRoutes ( routeBuilder ) ; } } protected void findRouteBuiders ( ) throws Exception , InstantiationException { if ( packages != null && packages . length > 0 ) { RouteBuilderFinder finder = new RouteBuilderFinder ( getContext ( ) , packages , contextClassLoaderOnStart ) ; finder . appendBuilders ( additionalBuilders ) ; } } } 	0	['27', '2', '0', '20', '62', '293', '1', '19', '23', '0.905325444', '343', '1', '4', '0.074074074', '0.134615385', '0', '0', '11.22222222', '3', '1.1481', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . util . * ; @ Converter public class CollectionConverter { private CollectionConverter ( ) { } @ Converter public static Object [ ] toArray ( Collection value ) { if ( value == null ) { return null ; } return value . toArray ( ) ; } @ Converter public static List toList ( Object [ ] array ) { return Arrays . asList ( array ) ; } @ Converter public static List toList ( Collection collection ) { return new ArrayList ( collection ) ; } @ Converter public static Set toSet ( Object [ ] array ) { Set answer = new HashSet ( ) ; for ( Object element : array ) { answer . add ( element ) ; } return answer ; } @ Converter public static Set toSet ( Collection collection ) { return new HashSet ( collection ) ; } @ Converter public static Set toSet ( Map map ) { return map . entrySet ( ) ; } @ Converter public static Properties toProperties ( Map map ) { Properties answer = new Properties ( ) ; answer . putAll ( map ) ; return answer ; } @ Converter public static Hashtable toHashtable ( Map map ) { return new Hashtable ( map ) ; } @ Converter public static HashMap toHashMap ( Map map ) { return new HashMap ( map ) ; } } 	1	['10', '1', '0', '0', '22', '45', '0', '0', '9', '2', '81', '0', '0', '0', '0.25', '0', '0', '7.1', '2', '1.1', '2']
package org . apache . camel . converter . jaxb ; import org . apache . camel . Message ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; @ XmlRootElement ( name = "message" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class MessageType { @ XmlElementRef ( type = HeaderType . class ) List < HeaderType > headers = new ArrayList < HeaderType > ( ) ; @ XmlAnyElement ( lax = true ) @ XmlMixed private List content = new ArrayList ( ) ; @ XmlTransient private Object body ; public Object getBody ( ) { if ( body == null ) { if ( content != null ) { if ( content . size ( ) == 1 ) { return content . get ( 0 ) ; } else { return content ; } } } return body ; } public void setBody ( Object body ) { this . body = body ; if ( body instanceof List ) { content = ( List ) body ; } else { content = new ArrayList ( ) ; content . add ( body ) ; } } public List < HeaderType > getHeaders ( ) { return headers ; } public void setHeaders ( List < HeaderType > headers ) { this . headers = headers ; } public Map < String , Object > getHeaderMap ( ) { Map < String , Object > answer = new HashMap < String , Object > ( ) ; for ( HeaderType header : headers ) { answer . put ( header . getName ( ) , header . getValue ( ) ) ; } return answer ; } public void copyFrom ( Message message ) { headers . clear ( ) ; Set < Map . Entry < String , Object > > entries = message . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { Object value = entry . getValue ( ) ; if ( value != null ) { headers . add ( createHeader ( entry . getKey ( ) , value ) ) ; } } setBody ( message . getBody ( ) ) ; } public void copyTo ( Message message ) { message . setHeaders ( getHeaderMap ( ) ) ; message . setBody ( getBody ( ) ) ; } protected HeaderType createHeader ( String key , Object value ) { if ( value instanceof String ) { return new StringHeader ( key , ( String ) value ) ; } else if ( value instanceof Integer ) { return new IntegerHeader ( key , ( Integer ) value ) ; } else if ( value instanceof Long ) { return new LongHeader ( key , ( Long ) value ) ; } else { return new StringHeader ( key , value . toString ( ) ) ; } } } 	0	['9', '1', '0', '6', '34', '10', '1', '5', '8', '0.5', '185', '0.666666667', '0', '0', '0.333333333', '0', '0', '19.22222222', '4', '1.8889', '0']
package org . apache . camel . impl ; import org . apache . camel . Service ; import org . apache . camel . util . ServiceHelper ; import java . util . ArrayList ; import java . util . Collection ; import java . util . concurrent . atomic . AtomicBoolean ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; public abstract class ServiceSupport implements Service { private static int threadCounter ; private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean starting = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; private Collection childServices ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { starting . set ( true ) ; try { if ( childServices != null ) { ServiceHelper . startServices ( childServices ) ; } doStart ( ) ; } finally { starting . set ( false ) ; } } } public void stop ( ) throws Exception { if ( started . get ( ) && stopping . compareAndSet ( false , true ) ) { try { doStop ( ) ; } finally { if ( childServices != null ) { ServiceHelper . stopServices ( childServices ) ; } stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStarting ( ) { return starting . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } protected boolean isRunAllowed ( ) { return ! ( stopping . get ( ) || stopped . get ( ) ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; protected String getThreadName ( String prefix ) { return prefix + " thread:" + nextThreadCounter ( ) ; } protected static synchronized int nextThreadCounter ( ) { return ++ threadCounter ; } protected void addChildService ( Object childService ) { if ( childServices == null ) { childServices = new ArrayList ( ) ; } childServices . add ( childService ) ; } protected boolean removeChildService ( Object childService ) { if ( childServices != null ) { return childServices . remove ( childService ) ; } else { return false ; } } } 	1	['14', '1', '27', '31', '28', '49', '29', '2', '7', '0.807692308', '200', '1', '0', '0', '0.380952381', '0', '0', '12.85714286', '3', '1.2143', '1']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . camel . ExchangePattern ; public abstract class RemoteFileEndpoint < T extends RemoteFileExchange > extends ScheduledPollEndpoint < T > { private RemoteFileBinding binding ; private RemoteFileConfiguration configuration ; public RemoteFileEndpoint ( String uri , RemoteFileComponent component , RemoteFileConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; } protected RemoteFileBinding createRemoteFileBinding ( ) { return new RemoteFileBinding ( ) ; } public T createExchange ( ) { return ( T ) new RemoteFileExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) ) ; } public T createExchange ( ExchangePattern pattern ) { return ( T ) new RemoteFileExchange ( getContext ( ) , pattern , getBinding ( ) ) ; } public T createExchange ( String fullFileName , ByteArrayOutputStream outputStream ) { return ( T ) new RemoteFileExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , getConfiguration ( ) . getHost ( ) , fullFileName , outputStream ) ; } public RemoteFileBinding getBinding ( ) { if ( binding == null ) { binding = createRemoteFileBinding ( ) ; } return binding ; } public void setBinding ( RemoteFileBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return true ; } public RemoteFileConfiguration getConfiguration ( ) { return configuration ; } } 	0	['11', '3', '2', '17', '16', '51', '9', '9', '10', '0.6', '85', '1', '2', '0.677419355', '0.246753247', '1', '1', '6.545454545', '2', '1', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . IntrospectionSupport ; @ XmlType ( name = "dataFormatType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DataFormatType { @ XmlTransient private DataFormat dataFormat ; @ XmlTransient private String dataFormatTypeName ; public DataFormatType ( ) { } public DataFormatType ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } protected DataFormatType ( String dataFormatTypeName ) { this . dataFormatTypeName = dataFormatTypeName ; } public DataFormat getDataFormat ( RouteContext routeContext ) { if ( dataFormat == null ) { dataFormat = createDataFormat ( routeContext ) ; ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; configureDataFormat ( dataFormat ) ; } return dataFormat ; } protected DataFormat createDataFormat ( RouteContext routeContext ) { if ( dataFormatTypeName != null ) { Class type = ObjectHelper . loadClass ( dataFormatTypeName , getClass ( ) . getClassLoader ( ) ) ; if ( type == null ) { throw new IllegalArgumentException ( "The class " + dataFormatTypeName + " is not on the classpath! Cannot use the dataFormat " + this ) ; } return ( DataFormat ) ObjectHelper . newInstance ( type ) ; } return null ; } protected void configureDataFormat ( DataFormat dataFormat ) { } protected void setProperty ( DataFormat dataFormat , String name , Object value ) { try { IntrospectionSupport . setProperty ( dataFormat , name , value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Failed to set property " + name + " on " + dataFormat + ". Reason: " + e , e ) ; } } } 	1	['7', '1', '4', '12', '20', '17', '8', '4', '3', '0.75', '108', '1', '1', '0', '0.428571429', '0', '0', '14.14285714', '3', '1', '2']
package org . apache . camel . util . jndi ; import java . util . Hashtable ; import javax . naming . Context ; import javax . naming . NamingException ; import javax . naming . spi . InitialContextFactory ; public class CamelInitialContextFactory implements InitialContextFactory { public Context getInitialContext ( Hashtable environment ) throws NamingException { try { return new JndiContext ( environment ) ; } catch ( NamingException e ) { throw e ; } catch ( Exception e ) { NamingException exception = new NamingException ( e . getMessage ( ) ) ; exception . initCause ( e ) ; throw exception ; } } } 	0	['2', '1', '0', '1', '7', '1', '0', '1', '2', '2', '26', '0', '0', '0', '0.75', '0', '0', '12', '1', '0.5', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import javax . xml . transform . stream . StreamSource ; public class BytesSource extends StreamSource { private byte [ ] data ; public BytesSource ( byte [ ] data ) { this . data = data ; } public BytesSource ( byte [ ] data , String systemId ) { this . data = data ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { return new ByteArrayInputStream ( data ) ; } public Reader getReader ( ) { return new InputStreamReader ( getInputStream ( ) ) ; } public byte [ ] getData ( ) { return data ; } public String toString ( ) { return "BytesSource[" + new String ( data ) + "]" ; } } 	1	['6', '2', '0', '1', '14', '0', '1', '0', '6', '0', '52', '1', '0', '0.692307692', '0.5', '0', '0', '7.5', '1', '0.6667', '1']
package org . apache . camel . component . cxf ; import java . net . URI ; import org . apache . camel . Processor ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . component . cxf . util . UriUtils ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . endpoint . ServerImpl ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; public class CxfConsumer extends DefaultConsumer < CxfExchange > { private CxfEndpoint endpoint ; private Server server ; public CxfConsumer ( CxfEndpoint endpoint , Processor processor ) throws Exception { super ( endpoint , processor ) ; this . endpoint = endpoint ; try { Bus bus = BusFactory . getDefaultBus ( ) ; ServerFactoryBean svrBean = null ; if ( endpoint . isSpringContextEndpoint ( ) ) { CxfEndpointBean endpointBean = endpoint . getCxfEndpointBean ( ) ; svrBean = CxfEndpointUtils . getServerFactoryBean ( endpointBean . getServiceClass ( ) ) ; endpoint . configure ( svrBean ) ; CxfEndpointBean cxfEndpointBean = endpoint . getCxfEndpointBean ( ) ; if ( cxfEndpointBean . getServiceName ( ) != null ) { svrBean . getServiceFactory ( ) . setServiceName ( cxfEndpointBean . getServiceName ( ) ) ; } if ( cxfEndpointBean . getEndpointName ( ) != null ) { svrBean . getServiceFactory ( ) . setEndpointName ( cxfEndpointBean . getEndpointName ( ) ) ; } } else { Class serviceClass = ClassLoaderUtils . loadClass ( endpoint . getServiceClass ( ) , this . getClass ( ) ) ; svrBean = CxfEndpointUtils . getServerFactoryBean ( serviceClass ) ; svrBean . setAddress ( endpoint . getAddress ( ) ) ; svrBean . setServiceClass ( serviceClass ) ; if ( endpoint . getServiceName ( ) != null ) { svrBean . getServiceFactory ( ) . setServiceName ( CxfEndpointUtils . getServiceName ( endpoint ) ) ; } if ( endpoint . getPortName ( ) != null ) { svrBean . getServiceFactory ( ) . setEndpointName ( CxfEndpointUtils . getPortName ( endpoint ) ) ; } if ( endpoint . getWsdlURL ( ) != null ) { svrBean . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } } DataFormat dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; if ( dataFormat . equals ( DataFormat . POJO ) ) { svrBean . setInvoker ( new CamelInvoker ( this ) ) ; } svrBean . setBus ( bus ) ; svrBean . setStart ( false ) ; server = svrBean . create ( ) ; if ( ! dataFormat . equals ( DataFormat . POJO ) ) { CxfMessageObserver observer = new CxfMessageObserver ( this , server . getEndpoint ( ) , bus , dataFormat ) ; ServerImpl serverImpl = ( ServerImpl ) server ; serverImpl . setMessageObserver ( observer ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; server . start ( ) ; } @ Override protected void doStop ( ) throws Exception { server . stop ( ) ; super . doStop ( ) ; } public CxfEndpoint getEndpoint ( ) { return endpoint ; } } 	0	['5', '3', '0', '19', '43', '2', '3', '19', '3', '0.5', '157', '1', '1', '0.846153846', '0.466666667', '1', '1', '30', '1', '0.8', '0']
package org . apache . camel . builder ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . Route ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . InterceptType ; import org . apache . camel . model . OtherwiseType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . RoutesType ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . DelegateProcessor ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; public abstract class RouteBuilder extends BuilderSupport { private AtomicBoolean initalized = new AtomicBoolean ( false ) ; private RoutesType routeCollection = new RoutesType ( ) ; private List < Route > routes = new ArrayList < Route > ( ) ; public RouteBuilder ( ) { this ( null ) ; } public RouteBuilder ( CamelContext context ) { super ( context ) ; } @ Override public String toString ( ) { return routeCollection . toString ( ) ; } public abstract void configure ( ) throws Exception ; public RouteType from ( String uri ) { RouteType answer = routeCollection . from ( uri ) ; configureRoute ( answer ) ; return answer ; } public RouteType from ( Endpoint endpoint ) { RouteType answer = routeCollection . from ( endpoint ) ; configureRoute ( answer ) ; return answer ; } public RouteBuilder errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } public RouteBuilder inheritErrorHandler ( boolean value ) { routeCollection . setInheritErrorHandlerFlag ( value ) ; return this ; } public RouteBuilder intercept ( DelegateProcessor interceptor ) { routeCollection . intercept ( interceptor ) ; return this ; } public InterceptType intercept ( ) { return routeCollection . intercept ( ) ; } public OtherwiseType intercept ( Predicate predicate ) { return routeCollection . intercept ( predicate ) ; } public ExceptionType exception ( Class exceptionType ) { return routeCollection . exception ( exceptionType ) ; } public CamelContext getContext ( ) { CamelContext context = super . getContext ( ) ; if ( context == null ) { context = createContainer ( ) ; setContext ( context ) ; } return context ; } public List < Route > getRouteList ( ) throws Exception { checkInitialized ( ) ; return routes ; } protected void checkInitialized ( ) throws Exception { if ( initalized . compareAndSet ( false , true ) ) { configure ( ) ; populateRoutes ( routes ) ; } } protected void populateRoutes ( List < Route > routes ) throws Exception { CamelContext camelContext = getContext ( ) ; if ( camelContext == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } routeCollection . setCamelContext ( camelContext ) ; camelContext . addRouteDefinitions ( routeCollection . getRoutes ( ) ) ; } public void setRouteCollection ( RoutesType routeCollection ) { this . routeCollection = routeCollection ; } protected CamelContext createContainer ( ) { return new DefaultCamelContext ( ) ; } protected void configureRoute ( RouteType route ) { route . setGroup ( getClass ( ) . getName ( ) ) ; } } 	1	['19', '2', '3', '17', '44', '55', '7', '12', '15', '0.666666667', '168', '1', '1', '0.622222222', '0.131578947', '1', '3', '7.684210526', '2', '0.9474', '3']
package org . apache . camel . component . mail ; import javax . mail . internet . MimeMessage ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . mail . javamail . JavaMailSender ; import org . springframework . mail . javamail . MimeMessagePreparator ; public class MailProducer extends DefaultProducer < MailExchange > { private static final transient Log LOG = LogFactory . getLog ( MailProducer . class ) ; private final MailEndpoint endpoint ; private final JavaMailSender sender ; public MailProducer ( MailEndpoint endpoint , JavaMailSender sender ) { super ( endpoint ) ; this . endpoint = endpoint ; this . sender = sender ; } public void process ( final Exchange exchange ) { sender . send ( new MimeMessagePreparator ( ) { public void prepare ( MimeMessage mimeMessage ) throws Exception { endpoint . getBinding ( ) . populateMailMessage ( endpoint , mimeMessage , exchange ) ; } } ) ; } } 	0	['4', '3', '0', '9', '8', '2', '2', '9', '2', '0.777777778', '33', '1', '2', '0.904761905', '0.4', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . UuidGenerator ; import java . util . HashMap ; import java . util . Map ; public class DefaultExchange implements Exchange { private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > properties ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId = DefaultExchange . DEFAULT_ID_GENERATOR . generateId ( ) ; private UnitOfWork unitOfWork ; private ExchangePattern pattern ; public DefaultExchange ( CamelContext context ) { this ( context , ExchangePattern . InOnly ) ; } public DefaultExchange ( CamelContext context , ExchangePattern pattern ) { this . context = context ; this . pattern = pattern ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setProperties ( safeCopy ( exchange . getProperties ( ) ) ) ; safeCopy ( getIn ( ) , exchange , exchange . getIn ( ) ) ; Message copyOut = exchange . getOut ( false ) ; if ( copyOut != null ) { safeCopy ( getOut ( true ) , exchange , copyOut ) ; } Message copyFault = exchange . getFault ( false ) ; if ( copyFault != null ) { safeCopy ( getFault ( true ) , exchange , copyFault ) ; } setException ( exchange . getException ( ) ) ; unitOfWork = exchange . getUnitOfWork ( ) ; pattern = exchange . getPattern ( ) ; } private static void safeCopy ( Message message , Exchange exchange , Message that ) { if ( message != null ) { message . copyFrom ( that ) ; } } private static Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) { return null ; } return new HashMap < String , Object > ( properties ) ; } private static Message safeCopy ( Exchange exchange , Message message ) { if ( message == null ) { return null ; } Message answer = message . copy ( ) ; if ( answer instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) answer ; messageSupport . setExchange ( exchange ) ; } return answer ; } public Exchange newInstance ( ) { return new DefaultExchange ( context ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( properties != null ) { return properties . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { getProperties ( ) . put ( name , value ) ; } public Object removeProperty ( String name ) { return getProperties ( ) . remove ( name ) ; } public Map < String , Object > getProperties ( ) { if ( properties == null ) { properties = new HashMap < String , Object > ( ) ; } return properties ; } public void setProperties ( Map < String , Object > properties ) { this . properties = properties ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } public void throwException ( ) throws Exception { if ( exception == null ) { return ; } if ( exception instanceof Exception ) { throw ( Exception ) exception ; } if ( exception instanceof RuntimeException ) { throw ( RuntimeException ) exception ; } throw new RuntimeCamelException ( exception ) ; } public Message getFault ( ) { return getFault ( true ) ; } public Message getFault ( boolean lazyCreate ) { if ( fault == null && lazyCreate ) { fault = createFaultMessage ( ) ; configureMessage ( fault ) ; } return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } public boolean isFailed ( ) { Message faultMessage = getFault ( false ) ; if ( faultMessage != null ) { Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { return true ; } } return getException ( ) != null ; } public UnitOfWork getUnitOfWork ( ) { return unitOfWork ; } public void setUnitOfWork ( UnitOfWork unitOfWork ) { this . unitOfWork = unitOfWork ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected Message createFaultMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1	['39', '1', '11', '23', '67', '687', '13', '10', '31', '0.897368421', '405', '1', '7', '0', '0.13377193', '0', '0', '9.128205128', '4', '1.3846', '4']
package org . apache . camel . processor ; public enum LoggingLevel { DEBUG , ERROR , FATAL , INFO , TRACE , WARN ; } 	0	['4', '2', '0', '11', '7', '4', '10', '1', '2', '0.952380952', '89', '0.142857143', '7', '0.857142857', '0.444444444', '1', '1', '19.5', '1', '0.5', '0']
package org . apache . camel . builder . xml ; public class DomResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new DomResultHandler ( ) ; } } 	1	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '2']
package org . apache . camel . processor . validation ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public class NoXmlBodyValidationException extends ValidationException { public NoXmlBodyValidationException ( Exchange exchange ) { super ( exchange , "No XML body could be found on the input message" + exchange ) ; } } 	0	['1', '6', '0', '3', '6', '0', '1', '2', '1', '2', '13', '0', '0', '1', '1', '0', '0', '12', '0', '0', '0']
package org . apache . camel . component . bean ; import org . apache . camel . * ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . language . LanguageAnnotation ; import static org . apache . camel . util . ExchangeHelper . convertToType ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; public class BeanInfo { private static final transient Log LOG = LogFactory . getLog ( BeanInfo . class ) ; private final CamelContext camelContext ; private Class type ; private ParameterMappingStrategy strategy ; private Map < String , MethodInfo > operations = new ConcurrentHashMap < String , MethodInfo > ( ) ; private MethodInfo defaultMethod ; private List < MethodInfo > operationsWithBody = new ArrayList < MethodInfo > ( ) ; public BeanInfo ( CamelContext camelContext , Class type , ParameterMappingStrategy strategy ) { this . camelContext = camelContext ; this . type = type ; this . strategy = strategy ; introspect ( getType ( ) ) ; if ( operations . size ( ) == 1 ) { Collection < MethodInfo > methodInfos = operations . values ( ) ; for ( MethodInfo methodInfo : methodInfos ) { defaultMethod = methodInfo ; } } } public Class getType ( ) { return type ; } public CamelContext getCamelContext ( ) { return camelContext ; } public MethodInvocation createInvocation ( Method method , Object pojo , Exchange exchange ) throws RuntimeCamelException { MethodInfo methodInfo = introspect ( type , method ) ; if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } public MethodInvocation createInvocation ( Object pojo , Exchange exchange ) throws RuntimeCamelException , AmbiguousMethodCallException { MethodInfo methodInfo = null ; String name = exchange . getIn ( ) . getHeader ( BeanProcessor . METHOD_NAME , String . class ) ; if ( name != null ) { methodInfo = operations . get ( name ) ; } if ( methodInfo == null ) { methodInfo = chooseMethod ( pojo , exchange ) ; } if ( methodInfo == null ) { methodInfo = defaultMethod ; } if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } protected void introspect ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( isValidMethod ( clazz , method ) ) { introspect ( clazz , method ) ; } } Class superclass = clazz . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { introspect ( superclass ) ; } } protected MethodInfo introspect ( Class clazz , Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parametersAnnotations = method . getParameterAnnotations ( ) ; final Expression [ ] parameterExpressions = new Expression [ parameterTypes . length ] ; List < ParameterInfo > parameters = new ArrayList < ParameterInfo > ( ) ; List < ParameterInfo > bodyParameters = new ArrayList < ParameterInfo > ( ) ; boolean hasCustomAnnotation = false ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { Class parameterType = parameterTypes [ i ] ; Annotation [ ] parameterAnnotations = parametersAnnotations [ i ] ; Expression expression = createParameterUnmarshalExpression ( clazz , method , parameterType , parameterAnnotations ) ; hasCustomAnnotation |= expression != null ; if ( expression == null ) { hasCustomAnnotation |= ObjectHelper . hasAnnotation ( parameterAnnotations , Body . class ) ; if ( bodyParameters . isEmpty ( ) ) { expression = ExpressionBuilder . bodyExpression ( parameterType ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No expression available for method: " + method . toString ( ) + " which already has a body so ignoring parameter: " + i + " so ignoring method" ) ; } return null ; } } ParameterInfo parameterInfo = new ParameterInfo ( i , parameterType , parameterAnnotations , expression ) ; parameters . add ( parameterInfo ) ; if ( isPossibleBodyParameter ( parameterAnnotations ) ) { bodyParameters . add ( parameterInfo ) ; } } String opName = method . getName ( ) ; MethodInfo methodInfo = new MethodInfo ( clazz , method , parameters , bodyParameters , hasCustomAnnotation ) ; operations . put ( opName , methodInfo ) ; if ( methodInfo . hasBodyParameter ( ) ) { operationsWithBody . add ( methodInfo ) ; } return methodInfo ; } protected MethodInfo chooseMethod ( Object pojo , Exchange exchange ) throws AmbiguousMethodCallException { if ( operationsWithBody . size ( ) == 1 ) { return operationsWithBody . get ( 0 ) ; } else if ( ! operationsWithBody . isEmpty ( ) ) { Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; if ( body != null ) { Class bodyType = body . getClass ( ) ; List < MethodInfo > possibles = new ArrayList < MethodInfo > ( ) ; for ( MethodInfo methodInfo : operationsWithBody ) { if ( methodInfo . bodyParameterMatches ( bodyType ) ) { possibles . add ( methodInfo ) ; } } if ( possibles . size ( ) == 1 ) { return possibles . get ( 0 ) ; } else if ( possibles . isEmpty ( ) ) { Object newBody = null ; MethodInfo matched = null ; for ( MethodInfo methodInfo : operationsWithBody ) { Object value = convertToType ( exchange , methodInfo . getBodyParameterType ( ) , body ) ; if ( value != null ) { if ( newBody != null ) { throw new AmbiguousMethodCallException ( exchange , Arrays . asList ( matched , methodInfo ) ) ; } else { newBody = value ; matched = methodInfo ; } } } if ( matched != null ) { in . setBody ( newBody ) ; return matched ; } } else { MethodInfo chosen = null ; for ( MethodInfo possible : possibles ) { if ( possible . isHasCustomAnnotation ( ) ) { if ( chosen != null ) { chosen = null ; break ; } else { chosen = possible ; } } } if ( chosen != null ) { return chosen ; } throw new AmbiguousMethodCallException ( exchange , possibles ) ; } } return null ; } return null ; } protected Expression createParameterUnmarshalExpression ( Class clazz , Method method , Class parameterType , Annotation [ ] parameterAnnotation ) { for ( Annotation annotation : parameterAnnotation ) { Expression answer = createParameterUnmarshalExpressionForAnnotation ( clazz , method , parameterType , annotation ) ; if ( answer != null ) { return answer ; } } return strategy . getDefaultParameterTypeExpression ( parameterType ) ; } protected boolean isPossibleBodyParameter ( Annotation [ ] annotations ) { if ( annotations != null ) { for ( Annotation annotation : annotations ) { if ( ( annotation instanceof Property ) || ( annotation instanceof Header ) ) { return false ; } } } return true ; } protected Expression createParameterUnmarshalExpressionForAnnotation ( Class clazz , Method method , Class parameterType , Annotation annotation ) { if ( annotation instanceof Property ) { Property propertyAnnotation = ( Property ) annotation ; return ExpressionBuilder . propertyExpression ( propertyAnnotation . name ( ) ) ; } else if ( annotation instanceof Properties ) { return ExpressionBuilder . propertiesExpresion ( ) ; } else if ( annotation instanceof Header ) { Header headerAnnotation = ( Header ) annotation ; return ExpressionBuilder . headerExpression ( headerAnnotation . name ( ) ) ; } else if ( annotation instanceof Headers ) { return ExpressionBuilder . headersExpresion ( ) ; } else { LanguageAnnotation languageAnnotation = annotation . annotationType ( ) . getAnnotation ( LanguageAnnotation . class ) ; if ( languageAnnotation != null ) { Class < ? > type = languageAnnotation . factory ( ) ; Object object = camelContext . getInjector ( ) . newInstance ( type ) ; if ( object instanceof AnnotationExpressionFactory ) { AnnotationExpressionFactory expressionFactory = ( AnnotationExpressionFactory ) object ; return expressionFactory . createExpression ( camelContext , annotation , languageAnnotation , parameterType ) ; } else { LOG . error ( "Ignoring bad annotation: " + languageAnnotation + "on method: " + method + " which declares a factory: " + type . getName ( ) + " which does not implement " + AnnotationExpressionFactory . class . getName ( ) ) ; } } } return null ; } protected boolean isValidMethod ( Class clazz , Method method ) { return Modifier . isPublic ( method . getModifiers ( ) ) ; } } 	1	['13', '1', '0', '23', '77', '48', '1', '22', '5', '0.738095238', '614', '1', '4', '0', '0.314814815', '0', '0', '45.69230769', '8', '2.6154', '9']
package org . apache . camel . util ; import java . util . LinkedHashMap ; import java . util . Map ; public class LRUCache < K , V > extends LinkedHashMap < K , V > { private static final long serialVersionUID = - 342098639681884413L ; private int maxCacheSize = 10000 ; public LRUCache ( int maximumCacheSize ) { this ( maximumCacheSize , maximumCacheSize , 0.75f , true ) ; } public LRUCache ( int initialCapacity , int maximumCacheSize , float loadFactor , boolean accessOrder ) { super ( initialCapacity , loadFactor , accessOrder ) ; this . maxCacheSize = maximumCacheSize ; } public int getMaxCacheSize ( ) { return maxCacheSize ; } protected boolean removeEldestEntry ( Map . Entry entry ) { return size ( ) > maxCacheSize ; } } 	0	['4', '4', '0', '1', '6', '0', '1', '0', '3', '0.666666667', '37', '1', '0', '0.972222222', '0.45', '0', '0', '7.75', '2', '0.75', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlRootElement ( name = "filter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FilterType extends ExpressionNode { public FilterType ( ) { } public FilterType ( ExpressionType expression ) { super ( expression ) ; } public FilterType ( Predicate predicate ) { super ( predicate ) ; } @ Override public String toString ( ) { return "Filter[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1	['6', '3', '0', '9', '15', '15', '3', '6', '6', '2', '42', '0', '0', '0.971428571', '0.416666667', '2', '3', '6', '1', '0.5', '3']
package org . apache . camel ; import org . apache . camel . spi . Registry ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface EndpointInject { String uri ( ) default "" ; String name ( ) default "" ; } 	0	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . idempotent ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . util . LRUCache ; public class MemoryMessageIdRepository implements MessageIdRepository { private Map cache ; public MemoryMessageIdRepository ( Map set ) { this . cache = set ; } public static MessageIdRepository memoryMessageIdRepository ( ) { return memoryMessageIdRepository ( new HashMap ( ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( int cacheSize ) { return memoryMessageIdRepository ( new LRUCache ( cacheSize ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( Map cache ) { return new MemoryMessageIdRepository ( cache ) ; } public boolean contains ( String messageId ) { synchronized ( cache ) { if ( cache . containsKey ( messageId ) ) { return true ; } else { cache . put ( messageId , messageId ) ; return false ; } } } } 	1	['5', '1', '0', '2', '10', '8', '0', '2', '5', '0.5', '57', '1', '0', '0', '0.3', '0', '0', '10.2', '2', '1', '1']
package org . apache . camel . component . cxf ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; import java . util . Map ; public class CxfSoapComponent extends DefaultComponent { @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Map soapProps = IntrospectionSupport . extractProperties ( parameters , "soap." ) ; if ( parameters . size ( ) > 0 ) { remaining += "?" + URISupport . createQueryString ( parameters ) ; } Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( getCamelContext ( ) , remaining ) ; CxfSoapEndpoint soapEndpoint = new CxfSoapEndpoint ( endpoint ) ; setProperties ( soapEndpoint , soapProps ) ; soapEndpoint . init ( ) ; return soapEndpoint ; } } 	0	['2', '3', '0', '7', '14', '1', '0', '7', '1', '2', '42', '0', '0', '0.958333333', '0.666666667', '1', '2', '20', '1', '0.5', '0']
package org . apache . camel . language ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; public class ExpressionEvaluationException extends RuntimeCamelException { private final Expression < Exchange > expression ; private final Exchange exchange ; public ExpressionEvaluationException ( Expression < Exchange > expression , Exchange exchange , Throwable cause ) { super ( cause ) ; this . expression = expression ; this . exchange = exchange ; } public Expression < Exchange > getExpression ( ) { return expression ; } } 	1	['2', '5', '0', '4', '3', '0', '1', '3', '2', '0.5', '17', '1', '2', '0.944444444', '0.625', '0', '0', '6.5', '1', '0.5', '1']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . config ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . config . BatchResequencerConfig ; import org . apache . camel . model . config . StreamResequencerConfig ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Resequencer ; import org . apache . camel . processor . StreamResequencer ; @ XmlRootElement ( name = "resequencer" ) public class ResequencerType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < ExpressionType > expressions = new ArrayList < ExpressionType > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private BatchResequencerConfig batchConfig ; private StreamResequencerConfig streamConfig ; @ XmlTransient private List < Expression > expressionList ; public ResequencerType ( ) { this ( null ) ; } public ResequencerType ( List < Expression > expressions ) { this . expressionList = expressions ; this . batch ( ) ; } public ResequencerType stream ( ) { return stream ( StreamResequencerConfig . getDefault ( ) ) ; } public ResequencerType batch ( ) { return batch ( BatchResequencerConfig . getDefault ( ) ) ; } public ResequencerType stream ( StreamResequencerConfig config ) { this . streamConfig = config ; this . batchConfig = null ; return this ; } public ResequencerType batch ( BatchResequencerConfig config ) { this . batchConfig = config ; this . streamConfig = null ; return this ; } @ Override public String toString ( ) { return "Resequencer[ " + getExpressions ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return ExpressionType . getLabel ( getExpressions ( ) ) ; } public List < ExpressionType > getExpressions ( ) { return expressions ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public BatchResequencerConfig getBatchConfig ( ) { return batchConfig ; } public BatchResequencerConfig getBatchConfig ( BatchResequencerConfig defaultConfig ) { return batchConfig ; } public StreamResequencerConfig getStreamConfig ( ) { return streamConfig ; } @ XmlElement ( name = "batch-config" , required = false ) public void setBatchConfig ( BatchResequencerConfig batchConfig ) { batch ( batchConfig ) ; } @ XmlElement ( name = "stream-config" , required = false ) public void setStreamConfig ( StreamResequencerConfig streamConfig ) { stream ( streamConfig ) ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createStreamResequencer ( routeContext , streamConfig ) ; } @ Override public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { if ( batchConfig != null ) { routes . add ( createBatchResequencerRoute ( routeContext ) ) ; } else { super . addRoutes ( routeContext , routes ) ; } } private Route < Exchange > createBatchResequencerRoute ( RouteContext routeContext ) throws Exception { final Resequencer resequencer = createBatchResequencer ( routeContext , batchConfig ) ; return new Route < Exchange > ( routeContext . getEndpoint ( ) , resequencer ) { @ Override public String toString ( ) { return "BatchResequencerRoute[" + getEndpoint ( ) + " -> " + resequencer . getProcessor ( ) + "]" ; } } ; } protected Resequencer createBatchResequencer ( RouteContext routeContext , BatchResequencerConfig config ) throws Exception { Processor processor = routeContext . createProcessor ( this ) ; Resequencer resequencer = new Resequencer ( routeContext . getEndpoint ( ) , processor , resolveExpressionList ( routeContext ) ) ; resequencer . setBatchSize ( config . getBatchSize ( ) ) ; resequencer . setBatchTimeout ( config . getBatchTimeout ( ) ) ; return resequencer ; } protected StreamResequencer createStreamResequencer ( RouteContext routeContext , StreamResequencerConfig config ) throws Exception { config . getComparator ( ) . setExpressions ( resolveExpressionList ( routeContext ) ) ; Processor processor = routeContext . createProcessor ( this ) ; StreamResequencer resequencer = new StreamResequencer ( processor , config . getComparator ( ) , config . getCapacity ( ) ) ; resequencer . setTimeout ( config . getTimeout ( ) ) ; return resequencer ; } private List < Expression > resolveExpressionList ( RouteContext routeContext ) { if ( expressionList == null ) { expressionList = new ArrayList < Expression > ( ) ; for ( ExpressionType expression : expressions ) { expressionList . add ( expression . createExpression ( routeContext ) ) ; } } if ( expressionList . isEmpty ( ) ) { throw new IllegalArgumentException ( "No expressions configured for: " + this ) ; } return expressionList ; } } 	1	['24', '2', '0', '16', '56', '218', '3', '15', '20', '0.753623188', '275', '1', '2', '0.808695652', '0.284722222', '1', '4', '10.20833333', '4', '1.0417', '5']
package org . apache . camel . component . cxf . invoker ; import javax . xml . ws . soap . SOAPBinding ; import org . apache . cxf . BusException ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . ClientImpl ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . endpoint . EndpointException ; import org . apache . cxf . frontend . ClientFactoryBean ; import org . apache . cxf . jaxws . binding . soap . JaxWsSoapBindingConfiguration ; import org . apache . cxf . jaxws . support . JaxWsServiceFactoryBean ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . apache . cxf . service . factory . ServiceConstructionException ; public class CxfClientFactoryBean extends ClientFactoryBean { private boolean isJSR181Enabled ; public CxfClientFactoryBean ( ) { super ( ) ; } public void setJSR181Enabled ( boolean enabled ) { if ( enabled ) { setServiceFactory ( new JaxWsServiceFactoryBean ( ) ) ; } else { setServiceFactory ( new ReflectionServiceFactoryBean ( ) ) ; } isJSR181Enabled = enabled ; } @ Override public void setBindingId ( String bind ) { super . setBindingId ( bind ) ; if ( isJSR181Enabled ) { if ( SOAPBinding . SOAP11HTTP_BINDING . equals ( bind ) || SOAPBinding . SOAP12HTTP_BINDING . equals ( bind ) ) { setBindingConfig ( new JaxWsSoapBindingConfiguration ( ( JaxWsServiceFactoryBean ) getServiceFactory ( ) ) ) ; } else if ( SOAPBinding . SOAP11HTTP_MTOM_BINDING . equals ( bind ) || SOAPBinding . SOAP12HTTP_MTOM_BINDING . equals ( bind ) ) { setBindingConfig ( new JaxWsSoapBindingConfiguration ( ( JaxWsServiceFactoryBean ) getServiceFactory ( ) ) ) ; ( ( JaxWsSoapBindingConfiguration ) getBindingConfig ( ) ) . setMtomEnabled ( true ) ; } } } protected void createClient ( Endpoint ep ) { CxfClient client = new CxfClient ( getBus ( ) , ep ) ; setClient ( client ) ; } } 	0	['4', '0', '0', '10', '18', '4', '1', '9', '3', '0.666666667', '81', '1', '0', '0', '0.4375', '0', '0', '19', '6', '2.25', '0']
package org . apache . camel . impl ; import org . apache . camel . Message ; import java . util . HashMap ; import java . util . Map ; public class DefaultMessage extends MessageSupport { private Map < String , Object > headers ; @ Override public String toString ( ) { return "Message: " + getBody ( ) ; } public Object getHeader ( String name ) { return getHeaders ( ) . get ( name ) ; } public < T > T getHeader ( String name , Class < T > type ) { Object value = getHeader ( name ) ; return getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setHeader ( String name , Object value ) { if ( headers == null ) { headers = createHeaders ( ) ; } headers . put ( name , value ) ; } public Object removeHeader ( String name ) { if ( headers != null ) { return headers . remove ( name ) ; } else { return null ; } } public Map < String , Object > getHeaders ( ) { if ( headers == null ) { headers = createHeaders ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public DefaultMessage newInstance ( ) { return new DefaultMessage ( ) ; } protected Map < String , Object > createHeaders ( ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; populateInitialHeaders ( map ) ; return map ; } protected void populateInitialHeaders ( Map < String , Object > map ) { } } 	1	['12', '2', '9', '15', '25', '54', '10', '5', '10', '0.545454545', '98', '1', '0', '0.52173913', '0.333333333', '1', '2', '7.083333333', '2', '1.1667', '1']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class RemoteFileExchange < T extends RemoteFileBinding > extends DefaultExchange { private T binding ; public RemoteFileExchange ( CamelContext context , ExchangePattern pattern , T binding ) { super ( context , pattern ) ; this . binding = binding ; } public RemoteFileExchange ( CamelContext context , ExchangePattern pattern , T binding , String host , String fullFileName , ByteArrayOutputStream outputStream ) { this ( context , pattern , binding ) ; setIn ( new RemoteFileMessage ( host , fullFileName , outputStream ) ) ; } public T getBinding ( ) { return binding ; } public void setBinding ( T binding ) { this . binding = binding ; } } 	0	['4', '2', '0', '11', '7', '0', '7', '6', '4', '0', '34', '1', '1', '0.947368421', '0.541666667', '0', '0', '7.25', '1', '0.5', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . SendProcessor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class BuilderSupport { private CamelContext context ; private ErrorHandlerBuilder errorHandlerBuilder ; private boolean inheritErrorHandler = true ; protected BuilderSupport ( CamelContext context ) { this . context = context ; } protected BuilderSupport ( BuilderSupport parent ) { this . context = parent . getContext ( ) ; this . inheritErrorHandler = parent . inheritErrorHandler ; if ( inheritErrorHandler && parent . errorHandlerBuilder != null ) { this . errorHandlerBuilder = parent . errorHandlerBuilder . copy ( ) ; } } public ValueBuilder header ( String name ) { return Builder . header ( name ) ; } public ValueBuilder body ( ) { return Builder . body ( ) ; } public < T > ValueBuilder body ( Class < T > type ) { return Builder . bodyAs ( type ) ; } public ValueBuilder outBody ( ) { return Builder . outBody ( ) ; } public < T > ValueBuilder outBody ( Class < T > type ) { return Builder . outBodyAs ( type ) ; } public ValueBuilder faultBody ( ) { return Builder . faultBody ( ) ; } public < T > ValueBuilder faultBodyAs ( Class < T > type ) { return Builder . faultBodyAs ( type ) ; } public ValueBuilder systemProperty ( String name ) { return Builder . systemProperty ( name ) ; } public ValueBuilder systemProperty ( String name , String defaultValue ) { return Builder . systemProperty ( name , defaultValue ) ; } public ValueBuilder constant ( Object value ) { return Builder . constant ( value ) ; } public Endpoint endpoint ( String uri ) throws NoSuchEndpointException { if ( uri == null ) { throw new IllegalArgumentException ( "uri parameter cannot be null" ) ; } Endpoint endpoint = getContext ( ) . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } public List < Endpoint > endpoints ( String ... uris ) throws NoSuchEndpointException { List < Endpoint > endpoints = new ArrayList < Endpoint > ( ) ; for ( String uri : uris ) { endpoints . add ( endpoint ( uri ) ) ; } return endpoints ; } public List < Endpoint > endpoints ( Endpoint ... endpoints ) { List < Endpoint > answer = new ArrayList < Endpoint > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint ) ; } return answer ; } public NoErrorHandlerBuilder noErrorHandler ( ) { return new NoErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( ) { return new LoggingErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( String log ) { return loggingErrorHandler ( LogFactory . getLog ( log ) ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log ) { return new LoggingErrorHandlerBuilder ( log ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log , LoggingLevel level ) { return new LoggingErrorHandlerBuilder ( log , level ) ; } public DeadLetterChannelBuilder deadLetterChannel ( ) { return new DeadLetterChannelBuilder ( ) ; } public DeadLetterChannelBuilder deadLetterChannel ( String deadLetterUri ) { return deadLetterChannel ( endpoint ( deadLetterUri ) ) ; } public DeadLetterChannelBuilder deadLetterChannel ( Endpoint deadLetterEndpoint ) { return new DeadLetterChannelBuilder ( new SendProcessor ( deadLetterEndpoint ) ) ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public boolean isInheritErrorHandler ( ) { return inheritErrorHandler ; } public void setInheritErrorHandler ( boolean inheritErrorHandler ) { this . inheritErrorHandler = inheritErrorHandler ; } } 	1	['30', '1', '1', '15', '55', '407', '1', '14', '27', '0.862068966', '251', '1', '2', '0', '0.130769231', '0', '0', '7.266666667', '2', '1.0333', '2']
package org . apache . camel . component . event ; import org . apache . camel . Exchange ; import org . springframework . context . ApplicationEvent ; public class CamelEvent extends ApplicationEvent { private final Exchange exchange ; public CamelEvent ( EventEndpoint source , Exchange exchange ) { super ( source ) ; this . exchange = exchange ; } @ Override public EventEndpoint getSource ( ) { return ( EventEndpoint ) super . getSource ( ) ; } public Exchange getExchange ( ) { return exchange ; } } 	0	['4', '3', '0', '3', '5', '4', '1', '3', '4', '0.666666667', '22', '1', '1', '0.5', '0.5', '0', '0', '4.25', '1', '0.75', '0']
package org . apache . camel ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class Route < E extends Exchange > { private final Map < String , Object > properties = new HashMap < String , Object > ( 16 ) ; private Endpoint < E > endpoint ; private List < Service > services = new ArrayList < Service > ( ) ; public Route ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Route ( Endpoint < E > endpoint , Service ... services ) { this ( endpoint ) ; for ( Service service : services ) { addService ( service ) ; } } @ Override public String toString ( ) { return "Route" ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Map < String , Object > getProperties ( ) { return properties ; } public List < Service > getServicesForRoute ( ) throws Exception { List < Service > servicesForRoute = new ArrayList < Service > ( getServices ( ) ) ; addServices ( servicesForRoute ) ; return servicesForRoute ; } public List < Service > getServices ( ) { return services ; } public void setServices ( List < Service > services ) { this . services = services ; } public void addService ( Service service ) { getServices ( ) . add ( service ) ; } protected void addServices ( List < Service > services ) throws Exception { } } 	1	['11', '1', '3', '12', '16', '41', '10', '2', '10', '0.666666667', '91', '1', '1', '0', '0.327272727', '0', '0', '7', '1', '0.8182', '2']
package org . apache . camel . spi ; public interface Registry { < T > T lookup ( String name , Class < T > type ) ; Object lookup ( String name ) ; } 	0	['2', '1', '0', '11', '2', '1', '11', '0', '2', '2', '2', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import javax . xml . transform . stream . StreamSource ; public class StringSource extends StreamSource implements Serializable { private final String text ; private String encoding = "UTF-8" ; public StringSource ( String text ) { if ( text == null ) { throw new NullPointerException ( "text can not be null" ) ; } this . text = text ; } public StringSource ( String text , String systemId ) { this ( text ) ; setSystemId ( systemId ) ; } public StringSource ( String text , String systemId , String encoding ) { this . text = text ; this . encoding = encoding ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { try { return new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public Reader getReader ( ) { return new StringReader ( text ) ; } public String toString ( ) { return "StringSource[" + text + "]" ; } public String getText ( ) { return text ; } } 	1	['7', '2', '0', '1', '17', '0', '1', '0', '7', '0.25', '83', '1', '0', '0.692307692', '0.714285714', '0', '0', '10.57142857', '1', '0.5714', '2']
package org . apache . camel . component . jms ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import static org . apache . camel . util . ObjectHelper . removeStartingCharacters ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . jms . support . destination . DestinationResolver ; import org . springframework . jms . connection . JmsTransactionManager ; import org . springframework . jms . core . JmsOperations ; import org . springframework . transaction . PlatformTransactionManager ; import javax . jms . ConnectionFactory ; import javax . jms . ExceptionListener ; import javax . jms . Session ; import java . util . Map ; public class JmsComponent extends DefaultComponent < JmsExchange > implements ApplicationContextAware { public static final String QUEUE_PREFIX = "queue:" ; public static final String TOPIC_PREFIX = "topic:" ; private JmsConfiguration configuration ; private ApplicationContext applicationContext ; public JmsComponent ( ) { } public JmsComponent ( JmsConfiguration configuration ) { this . configuration = configuration ; } public JmsComponent ( CamelContext context ) { super ( context ) ; } public static JmsComponent jmsComponent ( ) { return new JmsComponent ( ) ; } public static JmsComponent jmsComponent ( JmsConfiguration configuration ) { return new JmsComponent ( configuration ) ; } public static JmsComponent jmsComponent ( ConnectionFactory connectionFactory ) { return jmsComponent ( new JmsConfiguration ( connectionFactory ) ) ; } public static JmsComponent jmsComponentClientAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . CLIENT_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentAutoAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . AUTO_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory ) { JmsTransactionManager transactionManager = new JmsTransactionManager ( ) ; transactionManager . setConnectionFactory ( connectionFactory ) ; return jmsComponentTransacted ( connectionFactory , transactionManager ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory , PlatformTransactionManager transactionManager ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setTransactionManager ( transactionManager ) ; template . setTransacted ( true ) ; return jmsComponent ( template ) ; } @ Override protected Endpoint < JmsExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { boolean pubSubDomain = false ; if ( remaining . startsWith ( QUEUE_PREFIX ) ) { pubSubDomain = false ; remaining = removeStartingCharacters ( remaining . substring ( QUEUE_PREFIX . length ( ) ) , '/' ) ; } else if ( remaining . startsWith ( TOPIC_PREFIX ) ) { pubSubDomain = true ; remaining = removeStartingCharacters ( remaining . substring ( TOPIC_PREFIX . length ( ) ) , '/' ) ; } final String subject = convertPathToActualDestination ( remaining ) ; JmsEndpoint endpoint = new JmsEndpoint ( uri , this , subject , pubSubDomain , getConfiguration ( ) . copy ( ) ) ; String selector = ( String ) parameters . remove ( "selector" ) ; if ( selector != null ) { endpoint . setSelector ( selector ) ; } setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public JmsConfiguration getConfiguration ( ) { if ( configuration == null ) { configuration = createConfiguration ( ) ; if ( applicationContext != null ) { Map beansOfType = applicationContext . getBeansOfType ( ConnectionFactory . class ) ; if ( ! beansOfType . isEmpty ( ) ) { ConnectionFactory cf = ( ConnectionFactory ) beansOfType . values ( ) . iterator ( ) . next ( ) ; configuration . setConnectionFactory ( cf ) ; } beansOfType = applicationContext . getBeansOfType ( DestinationResolver . class ) ; if ( ! beansOfType . isEmpty ( ) ) { DestinationResolver destinationResolver = ( DestinationResolver ) beansOfType . values ( ) . iterator ( ) . next ( ) ; configuration . setDestinationResolver ( destinationResolver ) ; } } } return configuration ; } public void setConfiguration ( JmsConfiguration configuration ) { this . configuration = configuration ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { getConfiguration ( ) . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementMode ( consumerAcknowledgementMode ) ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementModeName ( consumerAcknowledgementMode ) ; } public void setAutoStartup ( boolean autoStartup ) { getConfiguration ( ) . setAutoStartup ( autoStartup ) ; } public void setCacheLevel ( int cacheLevel ) { getConfiguration ( ) . setCacheLevel ( cacheLevel ) ; } public void setCacheLevelName ( String cacheName ) { getConfiguration ( ) . setCacheLevelName ( cacheName ) ; } public void setClientId ( String consumerClientId ) { getConfiguration ( ) . setClientId ( consumerClientId ) ; } public void setConcurrentConsumers ( int concurrentConsumers ) { getConfiguration ( ) . setConcurrentConsumers ( concurrentConsumers ) ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { getConfiguration ( ) . setConnectionFactory ( connectionFactory ) ; } public void setConsumerType ( ConsumerType consumerType ) { getConfiguration ( ) . setConsumerType ( consumerType ) ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { getConfiguration ( ) . setDeliveryPersistent ( deliveryPersistent ) ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { getConfiguration ( ) . setDurableSubscriptionName ( durableSubscriptionName ) ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { getConfiguration ( ) . setExceptionListener ( exceptionListener ) ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { getConfiguration ( ) . setExplicitQosEnabled ( explicitQosEnabled ) ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { getConfiguration ( ) . setExposeListenerSession ( exposeListenerSession ) ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { getConfiguration ( ) . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { getConfiguration ( ) . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { getConfiguration ( ) . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } public void setMessageConverter ( MessageConverter messageConverter ) { getConfiguration ( ) . setMessageConverter ( messageConverter ) ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { getConfiguration ( ) . setMessageIdEnabled ( messageIdEnabled ) ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { getConfiguration ( ) . setMessageTimestampEnabled ( messageTimestampEnabled ) ; } public void setPriority ( int priority ) { getConfiguration ( ) . setPriority ( priority ) ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { getConfiguration ( ) . setPubSubNoLocal ( pubSubNoLocal ) ; } public void setReceiveTimeout ( long receiveTimeout ) { getConfiguration ( ) . setReceiveTimeout ( receiveTimeout ) ; } public void setRecoveryInterval ( long recoveryInterval ) { getConfiguration ( ) . setRecoveryInterval ( recoveryInterval ) ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { getConfiguration ( ) . setServerSessionFactory ( serverSessionFactory ) ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { getConfiguration ( ) . setSubscriptionDurable ( subscriptionDurable ) ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { getConfiguration ( ) . setTaskExecutor ( taskExecutor ) ; } public void setTimeToLive ( long timeToLive ) { getConfiguration ( ) . setTimeToLive ( timeToLive ) ; } public void setTransacted ( boolean consumerTransacted ) { getConfiguration ( ) . setTransacted ( consumerTransacted ) ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { getConfiguration ( ) . setTransactionManager ( transactionManager ) ; } public void setTransactionName ( String transactionName ) { getConfiguration ( ) . setTransactionName ( transactionName ) ; } public void setTransactionTimeout ( int transactionTimeout ) { getConfiguration ( ) . setTransactionTimeout ( transactionTimeout ) ; } public void setUseVersion102 ( boolean useVersion102 ) { getConfiguration ( ) . setUseVersion102 ( useVersion102 ) ; } public void setJmsOperations ( JmsOperations jmsOperations ) { getConfiguration ( ) . setJmsOperations ( jmsOperations ) ; } public void setDestinationResolver ( DestinationResolver destinationResolver ) { getConfiguration ( ) . setDestinationResolver ( destinationResolver ) ; } protected String convertPathToActualDestination ( String path ) { return path ; } protected JmsConfiguration createConfiguration ( ) { return new JmsConfiguration ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } } 	0	['52', '3', '0', '17', '109', '1318', '1', '17', '49', '0.607843137', '435', '0.5', '1', '0.319444444', '0.101495726', '1', '2', '7.288461538', '5', '1.0192', '0']
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Collection ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . * ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MockEndpoint extends DefaultEndpoint < Exchange > { private static final transient Log LOG = LogFactory . getLog ( MockEndpoint . class ) ; private int expectedCount = - 1 ; private int counter ; private Map < Integer , Processor > processors = new HashMap < Integer , Processor > ( ) ; private List < Exchange > receivedExchanges = new CopyOnWriteArrayList < Exchange > ( ) ; private List < Throwable > failures = new CopyOnWriteArrayList < Throwable > ( ) ; private List < Runnable > tests = new CopyOnWriteArrayList < Runnable > ( ) ; private CountDownLatch latch ; private long sleepForEmptyTest = 1000L ; private long defaulResultWaitMillis = 20000L ; private int expectedMinimumCount = - 1 ; private List expectedBodyValues ; private List actualBodyValues = new ArrayList ( ) ; public MockEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } public static void assertWait ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; long left = unit . toMillis ( timeout ) ; long end = start + left ; for ( MockEndpoint endpoint : endpoints ) { if ( ! endpoint . await ( left , TimeUnit . MILLISECONDS ) ) { throw new AssertionError ( "Timeout waiting for endpoints to receive enough messages. " + endpoint . getEndpointUri ( ) + " timed out." ) ; } left = end - System . currentTimeMillis ( ) ; if ( left <= 0 ) { left = 0 ; } } } public static void assertIsSatisfied ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { assertWait ( timeout , unit , endpoints ) ; for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( CamelContext context ) throws InterruptedException { Collection < Endpoint > endpoints = context . getSingletonEndpoints ( ) ; for ( Endpoint endpoint : endpoints ) { if ( endpoint instanceof MockEndpoint ) { MockEndpoint mockEndpoint = ( MockEndpoint ) endpoint ; mockEndpoint . assertIsSatisfied ( ) ; } } } public static void expectsMessageCount ( int count , MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . expectsMessageCount ( count ) ; } } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "You cannot consume from this endpoint" ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) { onExchange ( exchange ) ; } } ; } public void whenExchangeReceived ( int index , Processor processor ) { this . processors . put ( index , processor ) ; } public void assertIsSatisfied ( ) throws InterruptedException { assertIsSatisfied ( sleepForEmptyTest ) ; } public void assertIsSatisfied ( long timeoutForEmptyEndpoints ) throws InterruptedException { LOG . info ( "Asserting: " + this + " is satisfied" ) ; if ( expectedCount >= 0 ) { if ( expectedCount != getReceivedCounter ( ) ) { if ( expectedCount == 0 ) { if ( timeoutForEmptyEndpoints > 0 ) { LOG . debug ( "Sleeping for: " + timeoutForEmptyEndpoints + " millis to check there really are no messages received" ) ; Thread . sleep ( timeoutForEmptyEndpoints ) ; } } else { waitForCompleteLatch ( ) ; } } assertEquals ( "Received message count" , expectedCount , getReceivedCounter ( ) ) ; } else if ( expectedMinimumCount > 0 && getReceivedCounter ( ) < expectedMinimumCount ) { waitForCompleteLatch ( ) ; } if ( expectedMinimumCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertTrue ( "Received message count " + receivedCounter + ", expected at least " + expectedCount , expectedCount <= receivedCounter ) ; } for ( Runnable test : tests ) { test . run ( ) ; } for ( Throwable failure : failures ) { if ( failure != null ) { LOG . error ( "Caught on " + getEndpointUri ( ) + " Exception: " + failure , failure ) ; fail ( "Failed due to caught exception: " + failure ) ; } } } public void assertIsNotSatisfied ( ) throws InterruptedException { try { assertIsSatisfied ( ) ; fail ( "Expected assertion failure!" ) ; } catch ( AssertionError e ) { LOG . info ( "Caught expected failure: " + e ) ; } } public void expectedMessageCount ( int expectedCount ) { this . expectedCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedCount ) ; } } public void expectedMinimumMessageCount ( int expectedCount ) { this . expectedMinimumCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedMinimumCount ) ; } } public void expectedBodiesReceived ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; this . expectedBodyValues = bodies ; this . actualBodyValues = new ArrayList ( ) ; expects ( new Runnable ( ) { public void run ( ) { for ( int i = 0 ; i < expectedBodyValues . size ( ) ; i ++ ) { Exchange exchange = getReceivedExchanges ( ) . get ( i ) ; assertTrue ( "No exchange received for counter: " + i , exchange != null ) ; Object expectedBody = expectedBodyValues . get ( i ) ; Object actualBody = actualBodyValues . get ( i ) ; assertEquals ( "Body of message: " + i , expectedBody , actualBody ) ; } } } ) ; } public void expectedBodiesReceived ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; for ( Object body : bodies ) { bodyList . add ( body ) ; } expectedBodiesReceived ( bodyList ) ; } public void expectsAscending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesAscending ( expression ) ; } } ) ; } public void expectsDescending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesDescending ( expression ) ; } } ) ; } public void expectsNoDuplicates ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertNoDuplicates ( expression ) ; } } ) ; } public void assertMessagesAscending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , true ) ; } public void assertMessagesDescending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , false ) ; } protected void assertMessagesSorted ( Expression < Exchange > expression , boolean ascending ) { String type = ascending ? "ascending" : "descending" ; ExpressionComparator comparator = new ExpressionComparator ( expression ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 1 ; i < list . size ( ) ; i ++ ) { int j = i - 1 ; Exchange e1 = list . get ( j ) ; Exchange e2 = list . get ( i ) ; int result = comparator . compare ( e1 , e2 ) ; if ( result == 0 ) { fail ( "Messages not " + type + ". Messages" + j + " and " + i + " are equal with value: " + expression . evaluate ( e1 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { if ( ! ascending ) { result = result * - 1 ; } if ( result > 0 ) { fail ( "Messages not " + type + ". Message " + j + " has value: " + expression . evaluate ( e1 ) + " and message " + i + " has value: " + expression . evaluate ( e2 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } } } } public void assertNoDuplicates ( Expression < Exchange > expression ) { Map < Object , Exchange > map = new HashMap < Object , Exchange > ( ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Exchange e2 = list . get ( i ) ; Object key = expression . evaluate ( e2 ) ; Exchange e1 = map . get ( key ) ; if ( e1 != null ) { fail ( "Duplicate message found on message " + i + " has value: " + key + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { map . put ( key , e2 ) ; } } } public void expects ( Runnable runnable ) { tests . add ( runnable ) ; } public AssertionClause message ( final int messageIndex ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; return clause ; } public AssertionClause allMessages ( ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { applyAssertionOn ( MockEndpoint . this , index ++ , exchange ) ; } } } ; expects ( clause ) ; return clause ; } public Exchange assertExchangeReceived ( int index ) { int count = getReceivedCounter ( ) ; assertTrue ( "Not enough messages received. Was: " + count , count > index ) ; return getReceivedExchanges ( ) . get ( index ) ; } public List < Throwable > getFailures ( ) { return failures ; } public int getReceivedCounter ( ) { return getReceivedExchanges ( ) . size ( ) ; } public List < Exchange > getReceivedExchanges ( ) { return receivedExchanges ; } public int getExpectedCount ( ) { return expectedCount ; } public long getSleepForEmptyTest ( ) { return sleepForEmptyTest ; } public void setSleepForEmptyTest ( long sleepForEmptyTest ) { this . sleepForEmptyTest = sleepForEmptyTest ; } public long getDefaulResultWaitMillis ( ) { return defaulResultWaitMillis ; } public void setDefaulResultWaitMillis ( long defaulResultWaitMillis ) { this . defaulResultWaitMillis = defaulResultWaitMillis ; } protected synchronized void onExchange ( Exchange exchange ) { try { Message in = exchange . getIn ( ) ; Object actualBody = in . getBody ( ) ; if ( expectedBodyValues != null ) { int index = actualBodyValues . size ( ) ; if ( expectedBodyValues . size ( ) > index ) { Object expectedBody = expectedBodyValues . get ( index ) ; if ( expectedBody != null ) { actualBody = in . getBody ( expectedBody . getClass ( ) ) ; } actualBodyValues . add ( actualBody ) ; } } LOG . debug ( getEndpointUri ( ) + " >>>> " + ( ++ counter ) + " : " + exchange + " with body: " + actualBody ) ; receivedExchanges . add ( exchange ) ; Processor processor = processors . get ( getReceivedCounter ( ) ) ; if ( processor != null ) { processor . process ( exchange ) ; } if ( latch != null ) { latch . countDown ( ) ; } } catch ( Exception e ) { failures . add ( e ) ; } } protected void waitForCompleteLatch ( ) throws InterruptedException { if ( latch == null ) { fail ( "Should have a latch!" ) ; } LOG . debug ( "Waiting on the latch for: " + defaulResultWaitMillis + " millis" ) ; latch . await ( defaulResultWaitMillis , TimeUnit . MILLISECONDS ) ; } protected void assertEquals ( String message , Object expectedValue , Object actualValue ) { if ( ! ObjectHelper . equals ( expectedValue , actualValue ) ) { fail ( message + ". Expected: <" + expectedValue + "> but was: <" + actualValue + ">" ) ; } } protected void assertTrue ( String message , boolean predicate ) { if ( ! predicate ) { fail ( message ) ; } } protected void fail ( Object message ) { if ( LOG . isDebugEnabled ( ) ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { LOG . debug ( "Received[" + ( ++ index ) + "]: " + exchange ) ; } } throw new AssertionError ( getEndpointUri ( ) + " " + message ) ; } public int getExpectedMinimumCount ( ) { return expectedMinimumCount ; } public void await ( ) throws InterruptedException { if ( latch != null ) { latch . await ( ) ; } } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch != null ) { return latch . await ( timeout , unit ) ; } return true ; } public boolean isSingleton ( ) { return true ; } } 	1	['47', '2', '0', '23', '100', '943', '9', '22', '38', '0.87458194', '1056', '1', '1', '0.274193548', '0.104859335', '0', '0', '21.19148936', '6', '1.3617', '7']
package org . apache . camel . impl ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . processor . Logger ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; public class EventDrivenPollingConsumer < E extends Exchange > extends PollingConsumerSupport < E > implements Processor { private static final transient Log LOG = LogFactory . getLog ( EventDrivenPollingConsumer . class ) ; private BlockingQueue < E > queue ; private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler ( new Logger ( LOG ) ) ; private Consumer < E > consumer ; public EventDrivenPollingConsumer ( Endpoint < E > endpoint ) { this ( endpoint , new ArrayBlockingQueue < E > ( 1000 ) ) ; } public EventDrivenPollingConsumer ( Endpoint < E > endpoint , BlockingQueue < E > queue ) { super ( endpoint ) ; this . queue = queue ; } public E receiveNoWait ( ) { return receive ( 0 ) ; } public E receive ( ) { while ( isRunAllowed ( ) ) { try { return queue . take ( ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; } } return null ; } public E receive ( long timeout ) { try { return queue . poll ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; return null ; } } public void process ( Exchange exchange ) throws Exception { queue . offer ( ( E ) exchange ) ; } public ExceptionHandler getInteruptedExceptionHandler ( ) { return interuptedExceptionHandler ; } public void setInteruptedExceptionHandler ( ExceptionHandler interuptedExceptionHandler ) { this . interuptedExceptionHandler = interuptedExceptionHandler ; } protected void handleInteruptedException ( InterruptedException e ) { getInteruptedExceptionHandler ( ) . handleException ( e ) ; } protected void doStart ( ) throws Exception { consumer = getEndpoint ( ) . createConsumer ( this ) ; consumer . start ( ) ; } protected void doStop ( ) throws Exception { if ( consumer != null ) { try { consumer . stop ( ) ; } finally { consumer = null ; } } } } 	0	['12', '3', '0', '11', '26', '44', '1', '10', '8', '0.727272727', '121', '1', '3', '0.666666667', '0.233766234', '1', '1', '8.75', '2', '0.8333', '0']
package org . apache . camel . builder . xml ; public class StringResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StringResultHandler ( ) ; } } 	1	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '1']
package org . apache . camel . component . cxf . spring ; import org . apache . cxf . configuration . spring . StringBeanDefinitionParser ; import org . apache . cxf . frontend . spring . ServerFactoryBeanDefinitionParser ; import org . apache . cxf . jaxws . JaxWsServerFactoryBean ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NamespaceHandler extends NamespaceHandlerSupport { public void init ( ) { registerBeanDefinitionParser ( "cxfEndpoint" , new CxfEndpointBeanDefinitionParser ( ) ) ; } } 	0	['2', '2', '0', '3', '5', '1', '0', '3', '2', '2', '12', '0', '0', '0.9', '1', '0', '0', '5', '1', '0.5', '0']
package org . apache . camel . builder . xml ; import javax . xml . transform . Result ; import org . apache . camel . Message ; public interface ResultHandler { Result getResult ( ) ; void setBody ( Message in ) ; } 	1	['2', '1', '0', '9', '2', '1', '8', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '1']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class ValueBuilder < E extends Exchange > implements Expression < E > { private Expression < E > expression ; public ValueBuilder ( Expression < E > expression ) { this . expression = expression ; } public Object evaluate ( E exchange ) { return expression . evaluate ( exchange ) ; } public Expression < E > getExpression ( ) { return expression ; } @ Override public String toString ( ) { return expression . toString ( ) ; } public Predicate < E > isNotEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isNotEqualTo ( expression , right ) ) ; } public Predicate < E > isEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isEqualTo ( expression , right ) ) ; } public Predicate < E > isLessThan ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThan ( expression , right ) ) ; } public Predicate < E > isLessThanOrEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThanOrEqualTo ( expression , right ) ) ; } public Predicate < E > isGreaterThan ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThan ( expression , right ) ) ; } public Predicate < E > isGreaterThanOrEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThanOrEqualTo ( expression , right ) ) ; } public Predicate < E > isInstanceOf ( Class type ) { return onNewPredicate ( PredicateBuilder . isInstanceOf ( expression , type ) ) ; } public Predicate < E > matchesRegex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } public Predicate < E > isNull ( ) { return onNewPredicate ( PredicateBuilder . isNull ( expression ) ) ; } public Predicate < E > isNotNull ( ) { return onNewPredicate ( PredicateBuilder . isNotNull ( expression ) ) ; } public Predicate < E > contains ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . contains ( expression , right ) ) ; } public Predicate < E > regex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } public ValueBuilder < E > tokenize ( ) { return tokenize ( "\n" ) ; } public ValueBuilder < E > tokenize ( String token ) { Expression < E > newExp = ExpressionBuilder . tokenizeExpression ( expression , token ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexTokenize ( String regex ) { Expression < E > newExp = ExpressionBuilder . regexTokenize ( expression , regex ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexReplaceAll ( String regex , String replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexReplaceAll ( String regex , Expression < E > replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > convertTo ( Class type ) { Expression < E > newExp = ExpressionBuilder . convertTo ( expression , type ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > convertToString ( ) { return convertTo ( String . class ) ; } public ValueBuilder < E > append ( Object value ) { return new ValueBuilder < E > ( ExpressionBuilder . append ( expression , asExpression ( value ) ) ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { return predicate ; } protected Expression < E > asExpression ( Object value ) { if ( value instanceof Expression ) { return ( Expression < E > ) value ; } else { return ExpressionBuilder . constantExpression ( value ) ; } } } 	0	['26', '1', '1', '10', '47', '0', '5', '5', '24', '0.08', '236', '1', '1', '0', '0.258241758', '0', '0', '8.038461538', '2', '1', '0']
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Processor ; public class CatchProcessor extends DelegateProcessor { private List < Class > exceptions ; public CatchProcessor ( List < Class > exceptions , Processor processor ) { super ( processor ) ; this . exceptions = exceptions ; } @ Override public String toString ( ) { return "Catch[" + exceptions + " -> " + getProcessor ( ) + "]" ; } public boolean catches ( Throwable e ) { for ( Class type : exceptions ) { if ( type . isInstance ( e ) ) { return true ; } } return false ; } public List < Class > getExceptions ( ) { return exceptions ; } } 	1	['4', '3', '0', '6', '14', '0', '4', '2', '4', '0', '52', '1', '0', '0.875', '0.4375', '0', '0', '11.75', '2', '1', '1']
package org . apache . camel . component . xmpp ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class XmppComponent extends DefaultComponent < XmppExchange > { public XmppComponent ( ) { } public XmppComponent ( CamelContext context ) { super ( context ) ; } public static XmppComponent xmppComponent ( ) { return new XmppComponent ( ) ; } @ Override protected Endpoint < XmppExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { XmppEndpoint endpoint = new XmppEndpoint ( uri , this ) ; URI u = new URI ( uri ) ; endpoint . setHost ( u . getHost ( ) ) ; endpoint . setPort ( u . getPort ( ) ) ; if ( u . getUserInfo ( ) != null ) { endpoint . setUser ( u . getUserInfo ( ) ) ; } String remainingPath = u . getPath ( ) ; if ( remainingPath != null ) { if ( remainingPath . startsWith ( "/" ) ) { remainingPath = remainingPath . substring ( 1 ) ; } if ( remainingPath . length ( ) > 0 ) { endpoint . setParticipant ( remainingPath ) ; } } return endpoint ; } } 	0	['4', '3', '0', '4', '19', '6', '1', '4', '3', '2', '62', '0', '0', '0.92', '0.375', '1', '1', '14.5', '1', '0.5', '0']
package org . apache . camel ; public interface AsyncProcessor extends Processor { boolean process ( Exchange exchange , AsyncCallback callback ) ; } 	1	['1', '1', '0', '22', '1', '0', '19', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . language ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ThreadProcessor ; @ XmlRootElement ( name = "thread" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThreadType extends ProcessorType { @ XmlAttribute private int coreSize = 1 ; @ XmlAttribute private boolean daemon = true ; @ XmlAttribute private long keepAliveTime ; @ XmlAttribute private int maxSize = 1 ; @ XmlAttribute private String name = "Thread Processor" ; @ XmlAttribute private int priority = Thread . NORM_PRIORITY ; @ XmlAttribute private long stackSize ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; @ XmlTransient private BlockingQueue < Runnable > taskQueue ; @ XmlTransient private ThreadGroup threadGroup ; @ XmlTransient private ThreadPoolExecutor executor ; public ThreadType ( ) { } public ThreadType ( int coreSize ) { this . coreSize = coreSize ; this . maxSize = coreSize ; } public ThreadType ( ThreadPoolExecutor executor ) { this . executor = executor ; } @ Override public List getInterceptors ( ) { return Collections . EMPTY_LIST ; } @ Override public List getOutputs ( ) { return outputs ; } @ Override public String toString ( ) { return "Thread[" + getLabel ( ) + "]" ; } @ Override public String getLabel ( ) { return "coreSize=" + coreSize ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ThreadProcessor thread = new ThreadProcessor ( ) ; thread . setExecutor ( executor ) ; thread . setCoreSize ( coreSize ) ; thread . setDaemon ( daemon ) ; thread . setKeepAliveTime ( keepAliveTime ) ; thread . setMaxSize ( maxSize ) ; thread . setName ( name ) ; thread . setPriority ( priority ) ; thread . setStackSize ( stackSize ) ; thread . setTaskQueue ( taskQueue ) ; thread . setThreadGroup ( threadGroup ) ; ArrayList < Processor > pipe = new ArrayList < Processor > ( 2 ) ; pipe . add ( thread ) ; pipe . add ( createOutputsProcessor ( routeContext , outputs ) ) ; return new Pipeline ( pipe ) ; } public ThreadType coreSize ( int coreSize ) { setCoreSize ( coreSize ) ; return this ; } public ThreadType daemon ( boolean daemon ) { setDaemon ( daemon ) ; return this ; } public ThreadType keepAliveTime ( long keepAliveTime ) { setKeepAliveTime ( keepAliveTime ) ; return this ; } public ThreadType maxSize ( int maxSize ) { setMaxSize ( maxSize ) ; return this ; } public ThreadType name ( String name ) { setName ( name ) ; return this ; } public ThreadType priority ( int priority ) { setPriority ( priority ) ; return this ; } public ThreadType stackSize ( long stackSize ) { setStackSize ( stackSize ) ; return this ; } public ThreadType taskQueue ( BlockingQueue < Runnable > taskQueue ) { setTaskQueue ( taskQueue ) ; return this ; } public ThreadType threadGroup ( ThreadGroup threadGroup ) { setThreadGroup ( threadGroup ) ; return this ; } public ThreadType executor ( ThreadPoolExecutor executor ) { setExecutor ( executor ) ; return this ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public void setName ( String name ) { this . name = name ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public ThreadPoolExecutor getExecutor ( ) { return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	1	['29', '2', '0', '5', '50', '318', '1', '5', '29', '0.86038961', '304', '1', '0', '0.781512605', '0.199233716', '1', '4', '9.103448276', '1', '0.8966', '2']
package org . apache . camel . language ; import org . apache . camel . component . bean . XPathAnnotationExpressionFactory ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "xpath" , factory = XPathAnnotationExpressionFactory . class ) public @ interface XPath { public String value ( ) ; public NamespacePrefix [ ] namespaces ( ) default { @ NamespacePrefix ( prefix = "soap" , uri = "http://www.w3.org/2003/05/soap-envelope" ) , @ NamespacePrefix ( prefix = "xsd" , uri = "http://www.w3.org/2001/XMLSchema" ) } ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . spi . Injector ; import static org . apache . camel . util . ObjectHelper . notNull ; public class CamelContextHelper { private CamelContextHelper ( ) { } public static Endpoint getMandatoryEndpoint ( CamelContext camelContext , String uri ) throws NoSuchEndpointException { Endpoint endpoint = camelContext . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } else { return endpoint ; } } public static < T > T convertTo ( CamelContext context , Class < T > type , Object value ) { notNull ( context , "camelContext" ) ; return context . getTypeConverter ( ) . convertTo ( type , value ) ; } public static < T > T mandatoryConvertTo ( CamelContext context , Class < T > type , Object value ) { T answer = convertTo ( context , type , value ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Value " + value + " converted to " + type . getName ( ) + " cannot be null" ) ; } return answer ; } public static < T > T newInstance ( CamelContext context , Class < T > beanType ) { return context . getInjector ( ) . newInstance ( beanType ) ; } } 	1	['5', '1', '0', '13', '19', '10', '7', '6', '4', '2', '63', '0', '0', '0', '0.44', '0', '0', '11.6', '2', '1', '3']
package org . apache . camel . component . irc ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class IrcExchange extends DefaultExchange { private IrcBinding binding ; public IrcExchange ( CamelContext context , ExchangePattern pattern , IrcBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public IrcExchange ( CamelContext context , ExchangePattern pattern , IrcBinding binding , IrcMessage inMessage ) { this ( context , pattern , binding ) ; setIn ( inMessage ) ; } public IrcBinding getBinding ( ) { return binding ; } public void setBinding ( IrcBinding binding ) { this . binding = binding ; } @ Override public IrcMessage getIn ( ) { return ( IrcMessage ) super . getIn ( ) ; } @ Override public IrcMessage getOut ( ) { return ( IrcMessage ) super . getOut ( ) ; } @ Override public IrcMessage getOut ( boolean lazyCreate ) { return ( IrcMessage ) super . getOut ( lazyCreate ) ; } @ Override public IrcMessage getFault ( ) { return ( IrcMessage ) super . getFault ( ) ; } @ Override public IrcExchange newInstance ( ) { return new IrcExchange ( getContext ( ) , getPattern ( ) , getBinding ( ) ) ; } @ Override protected IrcMessage createInMessage ( ) { return new IrcMessage ( ) ; } @ Override protected IrcMessage createOutMessage ( ) { return new IrcMessage ( ) ; } } 	0	['18', '2', '0', '9', '20', '147', '4', '7', '14', '0.705882353', '100', '1', '1', '0.692307692', '0.259259259', '1', '3', '4.5', '1', '0.8889', '0']
package org . apache . camel . spi ; public interface Injector { < T > T newInstance ( Class < T > type ) ; } 	1	['1', '1', '0', '18', '1', '0', '18', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import static org . apache . camel . util . ObjectHelper . notNull ; public abstract class BinaryPredicateSupport < E extends Exchange > implements Predicate < E > { private final Expression < E > left ; private final Expression < E > right ; protected BinaryPredicateSupport ( Expression < E > left , Expression < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; this . left = left ; this . right = right ; } @ Override public String toString ( ) { return left + " " + getOperationText ( ) + " " + right ; } public boolean matches ( E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; return matches ( exchange , leftValue , rightValue ) ; } public void assertMatches ( String text , E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; if ( ! matches ( exchange , leftValue , rightValue ) ) { throw new AssertionError ( text + assertionFailureMessage ( exchange , leftValue , rightValue ) ) ; } } protected abstract boolean matches ( E exchange , Object leftValue , Object rightValue ) ; protected abstract String getOperationText ( ) ; protected String assertionFailureMessage ( E exchange , Object leftValue , Object rightValue ) { return this + " failed on " + exchange + " with left value <" + leftValue + "> right value <" + rightValue + ">" ; } } 	0	['9', '1', '7', '11', '17', '24', '7', '4', '5', '0.375', '125', '1', '2', '0', '0.444444444', '0', '0', '12.66666667', '2', '1', '0']
package org . apache . camel . component . bean ; import java . util . List ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; public class AmbiguousMethodCallException extends CamelExchangeException { private final List < MethodInfo > methods ; public AmbiguousMethodCallException ( Exchange exchange , List < MethodInfo > methods ) { super ( "Ambiguous method invocations possible: " + methods , exchange ) ; this . methods = methods ; } public List < MethodInfo > getMethods ( ) { return methods ; } } 	1	['2', '5', '0', '3', '7', '0', '1', '2', '2', '0', '21', '1', '0', '0.947368421', '0.666666667', '0', '0', '9', '1', '0.5', '1']
package org . apache . camel . spring . spi ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . TransactionDefinition ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; public class TransactionInterceptor extends DelegateProcessor { private static final transient Log LOG = LogFactory . getLog ( TransactionInterceptor . class ) ; private final TransactionTemplate transactionTemplate ; public TransactionInterceptor ( TransactionTemplate transactionTemplate ) { this . transactionTemplate = transactionTemplate ; } public void process ( final Exchange exchange ) { LOG . info ( "transaction begin" ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { processNext ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } ) ; LOG . info ( "transaction commit" ) ; } @ Override public String toString ( ) { return "TransactionInterceptor:" + propagationBehaviorToString ( transactionTemplate . getPropagationBehavior ( ) ) + "[" + getProcessor ( ) + "]" ; } private String propagationBehaviorToString ( int propagationBehavior ) { String rc ; switch ( propagationBehavior ) { case TransactionDefinition . PROPAGATION_MANDATORY : rc = "PROPAGATION_MANDATORY" ; break ; case TransactionDefinition . PROPAGATION_NESTED : rc = "PROPAGATION_NESTED" ; break ; case TransactionDefinition . PROPAGATION_NEVER : rc = "PROPAGATION_NEVER" ; break ; case TransactionDefinition . PROPAGATION_NOT_SUPPORTED : rc = "PROPAGATION_NOT_SUPPORTED" ; break ; case TransactionDefinition . PROPAGATION_REQUIRED : rc = "PROPAGATION_REQUIRED" ; break ; case TransactionDefinition . PROPAGATION_REQUIRES_NEW : rc = "PROPAGATION_REQUIRES_NEW" ; break ; case TransactionDefinition . PROPAGATION_SUPPORTS : rc = "PROPAGATION_SUPPORTS" ; break ; default : rc = "UNKOWN" ; } return rc ; } } 	0	['6', '3', '0', '10', '18', '7', '3', '8', '3', '0.7', '85', '1', '1', '0.84', '0.36', '0', '0', '12.83333333', '2', '0.8333', '0']
package org . apache . camel . builder . xml ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Transformer transformer ; private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Transformer transformer ) { this . transformer = transformer ; } @ Override public String toString ( ) { return "XSLT[" + transformer + "]" ; } public synchronized void process ( Exchange exchange ) throws Exception { Transformer transformer = getTransformer ( ) ; if ( transformer == null ) { throw new IllegalArgumentException ( "No transformer configured!" ) ; } configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; ResultHandler resultHandler = resultHandlerFactory . createResult ( ) ; Result result = resultHandler . getResult ( ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( exchange . getIn ( ) ) ; } public static XsltBuilder xslt ( Transformer transformer ) { return new XsltBuilder ( transformer ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandlerFactory ( new StreamResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandlerFactory ( new StringResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandlerFactory ( new DomResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Transformer getTransformer ( ) { return transformer ; } public void setTransformer ( Transformer transformer ) { this . transformer = transformer ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandlerFactory getResultHandlerFactory ( ) { return resultHandlerFactory ; } public void setResultHandlerFactory ( ResultHandlerFactory resultHandlerFactory ) { this . resultHandlerFactory = resultHandlerFactory ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { setTransformer ( converter . getTransformerFactory ( ) . newTransformer ( source ) ) ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { transformer . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	1	['25', '1', '0', '12', '64', '230', '0', '12', '22', '0.65', '318', '1', '2', '0', '0.13', '0', '0', '11.52', '3', '1.04', '3']
package org . apache . camel . spring . util ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; public class ReflectionUtils extends org . springframework . util . ReflectionUtils { public static < T extends Annotation > void callLifecycleMethod ( final Object bean , final Class < T > annotation ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( method . getAnnotation ( annotation ) != null ) { try { method . invoke ( bean , ( Object [ ] ) null ) ; } catch ( IllegalArgumentException ex ) { throw new IllegalStateException ( "Failure to invoke " + method + " on " + bean . getClass ( ) + ": args=[]" , ex ) ; } catch ( IllegalAccessException ex ) { throw new UnsupportedOperationException ( ex . toString ( ) ) ; } catch ( InvocationTargetException ex ) { throw new UnsupportedOperationException ( "PostConstruct method on bean threw exception" , ex . getTargetException ( ) ) ; } } } } ) ; } public static void setField ( Field f , Object instance , Object value ) { try { boolean oldAccessible = f . isAccessible ( ) ; boolean shouldSetAccessible = ! Modifier . isPublic ( f . getModifiers ( ) ) && ! oldAccessible ; if ( shouldSetAccessible ) { f . setAccessible ( true ) ; } f . set ( instance , value ) ; if ( shouldSetAccessible ) { f . setAccessible ( oldAccessible ) ; } } catch ( IllegalArgumentException ex ) { throw new UnsupportedOperationException ( "Cannot inject value of class '" + value . getClass ( ) + "' into " + f ) ; } catch ( IllegalAccessException ex ) { ReflectionUtils . handleReflectionException ( ex ) ; } } } 	0	['3', '2', '0', '5', '18', '3', '2', '3', '3', '2', '65', '0', '0', '0.882352941', '0.416666667', '0', '0', '20.66666667', '4', '1.6667', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . CachingInjector ; import org . apache . camel . util . ObjectHelper ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public synchronized < T > T convertTo ( Class < T > type , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate aninstance of: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	1	['3', '1', '0', '5', '12', '0', '1', '4', '3', '0.25', '54', '1', '1', '0', '0.466666667', '0', '0', '16.33333333', '2', '1', '1']
package org . apache . camel . component . cxf . interceptors ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . commons . io . IOUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class RawMessageContentRedirectInterceptor extends AbstractPhaseInterceptor < Message > { public RawMessageContentRedirectInterceptor ( ) { super ( Phase . WRITE ) ; } public void handleMessage ( Message message ) throws Fault { InputStream is = message . getContent ( InputStream . class ) ; OutputStream os = message . getContent ( OutputStream . class ) ; try { IOUtils . copy ( is , os ) ; is . close ( ) ; os . flush ( ) ; } catch ( Exception e ) { throw new Fault ( e ) ; } } } 	0	['2', '0', '0', '5', '8', '1', '1', '4', '2', '2', '32', '0', '0', '0', '0.75', '0', '0', '15', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "simple" ) public class SimpleExpression extends ExpressionType { public SimpleExpression ( ) { } public SimpleExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "simple" ; } } 	1	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . apache . cxf . binding . xml . XMLConstants ; import org . apache . cxf . binding . xml . XMLFault ; import org . apache . cxf . bindings . xformat . XMLBindingMessageFormat ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . MessagePartInfo ; import org . apache . cxf . staxutils . StaxUtils ; public class XMLMessageInInterceptor extends AbstractMessageInInterceptor < XMLMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( XMLMessageInInterceptor . class ) ; public XMLMessageInInterceptor ( ) { super ( Phase . READ ) ; } protected Logger getLogger ( ) { return LOG ; } protected boolean isFaultMessage ( XMLMessage message ) { XMLStreamReader xsr = message . getContent ( XMLStreamReader . class ) ; boolean isFault = false ; try { if ( StaxUtils . skipToStartOfElement ( xsr ) ) { QName startQName = xsr . getName ( ) ; isFault = XMLConstants . NS_XML_FORMAT . equals ( startQName . getNamespaceURI ( ) ) && XMLFault . XML_FAULT_ROOT . equals ( startQName . getLocalPart ( ) ) ; } } catch ( XMLStreamException xse ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "STAX_READ_EXC" , LOG ) ) ; } return isFault ; } protected BindingOperationInfo getBindingOperation ( XMLMessage message , Document doc ) { Exchange ex = message . getExchange ( ) ; BindingInfo binding = ex . get ( BindingInfo . class ) ; if ( binding == null ) { Endpoint ep = ex . get ( Endpoint . class ) ; binding = ep . getEndpointInfo ( ) . getBinding ( ) ; } Element payloadEl = ( Element ) doc . getChildNodes ( ) . item ( 0 ) ; QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; boolean client = isRequestor ( message ) ; List < BindingOperationInfo > boiList = new ArrayList < BindingOperationInfo > ( ) ; for ( BindingOperationInfo boi : binding . getOperations ( ) ) { BindingMessageInfo bmi = client ? boi . getOutput ( ) : boi . getInput ( ) ; QName rootName = null ; if ( bmi != null ) { XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; if ( msgFormat != null ) { rootName = msgFormat . getRootNode ( ) ; } else { Collection < MessagePartInfo > bodyParts = bmi . getMessageParts ( ) ; if ( bodyParts . size ( ) == 1 ) { MessagePartInfo p = bodyParts . iterator ( ) . next ( ) ; rootName = p . getConcreteName ( ) ; } } } if ( startQName . equals ( rootName ) ) { boiList . add ( boi ) ; } } BindingOperationInfo match = null ; if ( boiList . size ( ) > 1 ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "Mulitple matching BindingOperationIno found in Binding." ) ; } } else if ( ! boiList . isEmpty ( ) ) { match = boiList . get ( 0 ) ; } return match ; } protected List < Element > getPartList ( XMLMessage inMessage , Element rootNode , BindingMessageInfo bmi ) { List < Element > partList = new ArrayList < Element > ( ) ; XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; if ( msgFormat != null ) { NodeList nodeList = rootNode . getChildNodes ( ) ; for ( int idx = 0 ; idx < nodeList . getLength ( ) ; idx ++ ) { partList . add ( ( Element ) nodeList . item ( idx ) ) ; } } else { partList . add ( rootNode ) ; } return partList ; } protected Element getHeader ( XMLMessage inMessage ) { return null ; } } 	0	['11', '1', '0', '16', '52', '43', '1', '15', '1', '0.5', '248', '1', '0', '0.470588235', '0.4', '1', '4', '21.45454545', '10', '1.9091', '0']
package org . apache . camel . processor ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . LoggingExceptionHandler ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BatchProcessor extends ServiceSupport implements Runnable { public static final long DEFAULT_BATCH_TIMEOUT = 1000L ; public static final int DEFAULT_BATCH_SIZE = 100 ; private static final transient Log LOG = LogFactory . getLog ( Resequencer . class ) ; private Endpoint endpoint ; private Processor processor ; private Collection < Exchange > collection ; private long batchTimeout = DEFAULT_BATCH_TIMEOUT ; private int batchSize = DEFAULT_BATCH_SIZE ; private PollingConsumer consumer ; private ExceptionHandler exceptionHandler ; public BatchProcessor ( Endpoint endpoint , Processor processor , Collection < Exchange > collection ) { this . endpoint = endpoint ; this . processor = processor ; this . collection = collection ; } @ Override public String toString ( ) { return "BatchProcessor[to: " + processor + "]" ; } public void run ( ) { LOG . debug ( "Starting thread for " + this ) ; while ( isRunAllowed ( ) ) { try { processBatch ( ) ; } catch ( Exception e ) { getExceptionHandler ( ) . handleException ( e ) ; } } collection . clear ( ) ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } protected synchronized void processBatch ( ) throws Exception { long start = System . currentTimeMillis ( ) ; long end = start + batchTimeout ; for ( int i = 0 ; i < batchSize ; i ++ ) { long timeout = end - System . currentTimeMillis ( ) ; Exchange exchange = consumer . receive ( timeout ) ; if ( exchange == null ) { break ; } collection . add ( exchange ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Finsihed batch size: " + batchSize + " timeout: " + batchTimeout + " so sending set: " + collection ) ; } Iterator < Exchange > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { Exchange exchange = iter . next ( ) ; iter . remove ( ) ; processExchange ( exchange ) ; } } protected void processExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; } protected void doStart ( ) throws Exception { consumer = endpoint . createPollingConsumer ( ) ; ServiceHelper . startServices ( processor , consumer ) ; Thread thread = new Thread ( this , this + " Polling Thread" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( consumer , processor ) ; collection . clear ( ) ; } protected Collection < Exchange > getCollection ( ) { return collection ; } } 	1	['17', '2', '2', '12', '45', '56', '2', '10', '11', '0.84375', '257', '0.8', '5', '0.464285714', '0.1796875', '1', '1', '13.52941176', '2', '1', '4']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "python" ) public class PythonExpression extends ExpressionType { public PythonExpression ( ) { } public PythonExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "python" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . NoSuchLanguageException ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; public class DefaultLanguageResolver implements LanguageResolver { protected static final FactoryFinder LANGUAGE_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/language/" ) ; protected static final FactoryFinder LANGUAGE_RESOLVER = new FactoryFinder ( "META-INF/services/org/apache/camel/language/resolver/" ) ; public Language resolveLanguage ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( Language . class . isAssignableFrom ( type ) ) { return ( Language ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Language implementation. Found: " + type . getName ( ) ) ; } } return noSpecificLanguageFound ( name , context ) ; } protected Language noSpecificLanguageFound ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_RESOLVER . findClass ( "default" ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( LanguageResolver . class . isAssignableFrom ( type ) ) { LanguageResolver resolver = ( LanguageResolver ) context . getInjector ( ) . newInstance ( type ) ; return resolver . resolveLanguage ( name , context ) ; } else { throw new IllegalArgumentException ( "Type is not a LanguageResolver implementation. Found: " + type . getName ( ) ) ; } } throw new NoSuchLanguageException ( name ) ; } } 	1	['4', '1', '0', '8', '18', '2', '1', '7', '2', '0.5', '131', '1', '2', '0', '0.777777778', '0', '0', '31.25', '3', '1.5', '1']
package org . apache . camel ; public interface Consumer < E extends Exchange > extends Service { } 	0	['0', '1', '0', '31', '0', '0', '30', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel ; public interface Endpoint < E extends Exchange > { boolean isSingleton ( ) ; String getEndpointUri ( ) ; E createExchange ( ) ; E createExchange ( ExchangePattern pattern ) ; E createExchange ( Exchange exchange ) ; CamelContext getContext ( ) ; Producer < E > createProducer ( ) throws Exception ; Consumer < E > createConsumer ( Processor processor ) throws Exception ; PollingConsumer < E > createPollingConsumer ( ) throws Exception ; } 	1	['9', '1', '0', '127', '9', '36', '122', '7', '9', '2', '9', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . irc ; import java . net . URI ; import org . apache . camel . RuntimeCamelException ; public class IrcConfiguration implements Cloneable { String target ; String hostname ; String password ; String nickname ; String realname ; String username ; boolean persistent = true ; boolean colors = true ; boolean onNick = true ; boolean onQuit = true ; boolean onJoin = true ; boolean onKick = true ; boolean onMode = true ; boolean onPart = true ; boolean onTopic = true ; boolean onPrivmsg = true ; int [ ] ports = { 6667 , 6668 , 6669 } ; public IrcConfiguration ( ) { } public IrcConfiguration ( String hostname , String nickname , String displayname , String target ) { this . target = target ; this . hostname = hostname ; this . nickname = nickname ; this . username = nickname ; this . realname = displayname ; } public IrcConfiguration ( String hostname , String username , String password , String nickname , String displayname , String target ) { this . target = target ; this . hostname = hostname ; this . username = username ; this . password = password ; this . nickname = nickname ; this . realname = displayname ; } public IrcConfiguration copy ( ) { try { return ( IrcConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public String getCacheKey ( ) { return hostname + ":" + nickname ; } public void configure ( URI uri ) { setNickname ( uri . getUserInfo ( ) ) ; setUsername ( uri . getUserInfo ( ) ) ; setRealname ( uri . getUserInfo ( ) ) ; setHostname ( uri . getHost ( ) ) ; setTarget ( uri . getPath ( ) . substring ( 1 ) ) ; } public String getHostname ( ) { return hostname ; } public void setHostname ( String hostname ) { this . hostname = hostname ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getNickname ( ) { return nickname ; } public void setNickname ( String nickname ) { this . nickname = nickname ; } public String getRealname ( ) { return realname ; } public void setRealname ( String realname ) { this . realname = realname ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public int [ ] getPorts ( ) { return ports ; } public void setPorts ( int [ ] ports ) { this . ports = ports ; } public String getTarget ( ) { return target ; } public void setTarget ( String target ) { this . target = target ; } public boolean isPersistent ( ) { return persistent ; } public void setPersistent ( boolean persistent ) { this . persistent = persistent ; } public boolean isColors ( ) { return colors ; } public void setColors ( boolean colors ) { this . colors = colors ; } public boolean isOnNick ( ) { return onNick ; } public void setOnNick ( boolean onNick ) { this . onNick = onNick ; } public boolean isOnQuit ( ) { return onQuit ; } public void setOnQuit ( boolean onQuit ) { this . onQuit = onQuit ; } public boolean isOnJoin ( ) { return onJoin ; } public void setOnJoin ( boolean onJoin ) { this . onJoin = onJoin ; } public boolean isOnKick ( ) { return onKick ; } public void setOnKick ( boolean onKick ) { this . onKick = onKick ; } public boolean isOnMode ( ) { return onMode ; } public void setOnMode ( boolean onMode ) { this . onMode = onMode ; } public boolean isOnPart ( ) { return onPart ; } public void setOnPart ( boolean onPart ) { this . onPart = onPart ; } public boolean isOnTopic ( ) { return onTopic ; } public void setOnTopic ( boolean onTopic ) { this . onTopic = onTopic ; } public boolean isOnPrivmsg ( ) { return onPrivmsg ; } public void setOnPrivmsg ( boolean onPrivmsg ) { this . onPrivmsg = onPrivmsg ; } public String toString ( ) { return "IrcConfiguration{" + "target='" + target + '\'' + ", hostname='" + hostname + '\'' + ", password='" + password + '\'' + ", nickname='" + nickname + '\'' + ", realname='" + realname + '\'' + ", username='" + username + '\'' + ", persistent=" + persistent + ", colors=" + colors + ", onNick=" + onNick + ", onQuit=" + onQuit + ", onJoin=" + onJoin + ", onKick=" + onKick + ", onMode=" + onMode + ", onPart=" + onPart + ", onTopic=" + onTopic + ", onPrivmsg=" + onPrivmsg + ", ports=" + ports + '}' ; } } 	0	['41', '1', '0', '6', '54', '516', '5', '1', '41', '0.875', '507', '0', '0', '0', '0.297560976', '0', '0', '10.95121951', '1', '0.9268', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "xquery" ) public class XQueryExpression extends ExpressionType { public XQueryExpression ( ) { } public XQueryExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "xquery" ; } } 	1	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '2']
package org . apache . camel . language . ognl ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "ognl" ) public @ interface OGNL { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import java . util . List ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . RejectedExecutionHandler ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . util . AsyncProcessorHelper ; public class ThreadProcessor implements AsyncProcessor , Service { private ThreadPoolExecutor executor ; private long stackSize ; private ThreadGroup threadGroup ; private int priority = Thread . NORM_PRIORITY ; private boolean daemon = true ; private String name = "Thread Processor" ; private BlockingQueue < Runnable > taskQueue ; private long keepAliveTime ; private int maxSize = 1 ; private int coreSize = 1 ; private final AtomicBoolean shutdown = new AtomicBoolean ( true ) ; ; class ProcessCall implements Runnable { private final Exchange exchange ; private final AsyncCallback callback ; public ProcessCall ( Exchange exchange , AsyncCallback callback ) { this . exchange = exchange ; this . callback = callback ; } public void run ( ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; callback . done ( false ) ; } else { callback . done ( false ) ; } } } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( shutdown . get ( ) ) { throw new IllegalStateException ( "ThreadProcessor is not running." ) ; } ProcessCall call = new ProcessCall ( exchange , callback ) ; executor . execute ( call ) ; return false ; } public void start ( ) throws Exception { shutdown . set ( false ) ; getExecutor ( ) . setRejectedExecutionHandler ( new RejectedExecutionHandler ( ) { public void rejectedExecution ( Runnable runnable , ThreadPoolExecutor executor ) { ProcessCall call = ( ProcessCall ) runnable ; call . exchange . setException ( new RejectedExecutionException ( ) ) ; call . callback . done ( false ) ; } } ) ; } public void stop ( ) throws Exception { shutdown . set ( true ) ; executor . shutdown ( ) ; executor . awaitTermination ( 0 , TimeUnit . SECONDS ) ; } public long getStackSize ( ) { return stackSize ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public ThreadGroup getThreadGroup ( ) { return threadGroup ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public long getKeepAliveTime ( ) { return keepAliveTime ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public int getMaxSize ( ) { return maxSize ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public int getCoreSize ( ) { return coreSize ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public BlockingQueue < Runnable > getTaskQueue ( ) { if ( taskQueue == null ) { taskQueue = new ArrayBlockingQueue < Runnable > ( 1000 ) ; } return taskQueue ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public ThreadPoolExecutor getExecutor ( ) { if ( executor == null ) { executor = new ThreadPoolExecutor ( getCoreSize ( ) , getMaxSize ( ) , getKeepAliveTime ( ) , TimeUnit . MILLISECONDS , getTaskQueue ( ) , new ThreadFactory ( ) { public Thread newThread ( Runnable runnable ) { Thread thread ; if ( getStackSize ( ) > 0 ) { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) , getStackSize ( ) ) ; } else { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) ) ; } thread . setDaemon ( isDaemon ( ) ) ; thread . setPriority ( getPriority ( ) ) ; return thread ; } } ) ; } return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	1	['26', '1', '0', '9', '41', '257', '4', '8', '25', '0.905454545', '216', '1', '0', '0', '0.136363636', '0', '0', '6.884615385', '2', '1.0769', '1']
package org . apache . camel . builder . xml ; import javax . xml . xpath . XPathException ; import org . apache . camel . RuntimeExpressionException ; public class InvalidXPathExpression extends RuntimeExpressionException { private final String xpath ; public InvalidXPathExpression ( String xpath , XPathException e ) { super ( "Invalid xpath: " + xpath + ". Reason: " + e , e ) ; this . xpath = xpath ; } public String getXpath ( ) { return xpath ; } } 	0	['2', '6', '0', '2', '7', '0', '1', '1', '2', '0', '25', '1', '0', '0.944444444', '0.666666667', '0', '0', '11', '1', '0.5', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class BeanExchange extends DefaultExchange { public BeanExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } public BeanInvocation getInvocation ( ) { return getIn ( ) . getBody ( BeanInvocation . class ) ; } public void setInvocation ( BeanInvocation invocation ) { getIn ( ) . setBody ( invocation ) ; } @ Override public Exchange newInstance ( ) { return new BeanExchange ( getContext ( ) , getPattern ( ) ) ; } } 	1	['4', '2', '0', '9', '10', '6', '3', '6', '4', '2', '28', '0', '0', '0.923076923', '0.4375', '1', '1', '6', '1', '0.75', '1']
package org . apache . camel . processor . resequencer ; import java . util . TreeSet ; public class Sequence < E > extends TreeSet < E > { private static final long serialVersionUID = 5647393631147741711L ; private SequenceElementComparator < E > comparator ; public Sequence ( SequenceElementComparator < E > comparator ) { super ( comparator ) ; this . comparator = comparator ; } public E predecessor ( E e ) { E elem = lower ( e ) ; if ( elem == null ) { return null ; } if ( comparator . predecessor ( elem , e ) ) { return elem ; } return null ; } public E successor ( E e ) { E elem = higher ( e ) ; if ( elem == null ) { return null ; } if ( comparator . successor ( elem , e ) ) { return elem ; } return null ; } public SequenceElementComparator < E > comparator ( ) { return comparator ; } public E higher ( E e ) { boolean found = false ; for ( E current : this ) { if ( found ) { return current ; } if ( comparator . compare ( e , current ) == 0 ) { found = true ; } } return null ; } public E lower ( E e ) { E last = null ; for ( E current : this ) { if ( comparator . compare ( e , current ) == 0 ) { return last ; } last = current ; } return last ; } } 	0	['7', '4', '0', '2', '13', '0', '1', '1', '7', '0.583333333', '108', '1', '1', '0.85', '0.571428571', '0', '0', '14.14285714', '3', '2', '0']
package org . apache . camel . model ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Predicate ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Interceptor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . Collection ; @ XmlRootElement ( name = "intercept" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InterceptType extends OutputType < ProcessorType > { @ Override public String toString ( ) { return "Intercept[" + getOutputs ( ) + "]" ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Interceptor interceptor = new Interceptor ( ) ; routeContext . intercept ( interceptor ) ; final Processor interceptRoute = routeContext . createProcessor ( this ) ; interceptor . setInterceptorLogic ( interceptRoute ) ; } public OtherwiseType when ( Predicate predicate ) { return choice ( ) . when ( PredicateBuilder . not ( predicate ) ) . proceed ( ) . otherwise ( ) ; } } 	1	['4', '3', '0', '11', '19', '6', '3', '9', '4', '2', '43', '0', '0', '0.97029703', '0.4375', '0', '0', '9.75', '1', '0.75', '7']
package org . apache . camel . processor . validation ; import java . util . List ; import org . xml . sax . SAXParseException ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public class SchemaValidationException extends ValidationException { private final Object schema ; private final List < SAXParseException > fatalErrors ; private final List < SAXParseException > errors ; private final List < SAXParseException > warnings ; public SchemaValidationException ( Exchange exchange , Object schema , List < SAXParseException > fatalErrors , List < SAXParseException > errors , List < SAXParseException > warnings ) { super ( exchange , message ( schema , fatalErrors , errors , warnings ) ) ; this . schema = schema ; this . fatalErrors = fatalErrors ; this . errors = errors ; this . warnings = warnings ; } public Object getSchema ( ) { return schema ; } public List < SAXParseException > getErrors ( ) { return errors ; } public List < SAXParseException > getFatalErrors ( ) { return fatalErrors ; } public List < SAXParseException > getWarnings ( ) { return warnings ; } protected static String message ( Object schema , List < SAXParseException > fatalErrors , List < SAXParseException > errors , List < SAXParseException > warnings ) { StringBuffer buffer = new StringBuffer ( "Validation failed for: " + schema ) ; if ( ! fatalErrors . isEmpty ( ) ) { buffer . append ( " fatal errors: " ) ; buffer . append ( fatalErrors ) ; } if ( ! errors . isEmpty ( ) ) { buffer . append ( " errors: " ) ; buffer . append ( errors ) ; } return buffer . toString ( ) ; } } 	0	['6', '6', '0', '3', '16', '7', '1', '2', '5', '0.8', '80', '1', '0', '0.782608696', '0.416666667', '0', '0', '11.66666667', '3', '1.1667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . RecipientList ; @ XmlRootElement ( name = "recipientList" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RecipientListType extends ExpressionNode { public RecipientListType ( ) { } public RecipientListType ( ExpressionType expression ) { super ( expression ) ; } public RecipientListType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "RecipientList[ " + getExpression ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new RecipientList ( getExpression ( ) . createExpression ( routeContext ) ) ; } } 	1	['5', '3', '0', '8', '15', '10', '2', '6', '5', '2', '36', '0', '0', '0.980769231', '0.4', '1', '2', '6.2', '1', '0.4', '2']
package org . apache . camel . component . mail ; import javax . mail . Folder ; import javax . mail . Message ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . springframework . mail . javamail . JavaMailSender ; public class MailEndpoint extends ScheduledPollEndpoint < MailExchange > { private MailBinding binding ; private MailConfiguration configuration ; public MailEndpoint ( String uri , MailComponent component , MailConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; } public Producer < MailExchange > createProducer ( ) throws Exception { JavaMailSender sender = configuration . createJavaMailConnection ( this ) ; return createProducer ( sender ) ; } public Producer < MailExchange > createProducer ( JavaMailSender sender ) throws Exception { return new MailProducer ( this , sender ) ; } public Consumer < MailExchange > createConsumer ( Processor processor ) throws Exception { JavaMailConnection connection = configuration . createJavaMailConnection ( this ) ; String protocol = getConfiguration ( ) . getProtocol ( ) ; if ( protocol . equals ( "smtp" ) ) { protocol = "pop3" ; } String folderName = getConfiguration ( ) . getFolderName ( ) ; Folder folder = connection . getFolder ( protocol , folderName ) ; if ( folder == null ) { throw new IllegalArgumentException ( "No folder for protocol: " + protocol + " and name: " + folderName ) ; } return createConsumer ( processor , folder ) ; } public Consumer < MailExchange > createConsumer ( Processor processor , Folder folder ) throws Exception { MailConsumer answer = new MailConsumer ( this , processor , folder ) ; configureConsumer ( answer ) ; return answer ; } @ Override public MailExchange createExchange ( ExchangePattern pattern ) { return new MailExchange ( getContext ( ) , pattern , getBinding ( ) ) ; } public MailExchange createExchange ( Message message ) { return new MailExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , message ) ; } public MailBinding getBinding ( ) { if ( binding == null ) { binding = new MailBinding ( ) ; } return binding ; } public void setBinding ( MailBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return false ; } public MailConfiguration getConfiguration ( ) { return configuration ; } } 	0	['12', '3', '0', '17', '29', '52', '6', '16', '12', '0.681818182', '140', '1', '2', '0.65625', '0.191666667', '1', '1', '10.5', '2', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ExchangeConverter ; public class DefaultExchangeConverter implements ExchangeConverter { public < T > T convertTo ( Class < T > type , Exchange exchange ) { return null ; } } 	1	['2', '1', '0', '3', '3', '1', '1', '2', '2', '2', '7', '0', '0', '0', '0.666666667', '0', '0', '2.5', '1', '0.5', '1']
package org . apache . camel . spring . handler ; import org . w3c . dom . Element ; import org . springframework . beans . factory . xml . AbstractSimpleBeanDefinitionParser ; public class BeanDefinitionParser extends AbstractSimpleBeanDefinitionParser { private Class type ; protected BeanDefinitionParser ( ) { } public BeanDefinitionParser ( Class type ) { this . type = type ; } protected Class getBeanClass ( Element element ) { if ( type == null ) { type = loadType ( ) ; } return type ; } protected Class loadType ( ) { throw new IllegalArgumentException ( "No type specified!" ) ; } @ Override protected boolean isEligibleAttribute ( String attributeName ) { return attributeName != null && super . isEligibleAttribute ( attributeName ) && ! attributeName . equals ( "xmlns" ) ; } } 	0	['5', '4', '3', '5', '9', '8', '4', '1', '1', '0.75', '44', '1', '0', '0.85', '0.4', '3', '3', '7.6', '4', '1.4', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; @ Converter public class NIOConverter { private NIOConverter ( ) { } @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static String toString ( ByteBuffer buffer ) { return IOConverter . toString ( buffer . array ( ) ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( File file ) throws IOException { byte [ ] buf = new byte [ ( int ) file . length ( ) ] ; InputStream in = new BufferedInputStream ( new FileInputStream ( file ) ) ; in . read ( buf ) ; return ByteBuffer . wrap ( buf ) ; } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } @ Converter public static InputStream toInputStream ( ByteBuffer bufferbuffer ) { return IOConverter . toInputStream ( toByteArray ( bufferbuffer ) ) ; } } 	1	['12', '1', '0', '3', '35', '66', '2', '1', '11', '2', '112', '0', '0', '0', '0.1', '0', '0', '8.333333333', '1', '0.9167', '1']
package org . apache . camel ; public class RuntimeExpressionException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; public RuntimeExpressionException ( String message ) { super ( message ) ; } public RuntimeExpressionException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeExpressionException ( Throwable cause ) { super ( cause ) ; } } 	0	['3', '5', '1', '4', '6', '3', '3', '1', '3', '1.5', '17', '1', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class URISupport { public static class CompositeData { public String host ; String scheme ; String path ; URI components [ ] ; Map parameters ; String fragment ; public URI [ ] getComponents ( ) { return components ; } public String getFragment ( ) { return fragment ; } public Map getParameters ( ) { return parameters ; } public String getScheme ( ) { return scheme ; } public String getPath ( ) { return path ; } public String getHost ( ) { return host ; } public URI toURI ( ) throws URISyntaxException { StringBuffer sb = new StringBuffer ( ) ; if ( scheme != null ) { sb . append ( scheme ) ; sb . append ( ':' ) ; } if ( host != null && host . length ( ) != 0 ) { sb . append ( host ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( ',' ) ; } sb . append ( components [ i ] . toString ( ) ) ; } sb . append ( ')' ) ; } if ( path != null ) { sb . append ( '/' ) ; sb . append ( path ) ; } if ( ! parameters . isEmpty ( ) ) { sb . append ( "?" ) ; sb . append ( createQueryString ( parameters ) ) ; } if ( fragment != null ) { sb . append ( "#" ) ; sb . append ( fragment ) ; } return new URI ( sb . toString ( ) ) ; } } public static Map parseQuery ( String uri ) throws URISyntaxException { try { Map rc = new HashMap ( ) ; if ( uri != null ) { String [ ] parameters = uri . split ( "&" ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { int p = parameters [ i ] . indexOf ( "=" ) ; if ( p >= 0 ) { String name = URLDecoder . decode ( parameters [ i ] . substring ( 0 , p ) , "UTF-8" ) ; String value = URLDecoder . decode ( parameters [ i ] . substring ( p + 1 ) , "UTF-8" ) ; rc . put ( name , value ) ; } else { rc . put ( parameters [ i ] , null ) ; } } } return rc ; } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static Map parseParamters ( URI uri ) throws URISyntaxException { String query = uri . getQuery ( ) ; if ( query == null ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; int idx = schemeSpecificPart . lastIndexOf ( '?' ) ; if ( idx < 0 ) { return Collections . EMPTY_MAP ; } else { query = schemeSpecificPart . substring ( idx + 1 ) ; } } else { query = stripPrefix ( query , "?" ) ; } return parseQuery ( query ) ; } public static URI removeQuery ( URI uri ) throws URISyntaxException { return createURIWithQuery ( uri , null ) ; } public static URI createURIWithQuery ( URI uri , String query ) throws URISyntaxException { return new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , query , uri . getFragment ( ) ) ; } public static CompositeData parseComposite ( URI uri ) throws URISyntaxException { CompositeData rc = new CompositeData ( ) ; rc . scheme = uri . getScheme ( ) ; String ssp = stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) . trim ( ) ; parseComposite ( uri , rc , ssp ) ; rc . fragment = uri . getFragment ( ) ; return rc ; } private static void parseComposite ( URI uri , CompositeData rc , String ssp ) throws URISyntaxException { String componentString ; String params ; if ( ! checkParenthesis ( ssp ) ) { throw new URISyntaxException ( uri . toString ( ) , "Not a matching number of '(' and ')' parenthesis" ) ; } int p ; int intialParen = ssp . indexOf ( "(" ) ; if ( intialParen == 0 ) { rc . host = ssp . substring ( 0 , intialParen ) ; p = rc . host . indexOf ( "/" ) ; if ( p >= 0 ) { rc . path = rc . host . substring ( p ) ; rc . host = rc . host . substring ( 0 , p ) ; } p = ssp . lastIndexOf ( ")" ) ; componentString = ssp . substring ( intialParen + 1 , p ) ; params = ssp . substring ( p + 1 ) . trim ( ) ; } else { componentString = ssp ; params = "" ; } String components [ ] = splitComponents ( componentString ) ; rc . components = new URI [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { rc . components [ i ] = new URI ( components [ i ] . trim ( ) ) ; } p = params . indexOf ( "?" ) ; if ( p >= 0 ) { if ( p > 0 ) { rc . path = stripPrefix ( params . substring ( 0 , p ) , "/" ) ; } rc . parameters = parseQuery ( params . substring ( p + 1 ) ) ; } else { if ( params . length ( ) > 0 ) { rc . path = stripPrefix ( params , "/" ) ; } rc . parameters = Collections . EMPTY_MAP ; } } private static String [ ] splitComponents ( String str ) { ArrayList l = new ArrayList ( ) ; int last = 0 ; int depth = 0 ; char chars [ ] = str . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '(' : depth ++ ; break ; case ')' : depth -- ; break ; case ',' : if ( depth == 0 ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + 1 ; } break ; default : } } String s = str . substring ( last ) ; if ( s . length ( ) != 0 ) { l . add ( s ) ; } String rc [ ] = new String [ l . size ( ) ] ; l . toArray ( rc ) ; return rc ; } public static String stripPrefix ( String value , String prefix ) { if ( value . startsWith ( prefix ) ) { return value . substring ( prefix . length ( ) ) ; } return value ; } public static URI stripScheme ( URI uri ) throws URISyntaxException { return new URI ( stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) ) ; } public static String createQueryString ( Map options ) throws URISyntaxException { try { if ( options . size ( ) > 0 ) { StringBuffer rc = new StringBuffer ( ) ; boolean first = true ; for ( Iterator iter = options . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { if ( first ) { first = false ; } else { rc . append ( "&" ) ; } String key = ( String ) iter . next ( ) ; String value = ( String ) options . get ( key ) ; rc . append ( URLEncoder . encode ( key , "UTF-8" ) ) ; rc . append ( "=" ) ; rc . append ( URLEncoder . encode ( value , "UTF-8" ) ) ; } return rc . toString ( ) ; } else { return "" ; } } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static URI createRemainingURI ( URI originalURI , Map params ) throws URISyntaxException { String s = createQueryString ( params ) ; if ( s . length ( ) == 0 ) { s = null ; } return createURIWithQuery ( originalURI , s ) ; } public static URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; } public static boolean checkParenthesis ( String str ) { boolean result = true ; if ( str != null ) { int open = 0 ; int closed = 0 ; int i = 0 ; while ( ( i = str . indexOf ( '(' , i ) ) >= 0 ) { i ++ ; open ++ ; } i = 0 ; while ( ( i = str . indexOf ( ')' , i ) ) >= 0 ) { i ++ ; closed ++ ; } result = open == closed ; } return result ; } public int indexOfParenthesisMatch ( String str ) { int result = - 1 ; return result ; } } 	1	['15', '1', '0', '3', '59', '105', '3', '1', '13', '2', '519', '0', '0', '0', '0.28', '0', '0', '33.6', '5', '1.5333', '1']
package org . apache . camel . component . cxf ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; public class CxfMessage extends DefaultMessage { private Message cxfMessage ; public CxfMessage ( ) { this ( new MessageImpl ( ) ) ; } public CxfMessage ( Message cxfMessage ) { if ( cxfMessage == null ) { this . cxfMessage = new MessageImpl ( ) ; } this . cxfMessage = cxfMessage ; } @ Override public String toString ( ) { if ( cxfMessage != null ) { return "CxfMessage: " + cxfMessage ; } else { return "CxfMessage: " + getBody ( ) ; } } @ Override public CxfExchange getExchange ( ) { return ( CxfExchange ) super . getExchange ( ) ; } public Message getMessage ( ) { return cxfMessage ; } public void setMessage ( Message cxfMessage ) { this . cxfMessage = cxfMessage ; } public Object getHeader ( String name ) { return cxfMessage . get ( name ) ; } @ Override public void setHeader ( String name , Object value ) { cxfMessage . put ( name , value ) ; } @ Override public Map < String , Object > getHeaders ( ) { return cxfMessage ; } @ Override public CxfMessage newInstance ( ) { return new CxfMessage ( ) ; } @ Override protected Object createBody ( ) { return getExchange ( ) . getBinding ( ) . extractBodyFromCxf ( getExchange ( ) , cxfMessage ) ; } } 	0	['14', '3', '0', '8', '23', '35', '3', '7', '13', '0.153846154', '105', '1', '0', '0.657142857', '0.339285714', '2', '7', '6.428571429', '2', '0.9286', '0']
package org . apache . camel ; public class CamelException extends Exception { public CamelException ( ) { } public CamelException ( String message ) { super ( message ) ; } public CamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public CamelException ( Throwable cause ) { super ( cause ) ; } } 	1	['4', '3', '3', '5', '8', '6', '5', '0', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '1']
package org . apache . camel . component . timer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . Timer ; public class TimerComponent extends DefaultComponent < Exchange > { private Map < String , Timer > timers = new HashMap < String , Timer > ( ) ; public Timer getTimer ( TimerEndpoint endpoint ) { String key = endpoint . getTimerName ( ) ; if ( ! endpoint . isDaemon ( ) ) { key = "nonDaemon:" + key ; } Timer answer = timers . get ( key ) ; if ( answer == null ) { answer = new Timer ( endpoint . getTimerName ( ) , endpoint . isDaemon ( ) ) ; timers . put ( key , answer ) ; } return answer ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { TimerEndpoint answer = new TimerEndpoint ( uri , this , remaining ) ; setProperties ( answer , parameters ) ; return answer ; } @ Override protected void doStop ( ) throws Exception { Collection < Timer > collection = timers . values ( ) ; for ( Timer timer : collection ) { timer . cancel ( ) ; } timers . clear ( ) ; } } 	0	['4', '3', '0', '3', '22', '0', '1', '3', '2', '0.333333333', '86', '1', '0', '0.884615385', '0.4375', '2', '3', '20.25', '3', '1.25', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . spi . Synchronization ; import org . apache . camel . spi . UnitOfWork ; public class DefaultUnitOfWork implements UnitOfWork { private List < Synchronization > synchronizations ; private List < AsyncCallback > asyncCallbacks ; private CountDownLatch latch ; public DefaultUnitOfWork ( ) { } public synchronized void addSynchronization ( Synchronization synchronization ) { if ( synchronizations == null ) { synchronizations = new ArrayList < Synchronization > ( ) ; } synchronizations . add ( synchronization ) ; } public synchronized void removeSynchronization ( Synchronization synchronization ) { if ( synchronizations != null ) { synchronizations . remove ( synchronization ) ; } } public void reset ( ) { } public void done ( Exchange exchange ) { if ( synchronizations != null ) { boolean failed = exchange . isFailed ( ) ; for ( Synchronization synchronization : synchronizations ) { if ( failed ) { synchronization . onFailure ( exchange ) ; } else { synchronization . onComplete ( exchange ) ; } } } } public boolean isSynchronous ( ) { return asyncCallbacks == null || asyncCallbacks . isEmpty ( ) ; } } 	1	['6', '1', '0', '4', '17', '9', '1', '3', '6', '0.933333333', '75', '1', '0', '0', '0.5', '0', '0', '11', '4', '2', '1']
package org . apache . camel . converter . jaxb ; import org . apache . camel . Message ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlType ; @ XmlType ( name = "headerType" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public abstract class HeaderType { @ XmlAttribute private String name ; public HeaderType ( ) { } protected HeaderType ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public abstract Object getValue ( ) ; public abstract void setValue ( Object value ) ; } 	0	['6', '1', '4', '5', '7', '9', '5', '0', '5', '0.6', '23', '1', '0', '0', '0.5', '0', '0', '2.666666667', '1', '0.6667', '0']
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport { private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy ( ) ; private ProcessorFactory deadLetterFactory ; private Processor defaultDeadLetterEndpoint ; private Expression defaultDeadLetterEndpointExpression ; private String defaultDeadLetterEndpointUri = "log:org.apache.camel.DeadLetterChannel?level=error" ; private Logger logger = DeadLetterChannel . createDefaultLogger ( ) ; public DeadLetterChannelBuilder ( ) { } public DeadLetterChannelBuilder ( Processor processor ) { this ( new ConstantProcessorBuilder ( processor ) ) ; } public DeadLetterChannelBuilder ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public ErrorHandlerBuilder copy ( ) { DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder ( deadLetterFactory ) ; answer . setRedeliveryPolicy ( getRedeliveryPolicy ( ) . copy ( ) ) ; return answer ; } public Processor createErrorHandler ( Processor processor ) throws Exception { Processor deadLetter = getDeadLetterFactory ( ) . createProcessor ( ) ; DeadLetterChannel answer = new DeadLetterChannel ( processor , deadLetter , getRedeliveryPolicy ( ) , getLogger ( ) ) ; configure ( answer ) ; return answer ; } public DeadLetterChannelBuilder backOffMultiplier ( double backOffMultiplier ) { getRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public DeadLetterChannelBuilder collisionAvoidancePercent ( short collisionAvoidancePercent ) { getRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public DeadLetterChannelBuilder initialRedeliveryDelay ( long initialRedeliveryDelay ) { getRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveries ( int maximumRedeliveries ) { getRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public DeadLetterChannelBuilder useCollisionAvoidance ( ) { getRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public DeadLetterChannelBuilder useExponentialBackOff ( ) { getRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public DeadLetterChannelBuilder logger ( Logger logger ) { setLogger ( logger ) ; return this ; } public DeadLetterChannelBuilder loggingLevel ( LoggingLevel level ) { getLogger ( ) . setLevel ( level ) ; return this ; } public DeadLetterChannelBuilder log ( Log log ) { getLogger ( ) . setLog ( log ) ; return this ; } public DeadLetterChannelBuilder log ( String log ) { return log ( LogFactory . getLog ( log ) ) ; } public DeadLetterChannelBuilder log ( Class log ) { return log ( LogFactory . getLog ( log ) ) ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public ProcessorFactory getDeadLetterFactory ( ) { if ( deadLetterFactory == null ) { deadLetterFactory = new ProcessorFactory ( ) { public Processor createProcessor ( ) { return getDefaultDeadLetterEndpoint ( ) ; } } ; } return deadLetterFactory ; } public void setDeadLetterFactory ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public Processor getDefaultDeadLetterEndpoint ( ) { if ( defaultDeadLetterEndpoint == null ) { defaultDeadLetterEndpoint = new RecipientList ( getDefaultDeadLetterEndpointExpression ( ) ) ; } return defaultDeadLetterEndpoint ; } public void setDefaultDeadLetterEndpoint ( Processor defaultDeadLetterEndpoint ) { this . defaultDeadLetterEndpoint = defaultDeadLetterEndpoint ; } public Expression getDefaultDeadLetterEndpointExpression ( ) { if ( defaultDeadLetterEndpointExpression == null ) { defaultDeadLetterEndpointExpression = ExpressionBuilder . constantExpression ( getDefaultDeadLetterEndpointUri ( ) ) ; } return defaultDeadLetterEndpointExpression ; } public void setDefaultDeadLetterEndpointExpression ( Expression defaultDeadLetterEndpointExpression ) { this . defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression ; } public String getDefaultDeadLetterEndpointUri ( ) { return defaultDeadLetterEndpointUri ; } public void setDefaultDeadLetterEndpointUri ( String defaultDeadLetterEndpointUri ) { this . defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } } 	1	['28', '2', '0', '18', '49', '330', '3', '16', '28', '0.771604938', '241', '1', '5', '0.074074074', '0.117346939', '0', '0', '7.392857143', '2', '1', '1']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface ExchangeConverter { < T > T convertTo ( Class < T > type , Exchange exchange ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . spi ; import org . apache . camel . TypeConverter ; public interface TypeConverterAware { void setTypeConverter ( TypeConverter parentTypeConverter ) ; } 	1	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessagePropertyNamesAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 6744171518099741324L ; public MessagePropertyNamesAccessException ( JMSException e ) { super ( "Failed to access the JMS message property names: " + e , e ) ; } } 	0	['1', '5', '0', '2', '6', '0', '1', '1', '1', '2', '14', '1', '0', '1', '1', '0', '0', '12', '0', '0', '0']
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; public class FileProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( FileProducer . class ) ; private final FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public FileEndpoint getEndpoint ( ) { return ( FileEndpoint ) super . getEndpoint ( ) ; } public void process ( Exchange exchange ) throws Exception { FileExchange fileExchange = endpoint . createExchange ( exchange ) ; process ( fileExchange ) ; ExchangeHelper . copyResults ( exchange , fileExchange ) ; } public void process ( FileExchange exchange ) throws Exception { if ( ExchangeHelper . isOutCapable ( exchange ) ) { Message out = exchange . getOut ( true ) ; endpoint . configureMessage ( endpoint . getFile ( ) , out ) ; return ; } InputStream in = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; File file = createFileName ( exchange . getIn ( ) ) ; buildDirectory ( file ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to write to: " + file + " from exchange: " + exchange ) ; } FileChannel fc = null ; try { if ( getEndpoint ( ) . isAppend ( ) ) { fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . position ( fc . size ( ) ) ; } else { fc = new FileOutputStream ( file ) . getChannel ( ) ; } int size = getEndpoint ( ) . getBufferSize ( ) ; byte [ ] buffer = new byte [ size ] ; ByteBuffer byteBuffer = ByteBuffer . wrap ( buffer ) ; while ( true ) { int count = in . read ( buffer ) ; if ( count <= 0 ) { break ; } else if ( count < size ) { byteBuffer = ByteBuffer . wrap ( buffer , 0 , count ) ; fc . write ( byteBuffer ) ; break ; } else { fc . write ( byteBuffer ) ; byteBuffer . clear ( ) ; } } } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close input: " + e , e ) ; } } if ( fc != null ) { try { fc . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close output: " + e , e ) ; } } } } protected File createFileName ( Message message ) { File answer ; File endpointFile = endpoint . getFile ( ) ; String name = null ; if ( ! endpoint . isIgnoreFileNameHeader ( ) ) { name = message . getHeader ( FileComponent . HEADER_FILE_NAME , String . class ) ; } if ( endpointFile . isDirectory ( ) ) { if ( name != null ) { answer = new File ( endpointFile , name ) ; if ( answer . isDirectory ( ) ) { answer = new File ( answer , message . getMessageId ( ) ) ; } } else { answer = new File ( endpointFile , message . getMessageId ( ) ) ; } } else { answer = endpointFile ; } return answer ; } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	1	['8', '3', '0', '9', '50', '14', '1', '9', '5', '0.642857143', '295', '1', '2', '0.76', '0.285714286', '0', '0', '35.625', '5', '1.375', '4']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface UnitOfWork { void addSynchronization ( Synchronization synchronization ) ; void removeSynchronization ( Synchronization synchronization ) ; void done ( Exchange exchange ) ; } 	0	['3', '1', '0', '6', '3', '3', '5', '2', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . bean ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . builder . ExpressionBuilder ; public class DefaultParameterMappingStrategy implements ParameterMappingStrategy { private Map < Class , Expression > parameterTypeToExpressionMap = new ConcurrentHashMap < Class , Expression > ( ) ; public DefaultParameterMappingStrategy ( ) { } public synchronized Expression getDefaultParameterTypeExpression ( Class parameterType ) { return parameterTypeToExpressionMap . get ( parameterType ) ; } public synchronized void addParameterMapping ( Class parameterType , Expression expression ) { parameterTypeToExpressionMap . put ( parameterType , expression ) ; } public void loadDefaultRegistry ( ) { addParameterMapping ( Exchange . class , ExpressionBuilder . exchangeExpression ( ) ) ; addParameterMapping ( Message . class , ExpressionBuilder . inMessageExpression ( ) ) ; } } 	1	['4', '1', '0', '4', '10', '0', '1', '3', '4', '0', '35', '1', '0', '0', '0.583333333', '0', '0', '7.5', '1', '0.75', '1']
package org . apache . camel . bam . processor ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; public class NoCorrelationKeyException extends CamelExchangeException { private final BamProcessorSupport processor ; public NoCorrelationKeyException ( BamProcessorSupport processor , Exchange exchange ) { super ( "No correlation key could be found for " + processor . getCorrelationKeyExpression ( ) , exchange ) ; this . processor = processor ; } public BamProcessorSupport getProcessor ( ) { return processor ; } } 	0	['2', '5', '0', '4', '8', '0', '1', '4', '2', '0', '22', '1', '1', '0.947368421', '0.666666667', '0', '0', '9.5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElementRef ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExpressionNode extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private ExpressionType expression ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; public ExpressionNode ( ) { } public ExpressionNode ( ExpressionType expression ) { this . expression = expression ; } public ExpressionNode ( Expression expression ) { setExpression ( new ExpressionType ( expression ) ) ; } public ExpressionNode ( Predicate predicate ) { setExpression ( new ExpressionType ( predicate ) ) ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public ExpressionType getExpression ( ) { return expression ; } public void setExpression ( ExpressionType expression ) { this . expression = expression ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } @ Override public String getLabel ( ) { if ( getExpression ( ) == null ) { return "" ; } return getExpression ( ) . getLabel ( ) ; } protected FilterProcessor createFilterProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new FilterProcessor ( getExpression ( ) . createPredicate ( routeContext ) , childProcessor ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } } 	1	['13', '2', '7', '15', '25', '24', '7', '8', '11', '0.555555556', '137', '1', '1', '0.911764706', '0.230769231', '1', '5', '9.307692308', '2', '0.8462', '3']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . cxf . bindings . xformat . XMLBindingMessageFormat ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . MessagePartInfo ; public class XMLMessageOutInterceptor extends AbstractMessageOutInterceptor < XMLMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( XMLMessageOutInterceptor . class ) ; public XMLMessageOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; addAfter ( DOMOutInterceptor . class . getName ( ) ) ; } protected Logger getLogger ( ) { return LOG ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( XMLMessage message ) throws Fault { Exchange exchange = message . getExchange ( ) ; BindingMessageInfo bmi = exchange . get ( BindingMessageInfo . class ) ; List < Element > payload = message . get ( List . class ) ; if ( bmi == null && payload . size ( ) > 1 ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NO_XML_ROOT_NODE" , LOG ) ) ; } if ( bmi != null ) { Element header = message . get ( Element . class ) ; if ( header != null ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "DOMOutInterceptor Copy Message Part related Headers to Payload." ) ; } moveHeaderPartToPayload ( bmi , header , payload ) ; } XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; QName rootName = msgFormat != null ? msgFormat . getRootNode ( ) : null ; if ( rootName == null ) { if ( payload . size ( ) > 1 ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NO_XML_ROOT_NODE" , LOG ) ) ; } } else { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "DOMOutInterceptor Create xmlformat RootNode element" ) ; } Element el = createElement ( rootName , payload ) ; payload = new ArrayList < Element > ( ) ; payload . add ( el ) ; } message . put ( List . class , payload ) ; message . remove ( Element . class ) ; } } private void moveHeaderPartToPayload ( BindingMessageInfo bmi , Element header , List < Element > payload ) { Collection < MessagePartInfo > bodyParts = bmi . getMessageParts ( ) ; NodeList nodes = header . getChildNodes ( ) ; for ( int idx = 0 ; idx < nodes . getLength ( ) ; idx ++ ) { Node node = nodes . item ( idx ) ; int index = 0 ; for ( MessagePartInfo mpi : bodyParts ) { QName name = mpi . getConcreteName ( ) ; if ( name . getLocalPart ( ) . equals ( node . getLocalName ( ) ) && name . getNamespaceURI ( ) . equals ( node . getNamespaceURI ( ) ) ) { payload . add ( index , ( Element ) node ) ; break ; } ++ index ; } } } } 	0	['6', '1', '0', '11', '39', '9', '1', '10', '3', '0.4', '189', '1', '0', '0.428571429', '0.333333333', '0', '0', '30.33333333', '5', '1.3333', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; @ XmlRootElement ( name = "idempotentConsumer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class IdempotentConsumerType extends ExpressionNode { @ XmlAttribute private String messageIdRepositoryRef ; @ XmlTransient private MessageIdRepository messageIdRepository ; public IdempotentConsumerType ( ) { } public IdempotentConsumerType ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { super ( messageIdExpression ) ; this . messageIdRepository = messageIdRepository ; } @ Override public String toString ( ) { return "IdempotentConsumer[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } public String getMessageIdRepositoryRef ( ) { return messageIdRepositoryRef ; } public void setMessageIdRepositoryRef ( String messageIdRepositoryRef ) { this . messageIdRepositoryRef = messageIdRepositoryRef ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public void setMessageIdRepository ( MessageIdRepository messageIdRepository ) { this . messageIdRepository = messageIdRepository ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; MessageIdRepository messageIdRepository = resolveMessageIdRepository ( routeContext ) ; return new IdempotentConsumer ( getExpression ( ) . createExpression ( routeContext ) , messageIdRepository , childProcessor ) ; } public MessageIdRepository resolveMessageIdRepository ( RouteContext routeContext ) { if ( messageIdRepository == null ) { messageIdRepository = routeContext . lookup ( messageIdRepositoryRef , MessageIdRepository . class ) ; } return messageIdRepository ; } } 	1	['9', '3', '0', '8', '21', '18', '1', '8', '9', '0.5625', '84', '1', '1', '0.935779817', '0.333333333', '1', '2', '8.111111111', '2', '0.8889', '2']
package org . apache . camel . language ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . ANNOTATION_TYPE } ) public @ interface NamespacePrefix { public abstract String prefix ( ) ; public abstract String uri ( ) ; } 	0	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; public class Aggregator extends BatchProcessor { public Aggregator ( Endpoint endpoint , Processor processor , Expression correlationExpression , AggregationStrategy aggregationStrategy ) { this ( endpoint , processor , new AggregationCollection ( correlationExpression , aggregationStrategy ) ) ; } public Aggregator ( Endpoint endpoint , Processor processor , AggregationCollection collection ) { super ( endpoint , processor , collection ) ; } @ Override public String toString ( ) { return "Aggregator[to: " + getProcessor ( ) + "]" ; } } 	1	['3', '3', '0', '7', '10', '3', '1', '6', '3', '2', '31', '0', '0', '0.965517241', '0.555555556', '0', '0', '9.333333333', '1', '0.3333', '2']
package org . apache . camel . builder . xml ; import javax . xml . transform . Result ; import javax . xml . transform . dom . DOMResult ; import org . apache . camel . Message ; public class DomResultHandler implements ResultHandler { private DOMResult result = new DOMResult ( ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( result . getNode ( ) ) ; } } 	0	['3', '1', '0', '3', '7', '0', '1', '2', '3', '0', '21', '1', '0', '0', '0.666666667', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . camel . management ; import java . net . InetAddress ; import java . net . UnknownHostException ; import javax . management . MalformedObjectNameException ; import javax . management . ObjectName ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; public class CamelNamingStrategy { public static final String VALUE_UNKNOWN = "unknown" ; public static final String VALUE_ROUTE = "route" ; public static final String KEY_NAME = "name" ; public static final String KEY_TYPE = "type" ; public static final String KEY_CONTEXT = "context" ; public static final String KEY_GROUP = "group" ; public static final String KEY_COMPONENT = "component" ; public static final String KEY_ROUTE_TYPE = "routeType" ; public static final String KEY_ROUTE = "route" ; public static final String GROUP_ENDPOINTS = "endpoints" ; public static final String GROUP_SERVICES = "services" ; public static final String GROUP_ROUTE_BUILDER = "routeBuilder" ; public static final String GROUP_ROUTE_TYPE = "routeType" ; protected String domainName ; protected String hostName = "locahost" ; public CamelNamingStrategy ( ) { this ( "org.apache.camel" ) ; } public CamelNamingStrategy ( String domainName ) { if ( domainName != null ) { this . domainName = domainName ; } try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException ex ) { } } public ObjectName getObjectName ( CamelContext context ) throws MalformedObjectNameException { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( context ) + "," ) ; buffer . append ( KEY_NAME + "=" + "context" ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( ManagedEndpoint mbean ) throws MalformedObjectNameException { Endpoint ep = mbean . getEndpoint ( ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( ep . getContext ( ) ) + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_ENDPOINTS + "," ) ; buffer . append ( KEY_COMPONENT + "=" + getComponentId ( ep ) + "," ) ; buffer . append ( KEY_NAME + "=" + getEndpointId ( ep ) ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( CamelContext context , ManagedService mbean ) throws MalformedObjectNameException { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( context ) + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_SERVICES + "," ) ; buffer . append ( KEY_NAME + "=" + Integer . toHexString ( mbean . getService ( ) . hashCode ( ) ) ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( ManagedRoute mbean ) throws MalformedObjectNameException { Endpoint ep = mbean . getRoute ( ) . getEndpoint ( ) ; String ctxid = ep != null ? getContextId ( ep . getContext ( ) ) : VALUE_UNKNOWN ; String cid = getComponentId ( ep ) ; String id = VALUE_UNKNOWN . equals ( cid ) ? getEndpointId ( ep ) : "[" + cid + "]" + getEndpointId ( ep ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + ctxid + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_ROUTE_BUILDER + "," ) ; buffer . append ( KEY_ROUTE_TYPE + "=" + GROUP_ROUTE_TYPE + "," ) ; buffer . append ( KEY_ROUTE + "=" + id + "," ) ; buffer . append ( KEY_NAME + "=" + VALUE_ROUTE ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( CamelContext context , PerformanceCounter mbean ) throws MalformedObjectNameException { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( context ) + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_ENDPOINTS + "," ) ; buffer . append ( KEY_ROUTE + "=" + "Route.Counter" + "," ) ; buffer . append ( KEY_NAME + "=" + "Stats" ) ; return createObjectName ( buffer ) ; } public String getDomainName ( ) { return domainName ; } public void setDomainName ( String domainName ) { this . domainName = domainName ; } public String getHostName ( ) { return hostName ; } public void setHostName ( String hostName ) { this . hostName = hostName ; } protected String getContextId ( CamelContext context ) { String id = context != null ? context . getName ( ) : VALUE_UNKNOWN ; return hostName + "/" + id ; } protected String getComponentId ( Endpoint ep ) { String uri = ep . getEndpointUri ( ) ; int pos = uri . indexOf ( ':' ) ; return ( pos == - 1 ) ? VALUE_UNKNOWN : uri . substring ( 0 , pos ) ; } protected String getEndpointId ( Endpoint ep ) { String uri = ep . getEndpointUri ( ) ; int pos = uri . indexOf ( ':' ) ; String id = ( pos == - 1 ) ? uri : uri . substring ( pos + 1 ) ; if ( ! ep . isSingleton ( ) ) { id += "." + Integer . toString ( ep . hashCode ( ) ) ; } id = id . replace ( "=" , "_eq_" ) ; id = id . replace ( "," , "_cm_" ) ; return id ; } protected ObjectName createObjectName ( StringBuffer buffer ) throws MalformedObjectNameException { String text = buffer . toString ( ) ; try { text = text . replace ( "?" , "_qe_" ) ; return new ObjectName ( text ) ; } catch ( MalformedObjectNameException e ) { throw new MalformedObjectNameException ( "Could not create ObjectName from: " + text + ". Reason: " + e ) ; } } } 	1	['15', '1', '0', '11', '43', '37', '3', '8', '11', '0.980952381', '485', '0.133333333', '0', '0', '0.214814815', '0', '0', '30.33333333', '3', '1.1333', '10']
package org . apache . camel . component . cxf . interceptors ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapFault ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . xml . XMLFault ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class FaultOutInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( FaultOutInterceptor . class ) ; public FaultOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { Exception ex = message . getContent ( Exception . class ) ; if ( ex != null ) { if ( ! ( ex instanceof Fault ) ) { ex = new Fault ( ex ) ; } if ( message instanceof XMLMessage ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "FaultOutInterceptor Creating XMLFault" ) ; } ex = XMLFault . createFault ( ( Fault ) ex ) ; } else if ( message instanceof SoapMessage ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "FaultOutInterceptor Creating SoapFault" ) ; } SoapMessage sm = ( SoapMessage ) message ; ex = SoapFault . createFault ( ( Fault ) ex , sm . getVersion ( ) ) ; } message . setContent ( Exception . class , ex ) ; } } } 	0	['3', '0', '0', '10', '13', '1', '1', '9', '2', '0.5', '66', '1', '0', '0', '0.75', '0', '0', '20.66666667', '1', '0.3333', '0']
package org . apache . camel . model ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; @ XmlRootElement ( name = "process" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ProcessorRef extends OutputType { @ XmlAttribute ( required = true ) private String ref ; @ XmlTransient private Processor processor ; public ProcessorRef ( ) { } public ProcessorRef ( Processor processor ) { this . processor = processor ; } @ Override public String toString ( ) { return "Processor[ref:  " + ref + "]" ; } @ Override public String getLabel ( ) { if ( ref != null ) { return "ref:  " + ref ; } else if ( processor != null ) { return processor . toString ( ) ; } else { return "" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( processor == null ) { processor = routeContext . lookup ( getRef ( ) , Processor . class ) ; } return processor ; } } 	1	['7', '3', '0', '4', '13', '3', '1', '3', '7', '0.5', '73', '1', '1', '0.951456311', '0.357142857', '1', '2', '9.142857143', '3', '1.1429', '2']
package org . apache . camel . component . bean ; import java . lang . reflect . Proxy ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; public class ProxyHelper { private ProxyHelper ( ) { } public static Object createProxy ( final Endpoint endpoint , ClassLoader cl , Class interfaces [ ] ) throws Exception { final Producer producer = endpoint . createProducer ( ) ; return Proxy . newProxyInstance ( cl , interfaces , new CamelInvocationHandler ( endpoint , producer ) ) ; } public static Object createProxy ( Endpoint endpoint , Class interfaces [ ] ) throws Exception { if ( interfaces . length < 1 ) { throw new IllegalArgumentException ( "You must provide at least 1 interface class." ) ; } return createProxy ( endpoint , interfaces [ 0 ] . getClassLoader ( ) , interfaces ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , ClassLoader cl , Class < T > interfaceClass ) throws Exception { return ( T ) createProxy ( endpoint , cl , new Class [ ] { interfaceClass } ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , Class < T > interfaceClass ) throws Exception { return ( T ) createProxy ( endpoint , new Class [ ] { interfaceClass } ) ; } } 	0	['5', '1', '0', '4', '11', '10', '1', '3', '4', '2', '56', '0', '0', '0', '0.44', '0', '0', '10.2', '1', '0.8', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlType ( name = "outputType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class OutputType < Type extends ProcessorType > extends ProcessorType < Type > { private static final transient Log LOG = LogFactory . getLog ( OutputType . class ) ; @ XmlElementRef protected List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } } 	1	['7', '2', '10', '15', '17', '9', '11', '4', '5', '0.777777778', '68', '1', '1', '0.948979592', '0.5', '1', '5', '8.285714286', '3', '1.1429', '1']
package org . apache . camel . util ; import java . util . Comparator ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionListComparator implements Comparator < Exchange > { private final List < Expression > expressions ; public ExpressionListComparator ( List < Expression > expressions ) { this . expressions = expressions ; } public int compare ( Exchange e1 , Exchange e2 ) { for ( Expression expression : expressions ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; int answer = ObjectHelper . compare ( o1 , o2 ) ; if ( answer != 0 ) { return answer ; } } return 0 ; } } 	0	['3', '1', '0', '4', '9', '1', '1', '3', '3', '0', '47', '1', '0', '0', '0.5', '0', '0', '14.33333333', '2', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . Policy ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; public class DelegateAsyncProcessor extends ServiceSupport implements AsyncProcessor { protected AsyncProcessor processor ; public DelegateAsyncProcessor ( ) { } public DelegateAsyncProcessor ( AsyncProcessor processor ) { this . processor = processor ; } @ Override public String toString ( ) { return "Delegate(" + processor + ")" ; } public AsyncProcessor getProcessor ( ) { return processor ; } public void setProcessor ( AsyncProcessor processor ) { this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { return processor . process ( exchange , callback ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } } 	1	['9', '2', '1', '7', '18', '0', '1', '6', '7', '0.25', '66', '1', '1', '0.65', '0.388888889', '1', '1', '6.222222222', '1', '0.7778', '1']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "php" ) public class PhpExpression extends ExpressionType { public PhpExpression ( ) { } public PhpExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "php" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . Builder ; import org . apache . camel . builder . DataTypeExpression ; import org . apache . camel . builder . DeadLetterChannelBuilder ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . NoErrorHandlerBuilder ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . model . language . LanguageExpression ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . MulticastProcessor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . Policy ; import org . apache . camel . spi . Registry ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class ProcessorType < Type extends ProcessorType > { public static final String DEFAULT_TRACE_CATEGORY = "org.apache.camel.TRACE" ; private ErrorHandlerBuilder errorHandlerBuilder ; private Boolean inheritErrorHandlerFlag = Boolean . TRUE ; private DelegateProcessor lastInterceptor ; private NodeFactory nodeFactory ; public abstract List < ProcessorType < ? > > getOutputs ( ) ; public abstract List < InterceptorType > getInterceptors ( ) ; public Processor createProcessor ( RouteContext routeContext ) throws Exception { throw new UnsupportedOperationException ( "Not implemented yet for class: " + getClass ( ) . getName ( ) ) ; } public Processor createOutputsProcessor ( RouteContext routeContext ) throws Exception { Collection < ProcessorType < ? > > outputs = getOutputs ( ) ; return createOutputsProcessor ( routeContext , outputs ) ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Processor processor = makeProcessor ( routeContext ) ; routeContext . addEventDrivenProcessor ( processor ) ; } public Processor wrapProcessor ( RouteContext routeContext , Processor processor ) throws Exception { processor = wrapProcessorInInterceptors ( routeContext , processor ) ; return wrapInErrorHandler ( processor ) ; } public Type to ( String uri ) { addOutput ( new ToType ( uri ) ) ; return ( Type ) this ; } public Type to ( Endpoint endpoint ) { addOutput ( new ToType ( endpoint ) ) ; return ( Type ) this ; } public Type to ( String ... uris ) { for ( String uri : uris ) { addOutput ( new ToType ( uri ) ) ; } return ( Type ) this ; } public Type to ( Endpoint ... endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public Type to ( Collection < Endpoint > endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public MulticastType multicast ( ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; return answer ; } public Type pipeline ( String ... uris ) { return to ( uris ) ; } public Type pipeline ( Endpoint ... endpoints ) { return to ( endpoints ) ; } public Type pipeline ( Collection < Endpoint > endpoints ) { return to ( endpoints ) ; } public IdempotentConsumerType idempotentConsumer ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { IdempotentConsumerType answer = new IdempotentConsumerType ( messageIdExpression , messageIdRepository ) ; addOutput ( answer ) ; return answer ; } public FilterType filter ( Predicate predicate ) { FilterType filter = new FilterType ( predicate ) ; addOutput ( filter ) ; return filter ; } public ChoiceType choice ( ) { ChoiceType answer = new ChoiceType ( ) ; addOutput ( answer ) ; return answer ; } public TryType tryBlock ( ) { TryType answer = new TryType ( ) ; addOutput ( answer ) ; return answer ; } public Type recipientList ( Expression receipients ) { RecipientListType answer = new RecipientListType ( receipients ) ; addOutput ( answer ) ; return ( Type ) this ; } public SplitterType splitter ( Expression receipients ) { SplitterType answer = new SplitterType ( receipients ) ; addOutput ( answer ) ; return answer ; } public ResequencerType resequencer ( Expression < Exchange > expression ) { return resequencer ( Collections . < Expression > singletonList ( expression ) ) ; } public ResequencerType resequencer ( List < Expression > expressions ) { ResequencerType answer = new ResequencerType ( expressions ) ; addOutput ( answer ) ; return answer ; } public ResequencerType resequencer ( Expression ... expressions ) { List < Expression > list = new ArrayList < Expression > ( ) ; for ( Expression expression : expressions ) { list . add ( expression ) ; } return resequencer ( list ) ; } public AggregatorType aggregator ( Expression correlationExpression ) { AggregatorType answer = new AggregatorType ( correlationExpression ) ; addOutput ( answer ) ; return answer ; } public AggregatorType aggregator ( Expression correlationExpression , AggregationStrategy aggregationStrategy ) { AggregatorType answer = new AggregatorType ( correlationExpression , aggregationStrategy ) ; addOutput ( answer ) ; return answer ; } public DelayerType delayer ( Expression < Exchange > processAtExpression ) { return delayer ( processAtExpression , 0L ) ; } public DelayerType delayer ( Expression < Exchange > processAtExpression , long delay ) { DelayerType answer = new DelayerType ( processAtExpression , delay ) ; addOutput ( answer ) ; return answer ; } public DelayerType delayer ( long delay ) { return delayer ( null , delay ) ; } public ThrottlerType throttler ( long maximumRequestCount ) { ThrottlerType answer = new ThrottlerType ( maximumRequestCount ) ; addOutput ( answer ) ; return answer ; } public Type interceptor ( String ref ) { getInterceptors ( ) . add ( new InterceptorRef ( ref ) ) ; return ( Type ) this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer ; } public Type proceed ( ) { addOutput ( new ProceedType ( ) ) ; return ( Type ) this ; } public ExceptionType exception ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; addOutput ( answer ) ; return answer ; } public OtherwiseType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer . when ( predicate ) ; } public Type interceptors ( String ... refs ) { for ( String ref : refs ) { interceptor ( ref ) ; } return ( Type ) this ; } public FilterType filter ( ExpressionType expression ) { FilterType filter = getNodeFactory ( ) . createFilter ( ) ; filter . setExpression ( expression ) ; addOutput ( filter ) ; return filter ; } public FilterType filter ( String language , String expression ) { return filter ( new LanguageExpression ( language , expression ) ) ; } public Type trace ( ) { return trace ( DEFAULT_TRACE_CATEGORY ) ; } public Type trace ( String category ) { final Log log = LogFactory . getLog ( category ) ; return intercept ( new DelegateProcessor ( ) { @ Override public void process ( Exchange exchange ) throws Exception { log . trace ( exchange ) ; processNext ( exchange ) ; } } ) ; } public PolicyRef policies ( ) { PolicyRef answer = new PolicyRef ( ) ; addOutput ( answer ) ; return answer ; } public PolicyRef policy ( Policy policy ) { PolicyRef answer = new PolicyRef ( policy ) ; addOutput ( answer ) ; return answer ; } public Type intercept ( DelegateProcessor interceptor ) { getInterceptors ( ) . add ( new InterceptorRef ( interceptor ) ) ; lastInterceptor = interceptor ; return ( Type ) this ; } public Type errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return ( Type ) this ; } public Type inheritErrorHandler ( boolean condition ) { setInheritErrorHandlerFlag ( condition ) ; return ( Type ) this ; } public Type process ( Processor processor ) { ProcessorRef answer = new ProcessorRef ( processor ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type processRef ( String ref ) { ProcessorRef answer = new ProcessorRef ( ) ; answer . setRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref ) { BeanRef answer = new BeanRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref , String method ) { BeanRef answer = new BeanRef ( ref , method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type setBody ( Expression expression ) { return process ( ProcessorBuilder . setBody ( expression ) ) ; } public Type setOutBody ( Expression expression ) { return process ( ProcessorBuilder . setOutBody ( expression ) ) ; } public Type setFaultBody ( Expression expression ) { return process ( ProcessorBuilder . setFaultBody ( expression ) ) ; } public Type setHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setHeader ( name , expression ) ) ; } public Type setOutHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setOutHeader ( name , expression ) ) ; } public Type setFaultHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setFaultHeader ( name , expression ) ) ; } public Type setProperty ( String name , Expression expression ) { return process ( ProcessorBuilder . setProperty ( name , expression ) ) ; } public Type removeHeader ( String name ) { return process ( ProcessorBuilder . removeHeader ( name ) ) ; } public Type removeOutHeader ( String name ) { return process ( ProcessorBuilder . removeOutHeader ( name ) ) ; } public Type removeFaultHeader ( String name ) { return process ( ProcessorBuilder . removeFaultHeader ( name ) ) ; } public Type removeProperty ( String name ) { return process ( ProcessorBuilder . removeProperty ( name ) ) ; } public Type convertBodyTo ( Class type ) { return process ( ProcessorBuilder . setBody ( Builder . body ( ) . convertTo ( type ) ) ) ; } public Type convertOutBodyTo ( Class type ) { return process ( ProcessorBuilder . setOutBody ( Builder . outBody ( ) . convertTo ( type ) ) ) ; } public Type convertFaultBodyTo ( Class type ) { return process ( ProcessorBuilder . setFaultBody ( Builder . faultBody ( ) . convertTo ( type ) ) ) ; } public DataTypeExpression < Type > unmarshal ( ) { return new DataTypeExpression < Type > ( this , DataTypeExpression . Operation . Unmarshal ) ; } public Type unmarshal ( DataFormatType dataFormatType ) { addOutput ( new UnmarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type unmarshal ( DataFormat dataFormat ) { return unmarshal ( new DataFormatType ( dataFormat ) ) ; } public Type unmarshal ( String dataTypeRef ) { addOutput ( new UnmarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } public DataTypeExpression < Type > marshal ( ) { return new DataTypeExpression < Type > ( this , DataTypeExpression . Operation . Marshal ) ; } public Type marshal ( DataFormatType dataFormatType ) { addOutput ( new MarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type marshal ( DataFormat dataFormat ) { return marshal ( new DataFormatType ( dataFormat ) ) ; } public Type marshal ( String dataTypeRef ) { addOutput ( new MarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } @ XmlTransient public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } @ XmlTransient public boolean isInheritErrorHandler ( ) { return ObjectConverter . toBoolean ( getInheritErrorHandlerFlag ( ) ) ; } @ XmlAttribute ( name = "inheritErrorHandler" , required = false ) public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } @ XmlTransient public NodeFactory getNodeFactory ( ) { if ( nodeFactory == null ) { nodeFactory = new NodeFactory ( ) ; } return nodeFactory ; } public void setNodeFactory ( NodeFactory nodeFactory ) { this . nodeFactory = nodeFactory ; } public String getLabel ( ) { return "" ; } protected Processor makeProcessor ( RouteContext routeContext ) throws Exception { Processor processor = createProcessor ( routeContext ) ; return wrapProcessor ( routeContext , processor ) ; } protected Processor wrapProcessorInInterceptors ( RouteContext routeContext , Processor target ) throws Exception { if ( target == null ) { throw new RuntimeCamelException ( "target provided." ) ; } DelegateProcessor first = null ; DelegateProcessor last = null ; List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( routeContext . getRoute ( ) . getInterceptors ( ) ) ; List < InterceptorType > list = getInterceptors ( ) ; for ( InterceptorType interceptorType : list ) { if ( ! interceptors . contains ( interceptorType ) ) { interceptors . add ( interceptorType ) ; } } for ( InterceptorType interceptorRef : interceptors ) { DelegateProcessor p = interceptorRef . createInterceptor ( routeContext ) ; if ( first == null ) { first = p ; } if ( last != null ) { last . setProcessor ( p ) ; } last = p ; } if ( last != null ) { last . setProcessor ( target ) ; } return first == null ? target : first ; } protected Processor wrapInErrorHandler ( Processor processor ) throws Exception { return getErrorHandlerBuilder ( ) . createErrorHandler ( processor ) ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } protected void configureChild ( ProcessorType output ) { output . setNodeFactory ( getNodeFactory ( ) ) ; } protected void addOutput ( ProcessorType processorType ) { configureChild ( processorType ) ; getOutputs ( ) . add ( processorType ) ; } protected Processor createCompositeProcessor ( List < Processor > list ) { return new Pipeline ( list ) ; } protected Processor createOutputsProcessor ( RouteContext routeContext , Collection < ProcessorType < ? > > outputs ) throws Exception { List < Processor > list = new ArrayList < Processor > ( ) ; for ( ProcessorType output : outputs ) { Processor processor = output . createProcessor ( routeContext ) ; list . add ( processor ) ; } Processor processor = null ; if ( ! list . isEmpty ( ) ) { if ( list . size ( ) == 1 ) { processor = list . get ( 0 ) ; } else { processor = createCompositeProcessor ( list ) ; } } return processor ; } public ThreadType thread ( int coreSize ) { ThreadType answer = new ThreadType ( coreSize ) ; addOutput ( answer ) ; return answer ; } public ProcessorType < Type > thread ( ThreadPoolExecutor executor ) { ThreadType answer = new ThreadType ( executor ) ; addOutput ( answer ) ; return this ; } } 	1	['94', '1', '11', '63', '186', '4361', '28', '53', '86', '0.967741935', '1012', '0.8', '3', '0', '0.067131328', '0', '0', '9.712765957', '2', '1.0745', '28']
package org . apache . camel ; public interface Producer < E extends Exchange > extends Processor , Service { Endpoint < E > getEndpoint ( ) ; E createExchange ( ) ; E createExchange ( ExchangePattern pattern ) ; E createExchange ( E exchange ) ; } 	0	['4', '1', '0', '38', '4', '6', '34', '5', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import org . apache . camel . Expression ; public class ParameterInfo { private final int index ; private final Class type ; private final Annotation [ ] annotations ; private final Expression expression ; public ParameterInfo ( int index , Class type , Annotation [ ] annotations , Expression expression ) { this . index = index ; this . type = type ; this . annotations = annotations ; this . expression = expression ; } public Annotation [ ] getAnnotations ( ) { return annotations ; } public Expression getExpression ( ) { return expression ; } public int getIndex ( ) { return index ; } public Class getType ( ) { return type ; } } 	1	['5', '1', '0', '4', '6', '2', '3', '1', '5', '0.75', '36', '1', '1', '0', '0.36', '0', '0', '5.4', '1', '0.8', '2']
package org . apache . camel . spring . remoting ; import org . aopalliance . intercept . MethodInterceptor ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; import org . apache . camel . component . bean . CamelInvocationHandler ; import org . apache . camel . util . CamelContextHelper ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import static org . apache . camel . util . ObjectHelper . notNull ; public class SendBeforeInterceptor implements MethodInterceptor , CamelContextAware , InitializingBean , DisposableBean { private String uri ; private CamelContext camelContext ; private CamelInvocationHandler invocationHandler ; private Producer producer ; public Object invoke ( MethodInvocation invocation ) throws Throwable { invocationHandler . invoke ( invocation . getThis ( ) , invocation . getMethod ( ) , invocation . getArguments ( ) ) ; return invocation . proceed ( ) ; } public void afterPropertiesSet ( ) throws Exception { notNull ( uri , "uri" ) ; notNull ( camelContext , "camelContext" ) ; Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( camelContext , uri ) ; producer = endpoint . createProducer ( ) ; producer . start ( ) ; invocationHandler = new CamelInvocationHandler ( endpoint , producer ) ; } public void destroy ( ) throws Exception { if ( producer != null ) { producer . stop ( ) ; } } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } } 	0	['7', '1', '0', '11', '19', '9', '0', '11', '7', '0.791666667', '75', '1', '3', '0', '0.357142857', '0', '0', '9.142857143', '1', '0.8571', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; public class FilterProcessor extends DelegateProcessor { private Predicate < Exchange > predicate ; public FilterProcessor ( Predicate < Exchange > predicate , Processor processor ) { super ( processor ) ; this . predicate = predicate ; } public void process ( Exchange exchange ) throws Exception { if ( predicate . matches ( exchange ) ) { super . process ( exchange ) ; } } @ Override public String toString ( ) { return "Filter[if: " + predicate + " do: " + getProcessor ( ) + "]" ; } public Predicate < Exchange > getPredicate ( ) { return predicate ; } } 	1	['4', '3', '0', '9', '12', '0', '5', '4', '4', '0', '41', '1', '1', '0.875', '0.4375', '0', '0', '9', '1', '0.75', '1']
package org . apache . camel . component . cxf ; public enum DataFormat { PAYLOAD , MESSAGE , POJO } 	0	['4', '2', '0', '6', '7', '4', '5', '1', '2', '0.916666667', '56', '0.25', '4', '0.857142857', '0.444444444', '1', '1', '12', '1', '0.5', '0']
package org . apache . camel . processor . aggregate ; import java . util . AbstractCollection ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class AggregationCollection extends AbstractCollection < Exchange > { private final Expression < Exchange > correlationExpression ; private final AggregationStrategy aggregationStrategy ; private Map < Object , Exchange > map = new LinkedHashMap < Object , Exchange > ( ) ; public AggregationCollection ( Expression < Exchange > correlationExpression , AggregationStrategy aggregationStrategy ) { this . correlationExpression = correlationExpression ; this . aggregationStrategy = aggregationStrategy ; } @ Override public boolean add ( Exchange exchange ) { Object correlationKey = correlationExpression . evaluate ( exchange ) ; Exchange oldExchange = map . get ( correlationKey ) ; Exchange newExchange = exchange ; if ( oldExchange != null ) { newExchange = aggregationStrategy . aggregate ( oldExchange , newExchange ) ; } if ( newExchange != oldExchange ) { map . put ( correlationKey , newExchange ) ; } return true ; } public Iterator < Exchange > iterator ( ) { return map . values ( ) . iterator ( ) ; } public int size ( ) { return map . size ( ) ; } } 	1	['5', '2', '0', '4', '14', '0', '1', '3', '5', '0.333333333', '68', '1', '2', '0.777777778', '0.36', '1', '5', '12', '3', '1.2', '4']
package org . apache . camel . processor . idempotent ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; public class NoMessageIdException extends RuntimeCamelException { private final Exchange exchange ; private final Expression expression ; public NoMessageIdException ( Exchange exchange , Expression expression ) { super ( "No message ID could be found using expression: " + expression + " on message exchange: " + exchange ) ; this . exchange = exchange ; this . expression = expression ; } public Exchange getExchange ( ) { return exchange ; } public Expression getExpression ( ) { return expression ; } } 	0	['3', '5', '0', '4', '8', '0', '1', '3', '3', '0.5', '32', '1', '2', '0.894736842', '0.555555556', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultMessage ; import java . io . File ; public class FileMessage extends DefaultMessage { private File file ; public FileMessage ( ) { this ( new File ( "." ) ) ; } public FileMessage ( File file ) { this . file = file ; } @ Override public String toString ( ) { return "FileMessage: " + file ; } @ Override public FileExchange getExchange ( ) { return ( FileExchange ) super . getExchange ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } @ Override public FileMessage newInstance ( ) { return new FileMessage ( ) ; } @ Override protected Object createBody ( ) { return file ; } } 	1	['11', '3', '0', '4', '15', '35', '1', '4', '10', '0.2', '62', '1', '0', '0.71875', '0.590909091', '2', '5', '4.545454545', '1', '0.8182', '1']
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; import java . util . List ; import java . lang . reflect . Method ; public class JpaBamProcessorSupport < T > extends BamProcessorSupport < T > { private static final transient Log LOG = LogFactory . getLog ( JpaBamProcessorSupport . class ) ; private ActivityRules activityRules ; private JpaTemplate template ; private String findByKeyQuery ; private String keyPropertyName = "correlationKey" ; private boolean correlationKeyIsPrimary = true ; public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < T > entitytype ) { super ( transactionTemplate , correlationKeyExpression , entitytype ) ; this . activityRules = activityRules ; this . template = template ; } public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , correlationKeyExpression ) ; this . activityRules = activityRules ; this . template = template ; } public String getFindByKeyQuery ( ) { if ( findByKeyQuery == null ) { findByKeyQuery = createFindByKeyQuery ( ) ; } return findByKeyQuery ; } public void setFindByKeyQuery ( String findByKeyQuery ) { this . findByKeyQuery = findByKeyQuery ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public void setActivityRules ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public String getKeyPropertyName ( ) { return keyPropertyName ; } public void setKeyPropertyName ( String keyPropertyName ) { this . keyPropertyName = keyPropertyName ; } public JpaTemplate getTemplate ( ) { return template ; } public void setTemplate ( JpaTemplate template ) { this . template = template ; } public boolean isCorrelationKeyIsPrimary ( ) { return correlationKeyIsPrimary ; } public void setCorrelationKeyIsPrimary ( boolean correlationKeyIsPrimary ) { this . correlationKeyIsPrimary = correlationKeyIsPrimary ; } protected T loadEntity ( Exchange exchange , Object key ) throws Exception { T entity = findEntityByCorrelationKey ( key ) ; if ( entity == null ) { entity = createEntity ( exchange , key ) ; setKeyProperty ( entity , key ) ; ProcessDefinition definition = ProcessDefinition . getRefreshedProcessDefinition ( template , getActivityRules ( ) . getProcessRules ( ) . getProcessDefinition ( ) ) ; setProcessDefinitionProperty ( entity , definition ) ; template . persist ( entity ) ; LOG . debug ( "About to flush on entity: " + entity + " with key: " + key ) ; template . flush ( ) ; } return entity ; } protected T findEntityByCorrelationKey ( Object key ) { if ( isCorrelationKeyIsPrimary ( ) ) { return template . find ( getEntityType ( ) , key ) ; } else { List < T > list = template . find ( getFindByKeyQuery ( ) , key ) ; if ( list . isEmpty ( ) ) { return null ; } else { return list . get ( 0 ) ; } } } protected Class getKeyType ( ) { try { Method getter = IntrospectionSupport . getPropertyGetter ( getEntityType ( ) , getKeyPropertyName ( ) ) ; return getter . getReturnType ( ) ; } catch ( NoSuchMethodException e ) { LOG . warn ( "no such getter for: " + getKeyPropertyName ( ) + " on " + getEntityType ( ) + ". Reason: " + e , e ) ; return null ; } } protected void setKeyProperty ( T entity , Object key ) throws Exception { IntrospectionSupport . setProperty ( entity , getKeyPropertyName ( ) , key ) ; } protected void setProcessDefinitionProperty ( T entity , ProcessDefinition processDefinition ) throws Exception { IntrospectionSupport . setProperty ( entity , "processDefinition" , processDefinition ) ; } protected T createEntity ( Exchange exchange , Object key ) { return ( T ) exchange . getContext ( ) . getInjector ( ) . newInstance ( getEntityType ( ) ) ; } protected void processEntity ( Exchange exchange , T entity ) throws Exception { if ( entity instanceof Processor ) { Processor processor = ( Processor ) entity ; processor . process ( exchange ) ; } else { throw new IllegalArgumentException ( "No processor defined for this route" ) ; } } protected String createFindByKeyQuery ( ) { return "select x from " + getEntityType ( ) . getName ( ) + " x where x." + getKeyPropertyName ( ) + " = ?1" ; } } 	0	['21', '2', '1', '15', '49', '142', '1', '14', '12', '0.808333333', '276', '1', '2', '0.4', '0.2', '1', '2', '11.85714286', '3', '1', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelException ; public class NoBeanAvailableException extends CamelException { private final String name ; public NoBeanAvailableException ( String name ) { super ( "No bean available for endpoint: " + name ) ; this . name = name ; } public String getName ( ) { return name ; } } 	1	['2', '4', '0', '2', '6', '0', '1', '1', '2', '0', '20', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '1']
package org . apache . camel . component . bean ; import org . apache . camel . Expression ; public interface ParameterMappingStrategy { Expression getDefaultParameterTypeExpression ( Class parameterType ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public class InvalidHeaderTypeException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; private final Object headerValue ; public InvalidHeaderTypeException ( Throwable cause , Object headerValue ) { super ( cause . getMessage ( ) + " headerValue is: " + headerValue + " of type: " + typeName ( headerValue ) , cause ) ; this . headerValue = headerValue ; } public InvalidHeaderTypeException ( String message , Object headerValue ) { super ( message ) ; this . headerValue = headerValue ; } public Object getHeaderValue ( ) { return headerValue ; } protected static String typeName ( Object headerValue ) { return ( headerValue != null ) ? headerValue . getClass ( ) . getName ( ) : "null" ; } } 	1	['4', '5', '0', '1', '13', '0', '0', '1', '3', '0.833333333', '47', '1', '0', '0.894736842', '0.5', '0', '0', '10.25', '2', '0.75', '1']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; public abstract class PredicateSupport < E extends Exchange > implements Predicate < E > { public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( assertionFailureMessage ( exchange ) + " on " + exchange ) ; } } protected String assertionFailureMessage ( E exchange ) { return toString ( ) ; } } 	0	['4', '1', '6', '8', '12', '6', '6', '2', '3', '2', '37', '0', '0', '0', '0.5625', '0', '0', '8.25', '2', '1', '0']
package org . apache . camel ; import org . apache . camel . spi . UnitOfWork ; import java . util . Map ; public interface Exchange { ExchangePattern getPattern ( ) ; Object getProperty ( String name ) ; < T > T getProperty ( String name , Class < T > type ) ; void setProperty ( String name , Object value ) ; Object removeProperty ( String name ) ; Map < String , Object > getProperties ( ) ; Message getIn ( ) ; Message getOut ( ) ; Message getOut ( boolean lazyCreate ) ; Message getFault ( ) ; Message getFault ( boolean lazyCreate ) ; Throwable getException ( ) ; void setException ( Throwable e ) ; boolean isFailed ( ) ; CamelContext getContext ( ) ; Exchange copy ( ) ; void copyFrom ( Exchange source ) ; UnitOfWork getUnitOfWork ( ) ; void setUnitOfWork ( UnitOfWork unitOfWork ) ; String getExchangeId ( ) ; void setExchangeId ( String id ) ; } 	1	['21', '1', '0', '272', '21', '210', '270', '4', '21', '2', '21', '0', '0', '0', '0.196428571', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . quartz ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . quartz . JobExecutionContext ; import org . quartz . Trigger ; public class QuartzMessage extends DefaultMessage { private final JobExecutionContext jobExecutionContext ; public QuartzMessage ( QuartzExchange exchange , JobExecutionContext jobExecutionContext ) { this . jobExecutionContext = jobExecutionContext ; setExchange ( exchange ) ; setBody ( jobExecutionContext . getJobDetail ( ) ) ; } public JobExecutionContext getJobExecutionContext ( ) { return jobExecutionContext ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { super . populateInitialHeaders ( map ) ; if ( jobExecutionContext != null ) { map . put ( "calendar" , jobExecutionContext . getCalendar ( ) ) ; map . put ( "fireTime" , jobExecutionContext . getFireTime ( ) ) ; map . put ( "jobDetail" , jobExecutionContext . getJobDetail ( ) ) ; map . put ( "jobInstance" , jobExecutionContext . getJobInstance ( ) ) ; map . put ( "jobRunTime" , jobExecutionContext . getJobRunTime ( ) ) ; map . put ( "mergedJobDataMap" , jobExecutionContext . getMergedJobDataMap ( ) ) ; map . put ( "nextFireTime" , jobExecutionContext . getNextFireTime ( ) ) ; map . put ( "previousFireTime" , jobExecutionContext . getPreviousFireTime ( ) ) ; map . put ( "refireCount" , jobExecutionContext . getRefireCount ( ) ) ; map . put ( "result" , jobExecutionContext . getResult ( ) ) ; map . put ( "scheduledFireTime" , jobExecutionContext . getScheduledFireTime ( ) ) ; map . put ( "scheduler" , jobExecutionContext . getScheduler ( ) ) ; Trigger trigger = jobExecutionContext . getTrigger ( ) ; map . put ( "trigger" , trigger ) ; map . put ( "triggerName" , trigger . getName ( ) ) ; map . put ( "triggerGroup" , trigger . getGroup ( ) ) ; } } } 	0	['3', '3', '0', '10', '25', '0', '1', '10', '2', '0', '134', '1', '0', '0.92', '0.5', '1', '1', '43.33333333', '2', '1', '0']
package org . apache . camel . language ; import org . apache . camel . component . bean . DefaultAnnotationExpressionFactory ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . ANNOTATION_TYPE } ) public @ interface LanguageAnnotation { public abstract String language ( ) ; public abstract Class < ? > factory ( ) default DefaultAnnotationExpressionFactory . class ; } 	1	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . velocity ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringWriter ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . component . ResourceBasedEndpoint ; import org . apache . camel . util . ExchangeHelper ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . context . Context ; public class VelocityEndpoint extends ResourceBasedEndpoint { private final VelocityComponent component ; private VelocityEngine velocityEngine ; public VelocityEndpoint ( String uri , VelocityComponent component , String resourceUri , Map parameters ) { super ( uri , component , resourceUri , null ) ; this . component = component ; } public boolean isSingleton ( ) { return true ; } @ Override public ExchangePattern getExchangePattern ( ) { return ExchangePattern . InOut ; } public VelocityEngine getVelocityEngine ( ) throws Exception { if ( velocityEngine == null ) { velocityEngine = component . getVelocityEngine ( ) ; velocityEngine . init ( ) ; } return velocityEngine ; } public void setVelocityEngine ( VelocityEngine velocityEngine ) { this . velocityEngine = velocityEngine ; } @ Override protected void onExchange ( Exchange exchange ) throws Exception { Reader reader = new InputStreamReader ( getResource ( ) . getInputStream ( ) ) ; StringWriter buffer = new StringWriter ( ) ; String logTag = getClass ( ) . getName ( ) ; Map variableMap = ExchangeHelper . createVariableMap ( exchange ) ; Context velocityContext = new VelocityContext ( variableMap ) ; VelocityEngine engine = getVelocityEngine ( ) ; engine . evaluate ( velocityContext , buffer , logTag , reader ) ; Message out = exchange . getOut ( true ) ; out . setBody ( buffer . toString ( ) ) ; out . setHeader ( "org.apache.camel.velocity.resource" , getResource ( ) ) ; } } 	0	['6', '6', '0', '12', '22', '11', '1', '12', '5', '0.6', '87', '1', '1', '0.857142857', '0.305555556', '0', '0', '13.16666667', '1', '0.8333', '0']
package org . apache . camel . model ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; import java . util . Collections ; import java . util . List ; @ XmlRootElement ( name = "proceed" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ProceedType extends ProcessorType { public List < ProcessorType > getOutputs ( ) { return Collections . EMPTY_LIST ; } public List < InterceptorType > getInterceptors ( ) { return Collections . EMPTY_LIST ; } public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProceedProcessor ( ) ; } } 	1	['4', '2', '0', '3', '6', '6', '1', '3', '4', '2', '14', '0', '0', '0.96875', '0.625', '1', '4', '2.5', '1', '0.75', '4']
package org . apache . camel . component . xmpp ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . Chat ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; public class XmppPrivateChatProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( XmppPrivateChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String participant ; private Chat chat ; public XmppPrivateChatProducer ( XmppEndpoint endpoint , String participant ) { super ( endpoint ) ; this . endpoint = endpoint ; this . participant = participant ; if ( participant == null ) { throw new IllegalArgumentException ( "No participant property specified" ) ; } } public void process ( Exchange exchange ) { Message message = chat . createMessage ( ) ; message . setTo ( participant ) ; message . setFrom ( endpoint . getUser ( ) ) ; message . setThread ( exchange . getExchangeId ( ) ) ; message . setType ( Message . Type . NORMAL ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> message: " + message . getBody ( ) ) ; } try { chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( chat == null ) { chat = endpoint . getConnection ( ) . createChat ( getParticipant ( ) ) ; } } @ Override protected void doStop ( ) throws Exception { chat = null ; super . doStop ( ) ; } public Chat getChat ( ) { return chat ; } public void setChat ( Chat chat ) { this . chat = chat ; } public String getParticipant ( ) { return participant ; } } 	0	['8', '3', '0', '13', '32', '0', '1', '13', '5', '0.642857143', '115', '1', '2', '0.76', '0.314285714', '0', '0', '12.875', '2', '0.875', '0']
package org . apache . camel ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; import org . apache . camel . model . RouteType ; public interface CamelContext extends Service { String getName ( ) ; void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < RouteType > getRouteDefinitions ( ) ; List < Route > getRoutes ( ) ; void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( RouteBuilder builder ) throws Exception ; void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Registry getRegistry ( ) ; Injector getInjector ( ) ; LifecycleStrategy getLifecycleStrategy ( ) ; Language resolveLanguage ( String language ) ; } 	1	['23', '1', '0', '111', '23', '253', '105', '10', '23', '2', '23', '0', '0', '0', '0.202898551', '0', '0', '0', '1', '1', '1']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . spring ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public class UseLatestAggregationStrategy implements AggregationStrategy { public Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) { return newExchange ; } } 	1	['2', '1', '0', '3', '3', '1', '1', '2', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '1']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Component ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; public abstract class DefaultPollingEndpoint < E extends Exchange > extends ScheduledPollEndpoint < E > { protected DefaultPollingEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } protected DefaultPollingEndpoint ( String endpointUri , CamelContext context ) { super ( endpointUri , context ) ; } public Consumer < E > createConsumer ( Processor processor ) throws Exception { DefaultScheduledPollConsumer result = new DefaultScheduledPollConsumer ( this , processor ) ; configureConsumer ( result ) ; return result ; } } 	0	['3', '3', '2', '9', '7', '3', '2', '7', '1', '2', '24', '0', '0', '0.954545455', '0.533333333', '0', '0', '7', '1', '0.3333', '0']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . Map ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPathVariableResolver ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . builder . xml . Namespaces . ENVIRONMENT_VARIABLES ; import static org . apache . camel . builder . xml . Namespaces . EXCHANGE_PROPERTY ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . SYSTEM_PROPERTIES_NAMESPACE ; public class MessageVariableResolver implements XPathVariableResolver { private static final transient Log LOG = LogFactory . getLog ( MessageVariableResolver . class ) ; private Exchange exchange ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public Object resolveVariable ( QName name ) { String uri = name . getNamespaceURI ( ) ; String localPart = name . getLocalPart ( ) ; Object answer = null ; Message in = exchange . getIn ( ) ; if ( uri == null || uri . length ( ) == 0 ) { answer = variables . get ( localPart ) ; if ( answer == null ) { Message message = in ; if ( message != null ) { answer = message . getHeader ( localPart ) ; } if ( answer == null ) { answer = exchange . getProperty ( localPart ) ; } } } else if ( uri . equals ( SYSTEM_PROPERTIES_NAMESPACE ) ) { try { answer = System . getProperty ( localPart ) ; } catch ( Exception e ) { LOG . debug ( "Security exception evaluating system property: " + localPart + ". Reason: " + e , e ) ; } } else if ( uri . equals ( ENVIRONMENT_VARIABLES ) ) { answer = System . getenv ( ) . get ( localPart ) ; } else if ( uri . equals ( EXCHANGE_PROPERTY ) ) { answer = exchange . getProperty ( localPart ) ; } else if ( uri . equals ( IN_NAMESPACE ) ) { answer = in . getHeader ( localPart ) ; if ( answer == null && localPart . equals ( "body" ) ) { answer = in . getBody ( ) ; } } else if ( uri . equals ( OUT_NAMESPACE ) ) { Message out = exchange . getOut ( ) ; answer = out . getHeader ( localPart ) ; if ( answer == null && localPart . equals ( "body" ) ) { answer = out . getBody ( ) ; } } return answer ; } public void addVariable ( String localPart , Object value ) { variables . put ( localPart , value ) ; } } 	1	['6', '1', '0', '5', '27', '1', '1', '4', '5', '0.666666667', '160', '1', '2', '0', '0.36', '0', '0', '25.16666667', '14', '2.8333', '2']
package org . apache . camel . component . cxf ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import java . io . InputStream ; import java . util . List ; import java . util . Set ; public class CxfBinding { public Object extractBodyFromCxf ( CxfExchange exchange , Message message ) { return getBody ( message ) ; } protected Object getBody ( Message message ) { Set < Class < ? > > contentFormats = message . getContentFormats ( ) ; if ( contentFormats != null ) { for ( Class < ? > contentFormat : contentFormats ) { Object answer = message . getContent ( contentFormat ) ; if ( answer != null ) { return answer ; } } } return null ; } public Message createCxfMessage ( CxfExchange exchange ) { Message answer = exchange . getInMessage ( ) ; CxfMessage in = exchange . getIn ( ) ; Object body = in . getBody ( InputStream . class ) ; if ( body == null ) { body = in . getBody ( ) ; } if ( body instanceof InputStream ) { answer . setContent ( InputStream . class , body ) ; } else if ( body instanceof List ) { answer . setContent ( List . class , body ) ; answer . setContent ( String . class , in . getHeader ( CxfConstants . OPERATION_NAME ) ) ; } return answer ; } public void storeCxfResponse ( CxfExchange exchange , Message response ) { CxfMessage out = exchange . getOut ( ) ; if ( response != null ) { out . setMessage ( response ) ; out . setBody ( getBody ( response ) ) ; } } public void storeCxfResponse ( CxfExchange exchange , Object response ) { CxfMessage out = exchange . getOut ( ) ; if ( response != null ) { out . setBody ( response ) ; } } public void storeCxfFault ( CxfExchange exchange , Message message ) { CxfMessage fault = exchange . getFault ( ) ; if ( fault != null ) { fault . setBody ( getBody ( message ) ) ; } } } 	0	['7', '1', '0', '5', '23', '21', '4', '3', '6', '2', '112', '0', '0', '0', '0.607142857', '0', '0', '15', '4', '2', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Delayer ; @ XmlRootElement ( name = "delayer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DelayerType extends ExpressionNode { private Long delay = 0L ; public DelayerType ( ) { } public DelayerType ( Expression processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( ExpressionType processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( Expression processAtExpression , long delay ) { super ( processAtExpression ) ; this . delay = delay ; } @ Override public String toString ( ) { return "Delayer[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } public Long getDelay ( ) { return delay ; } public void setDelay ( Long delay ) { this . delay = delay ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; Expression processAtExpression = getExpression ( ) . createExpression ( routeContext ) ; return new Delayer ( childProcessor , processAtExpression , delay ) ; } } 	1	['8', '3', '0', '7', '22', '0', '1', '7', '8', '0.142857143', '86', '1', '0', '0.962264151', '0.291666667', '1', '2', '9.625', '1', '0.5', '3']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Session ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . MessageCreator ; public class JmsProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( JmsProducer . class ) ; private final JmsEndpoint endpoint ; private final JmsOperations template ; public JmsProducer ( JmsEndpoint endpoint , JmsOperations template ) { super ( endpoint ) ; this . endpoint = endpoint ; this . template = template ; } public void process ( final Exchange exchange ) { template . send ( endpoint . getDestination ( ) , new MessageCreator ( ) { public Message createMessage ( Session session ) throws JMSException { Message message = endpoint . getBinding ( ) . makeJmsMessage ( exchange , session ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " sending JMS message: " + message ) ; } return message ; } } ) ; } public JmsOperations getTemplate ( ) { return template ; } } 	0	['6', '3', '0', '9', '11', '3', '2', '9', '3', '0.666666667', '43', '1', '2', '0.826086957', '0.28', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; public class ProcessorBuilder { private ProcessorBuilder ( ) { } public static Processor setBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setBody(" + expression + ")" ; } } ; } public static Processor setOutBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setOutBody(" + expression + ")" ; } } ; } public static Processor setFaultBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setFaultBody(" + expression + ")" ; } } ; } public static Processor setHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setOutHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setOutHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setFaultHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setFaultHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setProperty ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . setProperty ( name , value ) ; } @ Override public String toString ( ) { return "setProperty(" + name + ", " + expression + ")" ; } } ; } public static Processor removeHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getIn ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeHeader(" + name + ")" ; } } ; } public static Processor removeOutHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getOut ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeOutHeader(" + name + ")" ; } } ; } public static Processor removeFaultHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getFault ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeFaultHeader(" + name + ")" ; } } ; } public static Processor removeProperty ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . removeProperty ( name ) ; } @ Override public String toString ( ) { return "removeProperty(" + name + ")" ; } } ; } } 	1	['12', '1', '0', '14', '24', '66', '1', '13', '11', '2', '74', '0', '0', '0', '0.444444444', '0', '0', '5.166666667', '1', '0.9167', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import org . w3c . dom . Element ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . staxutils . StaxUtils ; public class PayloadContentRedirectInterceptor extends AbstractPhaseInterceptor < Message > { public PayloadContentRedirectInterceptor ( ) { super ( Phase . POST_STREAM ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { XMLStreamWriter out = message . getContent ( XMLStreamWriter . class ) ; List < Element > in = message . get ( List . class ) ; try { for ( Element el : in ) { StaxUtils . writeElement ( el , out , false , true ) ; } } catch ( XMLStreamException e ) { throw new Fault ( e ) ; } } } 	0	['2', '0', '0', '5', '10', '1', '1', '4', '2', '2', '40', '0', '0', '0', '0.75', '0', '0', '19', '1', '0.5', '0']
package org . apache . camel . model ; import org . apache . camel . * ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . bind . annotation . * ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; @ XmlRootElement ( name = "route" ) @ XmlType ( propOrder = { "interceptors" , "inputs" , "outputs" } ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RouteType extends ProcessorType implements CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( RouteType . class ) ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < FromType > inputs = new ArrayList < FromType > ( ) ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; @ XmlAttribute private String group ; @ XmlTransient private CamelContext camelContext ; public RouteType ( ) { } public RouteType ( String uri ) { from ( uri ) ; } public RouteType ( Endpoint endpoint ) { from ( endpoint ) ; } @ Override public String toString ( ) { return "Route[ " + inputs + " -> " + outputs + "]" ; } public void addRoutes ( CamelContext context ) throws Exception { Collection < Route > routes = new ArrayList < Route > ( ) ; addRoutes ( context , routes ) ; context . addRoutes ( routes ) ; } public void addRoutes ( CamelContext context , Collection < Route > routes ) throws Exception { setCamelContext ( context ) ; for ( FromType fromType : inputs ) { addRoutes ( routes , fromType ) ; } } public Endpoint resolveEndpoint ( String uri ) throws NoSuchEndpointException { CamelContext context = getCamelContext ( ) ; if ( context == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } return CamelContextHelper . getMandatoryEndpoint ( context , uri ) ; } public RouteType from ( String uri ) { getInputs ( ) . add ( new FromType ( uri ) ) ; return this ; } public RouteType from ( Endpoint endpoint ) { getInputs ( ) . add ( new FromType ( endpoint ) ) ; return this ; } public RouteType group ( String name ) { setGroup ( name ) ; return this ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < FromType > getInputs ( ) { return inputs ; } public void setInputs ( List < FromType > inputs ) { this . inputs = inputs ; } public List < ProcessorType > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } protected void addRoutes ( Collection < Route > routes , FromType fromType ) throws Exception { RouteContext routeContext = new RouteContext ( this , fromType , routes ) ; Endpoint endpoint = routeContext . getEndpoint ( ) ; for ( ProcessorType output : outputs ) { output . addRoutes ( routeContext , routes ) ; } routeContext . commit ( ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } List < InterceptorType > list = output . getInterceptors ( ) ; if ( list == null ) { LOG . warn ( "No interceptor collection: " + output ) ; } else { list . addAll ( getInterceptors ( ) ) ; } } } 	1	['23', '2', '0', '23', '50', '161', '14', '11', '20', '0.787878788', '295', '1', '2', '0.830357143', '0.221590909', '1', '6', '11.56521739', '3', '1', '4']
package org . apache . camel . processor . resequencer ; class ElementComparator < E > implements SequenceElementComparator < Element < E > > { private SequenceElementComparator < E > comparator ; public ElementComparator ( SequenceElementComparator < E > comparator ) { this . comparator = comparator ; } public boolean predecessor ( Element < E > o1 , Element < E > o2 ) { return comparator . predecessor ( o1 . getObject ( ) , o2 . getObject ( ) ) ; } public boolean successor ( Element < E > o1 , Element < E > o2 ) { return comparator . successor ( o1 . getObject ( ) , o2 . getObject ( ) ) ; } public int compare ( Element < E > o1 , Element < E > o2 ) { return comparator . compare ( o1 . getObject ( ) , o2 . getObject ( ) ) ; } } 	0	['7', '1', '0', '3', '12', '9', '1', '2', '7', '0', '59', '1', '1', '0', '0.5', '0', '0', '7.285714286', '1', '0.8571', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Logger implements Processor { private Log log ; private LoggingLevel level ; public Logger ( ) { this ( LogFactory . getLog ( Logger . class ) ) ; } public Logger ( Log log ) { this ( log , LoggingLevel . INFO ) ; } public Logger ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public Logger ( String logName ) { this ( LogFactory . getLog ( logName ) ) ; } public Logger ( String logName , LoggingLevel level ) { this ( LogFactory . getLog ( logName ) , level ) ; } @ Override public String toString ( ) { return "Logger[" + log + "]" ; } public void process ( Exchange exchange ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange ) ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange ) ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange ) ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ( exchange ) ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange ) ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange ) ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange ) ) ; } } public void log ( String message ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message ) ; } } public void log ( String message , Throwable exception ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message , exception ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message , exception ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message , exception ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message , exception ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message , exception ) ; } } protected Object logMessage ( Exchange exchange ) { return exchange ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } } 	1	['14', '1', '0', '11', '39', '31', '5', '6', '13', '0.346153846', '326', '1', '2', '0', '0.321428571', '0', '0', '22.14285714', '8', '2.1429', '1']
package org . apache . camel . component . cxf ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultMessage ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; public class CxfExchange extends DefaultExchange { private final CxfBinding binding ; private Exchange exchange ; public CxfExchange ( CamelContext context , CxfBinding binding , Exchange exchange ) { super ( context ) ; this . binding = binding ; this . exchange = exchange ; setIn ( new CxfMessage ( exchange . getInMessage ( ) ) ) ; setOut ( new CxfMessage ( exchange . getOutMessage ( ) ) ) ; if ( exchange . getInFaultMessage ( ) != null ) { setFault ( new CxfMessage ( exchange . getInFaultMessage ( ) ) ) ; } } public CxfExchange ( CamelContext context , ExchangePattern pattern , CxfBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public CxfExchange ( CamelContext context , ExchangePattern pattern , CxfBinding binding , Message inMessage ) { this ( context , pattern , binding ) ; this . exchange = inMessage . getExchange ( ) ; setIn ( new CxfMessage ( inMessage ) ) ; if ( exchange != null ) { setOut ( new CxfMessage ( exchange . getOutMessage ( ) ) ) ; if ( exchange . getInFaultMessage ( ) != null ) { setFault ( new CxfMessage ( exchange . getInFaultMessage ( ) ) ) ; } } } @ Override public CxfMessage getIn ( ) { return ( CxfMessage ) super . getIn ( ) ; } @ Override public CxfMessage getOut ( ) { return ( CxfMessage ) super . getOut ( ) ; } @ Override public CxfMessage getOut ( boolean lazyCreate ) { return ( CxfMessage ) super . getOut ( lazyCreate ) ; } @ Override public CxfMessage getFault ( ) { return ( CxfMessage ) super . getFault ( ) ; } @ Override protected org . apache . camel . Message createFaultMessage ( ) { return new CxfMessage ( ) ; } public CxfBinding getBinding ( ) { return binding ; } public Exchange getExchange ( ) { return exchange ; } public Message getInMessage ( ) { return getIn ( ) . getMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getMessage ( ) ; } public Message getOutFaultMessage ( ) { return getExchange ( ) . getOutFaultMessage ( ) ; } public Message getInFaultMessage ( ) { return getExchange ( ) . getInFaultMessage ( ) ; } public Destination getDestination ( ) { return getExchange ( ) . getDestination ( ) ; } public Conduit getConduit ( Message message ) { return getExchange ( ) . getConduit ( message ) ; } @ Override protected CxfMessage createInMessage ( ) { return new CxfMessage ( ) ; } @ Override protected CxfMessage createOutMessage ( ) { return new CxfMessage ( ) ; } } 	0	['24', '2', '0', '13', '37', '264', '5', '10', '19', '0.804347826', '186', '1', '1', '0.631578947', '0.220238095', '1', '2', '6.666666667', '1', '0.875', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlElementRef ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . SendProcessor ; @ XmlRootElement ( name = "to" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ToType extends ProcessorType { @ XmlAttribute private String uri ; @ XmlAttribute private String ref ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlTransient private Endpoint endpoint ; public ToType ( ) { } public ToType ( String uri ) { setUri ( uri ) ; } public ToType ( Endpoint endpoint ) { setEndpoint ( endpoint ) ; } @ Override public String toString ( ) { return "To[" + getLabel ( ) + "]" ; } @ Override public String getLabel ( ) { return FromType . description ( getUri ( ) , getRef ( ) , getEndpoint ( ) ) ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Endpoint endpoint = resolveEndpoint ( routeContext ) ; return new SendProcessor ( endpoint ) ; } public Endpoint resolveEndpoint ( RouteContext context ) { if ( endpoint == null ) { endpoint = context . resolveEndpoint ( getUri ( ) , getRef ( ) ) ; } return endpoint ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public List < ProcessorType > getOutputs ( ) { return Collections . EMPTY_LIST ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public Object getUriOrRef ( ) { if ( ObjectHelper . isNullOrBlank ( uri ) ) { return uri ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } return ref ; } } 	1	['17', '2', '0', '9', '27', '92', '3', '7', '17', '0.703125', '141', '1', '1', '0.869158879', '0.294117647', '1', '4', '7.058823529', '3', '1', '2']
package org . apache . camel . component . xmpp ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . jivesoftware . smack . packet . Message ; public class XmppMessage extends DefaultMessage { private Message xmppMessage ; public XmppMessage ( ) { this ( new Message ( ) ) ; } public XmppMessage ( Message jmsMessage ) { this . xmppMessage = jmsMessage ; } @ Override public String toString ( ) { if ( xmppMessage != null ) { return "XmppMessage: " + xmppMessage ; } else { return "XmppMessage: " + getBody ( ) ; } } @ Override public XmppExchange getExchange ( ) { return ( XmppExchange ) super . getExchange ( ) ; } public Message getXmppMessage ( ) { return xmppMessage ; } public void setXmppMessage ( Message xmppMessage ) { this . xmppMessage = xmppMessage ; } public Object getHeader ( String name ) { return xmppMessage . getProperty ( name ) ; } @ Override public void setHeader ( String name , Object value ) { if ( value == null ) { xmppMessage . deleteProperty ( name ) ; } else { xmppMessage . setProperty ( name , value ) ; } } @ Override public Map < String , Object > getHeaders ( ) { Map < String , Object > answer = new HashMap < String , Object > ( ) ; Iterator iter = xmppMessage . getPropertyNames ( ) ; while ( iter . hasNext ( ) ) { String name = ( String ) iter . next ( ) ; answer . put ( name , xmppMessage . getProperty ( name ) ) ; } return answer ; } @ Override public XmppMessage newInstance ( ) { return new XmppMessage ( ) ; } @ Override protected Object createBody ( ) { if ( xmppMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromXmpp ( getExchange ( ) , xmppMessage ) ; } return null ; } } 	0	['14', '3', '0', '6', '29', '35', '1', '6', '13', '0.153846154', '132', '1', '0', '0.657142857', '0.339285714', '2', '7', '8.357142857', '2', '1.1429', '0']
package org . apache . camel . component . file ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . file . strategy . FileProcessStrategy ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileConsumer . class ) ; private final FileEndpoint endpoint ; private boolean recursive = true ; private String regexPattern = "" ; private long lastPollTime ; boolean generateEmptyExchangeWhenIdle ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected void poll ( ) throws Exception { int rc = pollFileOrDirectory ( endpoint . getFile ( ) , isRecursive ( ) ) ; if ( rc == 0 && generateEmptyExchangeWhenIdle ) { final FileExchange exchange = endpoint . createExchange ( ( File ) null ) ; getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } lastPollTime = System . currentTimeMillis ( ) ; } protected int pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { return pollFile ( fileOrDirectory ) ; } else if ( processDir ) { int rc = 0 ; if ( isValidFile ( fileOrDirectory ) ) { LOG . debug ( "Polling directory " + fileOrDirectory ) ; File [ ] files = fileOrDirectory . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { rc += pollFileOrDirectory ( files [ i ] , isRecursive ( ) ) ; } } return rc ; } else { LOG . debug ( "Skipping directory " + fileOrDirectory ) ; return 0 ; } } ConcurrentHashMap < File , File > filesBeingProcessed = new ConcurrentHashMap < File , File > ( ) ; protected int pollFile ( final File file ) { if ( ! file . exists ( ) ) { return 0 ; } if ( ! isValidFile ( file ) ) { return 0 ; } if ( endpoint . isNoop ( ) ) { long fileModified = file . lastModified ( ) ; if ( fileModified <= lastPollTime ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring file: " + file + " as modified time: " + fileModified + " less than last poll time: " + lastPollTime ) ; } return 0 ; } } else { if ( filesBeingProcessed . contains ( file ) ) { return 1 ; } filesBeingProcessed . put ( file , file ) ; } final FileProcessStrategy processStrategy = endpoint . getFileStrategy ( ) ; final FileExchange exchange = endpoint . createExchange ( file ) ; endpoint . configureMessage ( file , exchange . getIn ( ) ) ; try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to process file:  " + file + " using exchange: " + exchange ) ; } if ( processStrategy . begin ( endpoint , exchange , file ) ) { getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( exchange . getException ( ) == null ) { try { processStrategy . commit ( endpoint , ( FileExchange ) exchange , file ) ; } catch ( Exception e ) { handleException ( e ) ; } } else { handleException ( exchange . getException ( ) ) ; } filesBeingProcessed . remove ( file ) ; } } ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " cannot process file: " + file ) ; } } } catch ( Throwable e ) { handleException ( e ) ; } return 1 ; } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) ) { result = true ; } } return result ; } protected boolean isMatched ( File file ) { String name = file . getName ( ) ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { if ( ! name . matches ( getRegexPattern ( ) ) ) { return false ; } } String [ ] prefixes = endpoint . getExcludedNamePrefixes ( ) ; if ( prefixes != null ) { for ( String prefix : prefixes ) { if ( name . startsWith ( prefix ) ) { return false ; } } } String [ ] postfixes = endpoint . getExcludedNamePostfixes ( ) ; if ( postfixes != null ) { for ( String postfix : postfixes ) { if ( name . endsWith ( postfix ) ) { return false ; } } } return true ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } public boolean isGenerateEmptyExchangeWhenIdle ( ) { return generateEmptyExchangeWhenIdle ; } public void setGenerateEmptyExchangeWhenIdle ( boolean generateEmptyExchangeWhenIdle ) { this . generateEmptyExchangeWhenIdle = generateEmptyExchangeWhenIdle ; } } 	1	['16', '4', '0', '14', '52', '72', '3', '14', '7', '0.780952381', '396', '0.714285714', '2', '0.708333333', '0.225', '1', '1', '23.3125', '10', '2.3125', '6']
package org . apache . camel . component . file . remote ; import java . io . IOException ; import java . io . InputStream ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . SftpException ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; public class SftpProducer extends RemoteFileProducer < RemoteFileExchange > { SftpEndpoint endpoint ; private final ChannelSftp channel ; public SftpProducer ( SftpEndpoint endpoint , ChannelSftp channelSftp ) { super ( endpoint ) ; this . endpoint = endpoint ; this . channel = channelSftp ; } public void process ( Exchange exchange ) throws Exception { process ( endpoint . createExchange ( exchange ) ) ; } public void process ( RemoteFileExchange exchange ) throws Exception { InputStream payload = exchange . getIn ( ) . getBody ( InputStream . class ) ; final String endpointFile = endpoint . getConfiguration ( ) . getFile ( ) ; channel . cd ( endpointFile ) ; String fileName = createFileName ( exchange . getIn ( ) , endpoint . getConfiguration ( ) ) ; buildDirectory ( channel , fileName . substring ( 0 , fileName . lastIndexOf ( '/' ) ) ) ; try { channel . put ( payload , fileName ) ; } catch ( SftpException e ) { throw new RuntimeCamelException ( "error sending file" , e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { channel . disconnect ( ) ; super . doStop ( ) ; } protected static boolean buildDirectory ( ChannelSftp sftpClient , String dirName ) throws IOException { boolean atLeastOneSuccess = false ; final StringBuilder sb = new StringBuilder ( dirName . length ( ) ) ; final String [ ] dirs = dirName . split ( "\\/" ) ; for ( String dir : dirs ) { sb . append ( '/' ) . append ( dir ) ; try { sftpClient . mkdir ( sb . toString ( ) ) ; if ( ! atLeastOneSuccess ) { atLeastOneSuccess = true ; } } catch ( SftpException e ) { } } return atLeastOneSuccess ; } } 	0	['6', '4', '0', '10', '28', '5', '1', '10', '3', '0.5', '128', '0.5', '1', '0.8', '0.305555556', '1', '1', '20', '1', '0.8333', '0']
package org . apache . camel . component . jmx ; import javax . management . MBeanServer ; import javax . management . Notification ; import javax . management . ObjectName ; import javax . management . monitor . CounterMonitor ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JMXEndpoint extends DefaultEndpoint < JMXExchange > { private static final Log LOG = LogFactory . getLog ( JMXEndpoint . class ) ; private String name ; private ObjectName ourName ; private String observedObjectName ; private String attributeName ; private long granularityPeriod = 5000 ; private Number threshold ; private Number offset ; private MBeanServer mbeanServer ; private CounterMonitor counterMonitor = new CounterMonitor ( ) ; protected JMXEndpoint ( String endpointUri , JMXComponent component ) { super ( endpointUri , component ) ; observedObjectName = endpointUri ; } public Producer < JMXExchange > createProducer ( ) throws Exception { throw new RuntimeException ( "Not supported" ) ; } public Consumer < JMXExchange > createConsumer ( Processor proc ) throws Exception { ObjectName observedName = new ObjectName ( observedObjectName ) ; if ( name == null ) { String type = observedName . getKeyProperty ( "type" ) ; type = type != null ? type : "UNKNOWN" ; name = mbeanServer . getDefaultDomain ( ) + ":type=CounterMonitor_" + type ; } JMXConsumer result = new JMXConsumer ( this , proc ) ; ourName = new ObjectName ( name ) ; counterMonitor . setNotify ( true ) ; counterMonitor . addObservedObject ( observedName ) ; counterMonitor . setObservedAttribute ( attributeName ) ; counterMonitor . setGranularityPeriod ( granularityPeriod ) ; counterMonitor . setDifferenceMode ( false ) ; counterMonitor . setInitThreshold ( threshold ) ; counterMonitor . setOffset ( offset ) ; mbeanServer . registerMBean ( counterMonitor , ourName ) ; mbeanServer . addNotificationListener ( ourName , result , null , new Object ( ) ) ; return result ; } public boolean isSingleton ( ) { return true ; } public JMXExchange createExchange ( Notification notification ) { return new JMXExchange ( getContext ( ) , getExchangePattern ( ) , notification ) ; } public JMXExchange createExchange ( ) { return new JMXExchange ( getContext ( ) , getExchangePattern ( ) , null ) ; } public JMXExchange createExchange ( ExchangePattern pattern ) { return new JMXExchange ( getContext ( ) , pattern , null ) ; } public String getAttributeName ( ) { return attributeName ; } public void setAttributeName ( String attributeName ) { this . attributeName = attributeName ; } public long getGranularityPeriod ( ) { return granularityPeriod ; } public void setGranularityPeriod ( long granularityPeriod ) { this . granularityPeriod = granularityPeriod ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Number getOffset ( ) { return offset ; } public void setOffset ( Number offset ) { this . offset = offset ; } public Number getThreshold ( ) { return threshold ; } public void setThreshold ( Number threshold ) { this . threshold = threshold ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	1	['22', '2', '0', '13', '44', '189', '2', '13', '20', '0.928571429', '232', '1', '1', '0.459459459', '0.174603175', '1', '1', '9.090909091', '1', '0.9091', '2']
package org . apache . camel . component . jdbc ; import java . sql . Connection ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . ArrayList ; import java . util . HashMap ; import javax . sql . DataSource ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . IntrospectionSupport ; public class JdbcProducer extends DefaultProducer < DefaultExchange > { private DataSource source ; private int readSize = 2000 ; public JdbcProducer ( JdbcEndpoint endpoint , String remaining , int readSize ) throws Exception { super ( endpoint ) ; this . readSize = readSize ; source = ( DataSource ) getEndpoint ( ) . getContext ( ) . getRegistry ( ) . lookup ( remaining ) ; } public void process ( Exchange exchange ) throws Exception { String sql = exchange . getIn ( ) . getBody ( String . class ) ; Connection conn = null ; Statement stmt = null ; try { conn = source . getConnection ( ) ; stmt = conn . createStatement ( ) ; if ( stmt . execute ( sql ) ) { ResultSet rs = stmt . getResultSet ( ) ; setResultSet ( exchange , rs ) ; rs . close ( ) ; } else { int updateCount = stmt . getUpdateCount ( ) ; exchange . getOut ( ) . setHeader ( "jdbc.updateCount" , updateCount ) ; } } finally { if ( stmt != null ) { stmt . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } } public int getReadSize ( ) { return this . readSize ; } public void setReadSize ( int readSize ) { this . readSize = readSize ; } public void setResultSet ( Exchange exchange , ResultSet rs ) throws SQLException { ResultSetMetaData meta = rs . getMetaData ( ) ; HashMap < String , Object > props = new HashMap < String , Object > ( ) ; IntrospectionSupport . getProperties ( meta , props , "jdbc." ) ; exchange . getOut ( ) . setHeaders ( props ) ; int count = meta . getColumnCount ( ) ; ArrayList < HashMap < String , Object > > data = new ArrayList < HashMap < String , Object > > ( ) ; int rowNumber = 0 ; while ( rs . next ( ) && rowNumber < readSize ) { HashMap < String , Object > row = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int columnNumber = i + 1 ; String columnName = meta . getColumnName ( columnNumber ) ; row . put ( columnName , rs . getObject ( columnName ) ) ; } data . add ( row ) ; rowNumber ++ ; } exchange . getOut ( ) . setBody ( data ) ; } } 	0	['5', '3', '0', '8', '35', '0', '1', '8', '5', '0.375', '163', '1', '0', '0.826086957', '0.4', '0', '0', '31.2', '1', '0.8', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; public class DefaultAnnotationExpressionFactory implements AnnotationExpressionFactory { public Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) { String languageName = languageAnnotation . language ( ) ; if ( languageName == null ) { throw new IllegalArgumentException ( "Cannot determine the language from the annotation: " + annotation ) ; } Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Cannot find the language: " + languageName + " on the classpath" ) ; } String expression = getExpressionFromAnnotation ( annotation ) ; return language . createExpression ( expression ) ; } protected String getExpressionFromAnnotation ( Annotation annotation ) { try { Method method = annotation . getClass ( ) . getMethod ( "value" ) ; Object value = ObjectHelper . invokeMethod ( method , annotation ) ; if ( value == null ) { throw new IllegalArgumentException ( "Cannot determine the expression from the annotation: " + annotation ) ; } return value . toString ( ) ; } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( "Cannot determine the expression of the annotation: " + annotation + " as it does not have an value() method" ) ; } } } 	1	['3', '1', '1', '7', '16', '3', '1', '6', '2', '2', '96', '0', '0', '0', '0.533333333', '0', '0', '31', '3', '1.6667', '2']
package org . apache . camel . bam . model ; import java . util . Collection ; import java . util . Date ; import java . util . HashSet ; import javax . persistence . * ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Entity public class ProcessInstance { private static final transient Log LOG = LogFactory . getLog ( ProcessInstance . class ) ; private ProcessDefinition processDefinition ; private Collection < ActivityState > activityStates = new HashSet < ActivityState > ( ) ; private String correlationKey ; private Date timeStarted ; private Date timeCompleted ; public ProcessInstance ( ) { setTimeStarted ( new Date ( ) ) ; } public String toString ( ) { return "ProcessInstance[" + getCorrelationKey ( ) + "]" ; } @ Id public String getCorrelationKey ( ) { return correlationKey ; } public void setCorrelationKey ( String correlationKey ) { this . correlationKey = correlationKey ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } @ OneToMany ( mappedBy = "processInstance" , fetch = FetchType . LAZY , cascade = { CascadeType . ALL } ) public Collection < ActivityState > getActivityStates ( ) { return activityStates ; } public void setActivityStates ( Collection < ActivityState > activityStates ) { this . activityStates = activityStates ; } @ Transient public boolean isStarted ( ) { return timeStarted != null ; } @ Transient public boolean isCompleted ( ) { return timeCompleted != null ; } @ Temporal ( TemporalType . TIME ) public Date getTimeStarted ( ) { return timeStarted ; } public void setTimeStarted ( Date timeStarted ) { this . timeStarted = timeStarted ; } @ Temporal ( TemporalType . TIME ) public Date getTimeCompleted ( ) { return timeCompleted ; } public void setTimeCompleted ( Date timeCompleted ) { this . timeCompleted = timeCompleted ; } public ActivityState getActivityState ( ActivityRules activityRules ) { for ( ActivityState activityState : getActivityStates ( ) ) { if ( activityState . isActivity ( activityRules ) ) { return activityState ; } } return null ; } public ActivityState getOrCreateActivityState ( ActivityRules activityRules ) { ActivityState state = getActivityState ( activityRules ) ; if ( state == null ) { state = createActivityState ( ) ; state . setProcessInstance ( this ) ; state . setActivityDefinition ( activityRules . getActivityDefinition ( ) ) ; } return state ; } protected ActivityState createActivityState ( ) { return new ActivityState ( ) ; } } 	0	['18', '1', '0', '13', '33', '131', '9', '6', '16', '0.882352941', '144', '1', '2', '0', '0.235294118', '0', '0', '6.666666667', '2', '1.1111', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; public class StickyLoadBalancer extends QueueLoadBalancer { private Expression < Exchange > correlationExpression ; private QueueLoadBalancer loadBalancer ; private int numberOfHashGroups = 64 * 1024 ; private Map < Object , Processor > stickyMap = new HashMap < Object , Processor > ( ) ; public StickyLoadBalancer ( Expression < Exchange > correlationExpression ) { this ( correlationExpression , new RoundRobinLoadBalancer ( ) ) ; } public StickyLoadBalancer ( Expression < Exchange > correlationExpression , QueueLoadBalancer loadBalancer ) { this . correlationExpression = correlationExpression ; this . loadBalancer = loadBalancer ; } protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { Object value = correlationExpression . evaluate ( exchange ) ; Object key = getStickyKey ( value ) ; Processor processor ; synchronized ( stickyMap ) { processor = stickyMap . get ( key ) ; if ( processor == null ) { processor = loadBalancer . chooseProcessor ( processors , exchange ) ; stickyMap . put ( key , processor ) ; } } return processor ; } @ Override public void removeProcessor ( Processor processor ) { synchronized ( stickyMap ) { Iterator < Map . Entry < Object , Processor > > iter = stickyMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Object , Processor > entry = iter . next ( ) ; if ( processor . equals ( entry . getValue ( ) ) ) { iter . remove ( ) ; } } } super . removeProcessor ( processor ) ; } public int getNumberOfHashGroups ( ) { return numberOfHashGroups ; } public void setNumberOfHashGroups ( int numberOfHashGroups ) { this . numberOfHashGroups = numberOfHashGroups ; } protected Object getStickyKey ( Object value ) { int hashCode = 37 ; if ( value != null ) { hashCode = value . hashCode ( ) ; } if ( numberOfHashGroups > 0 ) { hashCode = hashCode % numberOfHashGroups ; } return hashCode ; } } 	1	['7', '3', '0', '5', '24', '3', '0', '5', '5', '0.5', '141', '1', '2', '0.5', '0.267857143', '2', '2', '18.57142857', '3', '1.2857', '2']
package org . apache . camel . component . mail ; import java . util . Enumeration ; import java . util . Map ; import javax . mail . Header ; import javax . mail . Message ; import javax . mail . MessagingException ; import org . apache . camel . impl . DefaultMessage ; import org . apache . camel . util . CollectionHelper ; public class MailMessage extends DefaultMessage { private Message mailMessage ; public MailMessage ( ) { } public MailMessage ( Message message ) { this . mailMessage = message ; } @ Override public String toString ( ) { if ( mailMessage != null ) { return "MailMessage: " + mailMessage ; } else { return "MailMessage: " + getBody ( ) ; } } @ Override public MailExchange getExchange ( ) { return ( MailExchange ) super . getExchange ( ) ; } public MailMessage copy ( ) { MailMessage answer = ( MailMessage ) super . copy ( ) ; answer . mailMessage = mailMessage ; return answer ; } public Message getMessage ( ) { return mailMessage ; } public void setMessage ( Message mailMessage ) { this . mailMessage = mailMessage ; } public Object getHeader ( String name ) { String [ ] answer = null ; if ( mailMessage != null ) { try { answer = mailMessage . getHeader ( name ) ; } catch ( MessagingException e ) { throw new MessageHeaderAccessException ( name , e ) ; } } if ( answer == null ) { return super . getHeader ( name ) ; } if ( answer . length == 1 ) { return answer [ 0 ] ; } return answer ; } @ Override public MailMessage newInstance ( ) { return new MailMessage ( ) ; } @ Override protected Object createBody ( ) { if ( mailMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromMail ( getExchange ( ) , mailMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( mailMessage != null ) { Enumeration names ; try { names = mailMessage . getAllHeaders ( ) ; } catch ( MessagingException e ) { throw new MessageHeaderNamesAccessException ( e ) ; } try { while ( names . hasMoreElements ( ) ) { Header header = ( Header ) names . nextElement ( ) ; String value = header . getValue ( ) ; String name = header . getName ( ) ; CollectionHelper . appendValue ( map , name , value ) ; } } catch ( Throwable e ) { throw new MessageHeaderNamesAccessException ( e ) ; } } } public void copyFrom ( org . apache . camel . Message that ) { super . copyFrom ( that ) ; if ( that instanceof MailMessage ) { MailMessage mailMessage = ( MailMessage ) that ; this . mailMessage = mailMessage . mailMessage ; } } } 	0	['16', '3', '0', '8', '33', '48', '1', '8', '14', '0.4', '188', '1', '0', '0.621621622', '0.2625', '2', '7', '10.6875', '4', '1.3125', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . processor . DelegateProcessor ; public class AsyncProcessorTypeConverter implements TypeConverter { public static final class ProcessorToAsynProcessorBridge extends DelegateProcessor implements AsyncProcessor { private ProcessorToAsynProcessorBridge ( Processor processor ) { super ( processor ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { try { processor . process ( exchange ) ; } catch ( Throwable e ) { exchange . setException ( e ) ; } callback . done ( true ) ; return true ; } } public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( AsyncProcessor . class ) ) { if ( value instanceof AsyncProcessor ) { return toType . cast ( value ) ; } else if ( value instanceof Processor ) { final Processor processor = ( Processor ) value ; return toType . cast ( new ProcessorToAsynProcessorBridge ( processor ) ) ; } } } return null ; } public static AsyncProcessor convert ( Processor value ) { if ( value instanceof AsyncProcessor ) { return ( AsyncProcessor ) value ; } return new ProcessorToAsynProcessorBridge ( value ) ; } } 	1	['3', '1', '0', '16', '7', '3', '11', '5', '3', '2', '47', '0', '0', '0', '0.416666667', '0', '0', '14.66666667', '5', '2.3333', '2']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public abstract class QueueLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; if ( list . isEmpty ( ) ) { throw new IllegalStateException ( "No processors available to process " + exchange ) ; } Processor processor = chooseProcessor ( list , exchange ) ; if ( processor == null ) { throw new IllegalStateException ( "No processors could be chosen to process " + exchange ) ; } else { processor . process ( exchange ) ; } } protected abstract Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) ; } 	0	['3', '2', '3', '6', '12', '3', '3', '3', '2', '2', '47', '0', '0', '0.6', '0.666666667', '0', '0', '14.66666667', '1', '0.6667', '0']
package org . apache . camel . management ; import java . io . IOException ; import org . apache . camel . Endpoint ; import org . apache . camel . Route ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Route" , currencyTimeLimit = 15 ) public class ManagedRoute { public static final String VALUE_UNKNOWN = "Unknown" ; private Route route ; private String description ; ManagedRoute ( Route route ) { this . route = route ; this . description = route . toString ( ) ; } public Route getRoute ( ) { return route ; } @ ManagedAttribute ( description = "Route Endpoint Uri" ) public String getEndpointUri ( ) { Endpoint ep = route . getEndpoint ( ) ; return ep != null ? ep . getEndpointUri ( ) : VALUE_UNKNOWN ; } @ ManagedAttribute ( description = "Route description" ) public String getDescription ( ) { return description ; } @ ManagedOperation ( description = "Start Route" ) public void start ( ) throws IOException { throw new IOException ( "Not supported" ) ; } @ ManagedOperation ( description = "Stop Route" ) public void stop ( ) throws IOException { throw new IOException ( "Not supported" ) ; } } 	1	['6', '1', '0', '4', '11', '7', '2', '2', '5', '0.866666667', '46', '0.666666667', '1', '0', '0.583333333', '0', '0', '6.166666667', '2', '1', '1']
package org . apache . camel . component . cxf . spring ; import com . sun . xml . bind . v2 . schemagen . xmlschema . List ; import java . util . Map ; import javax . xml . namespace . QName ; import org . w3c . dom . Element ; import org . apache . cxf . common . util . StringUtils ; import org . apache . cxf . configuration . spring . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . BeanDefinitionStoreException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; public class CxfEndpointBeanDefinitionParser extends AbstractBeanDefinitionParser { @ Override protected Class getBeanClass ( Element arg0 ) { return CxfEndpointBean . class ; } @ Override protected void mapAttribute ( BeanDefinitionBuilder bean , Element e , String name , String val ) { if ( "endpointName" . equals ( name ) || "serviceName" . equals ( name ) ) { QName q = parseQName ( e , val ) ; bean . addPropertyValue ( name , q ) ; } else { mapToProperty ( bean , name , val ) ; } } @ Override protected void mapElement ( ParserContext ctx , BeanDefinitionBuilder bean , Element el , String name ) { if ( "properties" . equals ( name ) ) { Map map = ctx . getDelegate ( ) . parseMapElement ( el , bean . getBeanDefinition ( ) ) ; bean . addPropertyValue ( "properties" , map ) ; } else if ( "binding" . equals ( name ) ) { setFirstChildAsProperty ( el , ctx , bean , "bindingConfig" ) ; } else if ( "inInterceptors" . equals ( name ) || "inFaultInterceptors" . equals ( name ) || "outInterceptors" . equals ( name ) || "outFaultInterceptors" . equals ( name ) || "features" . equals ( name ) || "schemaLocations" . equals ( name ) ) { List list = ( List ) ctx . getDelegate ( ) . parseListElement ( el , bean . getBeanDefinition ( ) ) ; bean . addPropertyValue ( name , list ) ; } else { setFirstChildAsProperty ( el , ctx , bean , name ) ; } } @ Override protected void doParse ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { super . doParse ( element , ctx , bean ) ; bean . setLazyInit ( false ) ; } @ Override protected String resolveId ( Element elem , AbstractBeanDefinition definition , ParserContext ctx ) throws BeanDefinitionStoreException { String id = super . resolveId ( elem , definition , ctx ) ; if ( StringUtils . isEmpty ( id ) ) { throw new BeanDefinitionStoreException ( "The bean id is needed." ) ; } return id ; } @ Override protected boolean hasBusProperty ( ) { return true ; } } 	0	['7', '0', '0', '10', '22', '21', '1', '9', '1', '2', '138', '0', '0', '0', '0.5', '0', '0', '18.71428571', '9', '2.2857', '0']
package org . apache . camel . util ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Body ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . io . OutputStream ; import java . io . Closeable ; import java . io . IOException ; public class ObjectHelper { private static final transient Log LOG = LogFactory . getLog ( ObjectHelper . class ) ; private ObjectHelper ( ) { } public static boolean equals ( Object a , Object b ) { if ( a == b ) { return true ; } return a != null && b != null && a . equals ( b ) ; } public static boolean isEqualToAny ( Object object , Object ... values ) { for ( Object value : values ) { if ( equals ( object , value ) ) { return true ; } } return false ; } public static int compare ( Object a , Object b ) { if ( a == b ) { return 0 ; } if ( a == null ) { return - 1 ; } if ( b == null ) { return 1 ; } if ( a instanceof Comparable ) { Comparable comparable = ( Comparable ) a ; return comparable . compareTo ( b ) ; } else { int answer = a . getClass ( ) . getName ( ) . compareTo ( b . getClass ( ) . getName ( ) ) ; if ( answer == 0 ) { answer = a . hashCode ( ) - b . hashCode ( ) ; } return answer ; } } public static void notNull ( Object value , String name ) { if ( value == null ) { throw new IllegalArgumentException ( name + " must be specified" ) ; } } public static String [ ] splitOnCharacter ( String value , String needle , int count ) { String rc [ ] = new String [ count ] ; rc [ 0 ] = value ; for ( int i = 1 ; i < count ; i ++ ) { String v = rc [ i - 1 ] ; int p = v . indexOf ( needle ) ; if ( p < 0 ) { return rc ; } rc [ i - 1 ] = v . substring ( 0 , p ) ; rc [ i ] = v . substring ( p + 1 ) ; } return rc ; } public static String removeStartingCharacters ( String text , char ch ) { int idx = 0 ; while ( text . charAt ( idx ) == ch ) { idx ++ ; } if ( idx > 0 ) { return text . substring ( idx ) ; } return text ; } public static String capitalize ( String text ) { int length = text . length ( ) ; if ( text == null || length == 0 ) { return text ; } String answer = text . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( length > 1 ) { answer += text . substring ( 1 , length ) ; } return answer ; } public static boolean contains ( Object collectionOrArray , Object value ) { if ( collectionOrArray instanceof Collection ) { Collection collection = ( Collection ) collectionOrArray ; return collection . contains ( value ) ; } else { Iterator iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { if ( equals ( value , iter . next ( ) ) ) { return true ; } } return false ; } } public static boolean matches ( List list ) { if ( ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value instanceof Boolean ) { Boolean flag = ( Boolean ) value ; return flag . booleanValue ( ) ; } else { return true ; } } return false ; } public static boolean isNotNullAndNonEmpty ( String text ) { return text != null && text . trim ( ) . length ( ) > 0 ; } public static boolean isNullOrBlank ( String text ) { return text == null || text . trim ( ) . length ( ) <= 0 ; } public static String getSystemProperty ( String name , String defaultValue ) { try { return System . getProperty ( name , defaultValue ) ; } catch ( Exception e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Caught security exception accessing system property: " + name + ". Reason: " + e , e ) ; } return defaultValue ; } } public static String name ( Class type ) { return type != null ? type . getName ( ) : null ; } public static String className ( Object value ) { return name ( value != null ? value . getClass ( ) : null ) ; } public static Class < ? > loadClass ( String name ) { return loadClass ( name , ObjectHelper . class . getClassLoader ( ) ) ; } public static Class < ? > loadClass ( String name , ClassLoader loader ) { ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( contextClassLoader != null ) { try { return contextClassLoader . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { try { return loader . loadClass ( name ) ; } catch ( ClassNotFoundException e1 ) { LOG . debug ( "Could not find class: " + name + ". Reason: " + e ) ; } } } return null ; } public static Object invokeMethod ( Method method , Object instance , Object ... parameters ) { try { return method . invoke ( instance , parameters ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } } public static List < Method > findMethodsWithAnnotation ( Class < ? > type , Class < ? extends Annotation > annotationType ) { List < Method > answer = new ArrayList < Method > ( ) ; do { Method [ ] methods = type . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotationType ) != null ) { answer . add ( method ) ; } } type = type . getSuperclass ( ) ; } while ( type != null ) ; return answer ; } public static String asString ( Object [ ] objects ) { if ( objects == null ) { return "null" ; } else { StringBuffer buffer = new StringBuffer ( "{" ) ; int counter = 0 ; for ( Object object : objects ) { if ( counter ++ > 0 ) { buffer . append ( ", " ) ; } String text = ( object == null ) ? "null" : object . toString ( ) ; buffer . append ( text ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } } public static boolean isAssignableFrom ( Class a , Class b ) { a = convertPrimitiveTypeToWrapperType ( a ) ; b = convertPrimitiveTypeToWrapperType ( b ) ; return a . isAssignableFrom ( b ) ; } public static Class convertPrimitiveTypeToWrapperType ( Class type ) { Class rc = type ; if ( type . isPrimitive ( ) ) { if ( type == int . class ) { rc = Integer . class ; } else if ( type == long . class ) { rc = Long . class ; } else if ( type == double . class ) { rc = Double . class ; } else if ( type == float . class ) { rc = Float . class ; } else if ( type == short . class ) { rc = Short . class ; } else if ( type == byte . class ) { rc = Byte . class ; } } return rc ; } public static String getDefaultCharacterSet ( ) { return Charset . defaultCharset ( ) . name ( ) ; } public static String getPropertyName ( Method method ) { String propertyName = method . getName ( ) ; if ( propertyName . startsWith ( "set" ) && method . getParameterTypes ( ) . length == 1 ) { propertyName = propertyName . substring ( 3 , 4 ) . toLowerCase ( ) + propertyName . substring ( 4 ) ; } return propertyName ; } public static boolean hasAnnotation ( Annotation [ ] annotations , Class < ? > type ) { for ( Annotation annotation : annotations ) { if ( type . isInstance ( annotation ) ) { return true ; } } return false ; } public static void close ( Closeable closeable , String name , Log log ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException e ) { log . warn ( "Could not close " + name + ". Reason: " + e , e ) ; } } } public static < T > T cast ( Class < T > toType , Object value ) { if ( toType == boolean . class ) { return ( T ) cast ( Boolean . class , value ) ; } else if ( toType . isPrimitive ( ) ) { Class newType = convertPrimitiveTypeToWrapperType ( toType ) ; if ( newType != toType ) { return ( T ) cast ( newType , value ) ; } } try { return toType . cast ( value ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( "Failed to convert: " + value + " to type: " + toType . getName ( ) + " due to: " + e , e ) ; } } public static < T > T newInstance ( Class < T > type ) { try { return type . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } public static < T > T newInstance ( Class < ? > actualType , Class < T > expectedType ) { try { Object value = actualType . newInstance ( ) ; return cast ( expectedType , value ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } } 	1	['30', '1', '0', '73', '92', '429', '69', '4', '28', '0.896551724', '693', '1', '1', '0', '0.103448276', '1', '1', '22.06666667', '8', '2.7333', '8']
package org . apache . camel . component . irc ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . schwering . irc . lib . IRCConnection ; import org . schwering . irc . lib . IRCEventListener ; public class IrcProducer extends DefaultProducer < IrcExchange > { public static final String [ ] COMMANDS = new String [ ] { "AWAY" , "INVITE" , "ISON" , "JOIN" , "KICK" , "LIST" , "NAMES" , "PRIVMSG" , "MODE" , "NICK" , "NOTICE" , "PART" , "PONG" , "QUIT" , "TOPIC" , "WHO" , "WHOIS" , "WHOWAS" , "USERHOST" } ; private static final transient Log LOG = LogFactory . getLog ( IrcProducer . class ) ; private IRCConnection connection ; private IrcEndpoint endpoint ; private IRCEventListener ircErrorLogger ; public IrcProducer ( IrcEndpoint endpoint , IRCConnection connection ) { super ( endpoint ) ; this . endpoint = endpoint ; this . connection = connection ; } public void process ( Exchange exchange ) throws Exception { try { final String msg = exchange . getIn ( ) . getBody ( String . class ) ; if ( isMessageACommand ( msg ) ) { connection . send ( msg ) ; } else { final String target = endpoint . getConfiguration ( ) . getTarget ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "sending to: " + target + " message: " + msg ) ; } connection . doPrivmsg ( target , msg ) ; } } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; ircErrorLogger = createIrcErrorLogger ( ) ; connection . addIRCEventListener ( ircErrorLogger ) ; final String target = endpoint . getConfiguration ( ) . getTarget ( ) ; LOG . debug ( "joining: " + target ) ; connection . doJoin ( target ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( connection != null ) { connection . removeIRCEventListener ( ircErrorLogger ) ; } } protected boolean isMessageACommand ( String msg ) { for ( String command : COMMANDS ) { if ( msg . startsWith ( command ) ) { return true ; } } return false ; } protected IRCEventListener createIrcErrorLogger ( ) { return new IrcErrorLogger ( LOG ) ; } } 	0	['7', '3', '0', '12', '28', '0', '1', '12', '2', '0.633333333', '227', '0.8', '2', '0.791666667', '0.333333333', '0', '0', '30.71428571', '3', '1', '0']
package org . apache . camel . view ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . model . * ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; public class NodeData { public String id ; private final String imagePrefix ; public String image ; public String label ; public String shape ; public String edgeLabel ; public String tooltop ; public String nodeType ; public boolean nodeWritten ; public String url ; public List < ProcessorType > outputs ; public String association = "property" ; public NodeData ( String id , Object node , String imagePrefix ) { this . id = id ; this . imagePrefix = imagePrefix ; if ( node instanceof ProcessorType ) { ProcessorType processorType = ( ProcessorType ) node ; this . edgeLabel = processorType . getLabel ( ) ; } if ( node instanceof FromType ) { FromType fromType = ( FromType ) node ; this . tooltop = fromType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof ToType ) { ToType toType = ( ToType ) node ; this . tooltop = toType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof FilterType ) { this . image = imagePrefix + "MessageFilterIcon.gif" ; this . nodeType = "Message Filter" ; } else if ( node instanceof WhenType ) { this . image = imagePrefix + "MessageFilterIcon.gif" ; this . nodeType = "When Filter" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; } else if ( node instanceof OtherwiseType ) { this . nodeType = "Otherwise" ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; this . tooltop = "Otherwise" ; } else if ( node instanceof ChoiceType ) { this . image = imagePrefix + "ContentBasedRouterIcon.gif" ; this . nodeType = "Content Based Router" ; this . label = "" ; this . edgeLabel = "" ; ChoiceType choice = ( ChoiceType ) node ; List < ProcessorType > outputs = new ArrayList < ProcessorType > ( choice . getWhenClauses ( ) ) ; outputs . add ( choice . getOtherwise ( ) ) ; this . outputs = outputs ; } else if ( node instanceof RecipientListType ) { this . image = imagePrefix + "RecipientListIcon.gif" ; this . nodeType = "Recipient List" ; } else if ( node instanceof SplitterType ) { this . image = imagePrefix + "SplitterIcon.gif" ; this . nodeType = "Splitter" ; } else if ( node instanceof AggregatorType ) { this . image = imagePrefix + "AggregatorIcon.gif" ; this . nodeType = "Aggregator" ; } else if ( node instanceof ResequencerType ) { this . image = imagePrefix + "ResequencerIcon.gif" ; this . nodeType = "Resequencer" ; } if ( isNullOrBlank ( this . nodeType ) ) { String name = node . getClass ( ) . getName ( ) ; int idx = name . lastIndexOf ( '.' ) ; if ( idx > 0 ) { name = name . substring ( idx + 1 ) ; } if ( name . endsWith ( "Type" ) ) { name = name . substring ( 0 , name . length ( ) - 4 ) ; } this . nodeType = insertSpacesBetweenCamelCase ( name ) ; } if ( this . label == null ) { if ( isNullOrBlank ( this . image ) ) { this . label = this . nodeType ; this . shape = "box" ; } else if ( isNotNullAndNonEmpty ( this . edgeLabel ) ) { this . label = "" ; } else { this . label = node . toString ( ) ; } } if ( isNullOrBlank ( this . tooltop ) ) { if ( isNotNullAndNonEmpty ( this . nodeType ) ) { String description = isNotNullAndNonEmpty ( this . edgeLabel ) ? this . edgeLabel : this . label ; this . tooltop = this . nodeType + ": " + description ; } else { this . tooltop = this . label ; } } if ( isNullOrBlank ( this . url ) && isNotNullAndNonEmpty ( this . nodeType ) ) { this . url = "http://activemq.apache.org/camel/" + this . nodeType . toLowerCase ( ) . replace ( ' ' , '-' ) + ".html" ; } if ( node instanceof ProcessorType && this . outputs == null ) { ProcessorType processorType = ( ProcessorType ) node ; this . outputs = processorType . getOutputs ( ) ; } } protected String removeQueryString ( String text ) { int idx = text . indexOf ( "?" ) ; if ( idx <= 0 ) { return text ; } else { return text . substring ( 0 , idx ) ; } } public static String insertSpacesBetweenCamelCase ( String name ) { boolean lastCharacterLowerCase = false ; StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 , size = name . length ( ) ; i < size ; i ++ ) { char ch = name . charAt ( i ) ; if ( Character . isUpperCase ( ch ) ) { if ( lastCharacterLowerCase ) { buffer . append ( ' ' ) ; } lastCharacterLowerCase = false ; } else { lastCharacterLowerCase = true ; } buffer . append ( ch ) ; } return buffer . toString ( ) ; } } 	1	['3', '1', '0', '15', '33', '3', '3', '12', '2', '1.041666667', '431', '0.083333333', '0', '0', '0.666666667', '0', '0', '138.6666667', '4', '2', '4']
package org . apache . camel . component . file . remote ; import java . io . OutputStream ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; public class RemoteFileMessage extends DefaultMessage { private OutputStream outputStream ; private String fullFileName ; private String hostname ; public RemoteFileMessage ( ) { } public RemoteFileMessage ( String hostname , String fullFileName , OutputStream outputStream ) { this . hostname = hostname ; this . fullFileName = fullFileName ; this . outputStream = outputStream ; setMessageId ( hostname + ":" + fullFileName ) ; } public String getHostname ( ) { return hostname ; } public void setHostname ( String hostname ) { this . hostname = hostname ; } public String getFullFileName ( ) { return fullFileName ; } public void setFullFileName ( String fullFileName ) { this . fullFileName = fullFileName ; } public OutputStream getOutputStream ( ) { return outputStream ; } public void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } @ Override public RemoteFileExchange getExchange ( ) { return ( RemoteFileExchange ) super . getExchange ( ) ; } @ Override protected Object createBody ( ) { if ( outputStream != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromOutputStream ( getExchange ( ) , outputStream ) ; } return null ; } @ Override public RemoteFileMessage newInstance ( ) { return new RemoteFileMessage ( ) ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { super . populateInitialHeaders ( map ) ; map . put ( "file.remote.host" , hostname ) ; map . put ( "file.remote.name" , fullFileName ) ; } } 	0	['15', '3', '0', '5', '22', '71', '1', '5', '13', '0.785714286', '113', '1', '0', '0.638888889', '0.35', '2', '6', '6.333333333', '2', '0.9333', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . impl . DefaultMessage ; public class JMXMessage extends DefaultMessage { private Notification notification ; public JMXMessage ( ) { this ( null ) ; } public JMXMessage ( Notification notification ) { this . notification = notification ; } @ Override public String toString ( ) { return "JMXMessage: " + notification ; } @ Override public JMXExchange getExchange ( ) { return ( JMXExchange ) super . getExchange ( ) ; } @ Override public JMXMessage newInstance ( ) { return new JMXMessage ( ) ; } public Notification getNotification ( ) { return notification ; } } 	1	['9', '3', '0', '4', '12', '30', '1', '4', '9', '0.25', '50', '1', '0', '0.766666667', '0.555555556', '2', '5', '4.444444444', '1', '0.7778', '1']
package org . apache . camel . component . jms ; import java . io . File ; import java . util . Enumeration ; import java . util . Map ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Queue ; import javax . jms . Topic ; import org . apache . camel . impl . DefaultMessage ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JmsMessage extends DefaultMessage { private static final transient Log LOG = LogFactory . getLog ( JmsMessage . class ) ; private Message jmsMessage ; public JmsMessage ( ) { } public JmsMessage ( Message jmsMessage ) { setJmsMessage ( jmsMessage ) ; } @ Override public String toString ( ) { if ( jmsMessage != null ) { return "JmsMessage: " + jmsMessage ; } else { return "JmsMessage: " + getBody ( ) ; } } public Message getJmsMessage ( ) { return jmsMessage ; } public void setJmsMessage ( Message jmsMessage ) { this . jmsMessage = jmsMessage ; try { String id = getDestinationAsString ( jmsMessage . getJMSDestination ( ) ) ; id += getSanitizedString ( jmsMessage . getJMSMessageID ( ) ) ; setMessageId ( id ) ; } catch ( JMSException e ) { LOG . error ( "Failed to get message id from message " + jmsMessage , e ) ; } } public Object getHeader ( String name ) { Object answer = null ; if ( jmsMessage != null && ! name . startsWith ( "JMS" ) ) { try { answer = jmsMessage . getObjectProperty ( name ) ; } catch ( JMSException e ) { throw new MessagePropertyAccessException ( name , e ) ; } } if ( answer == null ) { answer = super . getHeader ( name ) ; } return answer ; } @ Override public JmsMessage newInstance ( ) { return new JmsMessage ( ) ; } @ Override protected Object createBody ( ) { if ( jmsMessage != null && getExchange ( ) instanceof JmsExchange ) { JmsExchange exchange = ( JmsExchange ) getExchange ( ) ; return exchange . getBinding ( ) . extractBodyFromJms ( exchange , jmsMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( jmsMessage != null ) { try { map . put ( "JMSCorrelationID" , jmsMessage . getJMSCorrelationID ( ) ) ; map . put ( "JMSDeliveryMode" , jmsMessage . getJMSDeliveryMode ( ) ) ; map . put ( "JMSDestination" , jmsMessage . getJMSDestination ( ) ) ; map . put ( "JMSExpiration" , jmsMessage . getJMSExpiration ( ) ) ; map . put ( "JMSMessageID" , jmsMessage . getJMSMessageID ( ) ) ; map . put ( "JMSPriority" , jmsMessage . getJMSPriority ( ) ) ; map . put ( "JMSRedelivered" , jmsMessage . getJMSRedelivered ( ) ) ; map . put ( "JMSReplyTo" , jmsMessage . getJMSReplyTo ( ) ) ; map . put ( "JMSTimestamp" , jmsMessage . getJMSTimestamp ( ) ) ; map . put ( "JMSType" , jmsMessage . getJMSType ( ) ) ; map . put ( "JMSXGroupID" , jmsMessage . getStringProperty ( "JMSXGroupID" ) ) ; } catch ( JMSException e ) { throw new MessageJMSPropertyAccessException ( e ) ; } Enumeration names ; try { names = jmsMessage . getPropertyNames ( ) ; } catch ( JMSException e ) { throw new MessagePropertyNamesAccessException ( e ) ; } while ( names . hasMoreElements ( ) ) { String name = names . nextElement ( ) . toString ( ) ; try { Object value = jmsMessage . getObjectProperty ( name ) ; map . put ( name , value ) ; } catch ( JMSException e ) { throw new MessagePropertyAccessException ( name , e ) ; } } } } private String getDestinationAsString ( Destination destination ) throws JMSException { String result = "" ; if ( destination == null ) { result = "null destination!" ; } else if ( destination instanceof Topic ) { result += "topic" + File . separator + getSanitizedString ( ( ( Topic ) destination ) . getTopicName ( ) ) ; } else { result += "queue" + File . separator + getSanitizedString ( ( ( Queue ) destination ) . getQueueName ( ) ) ; } result += File . separator ; return result ; } private String getSanitizedString ( Object value ) { return value != null ? value . toString ( ) . replaceAll ( "[^a-zA-Z0-9\\.\\_\\-]" , "_" ) : "" ; } } 	0	['14', '3', '0', '11', '52', '59', '3', '10', '9', '0.692307692', '349', '1', '1', '0.676470588', '0.243589744', '2', '4', '23.78571429', '4', '1.4286', '0']
package org . apache . camel . language ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface LanguageExpression { String language ( ) ; String expression ( ) ; } 	1	['2', '1', '0', '0', '2', '1', '0', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel ; public class ExpectedBodyTypeException extends RuntimeCamelException { private final Exchange exchange ; private final Class expectedBodyType ; public ExpectedBodyTypeException ( Exchange exchange , Class expectedBodyType ) { super ( "Could not extract IN message body as type: " + expectedBodyType + " body is: " + exchange . getIn ( ) . getBody ( ) ) ; this . exchange = exchange ; this . expectedBodyType = expectedBodyType ; } public Exchange getExchange ( ) { return exchange ; } public Class getExpectedBodyType ( ) { return expectedBodyType ; } } 	0	['3', '5', '0', '4', '10', '0', '1', '3', '3', '0.5', '34', '1', '1', '0.894736842', '0.555555556', '0', '0', '9.666666667', '1', '0.6667', '0']
package org . apache . camel . management ; import org . apache . camel . Endpoint ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Endpoint" , currencyTimeLimit = 15 ) public class ManagedEndpoint { private Endpoint endpoint ; public ManagedEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public Endpoint getEndpoint ( ) { return endpoint ; } @ ManagedAttribute ( description = "Endpoint Uri" ) public String getUri ( ) throws Exception { return endpoint . getEndpointUri ( ) ; } } 	1	['3', '1', '0', '3', '5', '0', '2', '1', '3', '0', '17', '1', '1', '0', '0.666666667', '0', '0', '4.333333333', '1', '0.6667', '1']
package org . apache . camel . component . cxf . phase ; import java . util . SortedSet ; import org . apache . cxf . common . util . SortedArraySet ; import org . apache . cxf . phase . Phase ; public class PayloadPhaseManagerImpl extends AbstractPhaseManagerImpl { protected SortedSet < Phase > createInPhases ( ) { SortedSet < Phase > inPhases = new SortedArraySet < Phase > ( ) ; int i = 0 ; inPhases . add ( new Phase ( Phase . RECEIVE , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . PRE_STREAM , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . USER_STREAM , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . POST_STREAM , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . PRE_PROTOCOL , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . USER_PROTOCOL , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . POST_PROTOCOL , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . READ , ++ i * 1000 ) ) ; return inPhases ; } protected SortedSet < Phase > createOutPhases ( ) { SortedSet < Phase > outPhases = new SortedArraySet < Phase > ( ) ; int i = 0 ; outPhases . add ( new Phase ( Phase . PREPARE_SEND , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_STREAM , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_PROTOCOL , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_PROTOCOL , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_PROTOCOL , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . WRITE , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_STREAM , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_STREAM , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . SEND , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . SEND_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_STREAM_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_STREAM_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_PROTOCOL_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_PROTOCOL_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . WRITE_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_PROTOCOL_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_STREAM_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PREPARE_SEND_ENDING , ++ i * 1000 ) ) ; return outPhases ; } } 	0	['3', '2', '0', '4', '7', '3', '1', '3', '1', '2', '308', '0', '0', '0.666666667', '1', '1', '1', '101.6666667', '1', '0.6667', '0']
package org . apache . camel . processor . validation ; import javax . xml . transform . dom . DOMResult ; import javax . xml . validation . Schema ; import org . xml . sax . ErrorHandler ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public interface ValidatorErrorHandler extends ErrorHandler { void reset ( ) ; void handleErrors ( Exchange exchange , Schema schema , DOMResult result ) throws ValidationException ; } 	1	['2', '1', '0', '4', '2', '1', '2', '2', '2', '2', '2', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '1']
package org . apache . camel . model . config ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . processor . Resequencer ; @ XmlRootElement @ XmlAccessorType ( XmlAccessType . FIELD ) public class BatchResequencerConfig { @ XmlAttribute private Integer batchSize ; @ XmlAttribute private Long batchTimeout ; public BatchResequencerConfig ( ) { this ( 100 , 1000L ) ; } public BatchResequencerConfig ( int batchSize , long batchTimeout ) { this . batchSize = batchSize ; this . batchTimeout = batchTimeout ; } public static BatchResequencerConfig getDefault ( ) { return new BatchResequencerConfig ( ) ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } } 	0	['7', '1', '0', '1', '12', '9', '1', '0', '7', '0.333333333', '47', '1', '0', '0', '0.476190476', '0', '0', '5.428571429', '1', '0.7143', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultComponentResolver < E extends Exchange > implements ComponentResolver < E > { private static final transient Log LOG = LogFactory . getLog ( DefaultComponentResolver . class ) ; protected static final FactoryFinder COMPONENT_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; public Component < E > resolveComponent ( String name , CamelContext context ) { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } else { throw new IllegalArgumentException ( "Bean with name: " + name + " in registry is not a Component: " + bean ) ; } } Class type ; try { type = COMPONENT_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { return null ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Component registered for scheme : " + name , e ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " via type: " + type . getName ( ) + " via " + COMPONENT_FACTORY . getPath ( ) + name ) ; } if ( type == null ) { return null ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component < E > ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	1	['3', '1', '0', '10', '22', '1', '1', '9', '2', '0.5', '157', '1', '2', '0', '0.666666667', '0', '0', '50.66666667', '6', '2', '1']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . CamelTemplate ; import org . apache . camel . Endpoint ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; @ XmlRootElement ( name = "camelTemplate" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelTemplateFactoryBean implements FactoryBean , InitializingBean , CamelContextAware { @ XmlAttribute ( required = false ) private String defaultEndpoint ; @ XmlTransient private CamelContext camelContext ; public void afterPropertiesSet ( ) throws Exception { if ( camelContext == null ) { throw new IllegalArgumentException ( "A CamelContext must be injected!" ) ; } } public Object getObject ( ) throws Exception { CamelContext context = getCamelContext ( ) ; if ( defaultEndpoint != null ) { Endpoint endpoint = context . getEndpoint ( defaultEndpoint ) ; if ( endpoint == null ) { throw new IllegalArgumentException ( "No endpoint found for URI: " + defaultEndpoint ) ; } else { return new CamelTemplate ( context , endpoint ) ; } } return new CamelTemplate ( context ) ; } public Class getObjectType ( ) { return CamelTemplate . class ; } public boolean isSingleton ( ) { return true ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( String defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } } 	0	['9', '1', '0', '6', '17', '24', '0', '6', '9', '0.6875', '78', '1', '1', '0', '0.407407407', '0', '0', '7.444444444', '1', '0.8889', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . processor . MarshalProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . dataformat . DataFormatType ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlRootElement ( name = "marshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MarshalType extends OutputType { @ XmlAttribute ( required = false ) private String ref ; @ XmlElementRef private DataFormatType dataFormatType ; public MarshalType ( ) { } public MarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public MarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref:  " + ref + "]" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormatType type = getDataFormatType ( ) ; if ( type == null ) { notNull ( ref , "ref or dataFormatType" ) ; type = routeContext . lookup ( ref , DataFormatType . class ) ; } DataFormat dataFormat = type . getDataFormat ( routeContext ) ; return new MarshalProcessor ( dataFormat ) ; } } 	1	['9', '3', '0', '8', '18', '4', '1', '7', '9', '0.5', '92', '1', '1', '0.942307692', '0.388888889', '1', '2', '9', '2', '0.8889', '3']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "expression" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class LanguageExpression extends ExpressionType { @ XmlAttribute private String language ; public LanguageExpression ( ) { } public LanguageExpression ( String language , String expression ) { setLanguage ( language ) ; setExpression ( expression ) ; } public String getLanguage ( ) { return language ; } public void setLanguage ( String language ) { this . language = language ; } } 	0	['4', '2', '0', '2', '6', '4', '1', '1', '4', '0.333333333', '24', '1', '0', '0.857142857', '0.75', '1', '2', '4.75', '1', '0.5', '0']
package org . apache . camel . impl ; import java . net . URI ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; public abstract class DefaultComponent < E extends Exchange > extends ServiceSupport implements Component < E > { private int defaultThreadPoolSize = 5 ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; public DefaultComponent ( ) { } public DefaultComponent ( CamelContext context ) { this . camelContext = context ; } public Endpoint < E > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( uri ) ) ; String path = u . getSchemeSpecificPart ( ) ; if ( path . startsWith ( "//" ) ) { path = path . substring ( 2 ) ; } int idx = path . indexOf ( '?' ) ; if ( idx > 0 ) { path = path . substring ( 0 , idx ) ; } Map parameters = URISupport . parseParamters ( u ) ; Endpoint < E > endpoint = createEndpoint ( uri , path , parameters ) ; if ( endpoint == null ) { return null ; } if ( parameters != null ) { if ( endpoint instanceof ScheduledPollEndpoint ) { ScheduledPollEndpoint scheduledPollEndpoint = ( ScheduledPollEndpoint ) endpoint ; scheduledPollEndpoint . configureProperties ( parameters ) ; } setProperties ( endpoint , parameters ) ; } return endpoint ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext context ) { this . camelContext = context ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = createExecutorService ( ) ; } return executorService ; } public void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } protected ScheduledExecutorService createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( defaultThreadPoolSize , new ThreadFactory ( ) { int counter ; public synchronized Thread newThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setName ( "Thread: " + ( ++ counter ) + " " + DefaultComponent . this . toString ( ) ) ; return thread ; } } ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { if ( executorService != null ) { executorService . shutdown ( ) ; } } protected abstract Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception ; protected void setProperties ( Object bean , Map parameters ) throws Exception { IntrospectionSupport . setProperties ( getCamelContext ( ) . getTypeConverter ( ) , bean , parameters ) ; } } 	1	['12', '2', '24', '36', '28', '48', '26', '11', '7', '0.727272727', '139', '1', '1', '0.565217391', '0.277777778', '1', '1', '10.33333333', '2', '0.9167', '3']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class RuntimeJmsException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeJmsException ( String message , JMSException cause ) { super ( message , cause ) ; } } 	0	['1', '4', '3', '4', '2', '0', '4', '0', '1', '2', '7', '1', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . model ; import java . util . List ; import javax . xml . bind . annotation . XmlElementRef ; public interface RouteContainer { @ XmlElementRef List < RouteType > getRoutes ( ) ; void setRoutes ( List < RouteType > routes ) ; } 	1	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . cxf . invoker ; import org . apache . camel . component . cxf . DataFormat ; public final class InvokingContextFactory { private InvokingContextFactory ( ) { } public static InvokingContext createContext ( DataFormat dataFormat ) { if ( dataFormat == DataFormat . MESSAGE ) { return new RawMessageInvokingContext ( ) ; } if ( dataFormat == DataFormat . PAYLOAD ) { return new PayloadInvokingContext ( ) ; } return new RawMessageInvokingContext ( ) ; } } 	0	['2', '1', '0', '5', '5', '1', '1', '4', '1', '2', '23', '0', '0', '0', '0.5', '0', '0', '10.5', '3', '1.5', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . channels . Channel ; import java . nio . channels . FileChannel ; import java . nio . channels . FileLock ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class FileProcessStrategySupport implements FileProcessStrategy { public static final String DEFAULT_LOCK_FILE_POSTFIX = ".cameLock" ; private static final transient Log LOG = LogFactory . getLog ( FileProcessStrategySupport . class ) ; private boolean lockFile ; private FileRenamer lockFileRenamer ; protected FileProcessStrategySupport ( ) { this ( true ) ; } protected FileProcessStrategySupport ( boolean lockFile ) { this ( lockFile , new DefaultFileRenamer ( null , DEFAULT_LOCK_FILE_POSTFIX ) ) ; } protected FileProcessStrategySupport ( boolean lockFile , FileRenamer lockFileRenamer ) { this . lockFile = lockFile ; this . lockFileRenamer = lockFileRenamer ; } public boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { File newFile = lockFileRenamer . renameFile ( file ) ; String lockFileName = newFile . getAbsolutePath ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Locking the file: " + file + " using the lock file name: " + lockFileName ) ; } FileChannel channel = new RandomAccessFile ( lockFileName , "rw" ) . getChannel ( ) ; FileLock lock = channel . lock ( ) ; if ( lock != null ) { exchange . setProperty ( "org.apache.camel.fileChannel" , channel ) ; exchange . setProperty ( "org.apache.camel.file.lock" , lock ) ; exchange . setProperty ( "org.apache.camel.file.lock.name" , lockFileName ) ; return true ; } return false ; } return true ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { Channel channel = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.fileChannel" , Channel . class ) ; String lockfile = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.file.lock.name" , String . class ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Unlocking file: " + file ) ; } channel . close ( ) ; File lock = new File ( lockfile ) ; lock . delete ( ) ; } } public boolean isLockFile ( ) { return lockFile ; } public void setLockFile ( boolean lockFile ) { this . lockFile = lockFile ; } public FileRenamer getLockFileRenamer ( ) { return lockFileRenamer ; } public void setLockFileRenamer ( FileRenamer lockFileRenamer ) { this . lockFileRenamer = lockFileRenamer ; } } 	1	['10', '1', '3', '12', '29', '21', '3', '9', '6', '0.722222222', '151', '0.75', '2', '0', '0.37037037', '0', '0', '13.7', '1', '0.6', '1']
package org . apache . camel . component . ibatis ; import java . sql . SQLException ; import java . util . List ; import com . ibatis . sqlmap . client . SqlMapClient ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . PollingConsumerSupport ; public class IBatisPollingConsumer extends PollingConsumerSupport { private final IBatisEndpoint endpoint ; private SqlMapClient sqlClient ; private String queryName ; public IBatisPollingConsumer ( IBatisEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; queryName = endpoint . getEntityName ( ) ; } public Exchange receive ( long timeout ) { return receiveNoWait ( ) ; } public Exchange receive ( ) { return receiveNoWait ( ) ; } public Exchange receiveNoWait ( ) { try { if ( sqlClient == null ) { sqlClient = endpoint . getSqlClient ( ) ; } List list = sqlClient . queryForList ( queryName ) ; Exchange exchange = endpoint . createExchange ( ) ; Message in = exchange . getIn ( ) ; in . setBody ( list ) ; in . setHeader ( "org.apache.camel.ibatis.queryName" , queryName ) ; return exchange ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Failed to poll: " + endpoint + ". Reason: " + e , e ) ; } } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['6', '3', '0', '7', '19', '13', '1', '7', '4', '0.466666667', '78', '1', '1', '0.782608696', '0.444444444', '1', '1', '11.5', '2', '1', '0']
package org . apache . camel . management ; import java . util . Collection ; import javax . management . JMException ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . RouteType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class InstrumentationLifecycleStrategy implements LifecycleStrategy { private static final transient Log LOG = LogFactory . getLog ( InstrumentationProcessor . class ) ; private InstrumentationAgent agent ; private CamelNamingStrategy namingStrategy ; public InstrumentationLifecycleStrategy ( InstrumentationAgent agent ) { this . agent = agent ; setNamingStrategy ( agent . getNamingStrategy ( ) ) ; } public void onContextCreate ( CamelContext context ) { if ( context instanceof DefaultCamelContext ) { try { DefaultCamelContext dc = ( DefaultCamelContext ) context ; ManagedService ms = new ManagedService ( dc ) ; agent . register ( ms , getNamingStrategy ( ) . getObjectName ( dc ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register CamelContext MBean" , e ) ; } } } public void onEndpointAdd ( Endpoint endpoint ) { try { ManagedEndpoint me = new ManagedEndpoint ( endpoint ) ; agent . register ( me , getNamingStrategy ( ) . getObjectName ( me ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Endpoint MBean" , e ) ; } } public void onRoutesAdd ( Collection < Route > routes ) { for ( Route route : routes ) { try { ManagedRoute mr = new ManagedRoute ( route ) ; agent . register ( mr , getNamingStrategy ( ) . getObjectName ( mr ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Route MBean" , e ) ; } } } public void onServiceAdd ( CamelContext context , Service service ) { if ( service instanceof ServiceSupport ) { try { ManagedService ms = new ManagedService ( ( ServiceSupport ) service ) ; agent . register ( ms , getNamingStrategy ( ) . getObjectName ( context , ms ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Service MBean" , e ) ; } } } public void beforeStartRouteType ( CamelContext context , RouteType routeType ) { PerformanceCounter mc = new PerformanceCounter ( ) ; routeType . intercept ( new InstrumentationProcessor ( mc ) ) ; } public CamelNamingStrategy getNamingStrategy ( ) { return namingStrategy ; } public void setNamingStrategy ( CamelNamingStrategy namingStrategy ) { this . namingStrategy = namingStrategy ; } } 	1	['9', '1', '0', '20', '27', '6', '1', '19', '8', '0.416666667', '147', '1', '3', '0', '0.265625', '0', '0', '15', '2', '1.1111', '9']
package org . apache . camel . component . cxf . phase ; import java . util . SortedSet ; import org . apache . cxf . common . util . SortedArraySet ; import org . apache . cxf . phase . Phase ; public class RawMessagePhaseManagerImpl extends AbstractPhaseManagerImpl { protected SortedSet < Phase > createInPhases ( ) { SortedSet < Phase > inPhases = new SortedArraySet < Phase > ( ) ; int i = 0 ; inPhases . add ( new Phase ( Phase . RECEIVE , ++ i * 1000 ) ) ; return inPhases ; } protected SortedSet < Phase > createOutPhases ( ) { SortedSet < Phase > outPhases = new SortedArraySet < Phase > ( ) ; int i = 0 ; outPhases . add ( new Phase ( Phase . PREPARE_SEND , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . WRITE , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . SEND , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PREPARE_SEND_ENDING , ++ i * 1000 ) ) ; return outPhases ; } } 	0	['3', '2', '0', '4', '7', '3', '1', '3', '1', '2', '77', '0', '0', '0.666666667', '1', '1', '1', '24.66666667', '1', '0.6667', '0']
package org . apache . camel . spi ; import java . util . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . model . RouteType ; public interface LifecycleStrategy { void onContextCreate ( CamelContext context ) ; void onEndpointAdd ( Endpoint endpoint ) ; void onServiceAdd ( CamelContext context , Service service ) ; void onRoutesAdd ( Collection < Route > routes ) ; void beforeStartRouteType ( CamelContext context , RouteType routeType ) ; } 	1	['5', '1', '0', '8', '5', '10', '5', '4', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '4']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . spi . ExceptionHandler ; public abstract class PollingConsumerSupport < E extends Exchange > extends ServiceSupport implements PollingConsumer < E > { private final Endpoint < E > endpoint ; private ExceptionHandler exceptionHandler ; public PollingConsumerSupport ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "PullConsumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	0	['6', '2', '4', '9', '14', '7', '4', '5', '5', '0.6', '49', '1', '2', '0.722222222', '0.375', '0', '0', '6.833333333', '2', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . dataformat . ArtixDSContentType ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . spi . DataFormat ; public class DataTypeExpression < T extends ProcessorType > { private final ProcessorType < T > processorType ; private final Operation operation ; public enum Operation { Marshal , Unmarshal } ; public DataTypeExpression ( ProcessorType < T > processorType , Operation operation ) { this . processorType = processorType ; this . operation = operation ; } public T serialization ( ) { return dataFormat ( new SerializationDataFormat ( ) ) ; } public T jaxb ( ) { return dataFormat ( new JaxbDataFormat ( ) ) ; } public T jaxb ( boolean prettyPrint ) { return dataFormat ( new JaxbDataFormat ( prettyPrint ) ) ; } public T xmlBeans ( ) { return dataFormat ( new XMLBeansDataFormat ( ) ) ; } public T artixDS ( ) { return dataFormat ( new ArtixDSDataFormat ( ) ) ; } public T artixDS ( Class < ? > dataObjectType ) { return dataFormat ( new ArtixDSDataFormat ( dataObjectType ) ) ; } public T artixDS ( Class < ? > elementType , ArtixDSContentType contentType ) { return dataFormat ( new ArtixDSDataFormat ( elementType , contentType ) ) ; } public T artixDS ( ArtixDSContentType contentType ) { return dataFormat ( new ArtixDSDataFormat ( contentType ) ) ; } private T dataFormat ( DataFormatType dataFormatType ) { switch ( operation ) { case Unmarshal : return processorType . unmarshal ( dataFormatType ) ; case Marshal : return processorType . marshal ( dataFormatType ) ; default : throw new IllegalArgumentException ( "Unknown value: " + operation ) ; } } } 	1	['10', '1', '0', '9', '27', '43', '1', '9', '9', '0', '103', '1', '2', '0', '0.257142857', '0', '0', '9.1', '4', '1.2', '3']
package org . apache . camel . processor ; import java . io . ByteArrayOutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Message ; import org . apache . camel . spi . DataFormat ; public class MarshalProcessor implements Processor { private final DataFormat dataFormat ; public MarshalProcessor ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } public void process ( Exchange exchange ) throws Exception { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; Message out = exchange . getOut ( true ) ; out . copyFrom ( in ) ; dataFormat . marshal ( exchange , body , buffer ) ; byte [ ] data = buffer . toByteArray ( ) ; out . setBody ( data ) ; } } 	0	['2', '1', '0', '5', '11', '0', '1', '4', '2', '0', '39', '1', '1', '0', '0.666666667', '0', '0', '18', '1', '0.5', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . Injector ; public interface TypeConverterRegistry { void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) ; Injector getInjector ( ) ; } 	1	['2', '1', '0', '8', '2', '1', '6', '2', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '2']
package org . apache . camel . bam ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . model . ActivityDefinition ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . processor . ActivityMonitorEngine ; import org . apache . camel . bam . processor . JpaBamProcessor ; import org . apache . camel . bam . rules . ProcessRules ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; import static org . apache . camel . util . ObjectHelper . notNull ; public abstract class ProcessBuilder extends RouteBuilder { private static int processCounter ; private JpaTemplate jpaTemplate ; private final TransactionTemplate transactionTemplate ; private final String processName ; private List < ActivityBuilder > activityBuilders = new ArrayList < ActivityBuilder > ( ) ; private Class entityType = ProcessInstance . class ; private ProcessRules processRules = new ProcessRules ( ) ; private ProcessDefinition processDefinition ; protected ProcessBuilder ( JpaTemplate jpaTemplate , TransactionTemplate transactionTemplate ) { this ( jpaTemplate , transactionTemplate , createProcessName ( ) ) ; } protected ProcessBuilder ( JpaTemplate jpaTemplate , TransactionTemplate transactionTemplate , String processName ) { this . jpaTemplate = jpaTemplate ; this . transactionTemplate = transactionTemplate ; this . processName = processName ; } protected static synchronized String createProcessName ( ) { return "Process-" + ( ++ processCounter ) ; } public ActivityBuilder activity ( String endpointUri ) { return activity ( endpoint ( endpointUri ) ) ; } public ActivityBuilder activity ( Endpoint endpoint ) { ActivityBuilder answer = new ActivityBuilder ( this , endpoint ) ; activityBuilders . add ( answer ) ; return answer ; } public ProcessBuilder entityType ( Class entityType ) { this . entityType = entityType ; return this ; } public Processor createActivityProcessor ( ActivityBuilder activityBuilder ) { notNull ( jpaTemplate , "jpaTemplate" ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { processRules . setProcessDefinition ( getProcessDefinition ( ) ) ; } } ) ; return new JpaBamProcessor ( getTransactionTemplate ( ) , getJpaTemplate ( ) , activityBuilder . getCorrelationExpression ( ) , activityBuilder . getActivityRules ( ) , getEntityType ( ) ) ; } public List < ActivityBuilder > getActivityBuilders ( ) { return activityBuilders ; } public Class getEntityType ( ) { return entityType ; } public JpaTemplate getJpaTemplate ( ) { return jpaTemplate ; } public void setJpaTemplate ( JpaTemplate jpaTemplate ) { this . jpaTemplate = jpaTemplate ; } public TransactionTemplate getTransactionTemplate ( ) { return transactionTemplate ; } public ProcessRules getProcessRules ( ) { return processRules ; } public String getProcessName ( ) { return processName ; } public ProcessDefinition getProcessDefinition ( ) { if ( processDefinition == null ) { processDefinition = findOrCreateProcessDefinition ( ) ; } return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } protected void populateRoutes ( List < Route > routes ) throws Exception { boolean first = true ; for ( ActivityBuilder builder : activityBuilders ) { Route route = builder . createRoute ( ) ; if ( first ) { route . getServices ( ) . add ( new ActivityMonitorEngine ( getJpaTemplate ( ) , getTransactionTemplate ( ) , getProcessRules ( ) ) ) ; first = false ; } routes . add ( route ) ; } } public ActivityDefinition findOrCreateActivityDefinition ( String activityName ) { ProcessDefinition definition = getProcessDefinition ( ) ; List < ActivityDefinition > list = jpaTemplate . find ( "select x from " + ActivityDefinition . class . getName ( ) + " x where x.processDefinition = ?1 and x.name = ?2" , definition , activityName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ActivityDefinition answer = new ActivityDefinition ( ) ; answer . setName ( activityName ) ; answer . setProcessDefinition ( ProcessDefinition . getRefreshedProcessDefinition ( jpaTemplate , definition ) ) ; jpaTemplate . persist ( answer ) ; return answer ; } } protected ProcessDefinition findOrCreateProcessDefinition ( ) { List < ProcessDefinition > list = jpaTemplate . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; jpaTemplate . persist ( answer ) ; return answer ; } } } 	0	['20', '3', '0', '18', '53', '126', '4', '17', '14', '0.782894737', '299', '1', '2', '0.714285714', '0.16', '1', '1', '13.55', '2', '1.05', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . TimeUnit ; import org . apache . camel . AlreadyStoppedException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SedaConsumer extends ServiceSupport implements Consumer , Runnable { private static final Log LOG = LogFactory . getLog ( SedaConsumer . class ) ; private SedaEndpoint endpoint ; private AsyncProcessor processor ; private Thread thread ; public SedaConsumer ( SedaEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = AsyncProcessorTypeConverter . convert ( processor ) ; } @ Override public String toString ( ) { return "SedaConsumer: " + endpoint . getEndpointUri ( ) ; } public void run ( ) { while ( isRunAllowed ( ) ) { final Exchange exchange ; try { exchange = endpoint . getQueue ( ) . poll ( 1000 , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { break ; } if ( exchange != null && isRunAllowed ( ) ) { processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } } } protected void doStart ( ) throws Exception { thread = new Thread ( this , getThreadName ( endpoint . getEndpointUri ( ) ) ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { thread . join ( ) ; } } 	1	['6', '2', '0', '11', '23', '1', '2', '11', '3', '0.75', '88', '1', '3', '0.764705882', '0.466666667', '1', '2', '13', '2', '0.8333', '2']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . apache . cxf . helpers . DOMUtils ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; public abstract class AbstractMessageOutInterceptor < T extends Message > extends AbstractPhaseInterceptor < T > { public AbstractMessageOutInterceptor ( String phase ) { super ( phase ) ; } protected boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } protected abstract Logger getLogger ( ) ; protected Element createElement ( QName elName , List < Element > childEl ) { Document doc = DOMUtils . createDocument ( ) ; String prefix = elName . getPrefix ( ) ; StringBuilder tagName = new StringBuilder ( ) ; if ( ! "" . equals ( prefix ) ) { tagName . append ( prefix ) ; tagName . append ( ":" ) ; } tagName . append ( elName . getLocalPart ( ) ) ; Element el = doc . createElementNS ( elName . getNamespaceURI ( ) , tagName . toString ( ) ) ; if ( ! "" . equals ( elName . getPrefix ( ) ) ) { StringBuilder attrName = new StringBuilder ( "xmlns" ) ; attrName . append ( ':' ) ; attrName . append ( elName . getPrefix ( ) ) ; el . setAttribute ( attrName . toString ( ) , elName . getNamespaceURI ( ) ) ; } for ( Element part : childEl ) { Node adoptedNode = doc . adoptNode ( part ) ; el . appendChild ( adoptedNode ) ; } return el ; } } 	0	['4', '0', '2', '5', '24', '6', '2', '3', '1', '2', '93', '0', '0', '0', '0.4', '0', '0', '22.25', '4', '1.5', '0']
package org . apache . camel . component . vm ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . seda . SedaComponent ; import org . apache . camel . component . seda . SedaEndpoint ; public class VmComponent extends SedaComponent { private static final AtomicInteger START_COUNTER = new AtomicInteger ( ) ; protected static Map < String , BlockingQueue > queues = new HashMap < String , BlockingQueue > ( ) ; @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { BlockingQueue < Exchange > blockingQueue = getBlockingQueue ( uri ) ; return new SedaEndpoint ( uri , this , blockingQueue ) ; } protected BlockingQueue < Exchange > getBlockingQueue ( String uri ) { synchronized ( queues ) { BlockingQueue < Exchange > answer = queues . get ( uri ) ; if ( answer == null ) { answer = createQueue ( ) ; queues . put ( uri , answer ) ; } return answer ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; START_COUNTER . incrementAndGet ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( START_COUNTER . decrementAndGet ( ) == 0 ) { synchronized ( queues ) { for ( BlockingQueue q : queues . values ( ) ) { q . clear ( ) ; } queues . clear ( ) ; } } } } 	1	['6', '4', '0', '4', '23', '5', '0', '4', '1', '0.5', '99', '1', '0', '0.862068966', '0.533333333', '2', '2', '15.16666667', '2', '0.8333', '4']
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelTemplate ; import org . apache . camel . Exchange ; import org . apache . cxf . Bus ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; public class CamelTransportBase { CamelTemplate < Exchange > template ; Bus bus ; EndpointInfo endpointInfo ; private String replyDestination ; private final CamelContext camelContext ; public CamelTransportBase ( CamelContext camelContext , Bus bus , EndpointInfo endpointInfo , boolean b , String baseBeanNameSuffix ) { this . camelContext = camelContext ; this . bus = bus ; this . endpointInfo = endpointInfo ; this . template = new CamelTemplate < Exchange > ( camelContext ) ; } public void populateIncomingContext ( Exchange exchange , MessageImpl inMessage , String camelServerRequestHeaders ) { } public String getReplyDestination ( ) { return replyDestination ; } public void setMessageProperties ( Message inMessage , Exchange reply ) { } public void close ( ) { if ( template != null ) { try { template . stop ( ) ; } catch ( Exception e ) { } } } protected void marshal ( Object payload , String replyTo , Exchange exchange ) { org . apache . camel . Message message = exchange . getIn ( ) ; message . setBody ( payload ) ; if ( replyTo != null ) { message . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , replyTo ) ; } } public byte [ ] unmarshal ( Exchange exchange ) { return exchange . getIn ( ) . getBody ( byte [ ] . class ) ; } } 	0	['7', '1', '0', '14', '14', '19', '6', '8', '6', '0.966666667', '63', '0.4', '2', '0', '0.3', '0', '0', '7.285714286', '2', '1.1429', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . FromType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . processor . Interceptor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ProceedProcessor ; import org . apache . camel . processor . UnitOfWorkProcessor ; public class RouteContext { private final RouteType route ; private final FromType from ; private final Collection < Route > routes ; private Endpoint endpoint ; private List < Processor > eventDrivenProcessors = new ArrayList < Processor > ( ) ; private Interceptor lastInterceptor ; public RouteContext ( RouteType route , FromType from , Collection < Route > routes ) { this . route = route ; this . from = from ; this . routes = routes ; } public Endpoint getEndpoint ( ) { if ( endpoint == null ) { endpoint = from . resolveEndpoint ( this ) ; } return endpoint ; } public FromType getFrom ( ) { return from ; } public RouteType getRoute ( ) { return route ; } public CamelContext getCamelContext ( ) { return getRoute ( ) . getCamelContext ( ) ; } public Processor createProcessor ( ProcessorType node ) throws Exception { return node . createOutputsProcessor ( this ) ; } public Endpoint resolveEndpoint ( String uri ) { return route . resolveEndpoint ( uri ) ; } public Endpoint resolveEndpoint ( String uri , String ref ) { Endpoint endpoint = null ; if ( uri != null ) { endpoint = resolveEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } } if ( ref != null ) { endpoint = lookup ( ref , Endpoint . class ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( "ref:" + ref ) ; } } if ( endpoint == null ) { throw new IllegalArgumentException ( "Either 'uri' or 'ref' must be specified on: " + this ) ; } else { return endpoint ; } } public < T > T lookup ( String name , Class < T > type ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name , type ) ; } public void commit ( ) { if ( ! eventDrivenProcessors . isEmpty ( ) ) { Processor processor = Pipeline . newInstance ( eventDrivenProcessors ) ; final AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; Processor unitOfWorkProcessor = new UnitOfWorkProcessor ( asyncProcessor ) ; routes . add ( new EventDrivenConsumerRoute ( getEndpoint ( ) , unitOfWorkProcessor ) ) ; } } public void addEventDrivenProcessor ( Processor processor ) { eventDrivenProcessors . add ( processor ) ; } public void intercept ( Interceptor interceptor ) { getRoute ( ) . intercept ( interceptor ) ; lastInterceptor = interceptor ; } public Processor createProceedProcessor ( ) { if ( lastInterceptor == null ) { throw new IllegalArgumentException ( "Cannot proceed() from outside of an interceptor!" ) ; } else { return new ProceedProcessor ( lastInterceptor ) ; } } } 	1	['13', '1', '0', '48', '36', '58', '35', '16', '13', '0.805555556', '183', '1', '4', '0', '0.196581197', '0', '0', '12.61538462', '6', '1.5385', '4']
package org . apache . camel . component . xmpp ; import java . util . Iterator ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . PacketListener ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smack . packet . Packet ; import org . jivesoftware . smack . packet . RosterPacket ; public class XmppConsumer extends DefaultConsumer < XmppExchange > implements PacketListener { private static final transient Log LOG = LogFactory . getLog ( XmppConsumer . class ) ; private final XmppEndpoint endpoint ; public XmppConsumer ( XmppEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . getConnection ( ) . addPacketListener ( this , endpoint . getFilter ( ) ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . getConnection ( ) . removePacketListener ( this ) ; super . doStop ( ) ; } public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message message = ( Message ) packet ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "<<<< message: " + message . getBody ( ) ) ; } XmppExchange exchange = endpoint . createExchange ( message ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( packet instanceof RosterPacket ) { RosterPacket rosterPacket = ( RosterPacket ) packet ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Roster packet with : " + rosterPacket . getRosterItemCount ( ) + " item(s)" ) ; Iterator rosterItems = rosterPacket . getRosterItems ( ) ; while ( rosterItems . hasNext ( ) ) { Object item = rosterItems . next ( ) ; LOG . debug ( "Roster item: " + item ) ; } } } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "<<<< ignored packet: " + packet ) ; } } } } 	0	['5', '3', '0', '14', '29', '0', '1', '14', '2', '0.5', '129', '1', '2', '0.88', '0.4375', '1', '1', '24.4', '5', '1.4', '0']
package org . apache . camel . util ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . FailedToCreateProducerException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ProducerCache < E extends Exchange > extends ServiceSupport { private static final Log LOG = LogFactory . getLog ( ProducerCache . class ) ; private Map < String , Producer < E > > producers = new HashMap < String , Producer < E > > ( ) ; public synchronized Producer < E > getProducer ( Endpoint < E > endpoint ) { String key = endpoint . getEndpointUri ( ) ; Producer < E > answer = producers . get ( key ) ; if ( answer == null ) { try { answer = endpoint . createProducer ( ) ; answer . start ( ) ; } catch ( Exception e ) { throw new FailedToCreateProducerException ( endpoint , e ) ; } producers . put ( key , answer ) ; } return answer ; } public void send ( Endpoint < E > endpoint , E exchange ) { try { Producer < E > producer = getProducer ( endpoint ) ; producer . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public E send ( Endpoint < E > endpoint , Processor processor ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( ) ; return sendExchange ( endpoint , producer , processor , exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( ) ; boolean sync = sendExchange ( endpoint , producer , processor , exchange , callback ) ; setProcessedSync ( exchange , sync ) ; return exchange ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public static boolean isProcessedSync ( Exchange exchange ) { Boolean rc = exchange . getProperty ( ProducerCache . class . getName ( ) + ".SYNC" , Boolean . class ) ; return rc == null ? false : rc ; } public static void setProcessedSync ( Exchange exchange , boolean b ) { exchange . setProperty ( ProducerCache . class . getName ( ) + ".SYNC" , b ? Boolean . TRUE : Boolean . FALSE ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( pattern ) ; return sendExchange ( endpoint , producer , processor , exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } protected E sendExchange ( Endpoint < E > endpoint , Producer < E > producer , Processor processor , E exchange ) throws Exception { processor . process ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> " + endpoint + " " + exchange ) ; } producer . process ( exchange ) ; return exchange ; } protected boolean sendExchange ( Endpoint < E > endpoint , Producer < E > producer , Processor processor , E exchange , AsyncCallback callback ) throws Exception { processor . process ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> " + endpoint + " " + exchange ) ; } return AsyncProcessorTypeConverter . convert ( producer ) . process ( exchange , callback ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( producers . values ( ) ) ; } protected void doStart ( ) throws Exception { } } 	1	['13', '2', '0', '16', '41', '66', '2', '14', '8', '0.541666667', '236', '1', '1', '0.541666667', '0.34375', '1', '1', '17', '2', '1.0769', '1']
package org . apache . camel . component . validator . jing ; import java . util . Map ; public class RelaxNGCompactSyntaxComponent extends JingComponent { protected void configureValidator ( JingValidator validator , String uri , String remaining , Map parameters ) throws Exception { validator . setCompactSyntax ( true ) ; super . configureValidator ( validator , uri , remaining , parameters ) ; } } 	0	['2', '5', '0', '2', '5', '1', '0', '2', '1', '2', '15', '0', '0', '0.965517241', '0.625', '1', '1', '6.5', '1', '0.5', '0']
package org . apache . camel . component . seda ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class SedaComponent extends DefaultComponent { public BlockingQueue < Exchange > createQueue ( ) { return new LinkedBlockingQueue < Exchange > ( 1000 ) ; } @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new SedaEndpoint ( uri , this ) ; } } 	1	['3', '3', '2', '5', '6', '3', '3', '3', '2', '2', '17', '0', '0', '0.92', '0.555555556', '1', '1', '4.666666667', '1', '0.6667', '1']
package org . apache . camel . builder . script ; import org . apache . camel . RuntimeCamelException ; public class ScriptEvaluationException extends RuntimeCamelException { public ScriptEvaluationException ( String message ) { super ( message ) ; } public ScriptEvaluationException ( String message , Throwable cause ) { super ( message , cause ) ; } public ScriptEvaluationException ( Throwable cause ) { super ( cause ) ; } } 	0	['3', '5', '0', '2', '6', '3', '1', '1', '3', '2', '16', '0', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel . component . timer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . component . bean . BeanInvocation ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . Timer ; import java . util . TimerTask ; public class TimerConsumer extends DefaultConsumer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( TimerConsumer . class ) ; private final TimerEndpoint endpoint ; private TimerTask task ; public TimerConsumer ( TimerEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { task = new TimerTask ( ) { @ Override public void run ( ) { sendTimerExchange ( ) ; } } ; Timer timer = endpoint . getTimer ( ) ; configureTask ( task , timer ) ; } @ Override protected void doStop ( ) throws Exception { task . cancel ( ) ; } protected void configureTask ( TimerTask task , Timer timer ) { if ( endpoint . isFixedRate ( ) ) { if ( endpoint . getTime ( ) != null ) { timer . scheduleAtFixedRate ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { timer . scheduleAtFixedRate ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } } else { if ( endpoint . getTime ( ) != null ) { if ( endpoint . getPeriod ( ) >= 0 ) { timer . schedule ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { timer . schedule ( task , endpoint . getTime ( ) ) ; } } else { if ( endpoint . getPeriod ( ) >= 0 ) { timer . schedule ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } else { timer . schedule ( task , endpoint . getDelay ( ) ) ; } } } } protected void sendTimerExchange ( ) { Exchange exchange = endpoint . createExchange ( ) ; exchange . setProperty ( "org.apache.camel.timer.name" , endpoint . getTimerName ( ) ) ; exchange . setProperty ( "org.apache.camel.timer.time" , endpoint . getTime ( ) ) ; exchange . setProperty ( "org.apache.camel.timer.period" , endpoint . getPeriod ( ) ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { LOG . error ( "Caught: " + e , e ) ; } } } 	1	['6', '3', '0', '8', '32', '0', '2', '8', '1', '0.666666667', '161', '1', '2', '0.846153846', '0.36', '1', '1', '25.33333333', '6', '1.5', '1']
package org . apache . camel . management ; import java . io . IOException ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Service" , currencyTimeLimit = 15 ) public class ManagedService { private ServiceSupport service ; public ManagedService ( ServiceSupport service ) { this . service = service ; } public Service getService ( ) { return service ; } @ ManagedAttribute ( description = "Service running state" ) public boolean isStarted ( ) throws IOException { return service . isStarted ( ) ; } @ ManagedOperation ( description = "Start Service" ) public void start ( ) throws IOException { try { service . start ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } } @ ManagedOperation ( description = "Stop Service" ) public void stop ( ) throws IOException { try { service . stop ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } } } 	0	['5', '1', '0', '4', '11', '0', '2', '2', '5', '0', '43', '1', '1', '0', '0.6', '0', '0', '7.4', '1', '0.8', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . model . ExceptionType ; import java . util . List ; public interface ErrorHandlerBuilder { ErrorHandlerBuilder copy ( ) ; Processor createErrorHandler ( Processor processor ) throws Exception ; void addErrorHandlers ( ExceptionType exception ) ; } 	1	['3', '1', '0', '12', '3', '3', '11', '2', '3', '2', '3', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . direct ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import java . util . Map ; public class DirectComponent < E extends Exchange > extends DefaultComponent < E > { protected Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Endpoint < E > endpoint = new DirectEndpoint < E > ( uri , this ) ; setProperties ( endpoint , parameters ) ; return endpoint ; } } 	0	['2', '3', '0', '3', '5', '1', '1', '3', '1', '2', '17', '0', '0', '0.958333333', '0.666666667', '1', '2', '7.5', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "xpath" ) public class XPathExpression extends ExpressionType { public XPathExpression ( ) { } public XPathExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "xpath" ; } } 	1	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '1']
package org . apache . camel . view ; import java . io . PrintWriter ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . model . FromType ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; public class RouteDotGenerator extends GraphGeneratorSupport { public RouteDotGenerator ( String dir ) { super ( dir , ".dot" ) ; } protected void printRoutes ( PrintWriter writer , Map < String , List < RouteType > > map ) { Set < Map . Entry < String , List < RouteType > > > entries = map . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { String group = entry . getKey ( ) ; printRoutes ( writer , group , entry . getValue ( ) ) ; } } protected void printRoutes ( PrintWriter writer , String group , List < RouteType > routes ) { if ( group != null ) { writer . println ( "subgraph cluster_" + ( clusterCounter ++ ) + " {" ) ; writer . println ( "label = \"" + group + "\";" ) ; writer . println ( "color = grey;" ) ; writer . println ( "style = \"dashed\";" ) ; writer . println ( "URL = \"" + group + ".html\";" ) ; writer . println ( ) ; } for ( RouteType route : routes ) { List < FromType > inputs = route . getInputs ( ) ; for ( FromType input : inputs ) { printRoute ( writer , route , input ) ; } writer . println ( ) ; } if ( group != null ) { writer . println ( "}" ) ; writer . println ( ) ; } } protected String escapeNodeId ( String text ) { return text . replace ( '.' , '_' ) . replace ( "$" , "_" ) ; } protected void printRoute ( PrintWriter writer , final RouteType route , FromType input ) { NodeData nodeData = getNodeData ( input ) ; printNode ( writer , nodeData ) ; List < ProcessorType > outputs = route . getOutputs ( ) ; NodeData from = nodeData ; for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , from , output ) ; from = newData ; } } protected NodeData printNode ( PrintWriter writer , NodeData fromData , ProcessorType node ) { if ( node instanceof MulticastType ) { List < ProcessorType > outputs = node . getOutputs ( ) ; for ( ProcessorType output : outputs ) { printNode ( writer , fromData , output ) ; } return fromData ; } NodeData toData = getNodeData ( node ) ; printNode ( writer , toData ) ; if ( fromData != null ) { writer . print ( fromData . id ) ; writer . print ( " -> " ) ; writer . print ( toData . id ) ; writer . println ( " [" ) ; String label = fromData . edgeLabel ; if ( isNotNullAndNonEmpty ( label ) ) { writer . println ( "label = \"" + label + "\"" ) ; } writer . println ( "];" ) ; } List < ProcessorType > outputs = toData . outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , toData , output ) ; if ( ! isMulticastNode ( node ) ) { toData = newData ; } } } return toData ; } protected void printNode ( PrintWriter writer , NodeData data ) { if ( ! data . nodeWritten ) { data . nodeWritten = true ; writer . println ( ) ; writer . print ( data . id ) ; writer . println ( " [" ) ; writer . println ( "label = \"" + data . label + "\"" ) ; writer . println ( "tooltip = \"" + data . tooltop + "\"" ) ; if ( data . url != null ) { writer . println ( "URL = \"" + data . url + "\"" ) ; } String image = data . image ; if ( image != null ) { writer . println ( "shapefile = \"" + image + "\"" ) ; writer . println ( "peripheries=0" ) ; } String shape = data . shape ; if ( shape == null && image != null ) { shape = "custom" ; } if ( shape != null ) { writer . println ( "shape = \"" + shape + "\"" ) ; } writer . println ( "];" ) ; writer . println ( ) ; } } protected void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) { writer . println ( "digraph CamelRoutes {" ) ; writer . println ( ) ; writer . println ( "node [style = \"rounded,filled\", fillcolor = yellow, " + "fontname=\"Helvetica-Oblique\"];" ) ; writer . println ( ) ; printRoutes ( writer , map ) ; writer . println ( "}" ) ; } } 	0	['8', '2', '0', '8', '31', '28', '1', '7', '1', '2', '396', '0', '0', '0.588235294', '0.347222222', '1', '1', '48.5', '7', '3.125', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BeanProcessor extends ServiceSupport implements Processor { public static final String METHOD_NAME = "org.apache.camel.MethodName" ; private static final Log LOG = LogFactory . getLog ( BeanProcessor . class ) ; private final Object pojo ; private final BeanInfo beanInfo ; private Method method ; private String methodName ; private final Processor processor ; public BeanProcessor ( Object pojo , BeanInfo beanInfo ) { this . pojo = pojo ; this . beanInfo = beanInfo ; this . processor = CamelContextHelper . convertTo ( beanInfo . getCamelContext ( ) , Processor . class , pojo ) ; } public BeanProcessor ( Object pojo , CamelContext camelContext , ParameterMappingStrategy parameterMappingStrategy ) { this ( pojo , new BeanInfo ( camelContext , pojo . getClass ( ) , parameterMappingStrategy ) ) ; } public BeanProcessor ( Object pojo , CamelContext camelContext ) { this ( pojo , camelContext , createParameterMappingStrategy ( camelContext ) ) ; } public static ParameterMappingStrategy createParameterMappingStrategy ( CamelContext camelContext ) { Registry registry = camelContext . getRegistry ( ) ; ParameterMappingStrategy answer = registry . lookup ( ParameterMappingStrategy . class . getName ( ) , ParameterMappingStrategy . class ) ; if ( answer == null ) { answer = new DefaultParameterMappingStrategy ( ) ; } return answer ; } @ Override public String toString ( ) { String description = method != null ? " " + method : "" ; return "BeanProcessor[" + pojo + description + "]" ; } public void process ( Exchange exchange ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> invoking method for: " + exchange ) ; } if ( processor != null ) { processor . process ( exchange ) ; return ; } Message in = exchange . getIn ( ) ; BeanInvocation beanInvoke = in . getBody ( BeanInvocation . class ) ; if ( beanInvoke != null ) { beanInvoke . invoke ( pojo , exchange ) ; return ; } MethodInvocation invocation ; if ( method != null ) { invocation = beanInfo . createInvocation ( method , pojo , exchange ) ; } else { if ( ObjectHelper . isNotNullAndNonEmpty ( methodName ) ) { if ( isNullOrBlank ( in . getHeader ( METHOD_NAME , String . class ) ) ) { in . setHeader ( METHOD_NAME , methodName ) ; } } invocation = beanInfo . createInvocation ( pojo , exchange ) ; } if ( invocation == null ) { throw new IllegalStateException ( "No method invocation could be created, no maching method could be found on: " + pojo ) ; } try { Object value = invocation . proceed ( ) ; if ( value != null ) { exchange . getOut ( ) . setBody ( value ) ; } } catch ( InvocationTargetException e ) { Throwable cause = e . getTargetException ( ) ; if ( cause instanceof Exception ) { throw ( Exception ) cause ; } else { throw e ; } } catch ( Exception e ) { throw e ; } catch ( Throwable throwable ) { throw new Exception ( throwable ) ; } } public Method getMethod ( ) { return method ; } public void setMethod ( Method method ) { this . method = method ; } public String getMethodName ( ) { return methodName ; } public void setMethodName ( String methodName ) { this . methodName = methodName ; } protected void doStart ( ) throws Exception { ServiceHelper . startService ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopService ( processor ) ; } } 	1	['13', '2', '0', '22', '47', '44', '6', '16', '10', '0.797619048', '248', '0.857142857', '3', '0.590909091', '0.229166667', '1', '1', '17.53846154', '2', '0.8462', '9']
package org . apache . camel . component . mock ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class MockComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new MockEndpoint ( uri , this ) ; } } 	0	['2', '3', '0', '4', '4', '1', '0', '4', '1', '2', '11', '0', '0', '0.958333333', '0.666666667', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . camel ; import org . apache . camel . impl . MessageSupport ; import java . util . Map ; public interface Message { String getMessageId ( ) ; void setMessageId ( String messageId ) ; Exchange getExchange ( ) ; Object getHeader ( String name ) ; < T > T getHeader ( String name , Class < T > type ) ; void setHeader ( String name , Object value ) ; Object removeHeader ( String name ) ; Map < String , Object > getHeaders ( ) ; void setHeaders ( Map < String , Object > headers ) ; Object getBody ( ) ; < T > T getBody ( Class < T > type ) ; void setBody ( Object body ) ; < T > void setBody ( Object body , Class < T > type ) ; Message copy ( ) ; void copyFrom ( Message message ) ; } 	1	['15', '1', '0', '102', '15', '105', '102', '1', '15', '2', '15', '0', '0', '0', '0.311111111', '0', '0', '0', '1', '1', '2']
package org . apache . camel . language . juel ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "el" ) public @ interface EL { public String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Processor ; public class ConstantProcessorBuilder implements ProcessorFactory { private Processor processor ; public ConstantProcessorBuilder ( Processor processor ) { this . processor = processor ; } public Processor createProcessor ( ) { return processor ; } } 	1	['2', '1', '0', '3', '3', '0', '1', '2', '2', '0', '12', '1', '1', '0', '0.75', '0', '0', '4.5', '1', '0.5', '1']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "xmlBeans" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XMLBeansDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public XMLBeansDataFormat ( ) { super ( "org.apache.camel.dataformat.converter.XmlBeansDataType" ) ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } } 	0	['3', '2', '0', '2', '4', '1', '1', '1', '3', '0.5', '15', '1', '0', '0.666666667', '0.666666667', '0', '0', '3.666666667', '1', '0.6667', '0']
package org . apache . camel . model . language ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . CollectionStringBuffer ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlID ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . XmlValue ; import javax . xml . bind . annotation . adapters . CollapsedStringAdapter ; import javax . xml . bind . annotation . adapters . XmlJavaTypeAdapter ; import java . util . List ; @ XmlType ( name = "expressionType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExpressionType { @ XmlAttribute @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) @ XmlID private String id ; @ XmlValue private String expression ; @ XmlTransient private Predicate predicate ; @ XmlTransient private Expression expressionValue ; public static String getLabel ( List < ExpressionType > expressions ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; for ( ExpressionType expression : expressions ) { buffer . append ( expression . getLabel ( ) ) ; } return buffer . toString ( ) ; } public ExpressionType ( ) { } public ExpressionType ( String expression ) { this . expression = expression ; } public ExpressionType ( Predicate predicate ) { this . predicate = predicate ; } public ExpressionType ( Expression expression ) { this . expressionValue = expression ; } @ Override public String toString ( ) { return getLanguage ( ) + "Expression[" + getExpression ( ) + "]" ; } public String getLanguage ( ) { return "" ; } public Predicate < Exchange > createPredicate ( RouteContext route ) { if ( predicate == null ) { CamelContext camelContext = route . getCamelContext ( ) ; Language language = camelContext . resolveLanguage ( getLanguage ( ) ) ; predicate = language . createPredicate ( getExpression ( ) ) ; } return predicate ; } public Expression createExpression ( RouteContext routeContext ) { if ( expressionValue == null ) { CamelContext camelContext = routeContext . getCamelContext ( ) ; Language language = camelContext . resolveLanguage ( getLanguage ( ) ) ; expressionValue = language . createExpression ( getExpression ( ) ) ; } return expressionValue ; } public String getExpression ( ) { return expression ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getId ( ) { return id ; } public void setId ( String value ) { this . id = value ; } public Predicate getPredicate ( ) { return predicate ; } public Expression getExpressionValue ( ) { return expressionValue ; } public String getLabel ( ) { String language = getExpression ( ) ; if ( ObjectHelper . isNullOrBlank ( language ) ) { Predicate predicate = getPredicate ( ) ; if ( predicate != null ) { return predicate . toString ( ) ; } Expression expressionValue = getExpressionValue ( ) ; if ( expressionValue != null ) { return expressionValue . toString ( ) ; } } else { return language ; } return "" ; } } 	1	['16', '1', '13', '31', '32', '100', '24', '7', '16', '0.783333333', '167', '1', '2', '0', '0.239583333', '0', '0', '9.1875', '3', '1.0625', '3']
package org . apache . camel . component . seda ; import org . apache . camel . Exchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . concurrent . BlockingQueue ; public class QueueComponent extends SedaComponent { private static final transient Log LOG = LogFactory . getLog ( QueueComponent . class ) ; public QueueComponent ( ) { LOG . warn ( "This component has been deprecated; please use the seda: URI format instead of queue:" ) ; } } 	0	['2', '4', '0', '3', '5', '0', '0', '3', '1', '0', '13', '1', '1', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . util ; import java . net . InetAddress ; import java . net . ServerSocket ; import java . util . logging . Level ; import java . util . logging . Logger ; public class UuidGenerator { private static final Logger LOG = Logger . getLogger ( UuidGenerator . class . getName ( ) ) ; private static final String UNIQUE_STUB ; private static int instanceCount ; private static String hostName ; private String seed ; private long sequence ; static { String stub = "" ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; ServerSocket ss = new ServerSocket ( 0 ) ; stub = "/" + ss . getLocalPort ( ) + "-" + System . currentTimeMillis ( ) + "/" ; Thread . sleep ( 100 ) ; ss . close ( ) ; } catch ( Exception ioe ) { LOG . log ( Level . WARNING , "could not generate unique stub" , ioe ) ; } } else { hostName = "localhost" ; stub = "-1-" + System . currentTimeMillis ( ) + "-" ; } UNIQUE_STUB = stub ; } public UuidGenerator ( String prefix ) { synchronized ( UNIQUE_STUB ) { this . seed = prefix + UNIQUE_STUB + ( instanceCount ++ ) + "-" ; } } public UuidGenerator ( ) { this ( "ID-" + hostName ) ; } public static String getHostName ( ) { return hostName ; } public synchronized String generateId ( ) { return this . seed + ( this . sequence ++ ) ; } public String generateSanitizedId ( ) { String result = generateId ( ) ; result = result . replace ( ':' , '-' ) ; result = result . replace ( '_' , '-' ) ; result = result . replace ( '.' , '-' ) ; return result ; } } 	1	['6', '1', '0', '2', '25', '5', '2', '0', '5', '0.7', '166', '1', '0', '0', '0.5', '0', '0', '25.66666667', '1', '0.5', '2']
package org . apache . camel . component . jms ; import javax . jms . Message ; import javax . jms . MessageListener ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; public class MessageListenerProcessor implements MessageListener { private final JmsEndpoint endpoint ; private final Processor processor ; public MessageListenerProcessor ( JmsEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } public void onMessage ( Message message ) { try { Exchange exchange = endpoint . createExchange ( message ) ; processor . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } 	0	['2', '1', '0', '5', '6', '0', '0', '5', '2', '0', '30', '1', '2', '0', '0.625', '0', '0', '13', '1', '0.5', '0']
package org . apache . camel . impl ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . commons . logging . LogFactory ; public class LoggingExceptionHandler implements ExceptionHandler { private final Logger logger ; public LoggingExceptionHandler ( Class ownerType ) { this ( new Logger ( LogFactory . getLog ( ownerType ) , LoggingLevel . ERROR ) ) ; } public LoggingExceptionHandler ( Logger logger ) { this . logger = logger ; } public void handleException ( Throwable exception ) { logger . log ( exception . getMessage ( ) , exception ) ; } } 	1	['3', '1', '0', '9', '8', '1', '4', '5', '3', '0', '26', '1', '1', '0', '0.5', '0', '0', '7.333333333', '1', '0.3333', '1']
package org . apache . camel . component . jms ; import javax . jms . ConnectionFactory ; import javax . jms . ExceptionListener ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageProducer ; import javax . jms . QueueSender ; import javax . jms . Session ; import javax . jms . TopicPublisher ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ObjectHelper ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer102 ; import org . springframework . jms . listener . SimpleMessageListenerContainer ; import org . springframework . jms . listener . SimpleMessageListenerContainer102 ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer102 ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . jms . support . destination . DestinationResolver ; import org . springframework . transaction . PlatformTransactionManager ; public class JmsConfiguration implements Cloneable { protected static final String TRANSACTED = "TRANSACTED" ; protected static final String CLIENT_ACKNOWLEDGE = "CLIENT_ACKNOWLEDGE" ; protected static final String AUTO_ACKNOWLEDGE = "AUTO_ACKNOWLEDGE" ; protected static final String DUPS_OK_ACKNOWLEDGE = "DUPS_OK_ACKNOWLEDGE" ; private JmsOperations jmsOperations ; private DestinationResolver destinationResolver ; private ConnectionFactory connectionFactory ; private ConnectionFactory templateConnectionFactory ; private ConnectionFactory listenerConnectionFactory ; private int acknowledgementMode = - 1 ; private String acknowledgementModeName = null ; private ExceptionListener exceptionListener ; private ConsumerType consumerType = ConsumerType . Default ; private boolean autoStartup = true ; private boolean acceptMessagesWhileStopping ; private String clientId ; private String durableSubscriptionName ; private boolean subscriptionDurable ; private boolean exposeListenerSession = true ; private TaskExecutor taskExecutor ; private boolean pubSubNoLocal ; private int concurrentConsumers = 1 ; private int maxMessagesPerTask = 1 ; private ServerSessionFactory serverSessionFactory ; private int cacheLevel = - 1 ; private String cacheLevelName = "CACHE_CONNECTION" ; private long recoveryInterval = - 1 ; private long receiveTimeout = - 1 ; private int idleTaskExecutionLimit = 1 ; private int maxConcurrentConsumers = 1 ; private boolean useVersion102 ; private boolean explicitQosEnabled ; private boolean deliveryPersistent = true ; private long timeToLive = - 1 ; private MessageConverter messageConverter ; private boolean messageIdEnabled = true ; private boolean messageTimestampEnabled = true ; private int priority = - 1 ; private boolean transacted ; private PlatformTransactionManager transactionManager ; private String transactionName ; private int transactionTimeout = - 1 ; private boolean preserveMessageQos ; public JmsConfiguration ( ) { } public JmsConfiguration ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public JmsConfiguration copy ( ) { try { return ( JmsConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public JmsOperations createJmsOperations ( boolean pubSubDomain , String destination ) { if ( jmsOperations != null ) { return jmsOperations ; } ConnectionFactory factory = getTemplateConnectionFactory ( ) ; JmsTemplate template = useVersion102 ? new JmsTemplate102 ( factory , pubSubDomain ) { @ Override protected void doSend ( MessageProducer producer , Message message ) throws JMSException { if ( preserveMessageQos ) { long ttl = message . getJMSExpiration ( ) ; if ( ttl != 0 ) { ttl = ttl - System . currentTimeMillis ( ) ; if ( ttl <= 0 ) { ttl = 1 ; } } if ( isPubSubDomain ( ) ) { ( ( TopicPublisher ) producer ) . publish ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } else { ( ( QueueSender ) producer ) . send ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } } else { super . doSend ( producer , message ) ; } } } : new JmsTemplate ( factory ) { @ Override protected void doSend ( MessageProducer producer , Message message ) throws JMSException { if ( preserveMessageQos ) { long ttl = message . getJMSExpiration ( ) ; if ( ttl != 0 ) { ttl = ttl - System . currentTimeMillis ( ) ; if ( ttl <= 0 ) { ttl = 1 ; } } producer . send ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } else { super . doSend ( producer , message ) ; } } } ; template . setPubSubDomain ( pubSubDomain ) ; if ( destinationResolver != null ) { template . setDestinationResolver ( destinationResolver ) ; } template . setDefaultDestinationName ( destination ) ; template . setExplicitQosEnabled ( explicitQosEnabled ) ; template . setDeliveryPersistent ( deliveryPersistent ) ; if ( messageConverter != null ) { template . setMessageConverter ( messageConverter ) ; } template . setMessageIdEnabled ( messageIdEnabled ) ; template . setMessageTimestampEnabled ( messageTimestampEnabled ) ; if ( priority >= 0 ) { template . setPriority ( priority ) ; } template . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { template . setReceiveTimeout ( receiveTimeout ) ; } if ( timeToLive >= 0 ) { template . setTimeToLive ( timeToLive ) ; } template . setSessionTransacted ( transacted ) ; if ( transacted ) { template . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { template . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { template . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } } return template ; } public AbstractMessageListenerContainer createMessageListenerContainer ( ) { AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation ( ) ; configureMessageListenerContainer ( container ) ; return container ; } protected void configureMessageListenerContainer ( AbstractMessageListenerContainer container ) { container . setConnectionFactory ( getListenerConnectionFactory ( ) ) ; if ( destinationResolver != null ) { container . setDestinationResolver ( destinationResolver ) ; } if ( autoStartup ) { container . setAutoStartup ( true ) ; } if ( clientId != null ) { container . setClientId ( clientId ) ; } container . setSubscriptionDurable ( subscriptionDurable ) ; if ( durableSubscriptionName != null ) { container . setDurableSubscriptionName ( durableSubscriptionName ) ; } if ( durableSubscriptionName != null && clientId != null ) { container . setSubscriptionDurable ( true ) ; } if ( exceptionListener != null ) { container . setExceptionListener ( exceptionListener ) ; } container . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; container . setExposeListenerSession ( exposeListenerSession ) ; container . setSessionTransacted ( transacted ) ; if ( transacted ) { container . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { container . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { container . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } } if ( container instanceof DefaultMessageListenerContainer ) { DefaultMessageListenerContainer listenerContainer = ( DefaultMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } if ( cacheLevel >= 0 ) { listenerContainer . setCacheLevel ( cacheLevel ) ; } else if ( cacheLevelName != null ) { listenerContainer . setCacheLevelName ( cacheLevelName ) ; } else { listenerContainer . setCacheLevel ( DefaultMessageListenerContainer . CACHE_CONSUMER ) ; } if ( idleTaskExecutionLimit >= 0 ) { listenerContainer . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } if ( maxConcurrentConsumers >= 0 ) { listenerContainer . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { listenerContainer . setReceiveTimeout ( receiveTimeout ) ; } if ( recoveryInterval >= 0 ) { listenerContainer . setRecoveryInterval ( recoveryInterval ) ; } if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } if ( transactionManager != null ) { listenerContainer . setTransactionManager ( transactionManager ) ; } else if ( transacted ) { throw new IllegalArgumentException ( "Property transacted is enabled but a transactionManager was not injected!" ) ; } if ( transactionName != null ) { listenerContainer . setTransactionName ( transactionName ) ; } if ( transactionTimeout >= 0 ) { listenerContainer . setTransactionTimeout ( transactionTimeout ) ; } } else if ( container instanceof ServerSessionMessageListenerContainer ) { ServerSessionMessageListenerContainer listenerContainer = ( ServerSessionMessageListenerContainer ) container ; if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } if ( serverSessionFactory != null ) { listenerContainer . setServerSessionFactory ( serverSessionFactory ) ; } } else if ( container instanceof SimpleMessageListenerContainer ) { SimpleMessageListenerContainer listenerContainer = ( SimpleMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } } } public ConnectionFactory getConnectionFactory ( ) { if ( connectionFactory == null ) { connectionFactory = createConnectionFactory ( ) ; } return connectionFactory ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public ConnectionFactory getListenerConnectionFactory ( ) { if ( listenerConnectionFactory == null ) { listenerConnectionFactory = createListenerConnectionFactory ( ) ; } return listenerConnectionFactory ; } public void setListenerConnectionFactory ( ConnectionFactory listenerConnectionFactory ) { this . listenerConnectionFactory = listenerConnectionFactory ; } public ConnectionFactory getTemplateConnectionFactory ( ) { if ( templateConnectionFactory == null ) { templateConnectionFactory = createTemplateConnectionFactory ( ) ; } return templateConnectionFactory ; } public void setTemplateConnectionFactory ( ConnectionFactory templateConnectionFactory ) { this . templateConnectionFactory = templateConnectionFactory ; } public boolean isUseVersion102 ( ) { return useVersion102 ; } public void setUseVersion102 ( boolean useVersion102 ) { this . useVersion102 = useVersion102 ; } public boolean isAutoStartup ( ) { return autoStartup ; } public void setAutoStartup ( boolean autoStartup ) { this . autoStartup = autoStartup ; } public boolean isAcceptMessagesWhileStopping ( ) { return acceptMessagesWhileStopping ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { this . acceptMessagesWhileStopping = acceptMessagesWhileStopping ; } public String getClientId ( ) { return clientId ; } public void setClientId ( String consumerClientId ) { this . clientId = consumerClientId ; } public String getDurableSubscriptionName ( ) { return durableSubscriptionName ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { this . durableSubscriptionName = durableSubscriptionName ; } public ExceptionListener getExceptionListener ( ) { return exceptionListener ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { this . exceptionListener = exceptionListener ; } public boolean isSubscriptionDurable ( ) { return subscriptionDurable ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { this . subscriptionDurable = subscriptionDurable ; } public String getAcknowledgementModeName ( ) { return acknowledgementModeName ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { this . acknowledgementModeName = consumerAcknowledgementMode ; this . acknowledgementMode = - 1 ; } public boolean isExposeListenerSession ( ) { return exposeListenerSession ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { this . exposeListenerSession = exposeListenerSession ; } public TaskExecutor getTaskExecutor ( ) { return taskExecutor ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { this . taskExecutor = taskExecutor ; } public boolean isPubSubNoLocal ( ) { return pubSubNoLocal ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { this . pubSubNoLocal = pubSubNoLocal ; } public int getConcurrentConsumers ( ) { return concurrentConsumers ; } public void setConcurrentConsumers ( int concurrentConsumers ) { this . concurrentConsumers = concurrentConsumers ; } public int getMaxMessagesPerTask ( ) { return maxMessagesPerTask ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { this . maxMessagesPerTask = maxMessagesPerTask ; } public ServerSessionFactory getServerSessionFactory ( ) { return serverSessionFactory ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { this . serverSessionFactory = serverSessionFactory ; } public int getCacheLevel ( ) { return cacheLevel ; } public void setCacheLevel ( int cacheLevel ) { this . cacheLevel = cacheLevel ; } public String getCacheLevelName ( ) { return cacheLevelName ; } public void setCacheLevelName ( String cacheName ) { this . cacheLevelName = cacheName ; } public long getRecoveryInterval ( ) { return recoveryInterval ; } public void setRecoveryInterval ( long recoveryInterval ) { this . recoveryInterval = recoveryInterval ; } public long getReceiveTimeout ( ) { return receiveTimeout ; } public void setReceiveTimeout ( long receiveTimeout ) { this . receiveTimeout = receiveTimeout ; } public PlatformTransactionManager getTransactionManager ( ) { return transactionManager ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { this . transactionManager = transactionManager ; } public String getTransactionName ( ) { return transactionName ; } public void setTransactionName ( String transactionName ) { this . transactionName = transactionName ; } public int getTransactionTimeout ( ) { return transactionTimeout ; } public void setTransactionTimeout ( int transactionTimeout ) { this . transactionTimeout = transactionTimeout ; } public int getIdleTaskExecutionLimit ( ) { return idleTaskExecutionLimit ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { this . idleTaskExecutionLimit = idleTaskExecutionLimit ; } public int getMaxConcurrentConsumers ( ) { return maxConcurrentConsumers ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { this . maxConcurrentConsumers = maxConcurrentConsumers ; } public boolean isExplicitQosEnabled ( ) { return explicitQosEnabled ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { this . explicitQosEnabled = explicitQosEnabled ; } public boolean isDeliveryPersistent ( ) { return deliveryPersistent ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { this . deliveryPersistent = deliveryPersistent ; } public long getTimeToLive ( ) { return timeToLive ; } public void setTimeToLive ( long timeToLive ) { this . timeToLive = timeToLive ; } public MessageConverter getMessageConverter ( ) { return messageConverter ; } public void setMessageConverter ( MessageConverter messageConverter ) { this . messageConverter = messageConverter ; } public boolean isMessageIdEnabled ( ) { return messageIdEnabled ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { this . messageIdEnabled = messageIdEnabled ; } public boolean isMessageTimestampEnabled ( ) { return messageTimestampEnabled ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { this . messageTimestampEnabled = messageTimestampEnabled ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public ConsumerType getConsumerType ( ) { return consumerType ; } public void setConsumerType ( ConsumerType consumerType ) { this . consumerType = consumerType ; } public int getAcknowledgementMode ( ) { return acknowledgementMode ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { this . acknowledgementMode = consumerAcknowledgementMode ; this . acknowledgementModeName = null ; } public boolean isTransacted ( ) { return transacted ; } public void setTransacted ( boolean consumerTransacted ) { this . transacted = consumerTransacted ; } protected AbstractMessageListenerContainer chooseMessageListenerContainerImplementation ( ) { switch ( consumerType ) { case Simple : return isUseVersion102 ( ) ? new SimpleMessageListenerContainer102 ( ) : new SimpleMessageListenerContainer ( ) ; case ServerSessionPool : return isUseVersion102 ( ) ? new ServerSessionMessageListenerContainer102 ( ) : new ServerSessionMessageListenerContainer ( ) ; case Default : return isUseVersion102 ( ) ? new DefaultMessageListenerContainer102 ( ) : new DefaultMessageListenerContainer ( ) ; default : throw new IllegalArgumentException ( "Unknown consumer type: " + consumerType ) ; } } protected ConnectionFactory createConnectionFactory ( ) { ObjectHelper . notNull ( connectionFactory , "connectionFactory" ) ; return null ; } protected ConnectionFactory createListenerConnectionFactory ( ) { return getConnectionFactory ( ) ; } protected ConnectionFactory createTemplateConnectionFactory ( ) { return getConnectionFactory ( ) ; } public boolean isPreserveMessageQos ( ) { return preserveMessageQos ; } public void setPreserveMessageQos ( boolean preserveMessageQos ) { this . preserveMessageQos = preserveMessageQos ; } public JmsOperations getJmsOperations ( ) { return jmsOperations ; } public void setJmsOperations ( JmsOperations jmsOperations ) { this . jmsOperations = jmsOperations ; } public DestinationResolver getDestinationResolver ( ) { return destinationResolver ; } public void setDestinationResolver ( DestinationResolver destinationResolver ) { this . destinationResolver = destinationResolver ; } } 	0	['89', '1', '0', '22', '152', '3486', '4', '20', '83', '0.960359408', '1002', '1', '1', '0', '0.092696629', '0', '0', '9.775280899', '29', '1.4831', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import java . lang . reflect . Method ; public class EnumTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isEnum ( ) && value != null ) { String text = value . toString ( ) ; Method method = null ; try { method = type . getMethod ( "valueOf" , String . class ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeCamelException ( "Could not find valueOf method on enum type: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , null , text ) ; } return null ; } } 	1	['2', '1', '0', '4', '12', '1', '1', '3', '2', '2', '52', '0', '0', '0', '0.666666667', '0', '0', '25', '3', '1.5', '1']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessagePropertyAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 3996286386119163309L ; private final String propertyName ; public MessagePropertyAccessException ( String propertyName , JMSException e ) { super ( "Error accessing header: " + propertyName , e ) ; this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0	['2', '5', '0', '2', '6', '0', '1', '1', '2', '1', '22', '1', '0', '0.944444444', '0.666666667', '0', '0', '9', '1', '0.5', '0']
package org . apache . camel . model ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . impl . RouteContext ; import javax . xml . bind . annotation . XmlType ; @ XmlType ( name = "interceptorType" ) public abstract class InterceptorType { public abstract DelegateProcessor createInterceptor ( RouteContext routeContext ) throws Exception ; } 	1	['2', '1', '1', '4', '3', '1', '2', '2', '2', '2', '5', '0', '0', '0', '0.75', '0', '0', '1.5', '1', '0.5', '4']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlEnum ; @ XmlEnum ( String . class ) public enum ArtixDSContentType { Default , Auto , Binary , Text , Java , Xml , Sax , TagValuePair } 	0	['4', '2', '0', '3', '7', '4', '2', '1', '2', '0.962962963', '111', '0.111111111', '9', '0.857142857', '0.444444444', '1', '1', '24.5', '1', '0.5', '0']
package org . apache . camel . util . jndi ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Map ; import javax . naming . Binding ; import javax . naming . CompositeName ; import javax . naming . Context ; import javax . naming . LinkRef ; import javax . naming . Name ; import javax . naming . NameClassPair ; import javax . naming . NameNotFoundException ; import javax . naming . NameParser ; import javax . naming . NamingEnumeration ; import javax . naming . NamingException ; import javax . naming . NotContextException ; import javax . naming . OperationNotSupportedException ; import javax . naming . Reference ; import javax . naming . spi . NamingManager ; import org . apache . camel . impl . ReflectionInjector ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; public class JndiContext implements Context , Serializable { public static final String SEPARATOR = "/" ; protected static final NameParser NAME_PARSER = new NameParser ( ) { public Name parse ( String name ) throws NamingException { return new CompositeName ( name ) ; } } ; protected static final Injector INJETOR = new ReflectionInjector ( ) ; private static final long serialVersionUID = - 5754338187296859149L ; private final Hashtable environment ; private final Map bindings ; private final Map treeBindings ; private boolean frozen ; private String nameInNamespace = "" ; public JndiContext ( ) throws Exception { this ( new Hashtable ( ) ) ; } public JndiContext ( Hashtable env ) throws Exception { this ( env , createBindingsMapFromEnvironment ( env ) ) ; } public JndiContext ( Hashtable environment , Map bindings ) { if ( environment == null ) { this . environment = new Hashtable ( ) ; } else { this . environment = new Hashtable ( environment ) ; } this . bindings = bindings ; treeBindings = new HashMap ( ) ; } public JndiContext ( Hashtable environment , Map bindings , String nameInNamespace ) { this ( environment , bindings ) ; this . nameInNamespace = nameInNamespace ; } protected JndiContext ( JndiContext clone , Hashtable env ) { this . bindings = clone . bindings ; this . treeBindings = clone . treeBindings ; this . environment = new Hashtable ( env ) ; } protected JndiContext ( JndiContext clone , Hashtable env , String nameInNamespace ) { this ( clone , env ) ; this . nameInNamespace = nameInNamespace ; } public static Map createBindingsMapFromEnvironment ( Hashtable env ) throws Exception { Map answer = new HashMap ( env ) ; for ( Object object : env . entrySet ( ) ) { Map . Entry entry = ( Map . Entry ) object ; Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( key instanceof String && value instanceof String ) { String keyText = ( String ) key ; String valueText = ( String ) value ; if ( keyText . endsWith ( ".class" ) ) { Class < ? > type = ObjectHelper . loadClass ( valueText ) ; if ( type != null ) { String newEntry = keyText . substring ( 0 , keyText . length ( ) - ".class" . length ( ) ) ; Object bean = createBean ( type , answer , newEntry + "." ) ; if ( bean != null ) { answer . put ( newEntry , bean ) ; } } } } } return answer ; } public void freeze ( ) { frozen = true ; } boolean isFrozen ( ) { return frozen ; } protected Map internalBind ( String name , Object value ) throws NamingException { assert name != null && name . length ( ) > 0 ; assert ! frozen ; Map newBindings = new HashMap ( ) ; int pos = name . indexOf ( '/' ) ; if ( pos == - 1 ) { if ( treeBindings . put ( name , value ) != null ) { throw new NamingException ( "Something already bound at " + name ) ; } bindings . put ( name , value ) ; newBindings . put ( name , value ) ; } else { String segment = name . substring ( 0 , pos ) ; assert segment != null ; assert ! segment . equals ( "" ) ; Object o = treeBindings . get ( segment ) ; if ( o == null ) { o = newContext ( ) ; treeBindings . put ( segment , o ) ; bindings . put ( segment , o ) ; newBindings . put ( segment , o ) ; } else if ( ! ( o instanceof JndiContext ) ) { throw new NamingException ( "Something already bound where a subcontext should go" ) ; } JndiContext defaultContext = ( JndiContext ) o ; String remainder = name . substring ( pos + 1 ) ; Map subBindings = defaultContext . internalBind ( remainder , value ) ; for ( Iterator iterator = subBindings . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; String subName = segment + "/" + ( String ) entry . getKey ( ) ; Object bound = entry . getValue ( ) ; treeBindings . put ( subName , bound ) ; newBindings . put ( subName , bound ) ; } } return newBindings ; } protected JndiContext newContext ( ) { try { return new JndiContext ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } } public Object addToEnvironment ( String propName , Object propVal ) throws NamingException { return environment . put ( propName , propVal ) ; } public Hashtable getEnvironment ( ) throws NamingException { return ( Hashtable ) environment . clone ( ) ; } public Object removeFromEnvironment ( String propName ) throws NamingException { return environment . remove ( propName ) ; } public Object lookup ( String name ) throws NamingException { if ( name . length ( ) == 0 ) { return this ; } Object result = treeBindings . get ( name ) ; if ( result == null ) { result = bindings . get ( name ) ; } if ( result == null ) { int pos = name . indexOf ( ':' ) ; if ( pos > 0 ) { String scheme = name . substring ( 0 , pos ) ; Context ctx = NamingManager . getURLContext ( scheme , environment ) ; if ( ctx == null ) { throw new NamingException ( "scheme " + scheme + " not recognized" ) ; } return ctx . lookup ( name ) ; } else { CompositeName path = new CompositeName ( name ) ; if ( path . size ( ) == 0 ) { return this ; } else { String first = path . get ( 0 ) ; Object value = bindings . get ( first ) ; if ( value == null ) { throw new NameNotFoundException ( name ) ; } else if ( value instanceof Context && path . size ( ) > 1 ) { Context subContext = ( Context ) value ; value = subContext . lookup ( path . getSuffix ( 1 ) ) ; } return value ; } } } if ( result instanceof LinkRef ) { LinkRef ref = ( LinkRef ) result ; result = lookup ( ref . getLinkName ( ) ) ; } if ( result instanceof Reference ) { try { result = NamingManager . getObjectInstance ( result , null , null , this . environment ) ; } catch ( NamingException e ) { throw e ; } catch ( Exception e ) { throw ( NamingException ) new NamingException ( "could not look up : " + name ) . initCause ( e ) ; } } if ( result instanceof JndiContext ) { String prefix = getNameInNamespace ( ) ; if ( prefix . length ( ) > 0 ) { prefix = prefix + SEPARATOR ; } result = new JndiContext ( ( JndiContext ) result , environment , prefix + name ) ; } return result ; } public Object lookup ( Name name ) throws NamingException { return lookup ( name . toString ( ) ) ; } public Object lookupLink ( String name ) throws NamingException { return lookup ( name ) ; } public Name composeName ( Name name , Name prefix ) throws NamingException { Name result = ( Name ) prefix . clone ( ) ; result . addAll ( name ) ; return result ; } public String composeName ( String name , String prefix ) throws NamingException { CompositeName result = new CompositeName ( prefix ) ; result . addAll ( new CompositeName ( name ) ) ; return result . toString ( ) ; } public NamingEnumeration list ( String name ) throws NamingException { Object o = lookup ( name ) ; if ( o == this ) { return new ListEnumeration ( ) ; } else if ( o instanceof Context ) { return ( ( Context ) o ) . list ( "" ) ; } else { throw new NotContextException ( ) ; } } public NamingEnumeration listBindings ( String name ) throws NamingException { Object o = lookup ( name ) ; if ( o == this ) { return new ListBindingEnumeration ( ) ; } else if ( o instanceof Context ) { return ( ( Context ) o ) . listBindings ( "" ) ; } else { throw new NotContextException ( ) ; } } public Object lookupLink ( Name name ) throws NamingException { return lookupLink ( name . toString ( ) ) ; } public NamingEnumeration list ( Name name ) throws NamingException { return list ( name . toString ( ) ) ; } public NamingEnumeration listBindings ( Name name ) throws NamingException { return listBindings ( name . toString ( ) ) ; } public void bind ( Name name , Object value ) throws NamingException { bind ( name . toString ( ) , value ) ; } public void bind ( String name , Object value ) throws NamingException { if ( isFrozen ( ) ) { throw new OperationNotSupportedException ( ) ; } else { internalBind ( name , value ) ; } } public void close ( ) throws NamingException { } public Context createSubcontext ( Name name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public Context createSubcontext ( String name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void destroySubcontext ( Name name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void destroySubcontext ( String name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public String getNameInNamespace ( ) throws NamingException { return nameInNamespace ; } public NameParser getNameParser ( Name name ) throws NamingException { return NAME_PARSER ; } public NameParser getNameParser ( String name ) throws NamingException { return NAME_PARSER ; } public void rebind ( Name name , Object value ) throws NamingException { bind ( name , value ) ; } public void rebind ( String name , Object value ) throws NamingException { bind ( name , value ) ; } public void rename ( Name oldName , Name newName ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void rename ( String oldName , String newName ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void unbind ( Name name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void unbind ( String name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } private abstract class LocalNamingEnumeration implements NamingEnumeration { private Iterator i = bindings . entrySet ( ) . iterator ( ) ; public boolean hasMore ( ) throws NamingException { return i . hasNext ( ) ; } public boolean hasMoreElements ( ) { return i . hasNext ( ) ; } protected Map . Entry getNext ( ) { return ( Map . Entry ) i . next ( ) ; } public void close ( ) throws NamingException { } } private class ListEnumeration extends LocalNamingEnumeration { ListEnumeration ( ) { } public Object next ( ) throws NamingException { return nextElement ( ) ; } public Object nextElement ( ) { Map . Entry entry = getNext ( ) ; return new NameClassPair ( ( String ) entry . getKey ( ) , entry . getValue ( ) . getClass ( ) . getName ( ) ) ; } } private class ListBindingEnumeration extends LocalNamingEnumeration { ListBindingEnumeration ( ) { } public Object next ( ) throws NamingException { return nextElement ( ) ; } public Object nextElement ( ) { Map . Entry entry = getNext ( ) ; return new Binding ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; } } protected static Object createBean ( Class < ? > type , Map properties , String prefix ) throws Exception { Object value = INJETOR . newInstance ( type ) ; IntrospectionSupport . setProperties ( value , properties , prefix ) ; return value ; } } 	1	['43', '1', '0', '9', '100', '825', '4', '7', '35', '0.838095238', '785', '0.8', '1', '0', '0.261904762', '0', '0', '17.02325581', '1', '0.8372', '2']
package org . apache . camel . component . cxf . interceptors ; import java . util . logging . Logger ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . phase . Phase ; public class RawMessageInInterceptor extends AbstractInvokerInterceptor { private static final Logger LOG = LogUtils . getL7dLogger ( RawMessageInInterceptor . class ) ; public RawMessageInInterceptor ( ) { super ( Phase . RECEIVE ) ; } @ Override protected Logger getLogger ( ) { return LOG ; } } 	0	['3', '1', '0', '3', '5', '1', '1', '2', '1', '0.5', '14', '1', '0', '0.8', '1', '0', '0', '3.333333333', '1', '0.3333', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SendProcessor extends ServiceSupport implements AsyncProcessor , Service { private static final transient Log LOG = LogFactory . getLog ( SendProcessor . class ) ; private Endpoint destination ; private Producer producer ; private AsyncProcessor processor ; public SendProcessor ( Endpoint destination ) { if ( destination == null ) { throw new IllegalArgumentException ( "Endpoint cannot be null!" ) ; } this . destination = destination ; } @ Override public String toString ( ) { return "sendTo(" + destination + ")" ; } public void process ( Exchange exchange ) throws Exception { if ( producer == null ) { if ( isStopped ( ) ) { LOG . warn ( "Ignoring exchange sent after processor is stopped: " + exchange ) ; } else { throw new IllegalStateException ( "No producer, this processor has not been started!" ) ; } } else { producer . process ( exchange ) ; } } public boolean process ( Exchange exchange , AsyncCallback callback ) { if ( producer == null ) { if ( isStopped ( ) ) { LOG . warn ( "Ignoring exchange sent after processor is stopped: " + exchange ) ; } else { exchange . setException ( new IllegalStateException ( "No producer, this processor has not been started!" ) ) ; } callback . done ( true ) ; return true ; } else { return processor . process ( exchange , callback ) ; } } public Endpoint getDestination ( ) { return destination ; } protected void doStart ( ) throws Exception { this . producer = destination . createProducer ( ) ; this . producer . start ( ) ; this . processor = AsyncProcessorTypeConverter . convert ( producer ) ; } protected void doStop ( ) throws Exception { if ( producer != null ) { try { producer . stop ( ) ; } finally { producer = null ; processor = null ; } } } } 	1	['8', '2', '0', '13', '26', '0', '2', '11', '5', '0.642857143', '142', '1', '4', '0.684210526', '0.392857143', '1', '1', '16.25', '3', '1', '1']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "property" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class PropertyType { @ XmlAttribute private String key ; @ XmlAnyElement ( lax = true ) private Object value ; public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } } 	0	['5', '1', '0', '0', '6', '6', '0', '0', '5', '0.75', '24', '1', '0', '0', '0.466666667', '0', '0', '3.4', '1', '0.8', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandler extends ErrorHandlerSupport { private Processor output ; private Log log ; private LoggingLevel level ; public LoggingErrorHandler ( Processor output ) { this ( output , LogFactory . getLog ( LoggingErrorHandler . class ) , LoggingLevel . INFO ) ; } public LoggingErrorHandler ( Processor output , Log log , LoggingLevel level ) { this . output = output ; this . log = log ; this . level = level ; } @ Override public String toString ( ) { return "LoggingErrorHandler[" + output + "]" ; } public void process ( Exchange exchange ) throws Exception { try { output . process ( exchange ) ; } catch ( Throwable e ) { if ( ! customProcessorForException ( exchange , e ) ) { logError ( exchange , e ) ; } } } public Processor getOutput ( ) { return output ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } protected void logError ( Exchange exchange , Throwable e ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange , e ) , e ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange , e ) , e ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange , e ) , e ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( logMessage ( exchange , e ) , e ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange , e ) , e ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange , e ) , e ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange , e ) , e ) ; } } protected Object logMessage ( Exchange exchange , Throwable e ) { return e + " while processing exchange: " + exchange ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( output ) ; } } 	1	['13', '3', '0', '9', '35', '26', '1', '8', '9', '0.555555556', '214', '1', '3', '0.592592593', '0.307692308', '1', '1', '15.23076923', '8', '1.3846', '1']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . IdentifiedType ; @ XmlRootElement ( name = "export" ) public class CamelServiceExporterType extends IdentifiedType { @ XmlAttribute private String uri ; @ XmlAttribute private String serviceRef ; @ XmlAttribute private Class serviceInterface ; } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '7', '1', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . util ; import java . util . Map ; import java . util . HashMap ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . InvalidPayloadException ; import org . apache . camel . InvalidTypeException ; import org . apache . camel . Message ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . NoSuchPropertyException ; import org . apache . camel . CamelContext ; public class ExchangeHelper { private ExchangeHelper ( ) { } public static < T > T getExchangeProperty ( Exchange exchange , String propertyName , Class < T > type , T defaultValue ) { T answer = exchange . getProperty ( propertyName , type ) ; if ( answer == null ) { return defaultValue ; } return answer ; } @ SuppressWarnings ( { "unchecked" } ) public static < E extends Exchange > Endpoint < E > resolveEndpoint ( E exchange , Object value ) throws NoSuchEndpointException { Endpoint < E > endpoint ; if ( value instanceof Endpoint ) { endpoint = ( Endpoint < E > ) value ; } else { String uri = value . toString ( ) ; endpoint = CamelContextHelper . getMandatoryEndpoint ( exchange . getContext ( ) , uri ) ; } return endpoint ; } public static < T > T getMandatoryProperty ( Exchange exchange , String propertyName , Class < T > type ) throws NoSuchPropertyException { T answer = exchange . getProperty ( propertyName , type ) ; if ( answer == null ) { throw new NoSuchPropertyException ( exchange , propertyName , type ) ; } return answer ; } public static Object getMandatoryInBody ( Exchange exchange ) throws InvalidPayloadException { Object answer = exchange . getIn ( ) . getBody ( ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , Object . class ) ; } return answer ; } public static < T > T getMandatoryInBody ( Exchange exchange , Class < T > type ) throws InvalidPayloadException { T answer = exchange . getIn ( ) . getBody ( type ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , type ) ; } return answer ; } public static Object getMandatoryOutBody ( Exchange exchange ) throws InvalidPayloadException { Object answer = exchange . getOut ( ) . getBody ( ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , Object . class ) ; } return answer ; } public static < T > T getMandatoryOutBody ( Exchange exchange , Class < T > type ) throws InvalidPayloadException { T answer = exchange . getOut ( ) . getBody ( type ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , type ) ; } return answer ; } public static < T > T convertToMandatoryType ( Exchange exchange , Class < T > type , Object value ) throws InvalidTypeException { T answer = convertToType ( exchange , type , value ) ; if ( answer == null ) { throw new InvalidTypeException ( exchange , value , type ) ; } return answer ; } public static < T > T convertToType ( Exchange exchange , Class < T > type , Object value ) { return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public static void copyResults ( Exchange result , Exchange source ) { if ( result != source ) { result . setException ( source . getException ( ) ) ; Message fault = source . getFault ( false ) ; if ( fault != null ) { result . getFault ( true ) . copyFrom ( fault ) ; } Message out = source . getOut ( false ) ; if ( out != null ) { result . getOut ( true ) . copyFrom ( out ) ; } } } public static boolean isInCapable ( Exchange exchange ) { ExchangePattern pattern = exchange . getPattern ( ) ; return pattern != null && pattern . isInCapable ( ) ; } public static boolean isOutCapable ( Exchange exchange ) { ExchangePattern pattern = exchange . getPattern ( ) ; return pattern != null && pattern . isOutCapable ( ) ; } public static < T > T newInstance ( Exchange exchange , Class < T > type ) { return exchange . getContext ( ) . getInjector ( ) . newInstance ( type ) ; } public static Map createVariableMap ( Exchange exchange ) { Map answer = new HashMap ( ) ; populateVariableMap ( exchange , answer ) ; return answer ; } public static void populateVariableMap ( Exchange exchange , Map map ) { map . put ( "exchange" , exchange ) ; Message in = exchange . getIn ( ) ; map . put ( "in" , in ) ; map . put ( "request" , in ) ; map . put ( "headers" , in . getHeaders ( ) ) ; map . put ( "body" , in . getBody ( ) ) ; if ( isOutCapable ( exchange ) ) { Message out = exchange . getOut ( true ) ; map . put ( "out" , out ) ; map . put ( "response" , out ) ; } map . put ( "camelContext" , exchange . getContext ( ) ) ; } public static String getContentType ( Exchange exchange ) { return exchange . getIn ( ) . getHeader ( "Content-Type" , String . class ) ; } } 	1	['17', '1', '0', '26', '45', '136', '14', '12', '16', '2', '275', '0', '0', '0', '0.303921569', '0', '0', '15.17647059', '4', '1.4706', '5']
package org . apache . camel ; public interface Expression < E extends Exchange > { Object evaluate ( E exchange ) ; } 	0	['1', '1', '0', '104', '1', '0', '103', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . StringTokenizer ; import java . util . Collection ; import java . util . regex . Pattern ; public class ExpressionBuilder { private ExpressionBuilder ( ) { } public static < E extends Exchange > Expression < E > headerExpression ( final String headerName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object header = exchange . getIn ( ) . getHeader ( headerName ) ; if ( header == null ) { header = exchange . getProperty ( headerName ) ; } return header ; } @ Override public String toString ( ) { return "header(" + headerName + ")" ; } } ; } public static < E extends Exchange > Expression < E > headersExpresion ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeaders ( ) ; } @ Override public String toString ( ) { return "headers" ; } } ; } public static < E extends Exchange > Expression < E > outHeaderExpression ( final String headerName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object header = exchange . getOut ( ) . getHeader ( headerName ) ; if ( header == null ) { header = exchange . getProperty ( headerName ) ; } return header ; } @ Override public String toString ( ) { return "outHeader(" + headerName + ")" ; } } ; } public static < E extends Exchange > Expression < E > propertyExpression ( final String propertyName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getProperty ( propertyName ) ; } @ Override public String toString ( ) { return "property(" + propertyName + ")" ; } } ; } public static < E extends Exchange > Expression < E > propertiesExpresion ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getProperties ( ) ; } @ Override public String toString ( ) { return "properties" ; } } ; } public static < E extends Exchange > Expression < E > systemPropertyExpression ( final String propertyName ) { return systemPropertyExpression ( propertyName , null ) ; } public static < E extends Exchange > Expression < E > systemPropertyExpression ( final String propertyName , final String defaultValue ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return System . getProperty ( propertyName , defaultValue ) ; } @ Override public String toString ( ) { return "systemProperty(" + propertyName + ")" ; } } ; } public static < E extends Exchange > Expression < E > constantExpression ( final Object value ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return value ; } @ Override public String toString ( ) { return "" + value ; } } ; } public static < E extends Exchange > Expression < E > bodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "body" ; } } ; } public static < E extends Exchange , T > Expression < E > bodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "bodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > outBodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getOut ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "outBody" ; } } ; } public static < E extends Exchange , T > Expression < E > outBodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getOut ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "outBodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > faultBodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getFault ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "faultBody" ; } } ; } public static < E extends Exchange , T > Expression < E > faultBodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getFault ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "faultBodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > exchangeExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange ; } @ Override public String toString ( ) { return "exchange" ; } } ; } public static < E extends Exchange > Expression < E > inMessageExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) ; } @ Override public String toString ( ) { return "inMessage" ; } } ; } public static < E extends Exchange > Expression < E > convertTo ( final Expression expression , final Class type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } @ Override public String toString ( ) { return "" + expression + ".convertTo(" + type . getName ( ) + ".class)" ; } } ; } public static < E extends Exchange > Expression < E > tokenizeExpression ( final Expression < E > expression , final String token ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } StringTokenizer iter = new StringTokenizer ( text , token ) ; List < String > answer = new ArrayList < String > ( ) ; while ( iter . hasMoreTokens ( ) ) { answer . add ( iter . nextToken ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "tokenize(" + expression + ", " + token + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexTokenize ( final Expression < E > expression , String regexTokenizer ) { final Pattern pattern = Pattern . compile ( regexTokenizer ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } return Arrays . asList ( pattern . split ( text ) ) ; } @ Override public String toString ( ) { return "regexTokenize(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , String regex , final String replacement ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , String regex , final Expression < E > replacementExpression ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; String replacement = evaluateStringExpression ( replacementExpression , exchange ) ; if ( text == null || replacement == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > append ( final Expression < E > left , final Expression < E > right ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return evaluateStringExpression ( left , exchange ) + evaluateStringExpression ( right , exchange ) ; } @ Override public String toString ( ) { return "append(" + left + ", " + right + ")" ; } } ; } public static < E extends Exchange > String evaluateStringExpression ( Expression < E > expression , E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , value ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name , final String defaultValue ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return System . getProperty ( name , defaultValue ) ; } } ; } public static < E extends Exchange > Expression < E > concatExpression ( final Collection < Expression > expressions ) { return concatExpression ( expressions , null ) ; } public static < E extends Exchange > Expression < E > concatExpression ( final Collection < Expression > expressions , final String expression ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Expression < E > expression : expressions ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text != null ) { buffer . append ( text ) ; } } return buffer . toString ( ) ; } @ Override public String toString ( ) { if ( expression != null ) { return expression ; } else { return "concat" + expressions ; } } } ; } } 	1	['28', '1', '0', '35', '57', '378', '14', '27', '27', '2', '183', '0', '0', '0', '0.142857143', '0', '0', '5.535714286', '1', '0.9643', '3']
package org . apache . camel . component . xmpp ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . jivesoftware . smack . packet . Message ; public class XmppExchange extends DefaultExchange { private XmppBinding binding ; public XmppExchange ( CamelContext context , ExchangePattern pattern , XmppBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public XmppExchange ( CamelContext context , ExchangePattern pattern , XmppBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new XmppMessage ( message ) ) ; } @ Override public XmppMessage getIn ( ) { return ( XmppMessage ) super . getIn ( ) ; } @ Override public XmppMessage getOut ( ) { return ( XmppMessage ) super . getOut ( ) ; } @ Override public XmppMessage getOut ( boolean lazyCreate ) { return ( XmppMessage ) super . getOut ( lazyCreate ) ; } @ Override public XmppMessage getFault ( ) { return ( XmppMessage ) super . getFault ( ) ; } public XmppBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new XmppExchange ( getContext ( ) , getPattern ( ) , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getXmppMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } @ Override protected XmppMessage createInMessage ( ) { return new XmppMessage ( ) ; } @ Override protected XmppMessage createOutMessage ( ) { return new XmppMessage ( ) ; } } 	0	['19', '2', '0', '10', '24', '165', '4', '8', '15', '0.833333333', '109', '1', '1', '0.679245283', '0.245614035', '1', '3', '4.684210526', '1', '0.8947', '0']
package org . apache . camel . util ; import java . io . IOException ; public class IOHelper { public static IOException createIOException ( Throwable cause ) { return createIOException ( cause . getMessage ( ) , cause ) ; } public static IOException createIOException ( String message , Throwable cause ) { IOException answer = new IOException ( message ) ; answer . initCause ( cause ) ; return answer ; } } 	1	['3', '1', '0', '1', '7', '3', '1', '0', '3', '2', '22', '0', '0', '0', '0.444444444', '0', '0', '6.333333333', '1', '0.6667', '1']
package org . apache . camel . component . mail ; public class RuntimeMailException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeMailException ( String message , Throwable cause ) { super ( message , cause ) ; } } 	0	['1', '4', '2', '3', '2', '0', '3', '0', '1', '2', '7', '1', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel ; public class NoSuchEndpointException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final String uri ; public NoSuchEndpointException ( String uri ) { super ( "No endpoint could be found for: " + uri ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	1	['2', '5', '0', '8', '6', '0', '7', '1', '2', '1', '21', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . logging . Logger ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . phase . Phase ; public class PayloadInInterceptor extends AbstractInvokerInterceptor { private static final Logger LOG = LogUtils . getL7dLogger ( PayloadInInterceptor . class ) ; public PayloadInInterceptor ( ) { super ( Phase . READ ) ; } @ Override protected Logger getLogger ( ) { return LOG ; } } 	0	['3', '1', '0', '3', '5', '1', '1', '2', '1', '0.5', '14', '1', '0', '0.8', '1', '0', '0', '3.333333333', '1', '0.3333', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; @ XmlRootElement ( name = "finally" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FinallyType extends OutputType { @ Override public String toString ( ) { return "Finally[" + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return "" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProcessor ( this ) ; } } 	1	['4', '3', '0', '5', '11', '6', '1', '4', '4', '2', '25', '0', '0', '0.97029703', '0.625', '1', '2', '5.25', '1', '0.75', '3']
package org . apache . camel . component . cxf . invoker ; import java . util . Map ; import org . apache . cxf . Bus ; import org . apache . cxf . endpoint . EndpointImpl ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . PhaseInterceptorChain ; public interface InvokingContext { PhaseInterceptorChain getRequestInInterceptorChain ( Exchange exchange ) ; void setRequestOutMessageContent ( Message message , Object content ) ; PhaseInterceptorChain getResponseInInterceptorChain ( Exchange exchange ) ; PhaseInterceptorChain getRequestOutInterceptorChain ( Exchange exchange ) ; PhaseInterceptorChain getResponseOutInterceptorChain ( Exchange exchange ) ; Object getResponseObject ( Exchange exchange , Map < String , Object > responseContext ) ; void setEndpointFaultObservers ( EndpointImpl endpointImpl , Bus bus ) ; void setResponseContent ( Message outMessage , Object resultPayload ) ; Object getRequestContent ( Message inMessage ) ; } 	0	['9', '1', '0', '11', '9', '36', '6', '5', '9', '2', '9', '0', '0', '0', '0.349206349', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file . strategy ; public class NoOpFileProcessStrategy extends FileProcessStrategySupport { public NoOpFileProcessStrategy ( ) { super ( false ) ; } } 	1	['1', '2', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . camel . spring ; import org . apache . camel . * ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . spring . util . ReflectionUtils ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; @ XmlRootElement ( name = "beanPostProcessor" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelBeanPostProcessor implements BeanPostProcessor , ApplicationContextAware { private static final transient Log LOG = LogFactory . getLog ( CamelBeanPostProcessor . class ) ; @ XmlTransient private SpringCamelContext camelContext ; @ XmlTransient private ApplicationContext applicationContext ; public CamelBeanPostProcessor ( ) { } public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { injectFields ( bean ) ; injectMethods ( bean ) ; if ( bean instanceof CamelContextAware ) { CamelContextAware contextAware = ( CamelContextAware ) bean ; if ( camelContext == null ) { LOG . warn ( "No CamelContext defined yet so cannot inject into: " + bean ) ; } else { contextAware . setCamelContext ( camelContext ) ; } } return bean ; } public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { return bean ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public SpringCamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( SpringCamelContext camelContext ) { this . camelContext = camelContext ; } protected void injectFields ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { EndpointInject annotation = field . getAnnotation ( EndpointInject . class ) ; if ( annotation != null ) { ReflectionUtils . setField ( field , bean , getEndpointInjectionValue ( annotation , field . getType ( ) , field . getName ( ) ) ) ; } } } ) ; } protected void injectMethods ( final Object bean ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { setterInjection ( method , bean ) ; consumerInjection ( method , bean ) ; } } ) ; } protected void setterInjection ( Method method , Object bean ) { EndpointInject annoation = method . getAnnotation ( EndpointInject . class ) ; if ( annoation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes != null ) { if ( parameterTypes . length != 1 ) { LOG . warn ( "Ignoring badly annotated method for injection due to incorrect number of parameters: " + method ) ; } else { String propertyName = ObjectHelper . getPropertyName ( method ) ; Object value = getEndpointInjectionValue ( annoation , parameterTypes [ 0 ] , propertyName ) ; ObjectHelper . invokeMethod ( method , bean , value ) ; } } } } protected void consumerInjection ( final Object bean ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { } } ) ; } protected void consumerInjection ( Method method , Object bean ) { MessageDriven annotation = method . getAnnotation ( MessageDriven . class ) ; if ( annotation != null ) { LOG . info ( "Creating a consumer for: " + annotation ) ; String injectionPointName = method . getName ( ) ; Endpoint endpoint = getEndpointInjection ( annotation . uri ( ) , annotation . name ( ) , injectionPointName ) ; if ( endpoint != null ) { try { Processor processor = createConsumerProcessor ( bean , method , endpoint ) ; LOG . info ( "Created processor: " + processor ) ; Consumer consumer = endpoint . createConsumer ( processor ) ; consumer . start ( ) ; onConsumerAdded ( consumer ) ; } catch ( Exception e ) { LOG . warn ( e ) ; throw new RuntimeCamelException ( e ) ; } } } } protected Processor createConsumerProcessor ( final Object pojo , final Method method , final Endpoint endpoint ) { BeanProcessor answer = new BeanProcessor ( pojo , getCamelContext ( ) ) ; answer . setMethod ( method ) ; return answer ; } protected void onConsumerAdded ( Consumer consumer ) { LOG . debug ( "Adding consumer: " + consumer ) ; } protected Object getEndpointInjectionValue ( EndpointInject annotation , Class < ? > type , String injectionPointName ) { Endpoint endpoint = getEndpointInjection ( annotation . uri ( ) , annotation . name ( ) , injectionPointName ) ; if ( endpoint != null ) { if ( type . isInstance ( endpoint ) ) { return endpoint ; } else if ( type . isAssignableFrom ( Producer . class ) ) { return createInjectionProducer ( endpoint ) ; } else if ( type . isAssignableFrom ( CamelTemplate . class ) ) { return new CamelTemplate ( getCamelContext ( ) , endpoint ) ; } else if ( type . isAssignableFrom ( PollingConsumer . class ) ) { return createInjectionPollingConsumer ( endpoint ) ; } else { throw new IllegalArgumentException ( "Invalid type: " + type . getName ( ) + " which cannot be injected via @EndpointInject for " + endpoint ) ; } } return null ; } protected PollingConsumer createInjectionPollingConsumer ( Endpoint endpoint ) { try { PollingConsumer pollingConsumer = endpoint . createPollingConsumer ( ) ; pollingConsumer . start ( ) ; return pollingConsumer ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } protected Producer createInjectionProducer ( Endpoint endpoint ) { try { Producer producer = endpoint . createProducer ( ) ; producer . start ( ) ; return producer ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } protected Endpoint getEndpointInjection ( String uri , String name , String injectionPointName ) { Endpoint endpoint = null ; if ( isNotNullAndNonEmpty ( uri ) ) { endpoint = camelContext . getEndpoint ( uri ) ; } else { if ( isNullOrBlank ( name ) ) { name = injectionPointName ; } endpoint = ( Endpoint ) applicationContext . getBean ( name ) ; if ( endpoint == null ) { throw new NoSuchBeanDefinitionException ( name ) ; } } return endpoint ; } } 	0	['18', '1', '0', '27', '62', '119', '3', '27', '6', '0.745098039', '356', '1', '2', '0', '0.235294118', '0', '0', '18.61111111', '6', '1.6111', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import javax . management . NotificationListener ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class JMXConsumer extends DefaultConsumer implements NotificationListener { JMXEndpoint jmxEndpoint ; public JMXConsumer ( JMXEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . jmxEndpoint = endpoint ; } public void handleNotification ( Notification notification , Object handback ) { try { getProcessor ( ) . process ( jmxEndpoint . createExchange ( notification ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } } 	1	['2', '3', '0', '6', '7', '0', '1', '6', '2', '0', '24', '0', '1', '0.956521739', '0.6', '0', '0', '10.5', '1', '0.5', '2']
package org . apache . camel . builder . script ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "jruby" ) public @ interface Ruby { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import org . apache . camel . TypeConverter ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; public class IntrospectionSupport { private IntrospectionSupport ( ) { } public static boolean getProperties ( Object target , Map props , String optionPrefix ) { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } if ( optionPrefix == null ) { optionPrefix = "" ; } Class clazz = target . getClass ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; String name = method . getName ( ) ; Class type = method . getReturnType ( ) ; Class params [ ] = method . getParameterTypes ( ) ; if ( name . startsWith ( "get" ) && params . length == 0 && type != null && isSettableType ( type ) ) { try { Object value = method . invoke ( target , new Object [ ] { } ) ; if ( value == null ) { continue ; } String strValue = convertToString ( value , type ) ; if ( strValue == null ) { continue ; } name = name . substring ( 3 , 4 ) . toLowerCase ( ) + name . substring ( 4 ) ; props . put ( optionPrefix + name , strValue ) ; rc = true ; } catch ( Throwable ignore ) { } } } return rc ; } public static Object getProperty ( Object target , String prop ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( prop == null ) { throw new IllegalArgumentException ( "prop was null." ) ; } prop = prop . substring ( 0 , 1 ) . toUpperCase ( ) + prop . substring ( 1 ) ; Class clazz = target . getClass ( ) ; Method method = getPropertyGetter ( clazz , prop ) ; return method . invoke ( target , new Object [ ] { } ) ; } public static Method getPropertyGetter ( Class type , String propertyName ) throws NoSuchMethodException { Method method = type . getMethod ( "get" + ObjectHelper . capitalize ( propertyName ) , new Class [ ] { } ) ; return method ; } public static boolean setProperties ( Object target , Map props , String optionPrefix ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; if ( setProperty ( target , name , value ) ) { iter . remove ( ) ; rc = true ; } } } return rc ; } public static Map extractProperties ( Map props , String optionPrefix ) { if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } HashMap rc = new HashMap ( props . size ( ) ) ; for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; rc . put ( name , value ) ; iter . remove ( ) ; } } return rc ; } public static boolean setProperties ( TypeConverter typeConverter , Object target , Map props ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Entry ) iter . next ( ) ; if ( setProperty ( typeConverter , target , ( String ) entry . getKey ( ) , entry . getValue ( ) ) ) { iter . remove ( ) ; rc = true ; } } return rc ; } public static boolean setProperties ( Object target , Map props ) throws Exception { return setProperties ( null , target , props ) ; } public static boolean setProperty ( TypeConverter typeConverter , Object target , String name , Object value ) throws Exception { try { Class clazz = target . getClass ( ) ; Method setter = findSetterMethod ( typeConverter , clazz , name , value ) ; if ( setter == null ) { return false ; } if ( value == null || value . getClass ( ) == setter . getParameterTypes ( ) [ 0 ] ) { setter . invoke ( target , new Object [ ] { value } ) ; } else { Object convertedValue = convert ( typeConverter , setter . getParameterTypes ( ) [ 0 ] , value ) ; setter . invoke ( target , new Object [ ] { convertedValue } ) ; } return true ; } catch ( InvocationTargetException e ) { Throwable throwable = e . getTargetException ( ) ; if ( throwable instanceof Exception ) { Exception exception = ( Exception ) throwable ; throw exception ; } else { Error error = ( Error ) throwable ; throw error ; } } } public static boolean setProperty ( Object target , String name , Object value ) throws Exception { return setProperty ( null , target , name , value ) ; } private static Object convert ( TypeConverter typeConverter , Class type , Object value ) throws URISyntaxException { if ( typeConverter != null ) { Object answer = typeConverter . convertTo ( type , value ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Could not convert \"" + value + "\" to " + type . getName ( ) ) ; } return answer ; } PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return editor . getValue ( ) ; } if ( type == URI . class ) { return new URI ( value . toString ( ) ) ; } return null ; } private static String convertToString ( Object value , Class type ) throws URISyntaxException { PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setValue ( value ) ; return editor . getAsText ( ) ; } if ( type == URI . class ) { return ( ( URI ) value ) . toString ( ) ; } return null ; } private static Method findSetterMethod ( TypeConverter typeConverter , Class clazz , String name , Object value ) { name = "set" + ObjectHelper . capitalize ( name ) ; while ( clazz != Object . class ) { Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; Class params [ ] = method . getParameterTypes ( ) ; if ( method . getName ( ) . equals ( name ) && params . length == 1 ) { Class paramType = params [ 0 ] ; if ( typeConverter != null || isSettableType ( paramType ) || paramType . isInstance ( value ) ) { return method ; } } } clazz = clazz . getSuperclass ( ) ; } return null ; } private static boolean isSettableType ( Class clazz ) { if ( PropertyEditorManager . findEditor ( clazz ) != null ) { return true ; } if ( clazz == URI . class ) { return true ; } if ( clazz == Boolean . class ) { return true ; } return false ; } public static String toString ( Object target ) { return toString ( target , Object . class ) ; } public static String toString ( Object target , Class stopClass ) { LinkedHashMap map = new LinkedHashMap ( ) ; addFields ( target , target . getClass ( ) , stopClass , map ) ; StringBuffer buffer = new StringBuffer ( simpleName ( target . getClass ( ) ) ) ; buffer . append ( " {" ) ; Set entrySet = map . entrySet ( ) ; boolean first = true ; for ( Iterator iter = entrySet . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( first ) { first = false ; } else { buffer . append ( ", " ) ; } buffer . append ( entry . getKey ( ) ) ; buffer . append ( " = " ) ; appendToString ( buffer , entry . getValue ( ) ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } protected static void appendToString ( StringBuffer buffer , Object value ) { buffer . append ( value ) ; } public static String simpleName ( Class clazz ) { String name = clazz . getName ( ) ; int p = name . lastIndexOf ( "." ) ; if ( p >= 0 ) { name = name . substring ( p + 1 ) ; } return name ; } private static void addFields ( Object target , Class startClass , Class stopClass , LinkedHashMap map ) { if ( startClass != stopClass ) { addFields ( target , startClass . getSuperclass ( ) , stopClass , map ) ; } Field [ ] fields = startClass . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field field = fields [ i ] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) || Modifier . isTransient ( field . getModifiers ( ) ) || Modifier . isPrivate ( field . getModifiers ( ) ) ) { continue ; } try { field . setAccessible ( true ) ; Object o = field . get ( target ) ; if ( o != null && o . getClass ( ) . isArray ( ) ) { try { o = Arrays . asList ( ( Object [ ] ) o ) ; } catch ( Throwable e ) { } } map . put ( field . getName ( ) , o ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } } } 	1	['19', '1', '0', '10', '85', '171', '8', '2', '12', '2', '720', '0', '0', '0', '0.276315789', '0', '0', '36.89473684', '11', '2.6316', '3']
package org . apache . camel ; public interface Service { void start ( ) throws Exception ; void stop ( ) throws Exception ; } 	0	['2', '1', '0', '21', '2', '1', '21', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public class FailedToCreateProducerException extends RuntimeCamelException { private final Endpoint endpoint ; public FailedToCreateProducerException ( Endpoint endpoint , Throwable cause ) { super ( "Failed to create Producer for endpoint: " + endpoint + ". Reason: " + cause , cause ) ; this . endpoint = endpoint ; } public Endpoint getEndpoint ( ) { return endpoint ; } } 	1	['2', '5', '0', '3', '7', '0', '1', '2', '2', '0', '25', '1', '1', '0.944444444', '0.666666667', '0', '0', '11', '1', '0.5', '1']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "objectHeader" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class ObjectHeader extends HeaderType { @ XmlAnyElement ( lax = true ) private Object value ; public ObjectHeader ( ) { } public ObjectHeader ( String name , Object value ) { super ( name ) ; this . value = value ; } public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } } 	0	['4', '2', '0', '1', '6', '0', '0', '1', '4', '0.333333333', '22', '1', '0', '0.666666667', '0.583333333', '0', '0', '4.25', '1', '0.5', '0']
package org . apache . camel . util ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; public final class AsyncProcessorHelper { private AsyncProcessorHelper ( ) { } public static void process ( AsyncProcessor processor , Exchange exchange ) throws Exception { final CountDownLatch latch = new CountDownLatch ( 1 ) ; boolean sync = processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( ! sync ) { latch . countDown ( ) ; } } } ) ; if ( ! sync ) { latch . await ( ) ; } } } 	1	['2', '1', '0', '10', '7', '1', '6', '4', '1', '2', '23', '0', '0', '0', '0.5', '0', '0', '10.5', '1', '0.5', '1']
package org . apache . camel . builder . sql ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import org . apache . camel . util . ObjectHelper ; import org . josql . Query ; import org . josql . QueryExecutionException ; import org . josql . QueryParseException ; public class SqlBuilder < E extends Exchange > implements Expression < E > , Predicate < E > { private Query query ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public SqlBuilder ( Query query ) { this . query = query ; } public Object evaluate ( E exchange ) { return evaluateQuery ( exchange ) ; } public boolean matches ( E exchange ) { List list = evaluateQuery ( exchange ) ; return matches ( exchange , list ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { List list = evaluateQuery ( exchange ) ; if ( ! matches ( exchange , list ) ) { throw new AssertionError ( this + " failed on " + exchange + " as found " + list ) ; } } public static < E extends Exchange > SqlBuilder < E > sql ( String sql ) throws QueryParseException { Query q = new Query ( ) ; q . parse ( sql ) ; return new SqlBuilder ( q ) ; } public SqlBuilder < E > variable ( String name , Object value ) { getVariables ( ) . put ( name , value ) ; return this ; } public Map < String , Object > getVariables ( ) { return variables ; } public void setVariables ( Map < String , Object > properties ) { this . variables = properties ; } protected boolean matches ( E exchange , List list ) { return ObjectHelper . matches ( list ) ; } protected List evaluateQuery ( E exchange ) { configureQuery ( exchange ) ; Message in = exchange . getIn ( ) ; List list = in . getBody ( List . class ) ; if ( list == null ) { list = Collections . singletonList ( in . getBody ( ) ) ; } try { return query . execute ( list ) . getResults ( ) ; } catch ( QueryExecutionException e ) { throw new RuntimeExpressionException ( e ) ; } } protected void configureQuery ( E exchange ) { addVariables ( exchange . getProperties ( ) ) ; addVariables ( exchange . getIn ( ) . getHeaders ( ) ) ; addVariables ( getVariables ( ) ) ; query . setVariable ( "exchange" , exchange ) ; query . setVariable ( "in" , exchange . getIn ( ) ) ; query . setVariable ( "out" , exchange . getOut ( ) ) ; } protected void addVariables ( Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { query . setVariable ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	0	['14', '1', '0', '10', '42', '73', '0', '10', '10', '0.461538462', '192', '1', '0', '0', '0.306122449', '0', '0', '12.57142857', '2', '1.0714', '0']
package org . apache . camel . model ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . MulticastProcessor ; @ XmlRootElement ( name = "multicast" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MulticastType extends OutputType < ProcessorType > { @ Override public String toString ( ) { return "Multicast[" + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createOutputsProcessor ( routeContext ) ; } protected Processor createCompositeProcessor ( List < Processor > list ) { return new MulticastProcessor ( list ) ; } } 	1	['4', '3', '0', '8', '12', '6', '4', '4', '3', '2', '28', '0', '0', '0.97029703', '0.5', '1', '3', '6', '1', '0.75', '4']
package org . apache . camel . component . jms ; import org . apache . camel . Exchange ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . jms . BytesMessage ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . MapMessage ; import javax . jms . Message ; import javax . jms . ObjectMessage ; import javax . jms . Session ; import javax . jms . StreamMessage ; import javax . jms . TextMessage ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class JmsBinding { private static final transient Log LOG = LogFactory . getLog ( JmsBinding . class ) ; public Object extractBodyFromJms ( JmsExchange exchange , Message message ) { try { if ( message instanceof ObjectMessage ) { ObjectMessage objectMessage = ( ObjectMessage ) message ; return objectMessage . getObject ( ) ; } else if ( message instanceof TextMessage ) { TextMessage textMessage = ( TextMessage ) message ; return textMessage . getText ( ) ; } else if ( message instanceof MapMessage ) { return createMapFromMapMessage ( ( MapMessage ) message ) ; } else if ( message instanceof BytesMessage || message instanceof StreamMessage ) { return message ; } else { return null ; } } catch ( JMSException e ) { throw new RuntimeJmsException ( "Failed to extract body due to: " + e + ". Message: " + message , e ) ; } } public Message makeJmsMessage ( Exchange exchange , Session session ) throws JMSException { Message answer = null ; if ( exchange instanceof JmsExchange ) { JmsExchange jmsExchange = ( JmsExchange ) exchange ; answer = jmsExchange . getIn ( ) . getJmsMessage ( ) ; } if ( answer == null ) { answer = createJmsMessage ( exchange . getIn ( ) . getBody ( ) , session ) ; appendJmsProperties ( answer , exchange ) ; } return answer ; } public void appendJmsProperties ( Message jmsMessage , Exchange exchange ) throws JMSException { org . apache . camel . Message in = exchange . getIn ( ) ; Set < Map . Entry < String , Object > > entries = in . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String headerName = entry . getKey ( ) ; Object headerValue = entry . getValue ( ) ; if ( headerName . startsWith ( "JMS" ) && ! headerName . startsWith ( "JMSX" ) ) { if ( headerName . equals ( "JMSCorrelationID" ) ) { jmsMessage . setJMSCorrelationID ( ExchangeHelper . convertToType ( exchange , String . class , headerValue ) ) ; } else if ( headerName . equals ( "JMSCorrelationID" ) ) { jmsMessage . setJMSCorrelationID ( ExchangeHelper . convertToType ( exchange , String . class , headerValue ) ) ; } else if ( headerName . equals ( "JMSReplyTo" ) ) { jmsMessage . setJMSReplyTo ( ExchangeHelper . convertToType ( exchange , Destination . class , headerValue ) ) ; } else if ( headerName . equals ( "JMSType" ) ) { jmsMessage . setJMSType ( ExchangeHelper . convertToType ( exchange , String . class , headerValue ) ) ; } else if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring JMS header: " + headerName + " with value: " + headerValue ) ; } } else if ( shouldOutputHeader ( in , headerName , headerValue ) ) { jmsMessage . setObjectProperty ( headerName , headerValue ) ; } } } protected Message createJmsMessage ( Object body , Session session ) throws JMSException { if ( body instanceof String ) { return session . createTextMessage ( ( String ) body ) ; } else if ( body instanceof Serializable ) { return session . createObjectMessage ( ( Serializable ) body ) ; } else { return session . createMessage ( ) ; } } public Map < String , Object > createMapFromMapMessage ( MapMessage message ) throws JMSException { Map < String , Object > answer = new HashMap < String , Object > ( ) ; Enumeration names = message . getPropertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = names . nextElement ( ) . toString ( ) ; Object value = message . getObject ( name ) ; answer . put ( name , value ) ; } return answer ; } protected boolean shouldOutputHeader ( org . apache . camel . Message camelMessage , String headerName , Object headerValue ) { return headerValue != null ; } } 	0	['8', '1', '0', '12', '47', '26', '6', '8', '5', '0.714285714', '258', '1', '1', '0', '0.301587302', '0', '0', '31.125', '6', '1.5', '0']
package org . apache . camel ; public interface AsyncCallback { void done ( boolean doneSynchronously ) ; } 	1	['1', '1', '0', '28', '1', '0', '28', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . quartz . JobExecutionContext ; public class QuartzExchange extends DefaultExchange { public QuartzExchange ( CamelContext context , ExchangePattern pattern , JobExecutionContext jobExecutionContext ) { super ( context , pattern ) ; setIn ( new QuartzMessage ( this , jobExecutionContext ) ) ; } @ Override public QuartzMessage getIn ( ) { return ( QuartzMessage ) super . getIn ( ) ; } public JobExecutionContext getJobExecutionContext ( ) { return getIn ( ) . getJobExecutionContext ( ) ; } } 	0	['4', '2', '0', '7', '8', '6', '2', '6', '4', '2', '27', '0', '0', '0.923076923', '0.4375', '1', '1', '5.75', '1', '0.75', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . builder . xml . XPathBuilder ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . language . NamespacePrefix ; import org . apache . camel . language . XPath ; import java . lang . annotation . Annotation ; public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory { @ Override public Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) { String xpath = getExpressionFromAnnotation ( annotation ) ; XPathBuilder builder = XPathBuilder . xpath ( xpath ) ; if ( annotation instanceof XPath ) { XPath xpathAnnotation = ( XPath ) annotation ; NamespacePrefix [ ] namespaces = xpathAnnotation . namespaces ( ) ; if ( namespaces != null ) { for ( NamespacePrefix namespacePrefix : namespaces ) { builder = builder . namespace ( namespacePrefix . prefix ( ) , namespacePrefix . uri ( ) ) ; } } } return builder ; } } 	1	['2', '2', '0', '7', '9', '1', '0', '7', '2', '2', '48', '0', '0', '0.666666667', '0.6', '1', '1', '23', '4', '2', '2']
package org . apache . camel . component . validator ; import java . io . IOException ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . processor . validation . ValidatingProcessor ; import org . springframework . core . io . Resource ; public class SpringValidator extends ValidatingProcessor { private Resource schemaResource ; public Resource getSchemaResource ( ) { return schemaResource ; } public void setSchemaResource ( Resource schemaResource ) { this . schemaResource = schemaResource ; } @ Override protected Source createSchemaSource ( ) throws IOException { if ( schemaResource != null ) { if ( schemaResource . getURL ( ) == null ) { return new StreamSource ( schemaResource . getInputStream ( ) ) ; } else { return new StreamSource ( schemaResource . getInputStream ( ) , schemaResource . getURL ( ) . toExternalForm ( ) ) ; } } else { throw new IllegalArgumentException ( "You must specify a schema, schemaFile, schemaResource, schemaSource or schemaUrl property" ) ; } } } 	0	['4', '2', '0', '3', '11', '0', '1', '2', '3', '0.333333333', '45', '1', '0', '0.857142857', '0.625', '1', '1', '10', '1', '0.75', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlID ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . adapters . CollapsedStringAdapter ; import javax . xml . bind . annotation . adapters . XmlJavaTypeAdapter ; @ XmlType ( name = "identifiedType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public abstract class IdentifiedType { @ XmlAttribute @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) @ XmlID private String id ; public String getId ( ) { return id ; } public void setId ( String value ) { this . id = value ; } } 	1	['3', '1', '4', '4', '4', '1', '4', '0', '3', '0.5', '14', '1', '0', '0', '0.666666667', '0', '0', '3.333333333', '1', '0.6667', '1']
package org . apache . camel . component . cxf . transport ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . CamelContext ; import org . apache . camel . Processor ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . AttributedURIType ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class CamelConduit extends AbstractConduit implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-conduit-base" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelConduit . class ) ; private final CamelTransportBase base ; private String targetCamelEndpointUri ; public CamelConduit ( CamelContext camelContext , Bus bus , EndpointInfo endpointInfo , EndpointReferenceType targetReference ) { super ( targetReference ) ; AttributedURIType address = targetReference . getAddress ( ) ; if ( address != null ) { this . targetCamelEndpointUri = address . getValue ( ) ; } base = new CamelTransportBase ( camelContext , bus , endpointInfo , false , BASE_BEAN_NAME_SUFFIX ) ; initConfig ( ) ; } public void prepare ( Message message ) throws IOException { getLogger ( ) . log ( Level . FINE , "CamelConduit send message" ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( message ) ) ; } public void close ( ) { getLogger ( ) . log ( Level . FINE , "CamelConduit closed " ) ; base . close ( ) ; } protected Logger getLogger ( ) { return LOG ; } public String getBeanName ( ) { EndpointInfo info = base . endpointInfo ; if ( info == null ) { return "default.camel-conduit" ; } return info . getName ( ) + ".camel-conduit" ; } private void initConfig ( ) { Configurer configurer = base . bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( this ) ; } } private class CamelOutputStream extends CachedOutputStream { private Message outMessage ; private boolean isOneWay ; public CamelOutputStream ( Message m ) { outMessage = m ; } protected void doFlush ( ) throws IOException { } protected void doClose ( ) throws IOException { isOneWay = outMessage . getExchange ( ) . isOneWay ( ) ; commitOutputMessage ( ) ; if ( ! isOneWay ) { handleResponse ( ) ; } } protected void onWrite ( ) throws IOException { } private void commitOutputMessage ( ) { base . template . send ( targetCamelEndpointUri , new Processor ( ) { public void process ( org . apache . camel . Exchange reply ) { Object request = null ; if ( isTextPayload ( ) ) { request = currentStream . toString ( ) ; } else { request = ( ( ByteArrayOutputStream ) currentStream ) . toByteArray ( ) ; } getLogger ( ) . log ( Level . FINE , "Conduit Request is :[" + request + "]" ) ; String replyTo = base . getReplyDestination ( ) ; base . marshal ( request , replyTo , reply ) ; base . setMessageProperties ( outMessage , reply ) ; String correlationID = null ; if ( ! isOneWay ) { String id = null ; if ( id != null ) { if ( correlationID != null ) { String error = "User cannot set CamelCorrelationID when " + "making a request/reply invocation using " + "a static replyTo Queue." ; } correlationID = id ; } } if ( correlationID != null ) { reply . getIn ( ) . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , correlationID ) ; } else { } getLogger ( ) . log ( Level . FINE , "template sending request: " , reply . getIn ( ) ) ; } } ) ; } private void handleResponse ( ) throws IOException { Object response = null ; Message inMessage = new MessageImpl ( ) ; outMessage . getExchange ( ) . setInMessage ( inMessage ) ; getLogger ( ) . log ( Level . FINE , "The Response Message is : [" + response + "]" ) ; byte [ ] bytes = null ; if ( response instanceof String ) { String requestString = ( String ) response ; bytes = requestString . getBytes ( ) ; } else { bytes = ( byte [ ] ) response ; } inMessage . setContent ( InputStream . class , new ByteArrayInputStream ( bytes ) ) ; getLogger ( ) . log ( Level . FINE , "incoming observer is " + incomingObserver ) ; incomingObserver . onMessage ( inMessage ) ; } } private boolean isTextPayload ( ) { return true ; } protected class DecoupledDestination implements Destination { protected MessageObserver decoupledMessageObserver ; private EndpointReferenceType address ; DecoupledDestination ( EndpointReferenceType ref , MessageObserver incomingObserver ) { address = ref ; decoupledMessageObserver = incomingObserver ; } public EndpointReferenceType getAddress ( ) { return address ; } public Conduit getBackChannel ( Message inMessage , Message partialResponse , EndpointReferenceType addr ) throws IOException { return null ; } public void shutdown ( ) { } public synchronized void setMessageObserver ( MessageObserver observer ) { decoupledMessageObserver = observer ; } public synchronized MessageObserver getMessageObserver ( ) { return decoupledMessageObserver ; } } } 	0	['13', '0', '0', '16', '29', '52', '4', '13', '4', '0.854166667', '120', '1', '1', '0', '0.202380952', '0', '0', '7.923076923', '2', '1', '0']
package org . apache . camel . model ; import java . util . Collection ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Aggregator ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; @ XmlRootElement ( name = "aggregator" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class AggregatorType extends ExpressionNode { @ XmlTransient private AggregationStrategy aggregationStrategy = new UseLatestAggregationStrategy ( ) ; private int batchSize ; private long batchTimeout ; public AggregatorType ( ) { } public AggregatorType ( Expression correlationExpression ) { super ( correlationExpression ) ; } public AggregatorType ( ExpressionType correlationExpression ) { super ( correlationExpression ) ; } public AggregatorType ( Expression correlationExpression , AggregationStrategy aggregationStrategy ) { super ( correlationExpression ) ; this . aggregationStrategy = aggregationStrategy ; } @ Override public String toString ( ) { return "Aggregator[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Endpoint from = routeContext . getEndpoint ( ) ; final Processor processor = routeContext . createProcessor ( this ) ; final Aggregator service = new Aggregator ( from , processor , getExpression ( ) . createExpression ( routeContext ) , aggregationStrategy ) ; if ( batchSize != 0 ) { service . setBatchSize ( batchSize ) ; } if ( batchSize != 0 ) { service . setBatchTimeout ( batchTimeout ) ; } Route route = new Route < Exchange > ( from , service ) { @ Override public String toString ( ) { return "AggregatorRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } } ; routes . add ( route ) ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } public AggregatorType batchSize ( int batchSize ) { setBatchSize ( batchSize ) ; return this ; } public AggregatorType batchTimeout ( long batchTimeout ) { setBatchTimeout ( batchTimeout ) ; return this ; } } 	1	['14', '3', '0', '13', '32', '37', '3', '12', '14', '0.692307692', '154', '1', '1', '0.910714286', '0.223214286', '0', '0', '9.785714286', '1', '0.7143', '5']
package org . apache . camel . component . xmpp ; import org . jivesoftware . smack . XMPPException ; public class RuntimeXmppException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeXmppException ( XMPPException cause ) { super ( cause ) ; } public RuntimeXmppException ( String message , XMPPException cause ) { super ( message , cause ) ; } } 	0	['2', '4', '0', '3', '4', '1', '2', '1', '2', '2', '12', '1', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . camel . component . log ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LogComponent extends DefaultComponent < Exchange > { private static final Log LOG = LogFactory . getLog ( LogComponent . class ) ; protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { LoggingLevel level = getLoggingLevel ( parameters ) ; Logger logger = new Logger ( remaining , level ) ; return new ProcessorEndpoint ( uri , this , logger ) ; } protected LoggingLevel getLoggingLevel ( Map parameters ) { String levelText = ( String ) parameters . get ( "level" ) ; LoggingLevel level = null ; if ( levelText != null ) { level = LoggingLevel . valueOf ( levelText . toUpperCase ( ) ) ; if ( level == null ) { LOG . warn ( "Could not convert level text: " + levelText + " to a valid logging level so defaulting to WARN" ) ; } } if ( level == null ) { level = LoggingLevel . INFO ; } return level ; } } 	1	['4', '3', '0', '9', '15', '4', '0', '9', '1', '0.333333333', '62', '1', '1', '0.92', '0.666666667', '1', '1', '14.25', '4', '1.25', '2']
package org . apache . camel . spring . remoting ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . util . CamelContextHelper ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . remoting . support . RemoteExporter ; import static org . apache . camel . util . ObjectHelper . notNull ; public class CamelServiceExporter extends RemoteExporter implements InitializingBean , DisposableBean , ApplicationContextAware , CamelContextAware { private String uri ; private CamelContext camelContext ; private Consumer consumer ; private String serviceRef ; private ApplicationContext applicationContext ; public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getServiceRef ( ) { return serviceRef ; } public void setServiceRef ( String serviceRef ) { this . serviceRef = serviceRef ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public void afterPropertiesSet ( ) throws Exception { notNull ( uri , "uri" ) ; notNull ( camelContext , "camelContext" ) ; if ( serviceRef != null && getService ( ) == null && applicationContext != null ) { setService ( applicationContext . getBean ( serviceRef ) ) ; } Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( camelContext , uri ) ; Object proxy = getProxyForService ( ) ; consumer = endpoint . createConsumer ( new BeanProcessor ( proxy , camelContext ) ) ; consumer . start ( ) ; } public void destroy ( ) throws Exception { if ( consumer != null ) { consumer . stop ( ) ; } } } 	0	['11', '2', '0', '14', '22', '29', '0', '14', '11', '0.82', '101', '1', '2', '0.523809524', '0.340909091', '0', '0', '7.727272727', '1', '0.9091', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Splitter ; @ XmlRootElement ( name = "splitter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SplitterType extends ExpressionNode { public SplitterType ( ) { } public SplitterType ( Expression expression ) { super ( expression ) ; } public SplitterType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "Splitter[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new Splitter ( getExpression ( ) . createExpression ( routeContext ) , childProcessor ) ; } } 	1	['5', '3', '0', '8', '17', '10', '2', '7', '5', '2', '46', '0', '0', '0.980769231', '0.4', '1', '2', '8.2', '1', '0.4', '3']
package org . apache . camel . component . jms ; import java . io . ByteArrayOutputStream ; import java . io . DataOutputStream ; import java . io . ObjectOutputStream ; import java . nio . ByteBuffer ; import java . util . Enumeration ; import javax . jms . BytesMessage ; import javax . jms . MapMessage ; import javax . jms . Message ; import javax . jms . MessageEOFException ; import javax . jms . ObjectMessage ; import javax . jms . StreamMessage ; import javax . jms . TextMessage ; import org . apache . camel . Converter ; import org . apache . camel . converter . NIOConverter ; @ Converter public final class JmsIOConverter { private JmsIOConverter ( ) { } @ Converter public static ByteBuffer toByteBuffer ( final Message message ) throws Exception { if ( message instanceof TextMessage ) { final String text = ( ( TextMessage ) message ) . getText ( ) ; return NIOConverter . toByteBuffer ( text ) ; } if ( message instanceof BytesMessage ) { final BytesMessage bmsg = ( BytesMessage ) message ; final int len = ( int ) bmsg . getBodyLength ( ) ; final byte [ ] data = new byte [ len ] ; bmsg . readBytes ( data , len ) ; return NIOConverter . toByteBuffer ( data ) ; } if ( message instanceof StreamMessage ) { final StreamMessage msg = ( StreamMessage ) message ; final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; final DataOutputStream dataOut = new DataOutputStream ( bytesOut ) ; try { while ( true ) { final Object obj = msg . readObject ( ) ; writeData ( dataOut , obj ) ; } } catch ( MessageEOFException e ) { } dataOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } if ( message instanceof MapMessage ) { final MapMessage msg = ( MapMessage ) message ; final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; final DataOutputStream dataOut = new DataOutputStream ( bytesOut ) ; for ( final Enumeration en = msg . getMapNames ( ) ; en . hasMoreElements ( ) ; ) { final Object obj = msg . getObject ( en . nextElement ( ) . toString ( ) ) ; writeData ( dataOut , obj ) ; } dataOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } if ( message instanceof ObjectMessage ) { ObjectMessage objMessage = ( ObjectMessage ) message ; Object object = objMessage . getObject ( ) ; ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOut = new ObjectOutputStream ( bytesOut ) ; objectOut . writeObject ( object ) ; objectOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } return null ; } private static void writeData ( DataOutputStream dataOut , Object data ) throws Exception { if ( data instanceof byte [ ] ) { dataOut . write ( ( byte [ ] ) data ) ; } else if ( data instanceof String ) { dataOut . writeUTF ( data . toString ( ) ) ; } else if ( data instanceof Double ) { dataOut . writeDouble ( ( ( Double ) data ) . doubleValue ( ) ) ; } else if ( data instanceof Float ) { dataOut . writeFloat ( ( ( Float ) data ) . floatValue ( ) ) ; } else if ( data instanceof Long ) { dataOut . writeLong ( ( ( Long ) data ) . longValue ( ) ) ; } else if ( data instanceof Integer ) { dataOut . writeInt ( ( ( Integer ) data ) . intValue ( ) ) ; } else if ( data instanceof Short ) { dataOut . writeShort ( ( ( Short ) data ) . shortValue ( ) ) ; } else if ( data instanceof Character ) { dataOut . writeChar ( ( ( Character ) data ) . charValue ( ) ) ; } else if ( data instanceof Byte ) { dataOut . writeByte ( ( ( Byte ) data ) . byteValue ( ) ) ; } else if ( data instanceof Boolean ) { dataOut . writeBoolean ( ( ( Boolean ) data ) . booleanValue ( ) ) ; } } } 	0	['3', '1', '0', '1', '41', '3', '0', '1', '1', '2', '221', '0', '0', '0', '0.333333333', '0', '0', '72.66666667', '1', '0.6667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . processor . UnmarshalProcessor ; import org . apache . camel . spi . DataFormat ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlRootElement ( name = "unmarshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class UnmarshalType extends OutputType { @ XmlAttribute ( required = false ) private String ref ; @ XmlElementRef private DataFormatType dataFormatType ; public UnmarshalType ( ) { } public UnmarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public UnmarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref:  " + ref + "]" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormatType type = getDataFormatType ( ) ; if ( type == null ) { notNull ( ref , "ref or dataFormatType" ) ; type = routeContext . lookup ( ref , DataFormatType . class ) ; } DataFormat dataFormat = type . getDataFormat ( routeContext ) ; return new UnmarshalProcessor ( dataFormat ) ; } } 	1	['9', '3', '0', '8', '18', '4', '1', '7', '9', '0.5', '92', '1', '1', '0.942307692', '0.388888889', '1', '2', '9', '2', '0.8889', '3']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class RandomLoadBalancer extends QueueLoadBalancer { protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; while ( true ) { int index = ( int ) Math . round ( Math . random ( ) * size ) ; if ( index < size ) { return processors . get ( index ) ; } } } } 	0	['2', '3', '0', '3', '7', '1', '0', '3', '1', '2', '24', '0', '0', '0.833333333', '0.666666667', '1', '1', '11', '1', '0.5', '0']
package org . apache . camel . component . file ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import java . io . File ; import java . util . Map ; public class FileComponent extends DefaultComponent < FileExchange > { public static final String HEADER_FILE_NAME = "org.apache.camel.file.name" ; public FileComponent ( ) { } public FileComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < FileExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { File file = new File ( remaining ) ; FileEndpoint result = new FileEndpoint ( file , uri , this ) ; setProperties ( result , parameters ) ; return result ; } } 	1	['3', '3', '0', '4', '8', '3', '1', '4', '2', '1.5', '29', '0', '0', '0.958333333', '0.5', '1', '2', '8.333333333', '1', '0.3333', '2']
package org . apache . camel . converter ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface HasAnnotation { Class value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jmx ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import javax . management . MBeanServer ; import java . util . Map ; public class JMXComponent extends DefaultComponent < JMXExchange > { private MBeanServer mbeanServer ; public JMXComponent ( ) { } public JMXComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < JMXExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { JMXEndpoint result = new JMXEndpoint ( remaining , this ) ; setProperties ( result , parameters ) ; result . setMbeanServer ( getMbeanServer ( ) ) ; return result ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	1	['5', '3', '0', '4', '10', '8', '1', '4', '4', '0.5', '36', '1', '0', '0.884615385', '0.36', '1', '2', '6', '1', '0.6', '1']
package org . apache . camel . processor ; import org . apache . camel . Processor ; public interface ErrorHandler extends Processor { } 	0	['0', '1', '0', '2', '0', '0', '1', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . impl . converter ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . TypeConverterAware ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultTypeConverter implements TypeConverter , TypeConverterRegistry { private static final transient Log LOG = LogFactory . getLog ( DefaultTypeConverter . class ) ; private Map < TypeMapping , TypeConverter > typeMappings = new HashMap < TypeMapping , TypeConverter > ( ) ; private Injector injector ; private List < TypeConverterLoader > typeConverterLoaders = new ArrayList < TypeConverterLoader > ( ) ; private List < TypeConverter > fallbackConverters = new ArrayList < TypeConverter > ( ) ; private boolean loaded ; public DefaultTypeConverter ( Injector injector ) { typeConverterLoaders . add ( new AnnotationTypeConverterLoader ( ) ) ; this . injector = injector ; addFallbackConverter ( new AsyncProcessorTypeConverter ( ) ) ; addFallbackConverter ( new PropertyEditorTypeConverter ( ) ) ; addFallbackConverter ( new ToStringTypeConverter ( ) ) ; addFallbackConverter ( new ArrayTypeConverter ( ) ) ; addFallbackConverter ( new EnumTypeConverter ( ) ) ; } public < T > T convertTo ( Class < T > toType , Object value ) { if ( toType . isInstance ( value ) ) { return toType . cast ( value ) ; } checkLoaded ( ) ; TypeConverter converter = getOrFindTypeConverter ( toType , value ) ; if ( converter != null ) { return converter . convertTo ( toType , value ) ; } for ( TypeConverter fallback : fallbackConverters ) { T rc = fallback . convertTo ( toType , value ) ; if ( rc != null ) { return rc ; } } if ( boolean . class . isAssignableFrom ( toType ) ) { return ( T ) Boolean . FALSE ; } if ( toType . isPrimitive ( ) ) { Class primitiveType = ObjectHelper . convertPrimitiveTypeToWrapperType ( toType ) ; if ( primitiveType != toType ) { return ( T ) convertTo ( primitiveType , value ) ; } } return null ; } public void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; synchronized ( typeMappings ) { TypeConverter converter = typeMappings . get ( key ) ; if ( converter != null ) { LOG . warn ( "Overriding type converter from: " + converter + " to: " + typeConverter ) ; } typeMappings . put ( key , typeConverter ) ; } } public void addFallbackConverter ( TypeConverter converter ) { fallbackConverters . add ( converter ) ; if ( converter instanceof TypeConverterAware ) { TypeConverterAware typeConverterAware = ( TypeConverterAware ) converter ; typeConverterAware . setTypeConverter ( this ) ; } } public TypeConverter getTypeConverter ( Class toType , Class fromType ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; synchronized ( typeMappings ) { return typeMappings . get ( key ) ; } } public Injector getInjector ( ) { return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } protected < T > TypeConverter getOrFindTypeConverter ( Class toType , Object value ) { Class fromType = null ; if ( value != null ) { fromType = value . getClass ( ) ; } TypeMapping key = new TypeMapping ( toType , fromType ) ; TypeConverter converter ; synchronized ( typeMappings ) { converter = typeMappings . get ( key ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromType , value ) ; if ( converter != null ) { typeMappings . put ( key , converter ) ; } } } return converter ; } protected TypeConverter findTypeConverter ( Class toType , Class fromType , Object value ) { if ( fromType != null ) { Class fromSuperClass = fromType . getSuperclass ( ) ; if ( fromSuperClass != null && ! fromSuperClass . equals ( Object . class ) ) { TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } for ( Class type : fromType . getInterfaces ( ) ) { TypeConverter converter = getTypeConverter ( toType , type ) ; if ( converter != null ) { return converter ; } } if ( fromType . isArray ( ) && ! fromType . getComponentType ( ) . isPrimitive ( ) ) { if ( ! fromType . equals ( Object [ ] . class ) ) { fromSuperClass = Object [ ] . class ; TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } } if ( ! fromType . equals ( Object . class ) ) { TypeConverter converter = getTypeConverter ( toType , Object . class ) ; if ( converter != null ) { return converter ; } } } if ( fromType != null ) { Set < Map . Entry < TypeMapping , TypeConverter > > entries = typeMappings . entrySet ( ) ; for ( Map . Entry < TypeMapping , TypeConverter > entry : entries ) { TypeMapping key = entry . getKey ( ) ; Class aToType = key . getToType ( ) ; if ( toType . isAssignableFrom ( aToType ) ) { if ( fromType . isAssignableFrom ( key . getFromType ( ) ) ) { return entry . getValue ( ) ; } } } } return null ; } protected synchronized void checkLoaded ( ) { if ( ! loaded ) { loaded = true ; try { for ( TypeConverterLoader typeConverterLoader : typeConverterLoaders ) { typeConverterLoader . load ( this ) ; } try { loadFallbackTypeConverters ( ) ; } catch ( NoFactoryAvailableException e ) { } } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } protected void loadFallbackTypeConverters ( ) throws IOException , ClassNotFoundException { FactoryFinder finder = new FactoryFinder ( ) ; List < TypeConverter > converters = finder . newInstances ( "FallbackTypeConverter" , getInjector ( ) , TypeConverter . class ) ; for ( TypeConverter converter : converters ) { addFallbackConverter ( converter ) ; } } protected static class TypeMapping { Class toType ; Class fromType ; public TypeMapping ( Class toType , Class fromType ) { this . toType = toType ; this . fromType = fromType ; } public Class getFromType ( ) { return fromType ; } public Class getToType ( ) { return toType ; } @ Override public boolean equals ( Object object ) { if ( object instanceof TypeMapping ) { TypeMapping that = ( TypeMapping ) object ; return ObjectHelper . equals ( this . fromType , that . fromType ) && ObjectHelper . equals ( this . toType , that . toType ) ; } return false ; } @ Override public int hashCode ( ) { int answer = toType . hashCode ( ) ; if ( fromType != null ) { answer *= 37 + fromType . hashCode ( ) ; } return answer ; } @ Override public String toString ( ) { return "[" + fromType + "=>" + toType + "]" ; } } } 	1	['12', '1', '0', '19', '57', '30', '1', '18', '7', '0.772727273', '479', '1', '2', '0', '0.418181818', '0', '0', '38.41666667', '17', '3.25', '3']
package org . apache . camel . component . cxf . invoker ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . SortedSet ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . component . cxf . interceptors . RawMessageContentRedirectInterceptor ; import org . apache . camel . component . cxf . interceptors . RawMessageInInterceptor ; import org . apache . camel . component . cxf . phase . RawMessagePhaseManagerImpl ; import org . apache . cxf . Bus ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . helpers . IOUtils ; import org . apache . cxf . interceptor . Interceptor ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . phase . PhaseInterceptorChain ; import org . apache . cxf . phase . PhaseManager ; public class RawMessageInvokingContext extends AbstractInvokingContext { private static final Logger LOG = Logger . getLogger ( RawMessageInvokingContext . class . getName ( ) ) ; private PhaseManager phaseManager ; public RawMessageInvokingContext ( ) { phaseManager = new RawMessagePhaseManagerImpl ( ) ; } public PhaseInterceptorChain getRequestOutInterceptorChain ( Exchange exchange ) { return getOutInterceptorChain ( exchange ) ; } public PhaseInterceptorChain getResponseOutInterceptorChain ( Exchange exchange ) { return getOutInterceptorChain ( exchange ) ; } private PhaseInterceptorChain getOutInterceptorChain ( Exchange exchange ) { PhaseInterceptorChain chain = new PhaseInterceptorChain ( new RawMessagePhaseManagerImpl ( ) . getOutPhases ( ) ) ; Bus bus = exchange . get ( Bus . class ) ; assert bus != null ; List < Interceptor > list = bus . getOutInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by bus: " + list ) ; } chain . add ( list ) ; Endpoint endpoint = exchange . get ( Endpoint . class ) ; if ( endpoint != null ) { list = endpoint . getOutInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by endpoint: " + list ) ; } chain . add ( list ) ; } if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "inject " + RawMessageContentRedirectInterceptor . class ) ; } chain . add ( new RawMessageContentRedirectInterceptor ( ) ) ; return chain ; } public void setRequestOutMessageContent ( Message message , Object content ) { message . setContent ( InputStream . class , content ) ; } @ Override protected SortedSet < Phase > getInPhases ( ) { return phaseManager . getInPhases ( ) ; } @ Override protected List < Interceptor > getRoutingInterceptors ( ) { List < Interceptor > list = new ArrayList < Interceptor > ( ) ; list . add ( new RawMessageInInterceptor ( ) ) ; return list ; } public Object getResponseObject ( Exchange exchange , Map < String , Object > responseContext ) { return getResponseObject ( exchange . getInMessage ( ) , responseContext , InputStream . class ) ; } protected PhaseInterceptorChain getInInterceptorChain ( Exchange exchange , boolean isResponse ) { Bus bus = exchange . get ( Bus . class ) ; assert bus != null ; PhaseInterceptorChain chain = new PhaseInterceptorChain ( getInPhases ( ) ) ; if ( ! isResponse ) { List < Interceptor > routingInterceptors = getRoutingInterceptors ( ) ; chain . add ( routingInterceptors ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Injected " + routingInterceptors ) ; } } List < Interceptor > list = bus . getInInterceptors ( ) ; LOG . fine ( "Interceptors contributed by bus: " + list ) ; chain . add ( list ) ; Endpoint ep = exchange . get ( Endpoint . class ) ; if ( ep != null ) { list = ep . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by endpoint: " + list ) ; } chain . add ( list ) ; } return chain ; } public void setResponseContent ( Message outMessage , Object resultPayload ) { LOG . info ( "Set content: " + resultPayload ) ; outMessage . setContent ( InputStream . class , resultPayload ) ; } public Object getRequestContent ( Message inMessage ) { return inMessage . getContent ( InputStream . class ) ; } private void loggerTheMessage ( Message message , String messageTile ) { StringBuffer buffer = new StringBuffer ( messageTile + "\n" + "--------------------------------------" ) ; InputStream is = message . getContent ( InputStream . class ) ; if ( is != null ) { CachedOutputStream bos = new CachedOutputStream ( ) ; try { IOUtils . copy ( is , bos ) ; is . close ( ) ; bos . close ( ) ; buffer . append ( "\nMessage:\n" ) ; buffer . append ( bos . getOut ( ) . toString ( ) ) ; message . setContent ( InputStream . class , bos . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } buffer . append ( "\n--------------------------------------" ) ; LOG . info ( buffer . toString ( ) ) ; } } 	0	['13', '2', '0', '14', '55', '56', '1', '13', '7', '0.666666667', '327', '0.666666667', '0', '0.388888889', '0.30952381', '1', '3', '23.92307692', '7', '1.8462', '0']
package org . apache . camel ; public class RuntimeExchangeException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final Exchange exchange ; public RuntimeExchangeException ( String message , Exchange exchange ) { super ( message + " on the exchange: " + exchange ) ; this . exchange = exchange ; } public RuntimeExchangeException ( Exception e , Exchange exchange ) { super ( e . getMessage ( ) , e ) ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } } 	1	['3', '5', '0', '3', '10', '0', '1', '2', '3', '0.75', '33', '1', '1', '0.944444444', '0.583333333', '0', '0', '9.333333333', '1', '0.3333', '1']
package org . apache . camel . component . cxf ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import java . util . Map ; public class CxfComponent extends DefaultComponent < CxfExchange > { public CxfComponent ( ) { } public CxfComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < CxfExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { CxfEndpoint result = new CxfEndpoint ( uri , remaining , this ) ; setProperties ( result , parameters ) ; return result ; } } 	0	['3', '3', '0', '4', '7', '3', '1', '4', '2', '2', '23', '0', '0', '0.958333333', '0.5', '1', '2', '6.666666667', '1', '0.3333', '0']
package org . apache . camel ; public class InvalidTypeException extends CamelExchangeException { private final Object value ; private final Class < ? > type ; public InvalidTypeException ( Exchange exchange , Object value , Class < ? > type ) { super ( "Could not convert value: " + value + " to type: " + type . getName ( ) + NoSuchPropertyException . valueDescription ( value ) , exchange ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class < ? > getType ( ) { return type ; } } 	1	['3', '5', '0', '4', '10', '0', '1', '3', '3', '0.5', '37', '1', '0', '0.9', '0.5', '0', '0', '10.66666667', '1', '0.6667', '1']
package org . apache . camel . component . validator ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; import java . util . Map ; public class ValidatorComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { SpringValidator validator = new SpringValidator ( ) ; Resource resource = resolveMandatoryResource ( remaining ) ; validator . setSchemaResource ( resource ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( this + " using schema resource: " + resource ) ; } configureValidator ( validator , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , validator ) ; } protected void configureValidator ( SpringValidator validator , String uri , String remaining , Map parameters ) throws Exception { setProperties ( validator , parameters ) ; } } 	0	['3', '4', '0', '8', '15', '3', '0', '8', '1', '2', '50', '0', '0', '0.928571429', '0.666666667', '2', '2', '15.66666667', '1', '0.6667', '0']
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . nio . ByteBuffer ; import java . nio . CharBuffer ; import java . nio . charset . CharacterCodingException ; import java . util . BitSet ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class UnsafeUriCharactersEncoder { private static final transient Log LOG = LogFactory . getLog ( UnsafeUriCharactersEncoder . class ) ; static BitSet unsafeCharacters ; static { unsafeCharacters = new BitSet ( 256 ) ; unsafeCharacters . set ( ' ' ) ; unsafeCharacters . set ( '"' ) ; unsafeCharacters . set ( '<' ) ; unsafeCharacters . set ( '>' ) ; unsafeCharacters . set ( '#' ) ; unsafeCharacters . set ( '%' ) ; unsafeCharacters . set ( '{' ) ; unsafeCharacters . set ( '}' ) ; unsafeCharacters . set ( '|' ) ; unsafeCharacters . set ( '\\' ) ; unsafeCharacters . set ( '^' ) ; unsafeCharacters . set ( '~' ) ; unsafeCharacters . set ( '[' ) ; unsafeCharacters . set ( ']' ) ; unsafeCharacters . set ( '`' ) ; } private UnsafeUriCharactersEncoder ( ) { } public static String encode ( String s ) { int n = s . length ( ) ; if ( n == 0 ) return s ; try { byte [ ] bytes = s . getBytes ( "UTF8" ) ; for ( int i = 0 ; ; ) { if ( unsafeCharacters . get ( bytes [ i ] ) ) break ; if ( ++ i >= bytes . length ) return s ; } StringBuffer sb = new StringBuffer ( ) ; for ( byte b : bytes ) { if ( unsafeCharacters . get ( b ) ) { appendEscape ( sb , ( byte ) b ) ; } else sb . append ( ( char ) b ) ; } return sb . toString ( ) ; } catch ( UnsupportedEncodingException e ) { LOG . error ( "Can't encoding the uri: " , e ) ; return null ; } } private static void appendEscape ( StringBuffer sb , byte b ) { sb . append ( '%' ) ; sb . append ( hexDigits [ ( b > > 4 ) & 0x0f ] ) ; sb . append ( hexDigits [ ( b > > 0 ) & 0x0f ] ) ; } private final static char [ ] hexDigits = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; } 	1	['4', '1', '0', '3', '15', '2', '1', '2', '1', '0.555555556', '226', '0.666666667', '1', '0', '0.333333333', '0', '0', '54.75', '6', '1.75', '1']
package org . apache . camel . builder . xml ; import java . io . ByteArrayOutputStream ; import javax . xml . transform . Result ; import javax . xml . transform . stream . StreamResult ; import org . apache . camel . Message ; public class StreamResultHandler implements ResultHandler { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; StreamResult result = new StreamResult ( buffer ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( buffer . toByteArray ( ) ) ; } } 	0	['3', '1', '0', '3', '8', '0', '1', '2', '3', '0.5', '29', '0', '0', '0', '0.666666667', '0', '0', '8', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Route ; import org . apache . camel . Predicate ; import org . apache . camel . processor . DelegateProcessor ; @ XmlRootElement ( name = "routes" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RoutesType implements RouteContainer { @ XmlAttribute private Boolean inheritErrorHandlerFlag = Boolean . TRUE ; @ XmlElementRef private List < RouteType > routes = new ArrayList < RouteType > ( ) ; @ XmlElementRef private List < ServiceActivationType > activations = new ArrayList < ServiceActivationType > ( ) ; @ XmlTransient private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlTransient private List < InterceptType > intercepts = new ArrayList < InterceptType > ( ) ; @ XmlTransient private List < ExceptionType > exceptions = new ArrayList < ExceptionType > ( ) ; @ XmlTransient private CamelContext camelContext ; @ Override public String toString ( ) { return "Routes: " + routes ; } public void populateRoutes ( List < Route > answer ) throws Exception { for ( RouteType route : routes ) { route . addRoutes ( camelContext , answer ) ; } } public List < RouteType > getRoutes ( ) { return routes ; } public void setRoutes ( List < RouteType > routes ) { this . routes = routes ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < InterceptType > getIntercepts ( ) { return intercepts ; } public void setIntercepts ( List < InterceptType > intercepts ) { this . intercepts = intercepts ; } public List < ExceptionType > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < ExceptionType > exceptions ) { this . exceptions = exceptions ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } public RouteType route ( ) { RouteType route = createRoute ( ) ; return route ( route ) ; } public RouteType from ( String uri ) { RouteType route = createRoute ( ) ; route . from ( uri ) ; return route ( route ) ; } public RouteType from ( Endpoint endpoint ) { RouteType route = createRoute ( ) ; route . from ( endpoint ) ; return route ( route ) ; } public RouteType route ( RouteType route ) { route . setCamelContext ( getCamelContext ( ) ) ; route . setInheritErrorHandlerFlag ( getInheritErrorHandlerFlag ( ) ) ; route . getInterceptors ( ) . addAll ( getInterceptors ( ) ) ; route . getOutputs ( ) . addAll ( getIntercepts ( ) ) ; route . getOutputs ( ) . addAll ( getExceptions ( ) ) ; getRoutes ( ) . add ( route ) ; return route ; } public RoutesType intercept ( DelegateProcessor interceptor ) { getInterceptors ( ) . add ( new InterceptorRef ( interceptor ) ) ; return this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer ; } public OtherwiseType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer . when ( predicate ) ; } public ExceptionType exception ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; getExceptions ( ) . add ( answer ) ; return answer ; } protected RouteType createRoute ( ) { return new RouteType ( ) ; } } 	1	['24', '1', '0', '11', '47', '226', '1', '10', '23', '0.850931677', '244', '1', '1', '0', '0.154166667', '0', '0', '8.875', '1', '0.9583', '5']
package org . apache . camel . component . file . strategy ; import java . io . File ; public interface FileRenamer { File renameFile ( File file ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . ErrorHandlerSupport ; import java . util . ArrayList ; import java . util . List ; public abstract class ErrorHandlerBuilderSupport implements ErrorHandlerBuilder { private List < ExceptionType > exceptions = new ArrayList < ExceptionType > ( ) ; public void addErrorHandlers ( ExceptionType exception ) { exceptions . add ( exception ) ; } protected void configure ( ErrorHandlerSupport handler ) { for ( ExceptionType exception : exceptions ) { handler . addExceptionPolicy ( exception ) ; } } } 	1	['3', '1', '3', '6', '10', '0', '3', '3', '2', '0', '34', '1', '0', '0', '0.555555556', '0', '0', '10', '2', '1', '1']
package org . apache . camel . processor ; import java . io . InputStream ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Message ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class UnmarshalProcessor implements Processor { private final DataFormat dataFormat ; public UnmarshalProcessor ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } public void process ( Exchange exchange ) throws Exception { InputStream stream = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; Message out = exchange . getOut ( true ) ; out . copyFrom ( exchange . getIn ( ) ) ; Object result = dataFormat . unmarshal ( exchange , stream ) ; out . setBody ( result ) ; } } 	0	['2', '1', '0', '6', '9', '0', '1', '5', '2', '0', '32', '1', '1', '0', '0.666666667', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . camel . component . jmx ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import javax . management . Notification ; public class JMXExchange extends DefaultExchange { public JMXExchange ( CamelContext camelContext , ExchangePattern pattern , Notification notification ) { super ( camelContext , pattern ) ; setIn ( new JMXMessage ( notification ) ) ; } } 	1	['1', '2', '0', '7', '4', '0', '3', '5', '1', '2', '12', '0', '0', '1', '1', '0', '0', '11', '0', '0', '1']
package org . apache . camel . component . cxf . invoker ; import java . util . List ; import java . util . Map ; import java . util . SortedSet ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . cxf . Bus ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . endpoint . EndpointImpl ; import org . apache . cxf . interceptor . Interceptor ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . phase . PhaseInterceptorChain ; public abstract class AbstractInvokingContext implements InvokingContext { private static final Logger LOG = Logger . getLogger ( AbstractInvokingContext . class . getName ( ) ) ; public PhaseInterceptorChain getRequestInInterceptorChain ( Exchange exchange ) { return getInInterceptorChain ( exchange , false ) ; } protected PhaseInterceptorChain getInInterceptorChain ( Exchange exchange , boolean isResponse ) { Bus bus = exchange . get ( Bus . class ) ; assert bus != null ; PhaseInterceptorChain chain = new PhaseInterceptorChain ( getInPhases ( ) ) ; if ( ! isResponse ) { List < Interceptor > routingInterceptors = getRoutingInterceptors ( ) ; chain . add ( routingInterceptors ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Injected " + routingInterceptors ) ; } } List < Interceptor > list = bus . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by bus: " + list ) ; } chain . add ( list ) ; Endpoint ep = exchange . get ( Endpoint . class ) ; if ( ep != null ) { list = ep . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by endpoint: " + list ) ; } chain . add ( list ) ; list = ep . getBinding ( ) . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by binding: " + list ) ; } chain . add ( list ) ; list = ep . getService ( ) . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by service: " + list ) ; } chain . add ( list ) ; } return chain ; } protected abstract List < Interceptor > getRoutingInterceptors ( ) ; protected abstract SortedSet < Phase > getInPhases ( ) ; public PhaseInterceptorChain getResponseInInterceptorChain ( Exchange exchange ) { return getInInterceptorChain ( exchange , true ) ; } protected < T > T getResponseObject ( Message inMessage , Map < String , Object > responseContext , Class < T > clazz ) { T retval = null ; if ( inMessage != null ) { if ( null != responseContext ) { responseContext . putAll ( inMessage ) ; LOG . info ( "set responseContext to be" + responseContext ) ; } retval = inMessage . getContent ( clazz ) ; } return retval ; } public void setEndpointFaultObservers ( EndpointImpl endpointImpl , Bus bus ) { } } 	0	['9', '1', '2', '11', '32', '30', '2', '9', '4', '0.5625', '195', '0.5', '0', '0', '0.265625', '0', '0', '20.44444444', '10', '2', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . spi . Policy ; @ XmlRootElement ( name = "policy" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class PolicyRef extends OutputType { @ XmlAttribute ( required = true ) private String ref ; @ XmlTransient private Policy policy ; public PolicyRef ( ) { } public PolicyRef ( Policy policy ) { this . policy = policy ; } @ Override public String toString ( ) { return "Policy[" + description ( ) + "]" ; } @ Override public String getLabel ( ) { if ( ref != null ) { return "ref:  " + ref ; } else if ( policy != null ) { return policy . toString ( ) ; } else { return "" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = createOutputsProcessor ( routeContext ) ; Policy policy = resolvePolicy ( routeContext ) ; if ( policy == null ) { throw new IllegalArgumentException ( "No policy configured: " + this ) ; } return policy . wrap ( childProcessor ) ; } protected Policy resolvePolicy ( RouteContext routeContext ) { if ( policy == null ) { policy = routeContext . lookup ( getRef ( ) , Policy . class ) ; } return policy ; } protected String description ( ) { if ( policy != null ) { return policy . toString ( ) ; } else { return "ref:  " + ref ; } } } 	1	['9', '3', '0', '5', '19', '14', '1', '4', '7', '0.375', '118', '1', '1', '0.933333333', '0.361111111', '1', '2', '11.88888889', '3', '1.2222', '2']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Property { String name ( ) ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class CollectionHelper { private CollectionHelper ( ) { } public static void appendValue ( Map map , Object key , Object value ) { Object oldValue = map . get ( key ) ; if ( oldValue != null ) { List list ; if ( oldValue instanceof List ) { list = ( List ) oldValue ; } else { list = new ArrayList ( ) ; list . add ( oldValue ) ; } list . add ( value ) ; } else { map . put ( key , value ) ; } } } 	1	['2', '1', '0', '1', '7', '1', '1', '0', '1', '2', '37', '0', '0', '0', '0.5', '0', '0', '17.5', '3', '1.5', '1']
package org . apache . camel . util ; import java . util . Collection ; import org . apache . camel . Service ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ServiceHelper { private static final transient Log LOG = LogFactory . getLog ( ServiceHelper . class ) ; private ServiceHelper ( ) { } public static void startService ( Object value ) throws Exception { if ( value instanceof Service ) { Service service = ( Service ) value ; service . start ( ) ; } else if ( value instanceof Collection ) { startServices ( ( Collection ) value ) ; } } public static void startServices ( Object ... services ) throws Exception { for ( Object value : services ) { startService ( value ) ; } } public static void startServices ( Collection services ) throws Exception { for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; service . start ( ) ; } } } public static void stopServices ( Object ... services ) throws Exception { Exception firstException = null ; for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; try { service . stop ( ) ; } catch ( Exception e ) { LOG . debug ( "Caught exception shutting down: " + e , e ) ; if ( firstException == null ) { firstException = e ; } } } } if ( firstException != null ) { throw firstException ; } } public static void stopService ( Object value ) throws Exception { if ( value instanceof Service ) { Service service = ( Service ) value ; service . stop ( ) ; } else if ( value instanceof Collection ) { stopServices ( ( Collection ) value ) ; } } public static void stopServices ( Collection services ) throws Exception { Exception firstException = null ; for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; try { service . stop ( ) ; } catch ( Exception e ) { LOG . debug ( "Caught exception shutting down: " + e , e ) ; if ( firstException == null ) { firstException = e ; } } } } if ( firstException != null ) { throw firstException ; } } } 	0	['8', '1', '0', '24', '20', '22', '21', '3', '6', '0.571428571', '176', '1', '1', '0', '0.25', '0', '0', '20.875', '1', '0.75', '0']
package org . apache . camel . model ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . DelegateProcessor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; @ XmlRootElement ( name = "interceptor" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InterceptorRef extends InterceptorType { @ XmlAttribute ( required = true ) private String ref ; @ XmlTransient private DelegateProcessor interceptor ; public InterceptorRef ( ) { } public InterceptorRef ( String ref ) { setRef ( ref ) ; } public InterceptorRef ( DelegateProcessor interceptor ) { this . interceptor = interceptor ; } @ Override public String toString ( ) { return "Interceptor[" + getLabel ( ) + "]" ; } public DelegateProcessor createInterceptor ( RouteContext routeContext ) { if ( interceptor == null ) { interceptor = routeContext . lookup ( getRef ( ) , DelegateProcessor . class ) ; } if ( interceptor == null ) { throw new IllegalArgumentException ( "No DelegateProcessor bean available for reference: " + getRef ( ) ) ; } return interceptor ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getLabel ( ) { if ( ref != null ) { return "ref:  " + ref ; } else if ( interceptor != null ) { return interceptor . toString ( ) ; } else { return "" ; } } } 	1	['8', '2', '0', '5', '15', '16', '2', '3', '8', '0.428571429', '96', '1', '1', '0.166666667', '0.375', '0', '0', '10.75', '3', '1.125', '3']
package org . apache . camel . language . ognl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class OgnlLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return new OgnlExpression ( this , expression , Boolean . class ) ; } public Expression < Exchange > createExpression ( String expression ) { return new OgnlExpression ( this , expression , Object . class ) ; } } 	0	['3', '1', '0', '4', '5', '3', '1', '4', '3', '2', '20', '0', '0', '0', '0.833333333', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . camel ; public class AlreadyStoppedException extends CamelException { public AlreadyStoppedException ( ) { super ( "Already stopped" ) ; } } 	1	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . camel . component . mina ; import java . net . SocketAddress ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoServiceConfig ; import org . apache . mina . common . IoSession ; public class MinaEndpoint extends DefaultEndpoint < MinaExchange > { private final IoAcceptor acceptor ; private final SocketAddress address ; private final IoConnector connector ; private final IoServiceConfig config ; public MinaEndpoint ( String endpointUri , MinaComponent component , SocketAddress address , IoAcceptor acceptor , IoConnector connector , IoServiceConfig config ) { super ( endpointUri , component ) ; this . config = config ; this . address = address ; this . acceptor = acceptor ; this . connector = connector ; } public Producer < MinaExchange > createProducer ( ) throws Exception { return new MinaProducer ( this ) ; } public Consumer < MinaExchange > createConsumer ( Processor processor ) throws Exception { return new MinaConsumer ( this , processor ) ; } @ Override public MinaExchange createExchange ( ExchangePattern pattern ) { return new MinaExchange ( getContext ( ) , pattern ) ; } public MinaExchange createExchange ( IoSession session , Object object ) { MinaExchange exchange = new MinaExchange ( getContext ( ) , getExchangePattern ( ) ) ; exchange . getIn ( ) . setBody ( object ) ; return exchange ; } public IoAcceptor getAcceptor ( ) { return acceptor ; } public SocketAddress getAddress ( ) { return address ; } public IoConnector getConnector ( ) { return connector ; } public IoServiceConfig getConfig ( ) { return config ; } public boolean isSingleton ( ) { return true ; } } 	0	['11', '2', '0', '19', '18', '47', '5', '17', '11', '0.9', '82', '1', '0', '0.62962963', '0.181818182', '1', '1', '6.090909091', '1', '0.9091', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . * ; import java . net . URL ; @ Converter public class IOConverter { private static final transient Log LOG = LogFactory . getLog ( IOConverter . class ) ; private IOConverter ( ) { } @ Converter public static InputStream toInputStream ( URL url ) throws IOException { return url . openStream ( ) ; } @ Converter public static InputStream toInputStream ( File file ) throws FileNotFoundException { return new BufferedInputStream ( new FileInputStream ( file ) ) ; } @ Converter public static BufferedReader toReader ( File file ) throws FileNotFoundException { return new BufferedReader ( new FileReader ( file ) ) ; } @ Converter public static File toFile ( String name ) throws FileNotFoundException { return new File ( name ) ; } @ Converter public static OutputStream toOutputStream ( File file ) throws FileNotFoundException { return new BufferedOutputStream ( new FileOutputStream ( file ) ) ; } @ Converter public static BufferedWriter toWriter ( File file ) throws IOException { return new BufferedWriter ( new FileWriter ( file ) ) ; } @ Converter public static Reader toReader ( InputStream in ) throws FileNotFoundException { return new InputStreamReader ( in ) ; } @ Converter public static Writer toWriter ( OutputStream out ) throws FileNotFoundException { return new OutputStreamWriter ( out ) ; } @ Converter public static StringReader toReader ( String text ) { return new StringReader ( text ) ; } @ Converter public static InputStream toInputStream ( String text ) { return toInputStream ( text . getBytes ( ) ) ; } @ Converter public static byte [ ] toByteArray ( String text ) { return text . getBytes ( ) ; } @ Converter public static String toString ( byte [ ] data ) { return new String ( data ) ; } @ Converter public static String toString ( File file ) throws IOException { return toString ( toReader ( file ) ) ; } @ Converter public static String toString ( URL url ) throws IOException { return toString ( toInputStream ( url ) ) ; } @ Converter public static String toString ( Reader reader ) throws IOException { if ( reader instanceof BufferedReader ) { return toString ( ( BufferedReader ) reader ) ; } else { return toString ( new BufferedReader ( reader ) ) ; } } @ Converter public static String toString ( BufferedReader reader ) throws IOException { if ( reader == null ) { return null ; } try { CollectionStringBuffer builder = new CollectionStringBuffer ( "\n" ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { return builder . toString ( ) ; } builder . append ( line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close stream: " + e , e ) ; } } } @ Converter public static String toString ( InputStream in ) throws IOException { return toString ( toReader ( in ) ) ; } @ Converter public static InputStream toInputStream ( byte [ ] data ) { return new ByteArrayInputStream ( data ) ; } @ Converter public static ObjectOutput toObjectOutput ( OutputStream stream ) throws IOException { if ( stream instanceof ObjectOutput ) { return ( ObjectOutput ) stream ; } else { return new ObjectOutputStream ( stream ) ; } } @ Converter public static ObjectInput toObjectInput ( InputStream stream ) throws IOException { if ( stream instanceof ObjectInput ) { return ( ObjectInput ) stream ; } else { return new ObjectInputStream ( stream ) ; } } } 	1	['22', '1', '0', '6', '52', '229', '3', '3', '20', '0.80952381', '205', '1', '1', '0', '0.111111111', '0', '0', '8.272727273', '1', '0.9091', '1']
package org . apache . camel . bam . rules ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class ProcessRules extends ServiceSupport { private ProcessDefinition processDefinition ; private List < ActivityRules > activities = new ArrayList < ActivityRules > ( ) ; public void processExpired ( ActivityState activityState ) throws Exception { for ( ActivityRules activityRules : activities ) { activityRules . processExpired ( activityState ) ; } } public void processExchange ( Exchange exchange , ProcessInstance process ) { for ( ActivityRules activityRules : activities ) { activityRules . processExchange ( exchange , process ) ; } } public List < ActivityRules > getActivities ( ) { return activities ; } public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( activities ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( activities ) ; } } 	0	['8', '2', '0', '14', '17', '0', '8', '7', '6', '0.571428571', '69', '1', '1', '0.65', '0.3', '1', '1', '7.375', '2', '1', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . camel . Exchange ; public class BeanInvocation { private final Object proxy ; private final Method method ; private final Object [ ] args ; public BeanInvocation ( Object proxy , Method method , Object [ ] args ) { this . proxy = proxy ; this . method = method ; this . args = args ; } public Object [ ] getArgs ( ) { return args ; } public Method getMethod ( ) { return method ; } public Object getProxy ( ) { return proxy ; } public void invoke ( Object pojo , Exchange exchange ) { try { Object response = getMethod ( ) . invoke ( pojo , getArgs ( ) ) ; exchange . getOut ( ) . setBody ( response ) ; } catch ( InvocationTargetException e ) { exchange . setException ( e . getCause ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } } } 	1	['5', '1', '0', '7', '12', '4', '5', '2', '5', '0.583333333', '57', '1', '0', '0', '0.4', '0', '0', '9.8', '1', '0.8', '1']
package org . apache . camel . component . rmi ; import java . net . URI ; import java . net . URISyntaxException ; import java . rmi . RemoteException ; import java . rmi . registry . LocateRegistry ; import java . rmi . registry . Registry ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . ExchangePattern ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . impl . DefaultEndpoint ; public class RmiEndpoint extends DefaultEndpoint < BeanExchange > { private List < Class > remoteInterfaces ; private ClassLoader classLoader ; private URI uri ; private int port ; protected RmiEndpoint ( String endpointUri , RmiComponent component ) throws URISyntaxException { super ( endpointUri , component ) ; this . uri = new URI ( endpointUri ) ; } public boolean isSingleton ( ) { return false ; } @ Override public BeanExchange createExchange ( ExchangePattern pattern ) { return new BeanExchange ( getContext ( ) , pattern ) ; } public Consumer < BeanExchange > createConsumer ( Processor processor ) throws Exception { if ( remoteInterfaces == null || remoteInterfaces . size ( ) == 0 ) { throw new RuntimeCamelException ( "To create an RMI consumer, the RMI endpoint's remoteInterfaces property must be be configured." ) ; } return new RmiConsumer ( this , processor ) ; } public Producer < BeanExchange > createProducer ( ) throws Exception { return new RmiProducer ( this ) ; } public String getName ( ) { String path = uri . getPath ( ) ; if ( path == null ) { path = uri . getSchemeSpecificPart ( ) ; } return path ; } public Registry getRegistry ( ) throws RemoteException { if ( uri . getHost ( ) != null ) { if ( uri . getPort ( ) == - 1 ) { return LocateRegistry . getRegistry ( uri . getHost ( ) ) ; } else { return LocateRegistry . getRegistry ( uri . getHost ( ) , uri . getPort ( ) ) ; } } else { return LocateRegistry . getRegistry ( ) ; } } public List < Class > getRemoteInterfaces ( ) { return remoteInterfaces ; } public void setRemoteInterfaces ( List < Class > remoteInterfaces ) { this . remoteInterfaces = remoteInterfaces ; if ( classLoader == null && ! remoteInterfaces . isEmpty ( ) ) { classLoader = remoteInterfaces . get ( 0 ) . getClassLoader ( ) ; } } public void setRemoteInterfaces ( Class ... remoteInterfaces ) { setRemoteInterfaces ( Arrays . asList ( remoteInterfaces ) ) ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } } 	0	['15', '2', '0', '13', '33', '85', '3', '13', '14', '0.839285714', '141', '1', '0', '0.548387097', '0.177777778', '1', '1', '8.133333333', '3', '1.1333', '0']
package org . apache . camel ; public class NoSuchPropertyException extends CamelExchangeException { private static final long serialVersionUID = - 8721487431101572630L ; private final String propertyName ; private final Class < ? > type ; public NoSuchPropertyException ( Exchange exchange , String propertyName , Class < ? > type ) { super ( "No '" + propertyName + "' property available of type: " + type . getName ( ) + reason ( exchange , propertyName ) , exchange ) ; this . propertyName = propertyName ; this . type = type ; } public String getPropertyName ( ) { return propertyName ; } public Class < ? > getType ( ) { return type ; } protected static String reason ( Exchange exchange , String propertyName ) { Object value = exchange . getProperty ( propertyName ) ; return valueDescription ( value ) ; } static String valueDescription ( Object value ) { if ( value == null ) { return "" ; } return " but has value: " + value + " of type: " + value . getClass ( ) . getName ( ) ; } } 	1	['5', '5', '0', '5', '13', '6', '3', '2', '3', '0.916666667', '67', '1', '0', '0.818181818', '0.36', '0', '0', '11.8', '2', '1', '1']
package org . apache . camel . bam . model ; import java . util . Date ; import javax . persistence . Temporal ; import javax . persistence . TemporalType ; import javax . persistence . Transient ; public abstract class TemporalEntity extends EntitySupport { private Date timeStarted ; private Date timeCompleted ; @ Transient public boolean isStarted ( ) { return timeStarted != null ; } @ Transient public boolean isCompleted ( ) { return timeCompleted != null ; } @ Temporal ( TemporalType . TIME ) public Date getTimeStarted ( ) { return timeStarted ; } public void setTimeStarted ( Date timeStarted ) { this . timeStarted = timeStarted ; } @ Temporal ( TemporalType . TIME ) public Date getTimeCompleted ( ) { return timeCompleted ; } public void setTimeCompleted ( Date timeCompleted ) { this . timeCompleted = timeCompleted ; } } 	0	['7', '2', '1', '2', '8', '9', '1', '1', '7', '0.666666667', '40', '1', '0', '0.333333333', '0.642857143', '0', '0', '4.428571429', '2', '1.1429', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . impl . RouteContext ; @ XmlRootElement ( name = "serialization" ) public class SerializationDataFormat extends DataFormatType { @ Override protected DataFormat createDataFormat ( RouteContext routeContext ) { return new org . apache . camel . impl . SerializationDataFormat ( ) ; } } 	1	['2', '2', '0', '5', '4', '1', '1', '4', '1', '2', '9', '0', '0', '0.8', '0.75', '1', '1', '3.5', '1', '0.5', '1']
package org . apache . camel . spring . handler ; import org . w3c . dom . Element ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . xml . DomUtils ; public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser { private final String scriptEngineName ; public ScriptDefinitionParser ( String scriptEngineName ) { super ( "org.apache.camel.builder.script.ScriptBuilder" , "camel-script" ) ; this . scriptEngineName = scriptEngineName ; } @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String engine = scriptEngineName ; if ( engine == null ) { engine = element . getAttribute ( "language" ) ; } builder . addConstructorArg ( engine ) ; super . doParse ( element , parserContext , builder ) ; String scriptText = DomUtils . getTextValue ( element ) . trim ( ) ; if ( scriptText . length ( ) > 0 ) { builder . addPropertyValue ( "scriptText" , scriptText ) ; } } } 	0	['2', '6', '0', '5', '10', '0', '1', '4', '1', '0', '42', '1', '0', '0.954545455', '0.6', '1', '1', '19.5', '3', '1.5', '0']
package org . apache . camel . component . timer ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . ExchangePattern ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import java . util . Date ; import java . util . Timer ; public class TimerEndpoint extends DefaultEndpoint < Exchange > { private final TimerComponent component ; private final String timerName ; private Date time ; private long period = 1000 ; private long delay = 0 ; private boolean fixedRate ; private boolean daemon = true ; private Timer timer ; public TimerEndpoint ( String fullURI , TimerComponent component , String timerName ) { super ( fullURI , component ) ; this . component = component ; this . timerName = timerName ; } public Producer < Exchange > createProducer ( ) throws Exception { throw new RuntimeCamelException ( "Cannot produce to a TimerEndpoint: " + getEndpointUri ( ) ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new TimerConsumer ( this , processor ) ; } public TimerComponent getComponent ( ) { return component ; } public String getTimerName ( ) { return timerName ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public boolean isFixedRate ( ) { return fixedRate ; } public void setFixedRate ( boolean fixedRate ) { this . fixedRate = fixedRate ; } public long getPeriod ( ) { return period ; } public void setPeriod ( long period ) { this . period = period ; } public Date getTime ( ) { return time ; } public void setTime ( Date time ) { this . time = time ; } public boolean isSingleton ( ) { return true ; } public Timer getTimer ( ) { if ( timer == null ) { timer = component . getTimer ( this ) ; } return timer ; } } 	1	['18', '2', '0', '8', '25', '123', '2', '8', '18', '0.911764706', '123', '1', '1', '0.5', '0.206349206', '1', '1', '5.388888889', '2', '1', '1']
package org . apache . camel . component . ref ; import org . apache . camel . Exchange ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import java . util . Map ; public class RefComponent extends DefaultComponent < Exchange > { protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { String name = uri . substring ( 4 ) ; return getCamelContext ( ) . getRegistry ( ) . lookup ( name , Endpoint . class ) ; } } 	0	['2', '3', '0', '4', '7', '1', '0', '4', '1', '2', '17', '0', '0', '0.958333333', '0.666666667', '1', '1', '7.5', '1', '0.5', '0']
package org . apache . camel . converter . jaxp ; import org . apache . camel . Converter ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . converter . NIOConverter ; import org . apache . camel . util . ObjectHelper ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import java . lang . reflect . Constructor ; import java . nio . ByteBuffer ; @ Converter public class XmlConverter { public static final String DEFAULT_CHARSET_PROPERTY = "org.apache.camel.default.charset" ; public static String defaultCharset = ObjectHelper . getSystemProperty ( DEFAULT_CHARSET_PROPERTY , "UTF-8" ) ; private DocumentBuilderFactory documentBuilderFactory ; private TransformerFactory transformerFactory ; private static final Class dom2SaxClass ; static { Class cl = null ; try { cl = Class . forName ( "org.apache.xalan.xsltc.trax.DOM2SAX" ) ; } catch ( Throwable t ) { } dom2SaxClass = cl ; } public XmlConverter ( ) { } public XmlConverter ( DocumentBuilderFactory documentBuilderFactory ) { this . documentBuilderFactory = documentBuilderFactory ; } public void toResult ( Source source , Result result ) throws TransformerException { if ( source == null ) { return ; } Transformer transformer = createTransfomer ( ) ; if ( transformer == null ) { throw new TransformerException ( "Could not create a transformer - JAXP is misconfigured!" ) ; } transformer . setOutputProperty ( OutputKeys . ENCODING , defaultCharset ) ; transformer . setOutputProperty ( OutputKeys . OMIT_XML_DECLARATION , "yes" ) ; transformer . transform ( source , result ) ; } @ Converter public BytesSource toSource ( byte [ ] data ) { return new BytesSource ( data ) ; } @ Converter public StringSource toSource ( String data ) { return new StringSource ( data ) ; } @ Converter public DOMSource toSource ( Document document ) { return new DOMSource ( document ) ; } @ Converter public String toString ( Source source ) throws TransformerException { if ( source == null ) { return null ; } else if ( source instanceof StringSource ) { return ( ( StringSource ) source ) . getText ( ) ; } else if ( source instanceof BytesSource ) { return new String ( ( ( BytesSource ) source ) . getData ( ) ) ; } else { StringWriter buffer = new StringWriter ( ) ; toResult ( source , new StreamResult ( buffer ) ) ; return buffer . toString ( ) ; } } @ Converter public String toString ( NodeList nodeList ) throws TransformerException { StringWriter buffer = new StringWriter ( ) ; for ( int i = 0 , size = nodeList . getLength ( ) ; i < size ; i ++ ) { Node node = nodeList . item ( i ) ; Source source = new DOMSource ( node ) ; toResult ( source , new StreamResult ( buffer ) ) ; } return buffer . toString ( ) ; } @ Converter public String toString ( Node node ) throws TransformerException { return toString ( new DOMSource ( node ) ) ; } @ Converter public DOMSource toDOMSource ( Source source ) throws ParserConfigurationException , IOException , SAXException , TransformerException { if ( source instanceof DOMSource ) { return ( DOMSource ) source ; } else if ( source instanceof SAXSource ) { return toDOMSourceFromSAX ( ( SAXSource ) source ) ; } else if ( source instanceof StreamSource ) { return toDOMSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public DOMSource toDOMSource ( String text ) throws ParserConfigurationException , IOException , SAXException , TransformerException { Source source = toSource ( text ) ; if ( source != null ) { return toDOMSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public SAXSource toSAXSource ( String source ) throws IOException , SAXException , TransformerException { return toSAXSource ( toSource ( source ) ) ; } @ Converter public SAXSource toSAXSource ( InputStream source ) throws IOException , SAXException , TransformerException { return toSAXSource ( toStreamSource ( source ) ) ; } @ Converter public SAXSource toSAXSource ( Source source ) throws IOException , SAXException , TransformerException { if ( source instanceof SAXSource ) { return ( SAXSource ) source ; } else if ( source instanceof DOMSource ) { return toSAXSourceFromDOM ( ( DOMSource ) source ) ; } else if ( source instanceof StreamSource ) { return toSAXSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public StreamSource toStreamSource ( Source source ) throws TransformerException { if ( source instanceof StreamSource ) { return ( StreamSource ) source ; } else if ( source instanceof DOMSource ) { return toStreamSourceFromDOM ( ( DOMSource ) source ) ; } else if ( source instanceof SAXSource ) { return toStreamSourceFromSAX ( ( SAXSource ) source ) ; } else { return null ; } } @ Converter public StreamSource toStreamSource ( InputStream in ) throws TransformerException { if ( in != null ) { return new StreamSource ( in ) ; } return null ; } @ Converter public StreamSource toStreamSource ( Reader in ) throws TransformerException { if ( in != null ) { return new StreamSource ( in ) ; } return null ; } @ Converter public StreamSource toStreamSource ( File in ) throws TransformerException { if ( in != null ) { return new StreamSource ( in ) ; } return null ; } @ Converter public StreamSource toStreamSource ( byte [ ] in ) throws TransformerException { if ( in != null ) { return new StreamSource ( IOConverter . toInputStream ( in ) ) ; } return null ; } @ Converter public StreamSource toStreamSource ( ByteBuffer in ) throws TransformerException { if ( in != null ) { return new StreamSource ( NIOConverter . toInputStream ( in ) ) ; } return null ; } @ Converter public StreamSource toStreamSourceFromSAX ( SAXSource source ) throws TransformerException { InputSource inputSource = source . getInputSource ( ) ; if ( inputSource != null ) { if ( inputSource . getCharacterStream ( ) != null ) { return new StreamSource ( inputSource . getCharacterStream ( ) ) ; } if ( inputSource . getByteStream ( ) != null ) { return new StreamSource ( inputSource . getByteStream ( ) ) ; } } String result = toString ( source ) ; return new StringSource ( result ) ; } @ Converter public StreamSource toStreamSourceFromDOM ( DOMSource source ) throws TransformerException { String result = toString ( source ) ; return new StringSource ( result ) ; } @ Converter public SAXSource toSAXSourceFromStream ( StreamSource source ) { InputSource inputSource ; if ( source . getReader ( ) != null ) { inputSource = new InputSource ( source . getReader ( ) ) ; } else { inputSource = new InputSource ( source . getInputStream ( ) ) ; } inputSource . setSystemId ( source . getSystemId ( ) ) ; inputSource . setPublicId ( source . getPublicId ( ) ) ; return new SAXSource ( inputSource ) ; } @ Converter public Reader toReaderFromSource ( Source src ) throws TransformerException { StreamSource stSrc = toStreamSource ( src ) ; Reader r = stSrc . getReader ( ) ; if ( r == null ) { r = new InputStreamReader ( stSrc . getInputStream ( ) ) ; } return r ; } @ Converter public DOMSource toDOMSourceFromStream ( StreamSource source ) throws ParserConfigurationException , IOException , SAXException { DocumentBuilder builder = createDocumentBuilder ( ) ; String systemId = source . getSystemId ( ) ; Document document = null ; Reader reader = source . getReader ( ) ; if ( reader != null ) { document = builder . parse ( new InputSource ( reader ) ) ; } else { InputStream inputStream = source . getInputStream ( ) ; if ( inputStream != null ) { InputSource inputsource = new InputSource ( inputStream ) ; inputsource . setSystemId ( systemId ) ; document = builder . parse ( inputsource ) ; } else { throw new IOException ( "No input stream or reader available" ) ; } } return new DOMSource ( document , systemId ) ; } @ Converter public SAXSource toSAXSourceFromDOM ( DOMSource source ) throws TransformerException { if ( dom2SaxClass != null ) { try { Constructor cns = dom2SaxClass . getConstructor ( new Class [ ] { Node . class } ) ; XMLReader converter = ( XMLReader ) cns . newInstance ( new Object [ ] { source . getNode ( ) } ) ; return new SAXSource ( converter , new InputSource ( ) ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } else { String str = toString ( source ) ; StringReader reader = new StringReader ( str ) ; return new SAXSource ( new InputSource ( reader ) ) ; } } @ Converter public DOMSource toDOMSourceFromSAX ( SAXSource source ) throws IOException , SAXException , ParserConfigurationException , TransformerException { return new DOMSource ( toDOMNodeFromSAX ( source ) ) ; } @ Converter public Node toDOMNodeFromSAX ( SAXSource source ) throws ParserConfigurationException , IOException , SAXException , TransformerException { DOMResult result = new DOMResult ( ) ; toResult ( source , result ) ; return result . getNode ( ) ; } @ Converter public Node toDOMNode ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { DOMSource domSrc = toDOMSource ( source ) ; return domSrc != null ? domSrc . getNode ( ) : null ; } @ Converter public Element toDOMElement ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { Node node = toDOMNode ( source ) ; return toDOMElement ( node ) ; } @ Converter public Element toDOMElement ( Node node ) throws TransformerException { if ( node instanceof Document ) { return ( ( Document ) node ) . getDocumentElement ( ) ; } else if ( node instanceof Element ) { return ( Element ) node ; } else { throw new TransformerException ( "Unable to convert DOM node to an Element" ) ; } } @ Converter public Document toDOMDocument ( byte [ ] data ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( new ByteArrayInputStream ( data ) ) ; } @ Converter public Document toDOMDocument ( InputStream in ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( in ) ; } @ Converter public Document toDOMDocument ( InputSource in ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( in ) ; } @ Converter public Document toDOMDocument ( String text ) throws IOException , SAXException , ParserConfigurationException { return toDOMDocument ( text . getBytes ( ) ) ; } @ Converter public Document toDOMDocument ( File file ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( file ) ; } @ Converter public Document toDOMDocument ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { Node node = toDOMNode ( source ) ; return toDOMDocument ( node ) ; } @ Converter public Document toDOMDocument ( Node node ) throws ParserConfigurationException , TransformerException { if ( node instanceof Document ) { return ( Document ) node ; } else if ( node instanceof Element ) { Element elem = ( Element ) node ; if ( elem . getOwnerDocument ( ) . getDocumentElement ( ) == elem ) { return elem . getOwnerDocument ( ) ; } else { Document doc = createDocument ( ) ; doc . appendChild ( doc . importNode ( node , true ) ) ; return doc ; } } else { throw new TransformerException ( "Unable to convert DOM node to a Document" ) ; } } public DocumentBuilderFactory getDocumentBuilderFactory ( ) { if ( documentBuilderFactory == null ) { documentBuilderFactory = createDocumentBuilderFactory ( ) ; } return documentBuilderFactory ; } public void setDocumentBuilderFactory ( DocumentBuilderFactory documentBuilderFactory ) { this . documentBuilderFactory = documentBuilderFactory ; } public DocumentBuilderFactory createDocumentBuilderFactory ( ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; factory . setIgnoringElementContentWhitespace ( true ) ; factory . setIgnoringComments ( true ) ; return factory ; } public DocumentBuilder createDocumentBuilder ( ) throws ParserConfigurationException { DocumentBuilderFactory factory = getDocumentBuilderFactory ( ) ; return factory . newDocumentBuilder ( ) ; } public Document createDocument ( ) throws ParserConfigurationException { DocumentBuilder builder = createDocumentBuilder ( ) ; return builder . newDocument ( ) ; } public TransformerFactory getTransformerFactory ( ) { if ( transformerFactory == null ) { transformerFactory = createTransformerFactory ( ) ; } return transformerFactory ; } public void setTransformerFactory ( TransformerFactory transformerFactory ) { this . transformerFactory = transformerFactory ; } public Transformer createTransfomer ( ) throws TransformerConfigurationException { TransformerFactory factory = getTransformerFactory ( ) ; return factory . newTransformer ( ) ; } public TransformerFactory createTransformerFactory ( ) { TransformerFactory answer = TransformerFactory . newInstance ( ) ; return answer ; } } 	1	['48', '1', '0', '7', '111', '1116', '2', '5', '47', '0.914893617', '729', '0.6', '0', '0', '0.102836879', '0', '0', '14.08333333', '2', '1', '3']
package org . apache . camel . impl ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import java . util . concurrent . ScheduledExecutorService ; public class DefaultScheduledPollConsumer < E extends Exchange > extends ScheduledPollConsumer < E > { private PollingConsumer < E > pollingConsumer ; public DefaultScheduledPollConsumer ( DefaultEndpoint < E > defaultEndpoint , Processor processor ) { super ( defaultEndpoint , processor ) ; } public DefaultScheduledPollConsumer ( Endpoint < E > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; } protected void poll ( ) throws Exception { while ( true ) { E exchange = pollingConsumer . receiveNoWait ( ) ; if ( exchange == null ) { break ; } getProcessor ( ) . process ( exchange ) ; } } @ Override protected void doStart ( ) throws Exception { pollingConsumer = getEndpoint ( ) . createPollingConsumer ( ) ; super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( pollingConsumer != null ) { pollingConsumer . stop ( ) ; } } } 	0	['5', '4', '0', '7', '15', '4', '1', '6', '2', '0.5', '47', '1', '1', '0.918918919', '0.4', '2', '4', '8.2', '1', '0.6', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import static org . apache . camel . builder . PredicateBuilder . evaluateValuePredicate ; public abstract class ExpressionSupport < E extends Exchange > implements Expression < E > , Predicate < E > { public boolean matches ( E exchange ) { Object value = evaluate ( exchange ) ; return evaluateValuePredicate ( value ) ; } public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( text + assertionFailureMessage ( exchange ) + " for exchange: " + exchange ) ; } } protected abstract String assertionFailureMessage ( E exchange ) ; } 	1	['6', '1', '2', '6', '14', '15', '2', '4', '5', '2', '50', '0', '0', '0', '0.541666667', '0', '0', '7.333333333', '2', '1', '1']
package org . apache . camel . component . cxf . invoker ; import java . util . SortedSet ; import org . apache . camel . component . cxf . interceptors . FaultOutInterceptor ; import org . apache . cxf . Bus ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . AbstractFaultChainInitiatorObserver ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . phase . PhaseInterceptorChain ; public class FaultChainInitiatorObserver extends AbstractFaultChainInitiatorObserver { private SortedSet < Phase > phases ; private boolean isOutbound ; public FaultChainInitiatorObserver ( Bus bus , SortedSet < Phase > phases , boolean isOutbound ) { super ( bus ) ; this . phases = phases ; this . isOutbound = isOutbound ; } protected void initializeInterceptors ( Exchange ex , PhaseInterceptorChain chain ) { Endpoint e = ex . get ( Endpoint . class ) ; if ( isOutboundObserver ( ) ) { chain . add ( e . getOutFaultInterceptors ( ) ) ; chain . add ( e . getBinding ( ) . getOutFaultInterceptors ( ) ) ; chain . add ( e . getService ( ) . getOutFaultInterceptors ( ) ) ; chain . add ( getBus ( ) . getOutFaultInterceptors ( ) ) ; chain . add ( new FaultOutInterceptor ( ) ) ; } else { chain . add ( e . getBinding ( ) . getInFaultInterceptors ( ) ) ; chain . add ( e . getService ( ) . getInFaultInterceptors ( ) ) ; chain . add ( getBus ( ) . getInFaultInterceptors ( ) ) ; } } @ Override protected SortedSet < Phase > getPhases ( ) { return phases ; } @ Override protected boolean isOutboundObserver ( ) { return isOutbound ; } } 	0	['4', '0', '0', '10', '19', '2', '1', '9', '1', '0.5', '71', '1', '0', '0', '0.375', '0', '0', '16.25', '2', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; public interface PredicateFactory < E extends Exchange > { Predicate < E > createPredicate ( ) ; } 	1	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . rmi ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . rmi . Remote ; import java . rmi . registry . Registry ; import java . rmi . server . UnicastRemoteObject ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . component . bean . BeanInvocation ; import org . apache . camel . impl . DefaultConsumer ; public class RmiConsumer extends DefaultConsumer < BeanExchange > implements InvocationHandler { private final RmiEndpoint endpoint ; private Remote stub ; private Remote proxy ; public RmiConsumer ( RmiEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { Class [ ] interfaces = new Class [ endpoint . getRemoteInterfaces ( ) . size ( ) ] ; endpoint . getRemoteInterfaces ( ) . toArray ( interfaces ) ; proxy = ( Remote ) Proxy . newProxyInstance ( endpoint . getClassLoader ( ) , interfaces , this ) ; stub = UnicastRemoteObject . exportObject ( proxy , endpoint . getPort ( ) ) ; try { Registry registry = endpoint . getRegistry ( ) ; String name = endpoint . getName ( ) ; registry . bind ( name , stub ) ; } catch ( Exception e ) { try { UnicastRemoteObject . unexportObject ( stub , true ) ; } catch ( Throwable ignore ) { } stub = null ; throw e ; } super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; try { Registry registry = endpoint . getRegistry ( ) ; registry . unbind ( endpoint . getName ( ) ) ; } catch ( Throwable e ) { } UnicastRemoteObject . unexportObject ( proxy , true ) ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( ! isStarted ( ) ) { throw new IllegalStateException ( "The endpoint is not active: " + getEndpoint ( ) . getEndpointUri ( ) ) ; } BeanInvocation invocation = new BeanInvocation ( proxy , method , args ) ; BeanExchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . setInvocation ( invocation ) ; getProcessor ( ) . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( ) . getBody ( ) ; } public Remote getProxy ( ) { return proxy ; } public Remote getStub ( ) { return stub ; } } 	0	['6', '3', '0', '8', '37', '3', '1', '8', '4', '0.666666667', '151', '1', '1', '0.814814815', '0.305555556', '1', '1', '23.66666667', '1', '0.8333', '0']
package org . apache . camel . processor ; import java . util . Iterator ; import java . util . List ; import java . util . ArrayList ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . AsyncCallback ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ExchangeHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . apache . camel . util . ProducerCache ; public class RecipientList extends ServiceSupport implements Processor { private final Expression < Exchange > expression ; private ProducerCache < Exchange > producerCache = new ProducerCache < Exchange > ( ) ; public RecipientList ( Expression < Exchange > expression ) { notNull ( expression , "expression" ) ; this . expression = expression ; } @ Override public String toString ( ) { return "RecipientList[" + expression + "]" ; } public void process ( Exchange exchange ) throws Exception { Object receipientList = expression . evaluate ( exchange ) ; Iterator iter = ObjectConverter . iterator ( receipientList ) ; List < Processor > processors = new ArrayList < Processor > ( ) ; while ( iter . hasNext ( ) ) { Object recipient = iter . next ( ) ; Endpoint < Exchange > endpoint = resolveEndpoint ( exchange , recipient ) ; Producer < Exchange > producer = producerCache . getProducer ( endpoint ) ; processors . add ( producer ) ; } Pipeline pipeline = new Pipeline ( processors ) ; pipeline . process ( exchange ) ; } protected Endpoint < Exchange > resolveEndpoint ( Exchange exchange , Object recipient ) { return ExchangeHelper . resolveEndpoint ( exchange , recipient ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected void doStart ( ) throws Exception { } } 	1	['6', '2', '0', '13', '24', '5', '2', '11', '3', '0.6', '85', '1', '2', '0.722222222', '0.416666667', '1', '1', '12.83333333', '1', '0.8333', '1']
package org . apache . camel . builder . sql ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "sql" ) public @ interface SQL { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; import java . util . Map ; public interface ProducerTemplate < E extends Exchange > extends Service { E send ( E exchange ) ; E send ( Processor processor ) ; Object sendBody ( Object body ) ; Object sendBodyAndHeader ( Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) ; E send ( String endpointUri , E exchange ) ; E send ( String endpointUri , Processor processor ) ; E send ( String endpointUri , ExchangePattern pattern , Processor processor ) ; E send ( Endpoint < E > endpoint , E exchange ) ; E send ( Endpoint < E > endpoint , Processor processor ) ; E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) ; Object sendBody ( Endpoint < E > endpoint , Object body ) ; Object sendBody ( String endpointUri , Object body ) ; Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) ; Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) ; Object sendBodyAndHeader ( String endpointUri , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) ; Object sendBodyAndHeaders ( Endpoint endpoint , Object body , Map < String , Object > headers ) ; E request ( Endpoint < E > endpoint , Processor processor ) ; Object requestBody ( Endpoint < E > endpoint , Object body ) ; Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) ; E request ( String endpoint , Processor processor ) ; Object requestBody ( String endpoint , Object body ) ; Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) ; } 	1	['27', '1', '0', '6', '27', '351', '1', '5', '27', '2', '27', '0', '0', '0', '0.412037037', '0', '0', '0', '1', '1', '3']
package org . apache . camel . spring ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . component . event . EventComponent ; import org . apache . camel . component . event . EventEndpoint ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Registry ; import org . apache . camel . spring . spi . ApplicationContextRegistry ; import org . apache . camel . spring . spi . SpringInjector ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . ClassPathXmlApplicationContext ; public class SpringCamelContext extends DefaultCamelContext implements InitializingBean , DisposableBean , ApplicationContextAware , ApplicationListener { private static final transient Log LOG = LogFactory . getLog ( SpringCamelContext . class ) ; private ApplicationContext applicationContext ; private EventEndpoint eventEndpoint ; public SpringCamelContext ( ) { } public SpringCamelContext ( ApplicationContext applicationContext ) { setApplicationContext ( applicationContext ) ; } public static SpringCamelContext springCamelContext ( ApplicationContext applicationContext ) throws Exception { String [ ] names = applicationContext . getBeanNamesForType ( SpringCamelContext . class ) ; if ( names . length == 1 ) { return ( SpringCamelContext ) applicationContext . getBean ( names [ 0 ] , SpringCamelContext . class ) ; } SpringCamelContext answer = new SpringCamelContext ( ) ; answer . setApplicationContext ( applicationContext ) ; answer . afterPropertiesSet ( ) ; return answer ; } public static SpringCamelContext springCamelContext ( String configLocations ) throws Exception { return springCamelContext ( new ClassPathXmlApplicationContext ( configLocations ) ) ; } public void afterPropertiesSet ( ) throws Exception { start ( ) ; } public void destroy ( ) throws Exception { stop ( ) ; } public void onApplicationEvent ( ApplicationEvent event ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Publishing event: " + event ) ; } if ( event instanceof ContextRefreshedEvent ) { try { LOG . debug ( "Starting the CamelContext now that the ApplicationContext has started" ) ; start ( ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } if ( eventEndpoint != null ) { eventEndpoint . onApplicationEvent ( event ) ; } } else { if ( eventEndpoint != null ) { eventEndpoint . onApplicationEvent ( event ) ; } else { LOG . warn ( "No eventEndpoint enabled for event: " + event ) ; } } } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; if ( applicationContext instanceof ConfigurableApplicationContext ) { addComponent ( "event" , new EventComponent ( applicationContext ) ) ; } } public EventEndpoint getEventEndpoint ( ) { return eventEndpoint ; } public void setEventEndpoint ( EventEndpoint eventEndpoint ) { this . eventEndpoint = eventEndpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( eventEndpoint == null ) { eventEndpoint = createEventEndpoint ( ) ; } } @ Override protected Injector createInjector ( ) { if ( applicationContext instanceof ConfigurableApplicationContext ) { return new SpringInjector ( ( ConfigurableApplicationContext ) applicationContext ) ; } else { LOG . warn ( "Cannot use SpringInjector as applicationContext is not a ConfigurableApplicationContext as its: " + applicationContext ) ; return super . createInjector ( ) ; } } protected EventEndpoint createEventEndpoint ( ) { EventEndpoint endpoint = getEndpoint ( "event:default" , EventEndpoint . class ) ; return endpoint ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { Processor processor = new BeanProcessor ( bean , this ) ; return new ProcessorEndpoint ( uri , this , processor ) ; } @ Override protected Registry createRegistry ( ) { return new ApplicationContextRegistry ( getApplicationContext ( ) ) ; } } 	0	['17', '3', '0', '32', '42', '112', '6', '26', '11', '0.770833333', '213', '1', '2', '0.813333333', '0.229166667', '2', '3', '11.35294118', '5', '1.1176', '0']
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TryProcessor extends ServiceSupport implements Processor { private static final Log LOG = LogFactory . getLog ( TryProcessor . class ) ; private final Processor tryProcessor ; private final List < CatchProcessor > catchClauses ; private final Processor finallyProcessor ; public TryProcessor ( Processor tryProcessor , List < CatchProcessor > catchClauses , Processor finallyProcessor ) { this . tryProcessor = tryProcessor ; this . catchClauses = catchClauses ; this . finallyProcessor = finallyProcessor ; } public String toString ( ) { String finallyText = ( finallyProcessor == null ) ? "" : " Finally {" + finallyProcessor + "}" ; return "Try {" + tryProcessor + "} " + catchClauses + finallyText ; } public void process ( Exchange exchange ) throws Exception { Throwable e = null ; try { tryProcessor . process ( exchange ) ; e = exchange . getException ( ) ; if ( e != null && DeadLetterChannel . isFailureHandled ( exchange ) ) { e = null ; } } catch ( Exception ex ) { e = ex ; exchange . setException ( e ) ; } if ( e != null ) { try { DeadLetterChannel . setFailureHandled ( exchange , true ) ; handleException ( exchange , e ) ; } catch ( Exception ex ) { throw ex ; } catch ( Throwable ex ) { throw new RuntimeCamelException ( ex ) ; } finally { handleAll ( exchange ) ; } } else { handleAll ( exchange ) ; } } private void handleAll ( Exchange exchange ) { if ( finallyProcessor != null ) { DeadLetterChannel . setFailureHandled ( exchange , true ) ; try { finallyProcessor . process ( exchange ) ; } catch ( Exception e2 ) { LOG . warn ( "Caught exception in finally block while handling other exception: " + e2 , e2 ) ; } } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void handleException ( Exchange exchange , Throwable e ) throws Throwable { for ( CatchProcessor catchClause : catchClauses ) { if ( catchClause . catches ( e ) ) { exchange . setException ( e ) ; try { catchClause . process ( exchange ) ; } catch ( Exception e1 ) { LOG . warn ( "Caught exception inside catch clause: " + e1 , e1 ) ; throw e1 ; } return ; } } if ( finallyProcessor == null ) { throw e ; } } } 	1	['8', '2', '0', '10', '28', '0', '1', '9', '3', '0.357142857', '224', '1', '3', '0.684210526', '0.371428571', '1', '1', '26.5', '2', '1', '9']
package org . apache . camel . component . mail ; public class MessageHeaderNamesAccessException extends RuntimeMailException { private static final long serialVersionUID = - 6744171518099741324L ; public MessageHeaderNamesAccessException ( Throwable e ) { super ( "Failed to acess the Mail message property names" , e ) ; } } 	0	['1', '5', '0', '2', '2', '0', '1', '1', '1', '2', '7', '1', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . builder . xml ; import org . apache . camel . util . ObjectHelper ; public class Namespaces { public static final String DEFAULT_NAMESPACE = "http://activemq.apache.org/camel/schema/spring" ; public static final String IN_NAMESPACE = "http://camel.apache.org/xml/in/" ; public static final String OUT_NAMESPACE = "http://camel.apache.org/xml/out/" ; public static final String SYSTEM_PROPERTIES_NAMESPACE = "http://camel.apache.org/xml/variables/system-properties" ; public static final String ENVIRONMENT_VARIABLES = "http://camel.apache.org/xml/variables/environment-variables" ; public static final String EXCHANGE_PROPERTY = "http://camel.apache.org/xml/variables/exchange-property" ; private Namespaces ( ) { } public static boolean isMatchingNamespaceOrEmptyNamespace ( String namespaceURI , String expectedNamespace ) { return ObjectHelper . isNullOrBlank ( namespaceURI ) || namespaceURI . equals ( expectedNamespace ) ; } } 	1	['2', '1', '0', '2', '5', '1', '1', '1', '1', '2', '22', '0', '0', '0', '0.5', '0', '0', '7', '3', '1.5', '2']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "jaxb" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class JaxbDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public JaxbDataFormat ( ) { super ( "org.apache.camel.converter.jaxb.JaxbDataFormat" ) ; } public JaxbDataFormat ( boolean prettyPrint ) { this ( ) ; setPrettyPrint ( prettyPrint ) ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } @ Override protected void configureDataFormat ( DataFormat dataFormat ) { if ( ObjectConverter . toBool ( getPrettyPrint ( ) ) ) { setProperty ( dataFormat , "prettyPrint" , Boolean . TRUE ) ; } } } 	0	['5', '2', '0', '4', '9', '8', '1', '3', '4', '0.25', '34', '1', '0', '0.571428571', '0.4', '1', '2', '5.6', '2', '0.8', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; public class SedaEndpoint extends DefaultEndpoint < Exchange > { private final class SedaProducer extends DefaultProducer implements AsyncProcessor { private SedaProducer ( Endpoint endpoint ) { super ( endpoint ) ; } public void process ( Exchange exchange ) { queue . add ( exchange . copy ( ) ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { queue . add ( exchange . copy ( ) ) ; callback . done ( true ) ; return true ; } } private BlockingQueue < Exchange > queue ; public SedaEndpoint ( String endpointUri , Component component , BlockingQueue < Exchange > queue ) { super ( endpointUri , component ) ; this . queue = queue ; } public SedaEndpoint ( String uri , SedaComponent component ) { this ( uri , component , component . createQueue ( ) ) ; } public Producer createProducer ( ) throws Exception { return new SedaProducer ( this ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new SedaConsumer ( this , processor ) ; } public BlockingQueue < Exchange > getQueue ( ) { return queue ; } public boolean isSingleton ( ) { return true ; } } 	1	['7', '2', '0', '11', '11', '15', '4', '10', '6', '0.5', '44', '1', '0', '0.772727273', '0.265306122', '0', '0', '5.142857143', '1', '0.7143', '2']
package org . apache . camel . component . file ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import java . io . File ; public class FileExchange extends DefaultExchange { private File file ; public FileExchange ( CamelContext camelContext , ExchangePattern pattern , File file ) { super ( camelContext , pattern ) ; setIn ( new FileMessage ( file ) ) ; this . file = file ; } public File getFile ( ) { return this . file ; } public void setFile ( File file ) { this . file = file ; } public Exchange newInstance ( ) { return new FileExchange ( getContext ( ) , getPattern ( ) , getFile ( ) ) ; } } 	0	['4', '2', '0', '14', '9', '0', '9', '6', '4', '0', '36', '1', '0', '0.923076923', '0.5', '1', '1', '7.75', '1', '0.75', '0']
package org . apache . camel . model ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . ChoiceProcessor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . util . CollectionStringBuffer ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; @ XmlRootElement ( name = "choice" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ChoiceType extends ProcessorType < ChoiceType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < WhenType > whenClauses = new ArrayList < WhenType > ( ) ; @ XmlElement ( required = false ) private OtherwiseType otherwise ; @ Override public String toString ( ) { return "Choice[ " + getWhenClauses ( ) + " " + getOtherwise ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; for ( WhenType whenClaus : whenClauses ) { filters . add ( whenClaus . createProcessor ( routeContext ) ) ; } Processor otherwiseProcessor = null ; if ( otherwise != null ) { otherwiseProcessor = otherwise . createProcessor ( routeContext ) ; } return new ChoiceProcessor ( filters , otherwiseProcessor ) ; } public ChoiceType when ( Predicate predicate ) { getWhenClauses ( ) . add ( new WhenType ( predicate ) ) ; return this ; } public OtherwiseType otherwise ( ) { OtherwiseType answer = new OtherwiseType ( ) ; setOtherwise ( answer ) ; return answer ; } @ Override public String getLabel ( ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; List < WhenType > list = getWhenClauses ( ) ; for ( WhenType whenType : list ) { buffer . append ( whenType . getLabel ( ) ) ; } return buffer . toString ( ) ; } public List < WhenType > getWhenClauses ( ) { return whenClauses ; } public void setWhenClauses ( List < WhenType > whenClauses ) { this . whenClauses = whenClauses ; } public List < ProcessorType < ? > > getOutputs ( ) { if ( otherwise != null ) { return otherwise . getOutputs ( ) ; } else if ( whenClauses . isEmpty ( ) ) { return Collections . EMPTY_LIST ; } else { WhenType when = whenClauses . get ( whenClauses . size ( ) - 1 ) ; return when . getOutputs ( ) ; } } public OtherwiseType getOtherwise ( ) { return otherwise ; } public void setOtherwise ( OtherwiseType otherwise ) { this . otherwise = otherwise ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } } 	1	['13', '2', '0', '12', '37', '42', '4', '9', '13', '0.611111111', '175', '1', '1', '0.885714286', '0.276923077', '1', '4', '12.23076923', '3', '1.1538', '6']
package org . apache . camel . spring ; import java . lang . reflect . Modifier ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . context . ApplicationContext ; public class RouteBuilderFinder { private static final transient Log LOG = LogFactory . getLog ( RouteBuilderFinder . class ) ; private final SpringCamelContext camelContext ; private final String [ ] packages ; private ApplicationContext applicationContext ; private ResolverUtil resolver = new ResolverUtil ( ) ; public RouteBuilderFinder ( SpringCamelContext camelContext , String [ ] packages , ClassLoader classLoader ) { this . camelContext = camelContext ; this . applicationContext = camelContext . getApplicationContext ( ) ; this . packages = packages ; Set set = resolver . getClassLoaders ( ) ; set . clear ( ) ; set . add ( classLoader ) ; } public String [ ] getPackages ( ) { return packages ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void appendBuilders ( List < RouteBuilder > list ) throws IllegalAccessException , InstantiationException { resolver . findImplementations ( RouteBuilder . class , packages ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class aClass : classes ) { if ( shouldIgnoreBean ( aClass ) ) { continue ; } if ( isValidClass ( aClass ) ) { RouteBuilder builder = instantiateBuilder ( aClass ) ; list . add ( builder ) ; } } } public void destroy ( ) throws Exception { } protected boolean shouldIgnoreBean ( Class type ) { Map beans = applicationContext . getBeansOfType ( type , true , true ) ; if ( beans == null || beans . isEmpty ( ) ) { return false ; } return true ; } protected boolean isValidClass ( Class type ) { if ( ! Modifier . isAbstract ( type . getModifiers ( ) ) && ! type . isInterface ( ) ) { return true ; } return false ; } protected RouteBuilder instantiateBuilder ( Class type ) throws IllegalAccessException , InstantiationException { return ( RouteBuilder ) camelContext . getInjector ( ) . newInstance ( type ) ; } } 	0	['9', '1', '0', '8', '29', '22', '1', '7', '5', '0.8', '126', '1', '3', '0', '0.3125', '0', '0', '12.44444444', '3', '1.2222', '0']
package org . apache . camel . management ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . rmi . RemoteException ; import java . rmi . registry . LocateRegistry ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . management . InstanceAlreadyExistsException ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . MBeanServerFactory ; import javax . management . NotCompliantMBeanException ; import javax . management . ObjectInstance ; import javax . management . ObjectName ; import javax . management . modelmbean . InvalidTargetObjectTypeException ; import javax . management . modelmbean . ModelMBeanInfo ; import javax . management . modelmbean . RequiredModelMBean ; import javax . management . remote . JMXConnectorServer ; import javax . management . remote . JMXConnectorServerFactory ; import javax . management . remote . JMXServiceURL ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jmx . export . annotation . AnnotationJmxAttributeSource ; import org . springframework . jmx . export . assembler . MetadataMBeanInfoAssembler ; public class InstrumentationAgentImpl extends ServiceSupport implements InstrumentationAgent , CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( InstrumentationAgentImpl . class ) ; public static final String SYSTEM_PROPERTY_JMX = "org.apache.camel.jmx" ; public static final String DEFAULT_DOMAIN = "org.apache.camel" ; public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 1099 ; private MBeanServer server ; private CamelContext context ; private Set < ObjectName > mbeans = new HashSet < ObjectName > ( ) ; private MetadataMBeanInfoAssembler assembler ; private JMXConnectorServer cs ; private boolean jmxEnabled = false ; private String jmxDomainName = null ; private int jmxConnectorPort = 0 ; private CamelNamingStrategy namingStrategy ; public InstrumentationAgentImpl ( ) { assembler = new MetadataMBeanInfoAssembler ( ) ; assembler . setAttributeSource ( new AnnotationJmxAttributeSource ( ) ) ; namingStrategy = new CamelNamingStrategy ( ) ; } public CamelContext getCamelContext ( ) { return context ; } public void setCamelContext ( CamelContext camelContext ) { context = camelContext ; } public void setMBeanServer ( MBeanServer server ) { this . server = server ; jmxEnabled = true ; } public MBeanServer getMBeanServer ( ) { if ( server == null ) { server = ManagementFactory . getPlatformMBeanServer ( ) ; } return server ; } public void register ( Object obj , ObjectName name ) throws JMException { register ( obj , name , false ) ; } public void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { try { registerMBeanWithServer ( obj , name , forceRegistration ) ; } catch ( NotCompliantMBeanException e ) { ModelMBeanInfo mbi = null ; mbi = assembler . getMBeanInfo ( obj , name . toString ( ) ) ; RequiredModelMBean mbean = ( RequiredModelMBean ) server . instantiate ( RequiredModelMBean . class . getName ( ) ) ; mbean . setModelMBeanInfo ( mbi ) ; try { mbean . setManagedResource ( obj , "ObjectReference" ) ; } catch ( InvalidTargetObjectTypeException itotex ) { throw new JMException ( itotex . getMessage ( ) ) ; } registerMBeanWithServer ( mbean , name , forceRegistration ) ; } } public void unregister ( ObjectName name ) throws JMException { server . unregisterMBean ( name ) ; } public CamelNamingStrategy getNamingStrategy ( ) { return namingStrategy ; } public void setNamingStrategy ( CamelNamingStrategy namingStrategy ) { this . namingStrategy = namingStrategy ; } protected void doStart ( ) throws Exception { ObjectHelper . notNull ( context , "camelContext" ) ; if ( getMBeanServer ( ) == null ) { createMBeanServer ( ) ; } if ( jmxDomainName == null ) { jmxDomainName = System . getProperty ( SYSTEM_PROPERTY_JMX + ".domain" ) ; if ( jmxDomainName == null || jmxDomainName . length ( ) == 0 ) { jmxDomainName = DEFAULT_DOMAIN ; } } configureDomainName ( ) ; LOG . debug ( "Starting JMX agent on server: " + getMBeanServer ( ) ) ; if ( context instanceof DefaultCamelContext ) { DefaultCamelContext dc = ( DefaultCamelContext ) context ; InstrumentationLifecycleStrategy ls = new InstrumentationLifecycleStrategy ( this ) ; dc . setLifecycleStrategy ( ls ) ; ls . onContextCreate ( context ) ; } } protected void doStop ( ) throws Exception { Object [ ] mBeans = mbeans . toArray ( ) ; int caught = 0 ; for ( Object name : mBeans ) { mbeans . remove ( ( ObjectName ) name ) ; try { unregister ( ( ObjectName ) name ) ; } catch ( JMException jmex ) { LOG . info ( "Exception unregistering MBean" , jmex ) ; caught ++ ; } } if ( caught > 0 ) { LOG . warn ( "A number of " + caught + " exceptions caught while unregistering MBeans during stop operation.  " + "See INFO log for details." ) ; } } private void registerMBeanWithServer ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { ObjectInstance instance = null ; try { instance = server . registerMBean ( obj , name ) ; } catch ( InstanceAlreadyExistsException e ) { if ( forceRegistration ) { server . unregisterMBean ( name ) ; instance = server . registerMBean ( obj , name ) ; } else { throw e ; } } if ( instance != null ) { mbeans . add ( name ) ; } } public void enableJmx ( String domainName , int port ) { jmxEnabled = true ; jmxDomainName = domainName ; configureDomainName ( ) ; jmxConnectorPort = port ; } protected void configureDomainName ( ) { if ( jmxDomainName != null ) { namingStrategy . setDomainName ( jmxDomainName ) ; } } protected void createMBeanServer ( ) { String hostName = DEFAULT_HOST ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { if ( ! jmxEnabled ) { jmxEnabled = null != System . getProperty ( SYSTEM_PROPERTY_JMX ) ; if ( ! jmxEnabled ) { return ; } } if ( jmxConnectorPort <= 0 ) { String portKey = SYSTEM_PROPERTY_JMX + ".port" ; String portValue = System . getProperty ( portKey ) ; if ( portValue != null && portValue . length ( ) > 0 ) { try { jmxConnectorPort = Integer . parseInt ( portValue ) ; } catch ( NumberFormatException nfe ) { LOG . info ( "Invalid port number specified via System property [" + portKey + "=" + portValue + "].  Using default: " + DEFAULT_PORT ) ; jmxConnectorPort = DEFAULT_PORT ; } } } try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException uhe ) { LOG . info ( "Cannot determine host name.  Using default: " + DEFAULT_PORT , uhe ) ; hostName = DEFAULT_HOST ; } } else { jmxDomainName = jmxDomainName != null ? jmxDomainName : DEFAULT_DOMAIN ; jmxConnectorPort = jmxConnectorPort > 0 ? jmxConnectorPort : DEFAULT_PORT ; hostName = DEFAULT_HOST ; } if ( ! jmxEnabled ) { return ; } List servers = MBeanServerFactory . findMBeanServer ( jmxDomainName ) ; if ( servers . size ( ) == 0 ) { server = MBeanServerFactory . createMBeanServer ( jmxDomainName ) ; } else { server = ( MBeanServer ) servers . get ( 0 ) ; } try { createJmxConnector ( hostName ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not create and start jmx connector." , ioe ) ; } } protected void createJmxConnector ( String host ) throws IOException { if ( jmxConnectorPort > 0 ) { try { LocateRegistry . createRegistry ( jmxConnectorPort ) ; } catch ( RemoteException ex ) { LocateRegistry . getRegistry ( jmxConnectorPort ) ; } JMXServiceURL url = new JMXServiceURL ( "service:jmx:rmi:///jndi/rmi://" + host + ":" + jmxConnectorPort + "/jmxrmi" ) ; cs = JMXConnectorServerFactory . newJMXConnectorServer ( url , null , server ) ; Thread connectorThread = new Thread ( ) { public void run ( ) { try { cs . start ( ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not start jmx connector thread." , ioe ) ; } } } ; connectorThread . setName ( "JMX Connector Thread [" + url + "]" ) ; connectorThread . start ( ) ; LOG . info ( "Jmx connector thread started on " + url ) ; } } } 	1	['20', '2', '1', '16', '74', '68', '2', '15', '11', '0.864661654', '537', '0.714285714', '3', '0.419354839', '0.173684211', '1', '1', '25.15', '12', '1.55', '4']
package org . apache . camel . bam . model ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; public class EntitySupport { private Long id ; @ Id @ GeneratedValue public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + id + "]" ; } } 	0	['4', '1', '3', '3', '11', '0', '3', '0', '4', '0.333333333', '31', '1', '0', '0', '0.625', '0', '0', '6.5', '1', '0.75', '0']
package org . apache . camel ; public class CamelExchangeException extends CamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final Exchange exchange ; public CamelExchangeException ( String message , Exchange exchange ) { super ( message + " on the exchange: " + exchange ) ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } } 	1	['2', '4', '6', '8', '7', '0', '6', '2', '2', '1', '23', '1', '1', '0.944444444', '0.666666667', '0', '0', '9.5', '1', '0.5', '1']
package org . apache . camel . component ; import org . apache . camel . Exchange ; import org . apache . camel . component . validator . ValidatorComponent ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . DefaultResourceLoader ; import org . springframework . core . io . Resource ; import org . springframework . core . io . ResourceLoader ; public abstract class ResourceBasedComponent extends DefaultComponent < Exchange > { protected static final transient Log LOG = LogFactory . getLog ( ValidatorComponent . class ) ; private ResourceLoader resourceLoader = new DefaultResourceLoader ( ) ; public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } protected Resource resolveMandatoryResource ( String uri ) { Resource resource = getResourceLoader ( ) . getResource ( uri ) ; if ( resource == null ) { throw new IllegalArgumentException ( "Could not find resource for URI: " + uri + " using: " + getResourceLoader ( ) ) ; } else { return resource ; } } } 	0	['5', '3', '2', '8', '14', '4', '2', '6', '3', '0.625', '52', '1', '1', '0.884615385', '0.5', '0', '0', '9', '2', '0.8', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlRootElement ( name = "when" ) public class WhenType < Type extends ProcessorType > extends ExpressionNode { public WhenType ( ) { } public WhenType ( Predicate predicate ) { super ( predicate ) ; } public WhenType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "When[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1	['6', '3', '0', '8', '15', '15', '2', '6', '6', '2', '42', '0', '0', '0.971428571', '0.416666667', '2', '3', '6', '1', '0.5', '2']
package org . apache . camel . component . irc ; import org . apache . camel . CamelContext ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . schwering . irc . lib . IRCConnection ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; public class IrcComponent extends DefaultComponent < IrcExchange > { private static final transient Log LOG = LogFactory . getLog ( IrcComponent . class ) ; private IrcConfiguration configuration ; private final Map < String , IRCConnection > connectionCache = new HashMap < String , IRCConnection > ( ) ; public IrcComponent ( ) { configuration = new IrcConfiguration ( ) ; } public IrcComponent ( IrcConfiguration configuration ) { this . configuration = configuration ; } public IrcComponent ( CamelContext context ) { super ( context ) ; configuration = new IrcConfiguration ( ) ; } public static IrcComponent ircComponent ( ) { return new IrcComponent ( ) ; } protected IrcEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { IrcConfiguration config = getConfiguration ( ) . copy ( ) ; config . configure ( new URI ( uri ) ) ; final IrcEndpoint endpoint = new IrcEndpoint ( uri , this , config ) ; setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public IrcConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( IrcConfiguration configuration ) { this . configuration = configuration ; } public synchronized IRCConnection getIRCConnection ( IrcConfiguration configuration ) { final IRCConnection connection ; if ( connectionCache . containsKey ( configuration . getCacheKey ( ) ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Returning Cached Connection to " + configuration . getHostname ( ) + " " + configuration . getTarget ( ) ) ; } connection = connectionCache . get ( configuration . getCacheKey ( ) ) ; } else { connection = createConnection ( configuration ) ; connectionCache . put ( configuration . getCacheKey ( ) , connection ) ; } return connection ; } protected IRCConnection createConnection ( IrcConfiguration configuration ) { LOG . debug ( "Creating Connection to " + configuration . getHostname ( ) + " destination: " + configuration . getTarget ( ) + " nick: " + configuration . getNickname ( ) + " user: " + configuration . getUsername ( ) ) ; final IRCConnection conn = new IRCConnection ( configuration . getHostname ( ) , configuration . getPorts ( ) , configuration . getPassword ( ) , configuration . getNickname ( ) , configuration . getUsername ( ) , configuration . getRealname ( ) ) ; conn . setEncoding ( "UTF-8" ) ; conn . setColors ( configuration . isColors ( ) ) ; conn . setPong ( true ) ; try { conn . connect ( ) ; } catch ( Exception e ) { LOG . error ( "Failed to connect: " + e , e ) ; throw new RuntimeCamelException ( e ) ; } return conn ; } public void closeConnection ( String key , IRCConnection connection ) { try { connection . doQuit ( ) ; connection . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Override protected synchronized void doStop ( ) throws Exception { Map < String , IRCConnection > map = new HashMap < String , IRCConnection > ( connectionCache ) ; connectionCache . clear ( ) ; for ( Map . Entry < String , IRCConnection > entry : map . entrySet ( ) ) { closeConnection ( entry . getKey ( ) , entry . getValue ( ) ) ; } super . doStop ( ) ; } } 	0	['13', '3', '0', '9', '60', '38', '1', '9', '8', '0.611111111', '260', '1', '2', '0.71875', '0.305555556', '2', '3', '18.76923077', '3', '0.8462', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Throttler ; @ XmlRootElement ( name = "throttler" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThrottlerType extends ProcessorType { @ XmlAttribute private Long maximumRequestsPerPeriod ; @ XmlAttribute private long timePeriodMillis = 1000 ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; public ThrottlerType ( ) { } public ThrottlerType ( long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } @ Override public String toString ( ) { return "Throttler[" + getMaximumRequestsPerPeriod ( ) + " request per " + getTimePeriodMillis ( ) + " millis -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return "" + getMaximumRequestsPerPeriod ( ) + " per " + getTimePeriodMillis ( ) + " (ms)" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new Throttler ( childProcessor , maximumRequestsPerPeriod , timePeriodMillis ) ; } public ThrottlerType timePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; return this ; } public Long getMaximumRequestsPerPeriod ( ) { return maximumRequestsPerPeriod ; } public void setMaximumRequestsPerPeriod ( Long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } public long getTimePeriodMillis ( ) { return timePeriodMillis ; } public void setTimePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType > outputs ) { this . outputs = outputs ; } } 	1	['14', '2', '0', '4', '25', '31', '1', '4', '14', '0.634615385', '140', '1', '0', '0.885714286', '0.3', '1', '4', '8.714285714', '1', '0.8571', '3']
package org . apache . camel . builder . script ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "php" ) public @ interface PHP { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . getProcessor ( ) . process ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	1	['7', '2', '0', '7', '25', '0', '1', '6', '5', '0.166666667', '153', '1', '1', '0.684210526', '0.357142857', '1', '1', '20.57142857', '4', '1.2857', '2']
package org . apache . camel . builder ; import org . apache . camel . Processor ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingErrorHandler ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . ErrorHandlerSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandlerBuilder extends ErrorHandlerBuilderSupport { private Log log = LogFactory . getLog ( Logger . class ) ; private LoggingLevel level = LoggingLevel . INFO ; public LoggingErrorHandlerBuilder ( ) { } public LoggingErrorHandlerBuilder ( Log log ) { this . log = log ; } public LoggingErrorHandlerBuilder ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public ErrorHandlerBuilder copy ( ) { LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder ( ) ; answer . setLog ( getLog ( ) ) ; answer . setLevel ( getLevel ( ) ) ; return answer ; } public Processor createErrorHandler ( Processor processor ) { LoggingErrorHandler handler = new LoggingErrorHandler ( processor , log , level ) ; configure ( handler ) ; return handler ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } } 	0	['9', '2', '0', '9', '13', '0', '1', '8', '9', '0.25', '92', '1', '2', '0.25', '0.416666667', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class TopicLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; for ( Processor processor : list ) { Exchange copy = copyExchangeStrategy ( processor , exchange ) ; processor . process ( copy ) ; } } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	1	['3', '2', '0', '4', '10', '3', '1', '3', '2', '2', '32', '0', '0', '0.6', '0.666666667', '0', '0', '9.666666667', '1', '0.6667', '2']
package org . apache . camel . view ; import java . io . IOException ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . HashMap ; import java . util . ArrayList ; import org . apache . camel . CamelContext ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . FromType ; import org . apache . camel . model . ToType ; import org . apache . camel . model . language . ExpressionType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class GraphGeneratorSupport { private static final transient Log LOG = LogFactory . getLog ( RouteDotGenerator . class ) ; protected String dir ; private String imagePrefix = "http://www.enterpriseintegrationpatterns.com/img/" ; private Map < Object , NodeData > nodeMap = new HashMap < Object , NodeData > ( ) ; private boolean makeParentDirs = true ; protected int clusterCounter ; private Map < String , List < RouteType > > routeGroupMap ; protected String extension ; protected GraphGeneratorSupport ( String dir , String extension ) { this . dir = dir ; this . extension = extension ; } public String getDir ( ) { return dir ; } public void setDir ( String dir ) { this . dir = dir ; } public void drawRoutes ( CamelContext context ) throws IOException { File parent = new File ( dir ) ; if ( makeParentDirs ) { parent . mkdirs ( ) ; } List < RouteType > routes = context . getRouteDefinitions ( ) ; routeGroupMap = createRouteGroupMap ( routes ) ; generateFile ( parent , "routes" + extension , routeGroupMap ) ; if ( routeGroupMap . size ( ) >= 1 ) { Set < Map . Entry < String , List < RouteType > > > entries = routeGroupMap . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { Map < String , List < RouteType > > map = new HashMap < String , List < RouteType > > ( ) ; String group = entry . getKey ( ) ; map . put ( group , entry . getValue ( ) ) ; generateFile ( parent , group + extension , map ) ; } } } private void generateFile ( File parent , String fileName , Map < String , List < RouteType > > map ) throws IOException { nodeMap . clear ( ) ; clusterCounter = 0 ; PrintWriter writer = new PrintWriter ( new FileWriter ( new File ( parent , fileName ) ) ) ; try { generateFile ( writer , map ) ; } finally { writer . close ( ) ; } } protected abstract void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) ; protected boolean isMulticastNode ( ProcessorType node ) { return node instanceof MulticastType || node instanceof ChoiceType ; } protected String getLabel ( List < ExpressionType > expressions ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; for ( ExpressionType expression : expressions ) { buffer . append ( getLabel ( expression ) ) ; } return buffer . toString ( ) ; } protected String getLabel ( ExpressionType expression ) { if ( expression != null ) { return expression . getLabel ( ) ; } return "" ; } protected NodeData getNodeData ( Object node ) { Object key = node ; if ( node instanceof FromType ) { FromType fromType = ( FromType ) node ; key = fromType . getUriOrRef ( ) ; } else if ( node instanceof ToType ) { ToType toType = ( ToType ) node ; key = toType . getUriOrRef ( ) ; } NodeData answer = nodeMap . get ( key ) ; if ( answer == null ) { String id = "node" + ( nodeMap . size ( ) + 1 ) ; answer = new NodeData ( id , node , imagePrefix ) ; nodeMap . put ( key , answer ) ; } return answer ; } protected Map < String , List < RouteType > > createRouteGroupMap ( List < RouteType > routes ) { Map < String , List < RouteType > > map = new HashMap < String , List < RouteType > > ( ) ; for ( RouteType route : routes ) { String group = route . getGroup ( ) ; if ( group == null ) { group = "Camel Routes" ; } List < RouteType > list = map . get ( group ) ; if ( list == null ) { list = new ArrayList < RouteType > ( ) ; map . put ( group , list ) ; } list . add ( route ) ; } return map ; } } 	0	['12', '1', '2', '14', '47', '48', '2', '12', '3', '0.886363636', '306', '1', '1', '0', '0.218181818', '0', '0', '23.83333333', '4', '1.6667', '0']
package org . apache . camel . language . simple ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . language . IllegalSyntaxException ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class SimpleLanguage implements Language { public static Expression simple ( String expression ) { SimpleLanguage language = new SimpleLanguage ( ) ; return language . createExpression ( expression ) ; } public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { if ( expression . indexOf ( "${" ) >= 0 ) { return createComplexExpression ( expression ) ; } return createSimpleExpression ( expression ) ; } protected Expression < Exchange > createComplexExpression ( String expression ) { List < Expression > results = new ArrayList < Expression > ( ) ; int pivot = 0 ; int size = expression . length ( ) ; while ( pivot < size ) { int idx = expression . indexOf ( "${" , pivot ) ; if ( idx < 0 ) { results . add ( createConstantExpression ( expression , pivot , size ) ) ; break ; } else { if ( pivot < idx ) { results . add ( createConstantExpression ( expression , pivot , idx ) ) ; } pivot = idx + 2 ; int endIdx = expression . indexOf ( "}" , pivot ) ; if ( endIdx < 0 ) { throw new IllegalArgumentException ( "Expecting } but found end of string for simple expression: " + expression ) ; } String simpleText = expression . substring ( pivot , endIdx ) ; Expression simpleExpression = createSimpleExpression ( simpleText ) ; results . add ( simpleExpression ) ; pivot = endIdx + 1 ; } } return ExpressionBuilder . concatExpression ( results , expression ) ; } protected Expression createConstantExpression ( String expression , int start , int end ) { return ExpressionBuilder . constantExpression ( expression . substring ( start , end ) ) ; } protected Expression < Exchange > createSimpleExpression ( String expression ) { if ( ObjectHelper . isEqualToAny ( expression , "body" , "in.body" ) ) { return ExpressionBuilder . bodyExpression ( ) ; } else if ( ObjectHelper . equals ( expression , "out.body" ) ) { return ExpressionBuilder . outBodyExpression ( ) ; } String remainder = ifStartsWithReturnRemainder ( "in.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "header." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "headers." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "in.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . headerExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "out.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "out.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . outHeaderExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "property." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "sys." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } throw new IllegalSyntaxException ( this , expression ) ; } protected String ifStartsWithReturnRemainder ( String prefix , String text ) { if ( text . startsWith ( prefix ) ) { String remainder = text . substring ( prefix . length ( ) ) ; if ( remainder . length ( ) > 0 ) { return remainder ; } } return null ; } } 	1	['8', '1', '0', '7', '32', '28', '0', '7', '4', '2', '237', '0', '0', '0', '0.625', '0', '0', '28.625', '11', '3', '2']
package org . apache . camel . component . xmpp ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . AccountManager ; import org . jivesoftware . smack . XMPPConnection ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . filter . PacketFilter ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smack . packet . Presence ; public class XmppEndpoint extends DefaultEndpoint < XmppExchange > { private static final transient Log LOG = LogFactory . getLog ( XmppEndpoint . class ) ; private XmppBinding binding ; private XMPPConnection connection ; private String host ; private int port ; private String user ; private String password ; private String resource = "Camel" ; private boolean login = true ; private PacketFilter filter ; private boolean createAccount ; private String room ; private String participant ; public XmppEndpoint ( String uri , XmppComponent component ) { super ( uri , component ) ; } public Producer < XmppExchange > createProducer ( ) throws Exception { if ( room != null ) { return createGroupChatProducer ( room ) ; } else { if ( participant == null ) { throw new IllegalArgumentException ( "No room or participant configured on this endpoint: " + this ) ; } return createPrivateChatProducer ( participant ) ; } } public Producer < XmppExchange > createGroupChatProducer ( String room ) throws Exception { return new XmppGroupChatProducer ( this , room ) ; } public Producer < XmppExchange > createPrivateChatProducer ( String participant ) throws Exception { return new XmppPrivateChatProducer ( this , participant ) ; } public Consumer < XmppExchange > createConsumer ( Processor processor ) throws Exception { return new XmppConsumer ( this , processor ) ; } @ Override public XmppExchange createExchange ( ExchangePattern pattern ) { return new XmppExchange ( getContext ( ) , pattern , getBinding ( ) ) ; } public XmppExchange createExchange ( Message message ) { return new XmppExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , message ) ; } public XmppBinding getBinding ( ) { if ( binding == null ) { binding = new XmppBinding ( ) ; } return binding ; } public void setBinding ( XmppBinding binding ) { this . binding = binding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getUser ( ) { return user ; } public void setUser ( String user ) { this . user = user ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getResource ( ) { return resource ; } public void setResource ( String resource ) { this . resource = resource ; } public boolean isLogin ( ) { return login ; } public void setLogin ( boolean login ) { this . login = login ; } public PacketFilter getFilter ( ) { return filter ; } public void setFilter ( PacketFilter filter ) { this . filter = filter ; } public boolean isCreateAccount ( ) { return createAccount ; } public void setCreateAccount ( boolean createAccount ) { this . createAccount = createAccount ; } public String getRoom ( ) { return room ; } public void setRoom ( String room ) { this . room = room ; } public String getParticipant ( ) { return participant ; } public void setParticipant ( String participant ) { this . participant = participant ; } public XMPPConnection getConnection ( ) throws XMPPException { if ( connection == null ) { connection = createConnection ( ) ; } return connection ; } public void setConnection ( XMPPConnection connection ) { this . connection = connection ; } protected XMPPConnection createConnection ( ) throws XMPPException { XMPPConnection connection ; if ( port > 0 ) { connection = new XMPPConnection ( host , port ) ; } else { connection = new XMPPConnection ( host ) ; } if ( login && ! connection . isAuthenticated ( ) ) { if ( user != null ) { LOG . info ( "Logging in to XMPP as user: " + user + " on connection: " + connection ) ; if ( password == null ) { LOG . warn ( "No password configured for user: " + user ) ; } if ( createAccount ) { AccountManager accountManager = new AccountManager ( connection ) ; accountManager . createAccount ( user , password ) ; } if ( resource != null ) { connection . login ( user , password , resource ) ; } else { connection . login ( user , password ) ; } } else { LOG . info ( "Logging in anonymously to XMPP on connection: " + connection ) ; connection . loginAnonymously ( ) ; } connection . sendPacket ( new Presence ( Presence . Type . AVAILABLE ) ) ; } return connection ; } public boolean isSingleton ( ) { return true ; } } 	0	['35', '2', '0', '24', '61', '523', '4', '24', '33', '0.92081448', '343', '1', '2', '0.34', '0.144385027', '1', '1', '8.428571429', '2', '0.9714', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . util . ObjectHelper ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; public abstract class DefaultEndpoint < E extends Exchange > implements Endpoint < E > { private String endpointUri ; private CamelContext context ; private Component component ; private ScheduledExecutorService executorService ; private ExchangePattern exchangePattern = ExchangePattern . InOnly ; protected DefaultEndpoint ( String endpointUri , Component component ) { this ( endpointUri , component . getCamelContext ( ) ) ; this . component = component ; } protected DefaultEndpoint ( String endpointUri , CamelContext context ) { this . endpointUri = endpointUri ; this . context = context ; } public int hashCode ( ) { return endpointUri . hashCode ( ) * 37 + 1 ; } @ Override public boolean equals ( Object object ) { if ( object instanceof DefaultEndpoint ) { DefaultEndpoint that = ( DefaultEndpoint ) object ; return ObjectHelper . equals ( this . endpointUri , that . endpointUri ) ; } return false ; } @ Override public String toString ( ) { return "Endpoint[" + endpointUri + "]" ; } public String getEndpointUri ( ) { return endpointUri ; } public CamelContext getContext ( ) { return context ; } public Component getComponent ( ) { return component ; } public synchronized ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { Component c = getComponent ( ) ; if ( c != null && c instanceof DefaultComponent ) { DefaultComponent dc = ( DefaultComponent ) c ; executorService = dc . getExecutorService ( ) ; } if ( executorService == null ) { executorService = createExecutorService ( ) ; } } return executorService ; } public synchronized void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } public PollingConsumer < E > createPollingConsumer ( ) throws Exception { return new EventDrivenPollingConsumer < E > ( this ) ; } public E convertTo ( Class < E > type , Exchange exchange ) { if ( type . isInstance ( exchange ) ) { return type . cast ( exchange ) ; } return getContext ( ) . getExchangeConverter ( ) . convertTo ( type , exchange ) ; } public E createExchange ( Exchange exchange ) { Class < E > exchangeType = getExchangeType ( ) ; if ( exchangeType != null ) { if ( exchangeType . isInstance ( exchange ) ) { return exchangeType . cast ( exchange ) ; } } E answer = createExchange ( ) ; answer . copyFrom ( exchange ) ; return answer ; } public Class < E > getExchangeType ( ) { Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { return ( Class < E > ) argumentType ; } } } return null ; } public E createExchange ( ) { return createExchange ( getExchangePattern ( ) ) ; } public E createExchange ( ExchangePattern pattern ) { return ( E ) new DefaultExchange ( getContext ( ) , pattern ) ; } public ExchangePattern getExchangePattern ( ) { return exchangePattern ; } public void setExchangePattern ( ExchangePattern exchangePattern ) { this . exchangePattern = exchangePattern ; } protected ScheduledThreadPoolExecutor createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( 10 ) ; } } 	1	['19', '1', '15', '32', '38', '139', '21', '11', '16', '0.822222222', '216', '1', '3', '0', '0.175438596', '1', '1', '10.10526316', '5', '1.4737', '4']
package org . apache . camel . util ; import java . io . IOException ; public class NoFactoryAvailableException extends IOException { private final String uri ; public NoFactoryAvailableException ( String uri ) { super ( "Could not find factory class for resource: " + uri ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	0	['2', '4', '0', '5', '6', '0', '5', '0', '2', '0', '20', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . impl ; import java . util . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Route ; import org . apache . camel . Service ; public class DefaultLifecycleStrategy implements LifecycleStrategy { public void onContextCreate ( CamelContext context ) { } public void onEndpointAdd ( Endpoint endpoint ) { } public void onServiceAdd ( CamelContext context , Service service ) { } public void onRoutesAdd ( Collection < Route > routes ) { } public void beforeStartRouteType ( CamelContext context , RouteType routeType ) { } } 	1	['6', '1', '0', '6', '7', '15', '1', '5', '6', '2', '14', '0', '0', '0', '0.361111111', '0', '0', '1.333333333', '1', '0.8333', '4']
package org . apache . camel . processor . idempotent ; public interface MessageIdRepository { boolean contains ( String messageId ) ; } 	0	['1', '1', '0', '4', '1', '0', '4', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . impl . converter . TypeConverterRegistry ; public class CachingInjector < T > { private final TypeConverterRegistry repository ; private final Class < T > type ; private T instance ; public CachingInjector ( TypeConverterRegistry repository , Class < T > type ) { this . repository = repository ; this . type = type ; } public synchronized T newInstance ( ) { if ( instance == null ) { instance = createInstance ( type ) ; } return instance ; } protected T createInstance ( Class < T > t ) { return ( T ) repository . getInjector ( ) . newInstance ( t ) ; } } 	1	['3', '1', '0', '4', '6', '0', '2', '2', '2', '0.5', '33', '1', '1', '0', '0.666666667', '0', '0', '9', '2', '1', '1']
package org . apache . camel . impl ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . CamelContext ; import org . apache . camel . util . IntrospectionSupport ; import java . util . Map ; public abstract class ScheduledPollEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private Map consumerProperties ; protected ScheduledPollEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } protected ScheduledPollEndpoint ( String endpointUri , CamelContext context ) { super ( endpointUri , context ) ; } public Map getConsumerProperties ( ) { return consumerProperties ; } public void setConsumerProperties ( Map consumerProperties ) { this . consumerProperties = consumerProperties ; } protected void configureConsumer ( Consumer < E > consumer ) throws Exception { if ( consumerProperties != null ) { IntrospectionSupport . setProperties ( getContext ( ) . getTypeConverter ( ) , consumer , consumerProperties ) ; } } public void configureProperties ( Map options ) { Map consumerProperties = IntrospectionSupport . extractProperties ( options , "consumer." ) ; if ( consumerProperties != null ) { setConsumerProperties ( consumerProperties ) ; } } } 	0	['6', '2', '4', '11', '12', '9', '5', '6', '3', '0.4', '46', '1', '0', '0.80952381', '0.361111111', '0', '0', '6.5', '2', '0.8333', '0']
package org . apache . camel . processor . resequencer ; import java . util . Queue ; import java . util . Timer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ResequencerEngine < E > implements TimeoutHandler { private static final Log LOG = LogFactory . getLog ( ResequencerEngine . class ) ; private long timeout ; private int capacity ; private Queue < E > outQueue ; private Element < E > lastDelivered ; private Sequence < Element < E > > sequence ; private Timer timer ; public ResequencerEngine ( SequenceElementComparator < E > comparator ) { this ( comparator , Integer . MAX_VALUE ) ; } public ResequencerEngine ( SequenceElementComparator < E > comparator , int capacity ) { this . timer = new Timer ( "Resequencer Timer" ) ; this . sequence = createSequence ( comparator ) ; this . capacity = capacity ; this . timeout = 2000L ; this . lastDelivered = null ; } public void stop ( ) { this . timer . cancel ( ) ; } public Queue < E > getOutQueue ( ) { return outQueue ; } public void setOutQueue ( Queue < E > outQueue ) { this . outQueue = outQueue ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public synchronized void timeout ( Timeout timout ) { try { while ( deliver ( ) ) { } } catch ( RuntimeException e ) { LOG . error ( "error during delivery" , e ) ; } } public synchronized void add ( E o ) { if ( sequence . size ( ) >= capacity ) { throw new IllegalStateException ( "maximum capacity is reached" ) ; } insert ( o ) ; } public synchronized void put ( E o ) throws InterruptedException { if ( sequence . size ( ) >= capacity ) { wait ( ) ; } insert ( o ) ; } E getLastDelivered ( ) { if ( lastDelivered == null ) { return null ; } return lastDelivered . getObject ( ) ; } void setLastDelivered ( E o ) { lastDelivered = new Element < E > ( o ) ; } private void insert ( E o ) { Element < E > element = new Element < E > ( o ) ; sequence . add ( element ) ; Element < E > successor = sequence . successor ( element ) ; if ( successor != null ) { successor . cancel ( ) ; } if ( successorOfLastDelivered ( element ) ) { } else if ( sequence . predecessor ( element ) != null ) { } else { Timeout t = defineTimeout ( ) ; element . schedule ( t ) ; } while ( deliver ( ) ) { } } private boolean deliver ( ) { if ( sequence . size ( ) == 0 ) { return false ; } Element < E > element = sequence . first ( ) ; if ( element . scheduled ( ) ) { return false ; } sequence . remove ( element ) ; lastDelivered = element ; notify ( ) ; outQueue . add ( element . getObject ( ) ) ; return true ; } private boolean successorOfLastDelivered ( Element < E > element ) { if ( lastDelivered == null ) { return false ; } if ( sequence . comparator ( ) . successor ( element , lastDelivered ) ) { return true ; } return false ; } private Timeout defineTimeout ( ) { Timeout result = new Timeout ( timer , timeout ) ; result . addTimeoutHandler ( this ) ; return result ; } private static < E > Sequence < Element < E > > createSequence ( SequenceElementComparator < E > comparator ) { return new Sequence < Element < E > > ( new ElementComparator < E > ( comparator ) ) ; } } 	1	['18', '1', '0', '9', '44', '85', '1', '8', '10', '0.739495798', '242', '1', '3', '0', '0.205882353', '0', '0', '12.05555556', '5', '1.3889', '1']
package org . apache . camel . spi ; import org . apache . camel . Processor ; public interface Policy < E > { Processor wrap ( Processor processor ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public class RuntimeCamelException extends RuntimeException { private static final long serialVersionUID = 8046489554418284257L ; public RuntimeCamelException ( ) { } public RuntimeCamelException ( String message ) { super ( message ) ; } public RuntimeCamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeCamelException ( Throwable cause ) { super ( cause ) ; } } 	1	['4', '4', '15', '49', '8', '6', '49', '0', '4', '1.333333333', '21', '1', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '1']
package org . apache . camel . component . file . remote ; import org . apache . camel . CamelContext ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultComponent ; import java . net . URI ; import java . util . Map ; public class RemoteFileComponent extends DefaultComponent < RemoteFileExchange > { private RemoteFileConfiguration configuration ; public RemoteFileComponent ( ) { this . configuration = new RemoteFileConfiguration ( ) ; } public RemoteFileComponent ( RemoteFileConfiguration configuration ) { this . configuration = configuration ; } public RemoteFileComponent ( CamelContext context ) { super ( context ) ; this . configuration = new RemoteFileConfiguration ( ) ; } public String toString ( ) { return "RemoteFileComponent" ; } public static RemoteFileComponent remoteFileComponent ( ) { return new RemoteFileComponent ( ) ; } protected RemoteFileEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { RemoteFileConfiguration config = getConfiguration ( ) . copy ( ) ; config . configure ( new URI ( uri ) ) ; final RemoteFileEndpoint endpoint ; if ( "ftp" . equals ( config . getProtocol ( ) ) ) { endpoint = new FtpEndpoint ( uri , this , config ) ; } else if ( "sftp" . equals ( config . getProtocol ( ) ) ) { endpoint = new SftpEndpoint ( uri , this , config ) ; } else { throw new RuntimeCamelException ( "Unsupported protocol: " + config . getProtocol ( ) ) ; } setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public RemoteFileConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( RemoteFileConfiguration configuration ) { this . configuration = configuration ; } } 	0	['9', '3', '0', '8', '24', '16', '3', '8', '7', '0.125', '108', '1', '1', '0.793103448', '0.333333333', '2', '3', '10.88888889', '1', '0.6667', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import org . apache . camel . TypeConverter ; public class ArrayTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isArray ( ) ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; Object array = Array . newInstance ( type . getComponentType ( ) , collection . size ( ) ) ; if ( array instanceof Object [ ] ) { collection . toArray ( ( Object [ ] ) array ) ; } else { int index = 0 ; for ( Object element : collection ) { Array . set ( array , index ++ , element ) ; } } return ( T ) array ; } else if ( value != null && value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; Object answer = Array . newInstance ( type . getComponentType ( ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( answer , i , Array . get ( value , i ) ) ; } return ( T ) answer ; } } else if ( Collection . class . isAssignableFrom ( type ) ) { if ( value != null ) { if ( value instanceof Object [ ] ) { return ( T ) Arrays . asList ( ( Object [ ] ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; List answer = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { answer . add ( Array . get ( value , i ) ) ; } return ( T ) answer ; } } } return null ; } } 	1	['2', '1', '0', '2', '19', '1', '1', '1', '2', '2', '121', '0', '0', '0', '0.666666667', '0', '0', '59.5', '13', '6.5', '1']
package org . apache . camel . component . file . remote ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . JSch ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . UserInfo ; import org . apache . camel . Processor ; public class SftpEndpoint extends RemoteFileEndpoint < RemoteFileExchange > { public SftpEndpoint ( String uri , RemoteFileComponent remoteFileComponent , RemoteFileConfiguration configuration ) { super ( uri , remoteFileComponent , configuration ) ; } public SftpProducer createProducer ( ) throws Exception { return new SftpProducer ( this , createChannelSftp ( ) ) ; } public SftpConsumer createConsumer ( Processor processor ) throws Exception { final SftpConsumer consumer = new SftpConsumer ( this , processor , createChannelSftp ( ) ) ; configureConsumer ( consumer ) ; return consumer ; } protected ChannelSftp createChannelSftp ( ) throws JSchException { final JSch jsch = new JSch ( ) ; final Session session = jsch . getSession ( getConfiguration ( ) . getUsername ( ) , getConfiguration ( ) . getHost ( ) ) ; session . setUserInfo ( new UserInfo ( ) { public String getPassphrase ( ) { return null ; } public String getPassword ( ) { return SftpEndpoint . this . getConfiguration ( ) . getPassword ( ) ; } public boolean promptPassword ( String string ) { return true ; } public boolean promptPassphrase ( String string ) { return true ; } public boolean promptYesNo ( String string ) { return true ; } public void showMessage ( String string ) { } } ) ; session . connect ( ) ; final ChannelSftp channel = ( ChannelSftp ) session . openChannel ( "sftp" ) ; channel . connect ( ) ; return channel ; } } 	0	['6', '4', '0', '15', '18', '15', '4', '15', '5', '2', '69', '0', '0', '0.861111111', '0.366666667', '0', '0', '10.5', '1', '0.8333', '0']
package org . apache . camel . component . direct ; import java . util . ArrayList ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DirectEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private final class DirectProducer extends DefaultProducer implements AsyncProcessor { private DirectProducer ( Endpoint endpoint ) { super ( endpoint ) ; } public void process ( Exchange exchange ) throws Exception { if ( consumers . isEmpty ( ) ) { LOG . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } } public boolean process ( Exchange exchange , AsyncCallback callback ) { int size = consumers . size ( ) ; if ( size == 0 ) { LOG . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { if ( size > 1 ) { try { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } catch ( Throwable error ) { exchange . setException ( error ) ; } } else { for ( DefaultConsumer < E > consumer : consumers ) { AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( consumer . getProcessor ( ) ) ; return processor . process ( exchange , callback ) ; } } } callback . done ( true ) ; return true ; } } private static final Log LOG = LogFactory . getLog ( DirectEndpoint . class ) ; boolean allowMultipleConsumers = true ; private final CopyOnWriteArrayList < DefaultConsumer < E > > consumers = new CopyOnWriteArrayList < DefaultConsumer < E > > ( ) ; public DirectEndpoint ( String uri , DirectComponent < E > component ) { super ( uri , component ) ; } public Producer createProducer ( ) throws Exception { return new DirectProducer ( this ) ; } public Consumer < E > createConsumer ( Processor processor ) throws Exception { return new DefaultConsumer < E > ( this , processor ) { @ Override public void start ( ) throws Exception { if ( ! allowMultipleConsumers && ! consumers . isEmpty ( ) ) { throw new IllegalStateException ( "Endpoint " + getEndpointUri ( ) + " only allows 1 active consumer but you attempted to start a 2nd consumer." ) ; } consumers . add ( this ) ; super . start ( ) ; } @ Override public void stop ( ) throws Exception { super . stop ( ) ; consumers . remove ( this ) ; } } ; } public boolean isAllowMultipleConsumers ( ) { return allowMultipleConsumers ; } public void setAllowMultipleConsumers ( boolean allowMutlipleConsumers ) { this . allowMultipleConsumers = allowMutlipleConsumers ; } public boolean isSingleton ( ) { return true ; } } 	1	['9', '2', '0', '11', '14', '26', '3', '11', '6', '0.833333333', '57', '0.666666667', '1', '0.708333333', '0.229166667', '0', '0', '5', '1', '0.7778', '1']
package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . CronTrigger ; import org . quartz . JobDetail ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . SchedulerFactory ; import org . quartz . Trigger ; import org . quartz . impl . StdSchedulerFactory ; import java . net . URI ; import java . util . Map ; public class QuartzComponent extends DefaultComponent < QuartzExchange > { private static final transient Log LOG = LogFactory . getLog ( QuartzComponent . class ) ; private SchedulerFactory factory ; private Scheduler scheduler ; private Map < Trigger , JobDetail > triggers ; public QuartzComponent ( ) { } public QuartzComponent ( CamelContext context ) { super ( context ) ; } @ Override protected QuartzEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { QuartzEndpoint answer = new QuartzEndpoint ( uri , this , getScheduler ( ) ) ; URI u = new URI ( uri ) ; String name ; String group = "Camel" ; String path = u . getPath ( ) ; CronTrigger cronTrigger = null ; if ( path != null && path . length ( ) > 1 ) { if ( path . startsWith ( "/" ) ) { path = path . substring ( 1 ) ; } int idx = path . indexOf ( '/' ) ; if ( idx > 0 ) { cronTrigger = new CronTrigger ( ) ; name = path . substring ( 0 , idx ) ; String cronExpression = path . substring ( idx + 1 ) ; cronExpression = cronExpression . replace ( '/' , ' ' ) ; cronExpression = cronExpression . replace ( '$' , '?' ) ; LOG . debug ( "Creating cron trigger: " + cronExpression ) ; cronTrigger . setCronExpression ( cronExpression ) ; answer . setTrigger ( cronTrigger ) ; } else { name = path ; } group = u . getHost ( ) ; } else { name = u . getHost ( ) ; } Trigger trigger = cronTrigger ; if ( trigger == null ) { trigger = answer . getTrigger ( ) ; } trigger . setName ( name ) ; trigger . setGroup ( group ) ; Map triggerParameters = IntrospectionSupport . extractProperties ( parameters , "trigger." ) ; Map jobParameters = IntrospectionSupport . extractProperties ( parameters , "job." ) ; setProperties ( trigger , triggerParameters ) ; setProperties ( answer . getJobDetail ( ) , jobParameters ) ; return answer ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getScheduler ( ) . start ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( scheduler != null ) { scheduler . shutdown ( ) ; } super . doStop ( ) ; } public SchedulerFactory getFactory ( ) { if ( factory == null ) { factory = createSchedulerFactory ( ) ; } return factory ; } public void setFactory ( SchedulerFactory factory ) { this . factory = factory ; } public Scheduler getScheduler ( ) throws SchedulerException { if ( scheduler == null ) { scheduler = createScheduler ( ) ; } return scheduler ; } public void setScheduler ( Scheduler scheduler ) { this . scheduler = scheduler ; } public Map getTriggers ( ) { return triggers ; } public void setTriggers ( Map triggers ) { this . triggers = triggers ; } protected SchedulerFactory createSchedulerFactory ( ) { return new StdSchedulerFactory ( ) ; } protected Scheduler createScheduler ( ) throws SchedulerException { return getFactory ( ) . getScheduler ( ) ; } } 	0	['15', '3', '0', '14', '46', '93', '1', '14', '8', '0.821428571', '217', '1', '1', '0.657142857', '0.261904762', '2', '3', '13.2', '2', '0.8667', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class NoErrorHandlerBuilder extends ErrorHandlerBuilderSupport { public ErrorHandlerBuilder copy ( ) { return this ; } public Processor createErrorHandler ( Processor processor ) { return processor ; } } 	1	['3', '2', '0', '5', '4', '3', '2', '3', '3', '2', '10', '0', '0', '0.5', '0.666666667', '0', '0', '2.333333333', '1', '0.6667', '1']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; public class ProcessorEndpoint extends DefaultPollingEndpoint < Exchange > { private final Processor processor ; public ProcessorEndpoint ( String endpointUri , CamelContext context , Processor processor ) { super ( endpointUri , context ) ; this . processor = processor ; } public ProcessorEndpoint ( String endpointUri , Component component , Processor processor ) { super ( endpointUri , component ) ; this . processor = processor ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } @ Override public PollingConsumer < Exchange > createPollingConsumer ( ) throws Exception { return new ProcessorPollingConsumer ( this , getProcessor ( ) ) ; } public Processor getProcessor ( ) { if ( processor == null ) { return new Processor ( ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } return processor ; } protected void onExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; } public boolean isSingleton ( ) { return true ; } } 	0	['7', '4', '1', '18', '13', '9', '9', '11', '6', '0.333333333', '55', '1', '1', '0.814814815', '0.333333333', '0', '0', '6.714285714', '2', '0.8571', '0']
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; public enum ExchangePattern { InOnly , RobustInOnly , InOut , InOptionalOut , OutOnly , RobustOutOnly , OutIn , OutOptionalIn ; protected static final Map < String , ExchangePattern > map = new HashMap < String , ExchangePattern > ( ) ; public String getWsdlUri ( ) { switch ( this ) { case InOnly : return "http://www.w3.org/ns/wsdl/in-only" ; case InOptionalOut : return "http://www.w3.org/ns/wsdl/in-optional-out" ; case InOut : return "http://www.w3.org/ns/wsdl/in-out" ; case OutIn : return "http://www.w3.org/ns/wsdl/out-in" ; case OutOnly : return "http://www.w3.org/ns/wsdl/out-only" ; case OutOptionalIn : return "http://www.w3.org/ns/wsdl/out-optional_in" ; case RobustInOnly : return "http://www.w3.org/ns/wsdl/robust-in-only" ; case RobustOutOnly : return "http://www.w3.org/ns/wsdl/robust-out-only" ; default : throw new IllegalArgumentException ( "Unknown message exchange pattern: " + this ) ; } } public boolean isInCapable ( ) { switch ( this ) { case OutOnly : case RobustOutOnly : return true ; default : return false ; } } public boolean isOutCapable ( ) { switch ( this ) { case InOnly : case RobustInOnly : return false ; default : return true ; } } public boolean isFaultCapable ( ) { switch ( this ) { case InOnly : case OutOnly : return false ; default : return true ; } } public static ExchangePattern fromWsdlUri ( String wsdlUri ) { return map . get ( wsdlUri ) ; } static { for ( ExchangePattern mep : values ( ) ) { String uri = mep . getWsdlUri ( ) ; map . put ( uri , mep ) ; String name = uri . substring ( uri . lastIndexOf ( '/' ) ) ; map . put ( "http://www.w3.org/2004/08/wsdl/" + name , mep ) ; map . put ( "http://www.w3.org/2006/01/wsdl/" + name , mep ) ; } } } 	1	['9', '2', '0', '40', '23', '32', '39', '2', '7', '0.975', '240', '0.2', '9', '0.631578947', '0.375', '1', '1', '24.55555556', '4', '1.8889', '1']
package org . apache . camel . processor . resequencer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public interface ExpressionResultComparator < E extends Exchange > extends SequenceElementComparator < E > { void setExpressions ( List < Expression > expressions ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import org . apache . camel . processor . RedeliveryPolicy ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "redeliveryPolicy" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RedeliveryPolicyType { private Integer maximumRedeliveries ; private Long initialRedeliveryDelay ; private Double backOffMultiplier ; private Boolean useExponentialBackOff ; private Double collisionAvoidanceFactor ; private Boolean useCollisionAvoidance ; public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; if ( maximumRedeliveries != null ) { answer . setMaximumRedeliveries ( maximumRedeliveries ) ; } if ( initialRedeliveryDelay != null ) { answer . setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; } if ( backOffMultiplier != null ) { answer . setBackOffMultiplier ( backOffMultiplier ) ; } if ( useExponentialBackOff != null ) { answer . setUseExponentialBackOff ( useExponentialBackOff ) ; } if ( collisionAvoidanceFactor != null ) { answer . setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; } if ( useCollisionAvoidance != null ) { answer . setUseCollisionAvoidance ( useCollisionAvoidance ) ; } return answer ; } public String toString ( ) { return "RedeliveryPolicy[maxRedeliveries: " + maximumRedeliveries + "]" ; } public RedeliveryPolicyType backOffMultiplier ( double backOffMultiplier ) { setBackOffMultiplier ( backOffMultiplier ) ; return this ; } public RedeliveryPolicyType collisionAvoidancePercent ( double collisionAvoidancePercent ) { setCollisionAvoidanceFactor ( collisionAvoidancePercent * 0.01d ) ; return this ; } public RedeliveryPolicyType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public RedeliveryPolicyType initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicyType maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicyType useCollisionAvoidance ( ) { setUseCollisionAvoidance ( true ) ; return this ; } public RedeliveryPolicyType useExponentialBackOff ( ) { setUseExponentialBackOff ( true ) ; return this ; } public Double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( Double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public Double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( Double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public Long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( Long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public Integer getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( Integer maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public Boolean getUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( Boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public Boolean getUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( Boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } } 	1	['22', '1', '0', '2', '42', '189', '1', '1', '22', '0.841269841', '182', '1', '0', '0', '0.171717172', '0', '0', '7', '7', '1.2273', '2']
package org . apache . camel . builder . script ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import javax . script . Compilable ; import javax . script . CompiledScript ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptEngineManager ; import javax . script . ScriptException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; public class ScriptBuilder < E extends Exchange > implements Expression < E > , Predicate < E > , Processor { private static final transient Log LOG = LogFactory . getLog ( ScriptBuilder . class ) ; private String scriptEngineName ; private Resource scriptResource ; private String scriptText ; private ScriptEngine engine ; private CompiledScript compiledScript ; public ScriptBuilder ( String scriptEngineName ) { this . scriptEngineName = scriptEngineName ; } public ScriptBuilder ( String scriptEngineName , String scriptText ) { this ( scriptEngineName ) ; this . scriptText = scriptText ; } public ScriptBuilder ( String scriptEngineName , Resource scriptResource ) { this ( scriptEngineName ) ; this . scriptResource = scriptResource ; } @ Override public String toString ( ) { return getScriptDescription ( ) ; } public Object evaluate ( E exchange ) { return evaluateScript ( exchange ) ; } public boolean matches ( E exchange ) { Object scriptValue = evaluateScript ( exchange ) ; return matches ( exchange , scriptValue ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object scriptValue = evaluateScript ( exchange ) ; if ( ! matches ( exchange , scriptValue ) ) { throw new AssertionError ( this + " failed on " + exchange + " as script returned <" + scriptValue + ">" ) ; } } public void process ( Exchange exchange ) { evaluateScript ( exchange ) ; } public ScriptBuilder attribute ( String name , Object value ) { getScriptContext ( ) . setAttribute ( name , value , ScriptContext . ENGINE_SCOPE ) ; return this ; } public static ScriptBuilder script ( String language , String scriptText ) { return new ScriptBuilder ( language , scriptText ) ; } public static ScriptBuilder script ( String language , Resource scriptResource ) { return new ScriptBuilder ( language , scriptResource ) ; } public static ScriptBuilder script ( String language , File scriptFile ) { return new ScriptBuilder ( language , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder script ( String language , URL scriptURL ) { return new ScriptBuilder ( language , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder groovy ( String scriptText ) { return new ScriptBuilder ( "groovy" , scriptText ) ; } public static ScriptBuilder groovy ( Resource scriptResource ) { return new ScriptBuilder ( "groovy" , scriptResource ) ; } public static ScriptBuilder groovy ( File scriptFile ) { return new ScriptBuilder ( "groovy" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder groovy ( URL scriptURL ) { return new ScriptBuilder ( "groovy" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder javaScript ( String scriptText ) { return new ScriptBuilder ( "js" , scriptText ) ; } public static ScriptBuilder javaScript ( Resource scriptResource ) { return new ScriptBuilder ( "js" , scriptResource ) ; } public static ScriptBuilder javaScript ( File scriptFile ) { return new ScriptBuilder ( "js" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder javaScript ( URL scriptURL ) { return new ScriptBuilder ( "js" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder php ( String scriptText ) { return new ScriptBuilder ( "php" , scriptText ) ; } public static ScriptBuilder php ( Resource scriptResource ) { return new ScriptBuilder ( "php" , scriptResource ) ; } public static ScriptBuilder php ( File scriptFile ) { return new ScriptBuilder ( "php" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder php ( URL scriptURL ) { return new ScriptBuilder ( "php" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder python ( String scriptText ) { return new ScriptBuilder ( "python" , scriptText ) ; } public static ScriptBuilder python ( Resource scriptResource ) { return new ScriptBuilder ( "python" , scriptResource ) ; } public static ScriptBuilder python ( File scriptFile ) { return new ScriptBuilder ( "python" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder python ( URL scriptURL ) { return new ScriptBuilder ( "python" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder ruby ( String scriptText ) { return new ScriptBuilder ( "jruby" , scriptText ) ; } public static ScriptBuilder ruby ( Resource scriptResource ) { return new ScriptBuilder ( "jruby" , scriptResource ) ; } public static ScriptBuilder ruby ( File scriptFile ) { return new ScriptBuilder ( "jruby" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder ruby ( URL scriptURL ) { return new ScriptBuilder ( "jruby" , new UrlResource ( scriptURL ) ) ; } public ScriptEngine getEngine ( ) { checkInitialised ( ) ; if ( engine == null ) { throw new IllegalArgumentException ( "No script engine could be created for: " + getScriptEngineName ( ) ) ; } return engine ; } public CompiledScript getCompiledScript ( ) { return compiledScript ; } public String getScriptText ( ) { return scriptText ; } public void setScriptText ( String scriptText ) { this . scriptText = scriptText ; } public String getScriptEngineName ( ) { return scriptEngineName ; } public String getScriptDescription ( ) { if ( scriptText != null ) { return scriptEngineName + ": " + scriptText ; } else if ( scriptResource != null ) { return scriptEngineName + ": " + scriptResource . getDescription ( ) ; } else { return scriptEngineName + ": null script" ; } } public ScriptContext getScriptContext ( ) { return getEngine ( ) . getContext ( ) ; } public void setScriptContext ( ScriptContext scriptContext ) { getEngine ( ) . setContext ( scriptContext ) ; } public Resource getScriptResource ( ) { return scriptResource ; } public void setScriptResource ( Resource scriptResource ) { this . scriptResource = scriptResource ; } protected void checkInitialised ( ) { if ( scriptText == null && scriptResource == null ) { throw new IllegalArgumentException ( "Neither scriptText or scriptResource are specified" ) ; } if ( engine == null ) { engine = createScriptEngine ( ) ; } if ( compiledScript == null ) { if ( engine instanceof Compilable ) { compileScript ( ( Compilable ) engine ) ; } } } protected boolean matches ( E exchange , Object scriptValue ) { return ObjectConverter . toBoolean ( scriptValue ) ; } protected ScriptEngine createScriptEngine ( ) { ScriptEngineManager manager = new ScriptEngineManager ( ) ; return manager . getEngineByName ( scriptEngineName ) ; } protected void compileScript ( Compilable compilable ) { try { if ( scriptText != null ) { compiledScript = compilable . compile ( scriptText ) ; } else if ( scriptResource != null ) { compiledScript = compilable . compile ( createScriptReader ( ) ) ; } } catch ( ScriptException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Script compile failed: " + e , e ) ; } throw createScriptCompileException ( e ) ; } catch ( IOException e ) { throw createScriptCompileException ( e ) ; } } protected synchronized Object evaluateScript ( Exchange exchange ) { try { getScriptContext ( ) ; populateBindings ( getEngine ( ) , exchange ) ; return runScript ( ) ; } catch ( ScriptException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Script evaluation failed: " + e , e ) ; } throw createScriptEvaluationException ( e . getCause ( ) ) ; } catch ( IOException e ) { throw createScriptEvaluationException ( e ) ; } } protected Object runScript ( ) throws ScriptException , IOException { checkInitialised ( ) ; if ( compiledScript != null ) { return compiledScript . eval ( ) ; } else { if ( scriptText != null ) { return getEngine ( ) . eval ( scriptText ) ; } else { return getEngine ( ) . eval ( createScriptReader ( ) ) ; } } } protected void populateBindings ( ScriptEngine engine , Exchange exchange ) { ScriptContext context = engine . getContext ( ) ; int scope = ScriptContext . ENGINE_SCOPE ; context . setAttribute ( "context" , exchange . getContext ( ) , scope ) ; context . setAttribute ( "exchange" , exchange , scope ) ; context . setAttribute ( "request" , exchange . getIn ( ) , scope ) ; context . setAttribute ( "response" , exchange . getOut ( ) , scope ) ; } protected InputStreamReader createScriptReader ( ) throws IOException { return new InputStreamReader ( scriptResource . getInputStream ( ) ) ; } protected ScriptEvaluationException createScriptCompileException ( Exception e ) { return new ScriptEvaluationException ( "Failed to compile: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } protected ScriptEvaluationException createScriptEvaluationException ( Throwable e ) { return new ScriptEvaluationException ( "Failed to evaluate: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } } 	0	['56', '1', '0', '14', '88', '1436', '1', '13', '45', '0.663636364', '650', '1', '1', '0', '0.125757576', '0', '0', '10.5', '6', '1.125', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Processor ; public abstract class LoadBalancerSupport implements LoadBalancer { private List < Processor > processors = new CopyOnWriteArrayList < Processor > ( ) ; public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public void removeProcessor ( Processor processor ) { processors . remove ( processor ) ; } public List < Processor > getProcessors ( ) { return processors ; } } 	1	['4', '1', '2', '4', '8', '0', '2', '2', '4', '0', '28', '1', '0', '0', '0.75', '0', '0', '5.75', '1', '0.75', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . soap . model . SoapBindingInfo ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . helpers . DOMUtils ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . MessagePartInfo ; public class SoapMessageInInterceptor extends AbstractMessageInInterceptor < SoapMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( SoapMessageInInterceptor . class ) ; public SoapMessageInInterceptor ( ) { super ( Phase . READ ) ; } protected Logger getLogger ( ) { return LOG ; } protected boolean isFaultMessage ( SoapMessage message ) { return false ; } protected BindingOperationInfo getBindingOperation ( SoapMessage message , Document doc ) { Exchange ex = message . getExchange ( ) ; SoapBindingInfo soapBinding = ( SoapBindingInfo ) ex . get ( BindingInfo . class ) ; Element payloadEl = ( Element ) doc . getChildNodes ( ) . item ( 0 ) ; QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; boolean client = isRequestor ( message ) ; List < BindingOperationInfo > boiList = new ArrayList < BindingOperationInfo > ( ) ; for ( BindingOperationInfo boi : soapBinding . getOperations ( ) ) { String style = soapBinding . getStyle ( boi . getOperationInfo ( ) ) ; QName rootName = null ; if ( "rpc" . equals ( style ) ) { rootName = boi . getOperationInfo ( ) . getName ( ) ; } else { BindingMessageInfo bmi = client ? boi . getOutput ( ) : boi . getInput ( ) ; if ( bmi != null ) { Collection < MessagePartInfo > bodyParts = bmi . getMessageParts ( ) ; if ( bodyParts . size ( ) == 1 ) { MessagePartInfo p = bodyParts . iterator ( ) . next ( ) ; rootName = p . getConcreteName ( ) ; } } } if ( startQName . equals ( rootName ) ) { boiList . add ( boi ) ; } } if ( boiList . size ( ) > 1 && LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "Mulitple matching BindingOperationIno found in Binding." ) ; } return boiList . size ( ) != 1 ? null : boiList . get ( 0 ) ; } protected List < Element > getPartList ( SoapMessage inMessage , Element rootNode , BindingMessageInfo bmi ) { List < Element > partList = new ArrayList < Element > ( ) ; Exchange ex = inMessage . getExchange ( ) ; SoapBindingInfo soapBinding = ( SoapBindingInfo ) ex . get ( BindingInfo . class ) ; String style = soapBinding . getStyle ( bmi . getBindingOperation ( ) . getOperationInfo ( ) ) ; if ( "rpc" . equals ( style ) ) { rootNode = ( Element ) DOMUtils . getChild ( rootNode , Node . ELEMENT_NODE ) ; } partList . add ( rootNode ) ; return partList ; } protected Element getHeader ( SoapMessage inMessage ) { Element element = null ; return element ; } } 	0	['11', '1', '0', '12', '43', '49', '1', '11', '1', '0.7', '197', '1', '0', '0.470588235', '0.4', '1', '4', '16.81818182', '9', '1.6364', '0']
package org . apache . camel . processor ; import java . util . concurrent . RejectedExecutionException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor { public static final String REDELIVERY_COUNTER = "org.apache.camel.RedeliveryCounter" ; public static final String REDELIVERED = "org.apache.camel.Redelivered" ; private class RedeliveryData { int redeliveryCounter ; long redeliveryDelay ; boolean sync = true ; RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy ; Processor failureProcessor = deadLetter ; } private static final transient Log LOG = LogFactory . getLog ( DeadLetterChannel . class ) ; private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel . class . getName ( ) + ".FAILURE_HANDLED" ; private Processor output ; private Processor deadLetter ; private AsyncProcessor outputAsync ; private RedeliveryPolicy redeliveryPolicy ; private Logger logger ; public DeadLetterChannel ( Processor output , Processor deadLetter ) { this ( output , deadLetter , new RedeliveryPolicy ( ) , DeadLetterChannel . createDefaultLogger ( ) ) ; } public DeadLetterChannel ( Processor output , Processor deadLetter , RedeliveryPolicy redeliveryPolicy , Logger logger ) { this . deadLetter = deadLetter ; this . output = output ; this . outputAsync = AsyncProcessorTypeConverter . convert ( output ) ; this . redeliveryPolicy = redeliveryPolicy ; this . logger = logger ; } public static < E extends Exchange > Logger createDefaultLogger ( ) { return new Logger ( LOG , LoggingLevel . ERROR ) ; } @ Override public String toString ( ) { return "DeadLetterChannel[" + output + ", " + deadLetter + ", " + redeliveryPolicy + "]" ; } public boolean process ( Exchange exchange , final AsyncCallback callback ) { return process ( exchange , callback , new RedeliveryData ( ) ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { while ( true ) { if ( ! isRunAllowed ( ) ) { if ( exchange . getException ( ) == null ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( data . sync ) ; return data . sync ; } if ( exchange . getException ( ) != null ) { Throwable e = exchange . getException ( ) ; exchange . setException ( null ) ; logger . log ( "On delivery attempt: " + data . redeliveryCounter + " caught: " + e , e ) ; data . redeliveryCounter = incrementRedeliveryCounter ( exchange , e ) ; ExceptionType exceptionPolicy = getExceptionPolicy ( exchange , e ) ; if ( exceptionPolicy != null ) { data . currentRedeliveryPolicy = exceptionPolicy . createRedeliveryPolicy ( data . currentRedeliveryPolicy ) ; Processor processor = exceptionPolicy . getErrorHandler ( ) ; if ( processor != null ) { data . failureProcessor = processor ; } } } if ( ! data . currentRedeliveryPolicy . shouldRedeliver ( data . redeliveryCounter ) ) { setFailureHandled ( exchange , true ) ; AsyncProcessor afp = AsyncProcessorTypeConverter . convert ( data . failureProcessor ) ; return afp . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( data . sync ) ; } } ) ; } if ( data . redeliveryCounter > 0 ) { data . redeliveryDelay = data . currentRedeliveryPolicy . getRedeliveryDelay ( data . redeliveryDelay ) ; sleep ( data . redeliveryDelay ) ; } exchange . setException ( null ) ; boolean sync = outputAsync . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } data . sync = false ; if ( exchange . getException ( ) != null ) { process ( exchange , callback , data ) ; } else { callback . done ( sync ) ; } } } ) ; if ( ! sync ) { return false ; } if ( exchange . getException ( ) == null || isFailureHandled ( exchange ) ) { callback . done ( true ) ; return true ; } } } public static boolean isFailureHandled ( Exchange exchange ) { Boolean rc = exchange . getProperty ( FAILURE_HANDLED_PROPERTY , Boolean . class ) ; return rc == null ? false : rc ; } public static void setFailureHandled ( Exchange exchange , boolean b ) { exchange . setProperty ( FAILURE_HANDLED_PROPERTY , b ? Boolean . TRUE : Boolean . FALSE ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public Processor getOutput ( ) { return output ; } public Processor getDeadLetter ( ) { return deadLetter ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } protected int incrementRedeliveryCounter ( Exchange exchange , Throwable e ) { Message in = exchange . getIn ( ) ; Integer counter = in . getHeader ( REDELIVERY_COUNTER , Integer . class ) ; int next = 1 ; if ( counter != null ) { next = counter + 1 ; } in . setHeader ( REDELIVERY_COUNTER , next ) ; in . setHeader ( REDELIVERED , true ) ; exchange . setException ( e ) ; return next ; } protected void sleep ( long redeliveryDelay ) { if ( redeliveryDelay > 0 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + redeliveryDelay + " until attempting redelivery" ) ; } try { Thread . sleep ( redeliveryDelay ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Thread interupted: " + e , e ) ; } } } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output , deadLetter ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( deadLetter , output ) ; } } 	1	['22', '3', '0', '20', '65', '151', '5', '18', '15', '0.846560847', '401', '0.777777778', '6', '0.457142857', '0.155844156', '1', '1', '16.81818182', '10', '1.5455', '7']
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; public interface LanguageResolver { Language resolveLanguage ( String name , CamelContext context ) ; } 	0	['1', '1', '0', '5', '1', '0', '3', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . resequencer ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SequenceSender extends Thread { private static final Log LOG = LogFactory . getLog ( SequenceSender . class ) ; private static final Exchange STOP = createStopSignal ( ) ; private BlockingQueue < Exchange > queue ; private Processor processor ; public SequenceSender ( Processor processor ) { this . processor = processor ; } public void setQueue ( BlockingQueue < Exchange > queue ) { this . queue = queue ; } public void run ( ) { while ( true ) { try { Exchange exchange = queue . take ( ) ; if ( exchange == STOP ) { LOG . info ( "exit processing loop after cancellation" ) ; return ; } processor . process ( exchange ) ; } catch ( InterruptedException e ) { LOG . info ( "exit processing loop after interrupt" ) ; return ; } catch ( Exception e ) { LOG . warn ( "exception during exchange processing" ) ; } } } public void cancel ( ) throws InterruptedException { queue . put ( STOP ) ; } private static Exchange createStopSignal ( ) { return ( Exchange ) Proxy . newProxyInstance ( SequenceSender . class . getClassLoader ( ) , new Class [ ] { Exchange . class } , createStopHandler ( ) ) ; } private static InvocationHandler createStopHandler ( ) { return new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { throw new RuntimeException ( "illegal method invocation on stop signal" ) ; } } ; } } 	1	['7', '2', '0', '6', '17', '9', '1', '5', '4', '0.75', '75', '1', '3', '0.923076923', '0.333333333', '0', '0', '9.142857143', '2', '0.8571', '1']
package org . apache . camel ; public interface TypeConverter { < T > T convertTo ( Class < T > type , Object value ) ; } 	0	['1', '1', '0', '28', '1', '0', '28', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . spi ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import org . apache . camel . Service ; import org . apache . camel . management . CamelNamingStrategy ; public interface InstrumentationAgent extends Service { void register ( Object obj , ObjectName name ) throws JMException ; void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException ; void unregister ( ObjectName name ) throws JMException ; MBeanServer getMBeanServer ( ) ; CamelNamingStrategy getNamingStrategy ( ) ; } 	1	['5', '1', '0', '5', '5', '10', '3', '2', '5', '2', '5', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . irc ; import org . apache . camel . Processor ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcEndpoint extends DefaultEndpoint < IrcExchange > { private IrcBinding binding ; private IrcConfiguration configuration ; private IrcComponent component ; public IrcEndpoint ( String endpointUri , IrcComponent component , IrcConfiguration configuration ) { super ( endpointUri , component ) ; this . component = component ; this . configuration = configuration ; } public boolean isSingleton ( ) { return true ; } public IrcExchange createExchange ( ExchangePattern pattern ) { return new IrcExchange ( getContext ( ) , pattern , getBinding ( ) ) ; } public IrcExchange createOnPrivmsgExchange ( String target , IRCUser user , String msg ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "PRIVMSG" , target , user , msg ) ) ; } public IrcExchange createOnNickExchange ( IRCUser user , String newNick ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "NICK" , user , newNick ) ) ; } public IrcExchange createOnQuitExchange ( IRCUser user , String msg ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "QUIT" , user , msg ) ) ; } public IrcExchange createOnJoinExchange ( String channel , IRCUser user ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "JOIN" , channel , user ) ) ; } public IrcExchange createOnKickExchange ( String channel , IRCUser user , String whoWasKickedNick , String msg ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "KICK" , channel , user , whoWasKickedNick , msg ) ) ; } public IrcExchange createOnModeExchange ( String channel , IRCUser user , IRCModeParser modeParser ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "MODE" , channel , user , modeParser . getLine ( ) ) ) ; } public IrcExchange createOnPartExchange ( String channel , IRCUser user , String msg ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "PART" , channel , user , msg ) ) ; } public IrcExchange createOnTopicExchange ( String channel , IRCUser user , String topic ) { return new IrcExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "TOPIC" , channel , user , topic ) ) ; } public IrcProducer createProducer ( ) throws Exception { return new IrcProducer ( this , component . getIRCConnection ( configuration ) ) ; } public IrcConsumer createConsumer ( Processor processor ) throws Exception { return new IrcConsumer ( this , processor , component . getIRCConnection ( configuration ) ) ; } public IrcComponent getComponent ( ) { return component ; } public void setComponent ( IrcComponent component ) { this . component = component ; } public IrcBinding getBinding ( ) { if ( binding == null ) { binding = new IrcBinding ( ) ; } return binding ; } public void setBinding ( IrcBinding binding ) { this . binding = binding ; } public IrcConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( IrcConfiguration configuration ) { this . configuration = configuration ; } } 	0	['23', '2', '0', '19', '33', '217', '4', '18', '23', '0.636363636', '247', '1', '3', '0.435897436', '0.241545894', '1', '2', '9.608695652', '2', '1', '0']
package org . apache . camel . component . file ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . component . file . strategy . DefaultFileRenamer ; import org . apache . camel . component . file . strategy . DeleteFileProcessStrategy ; import org . apache . camel . component . file . strategy . FileProcessStrategy ; import org . apache . camel . component . file . strategy . FileProcessStrategySupport ; import org . apache . camel . component . file . strategy . NoOpFileProcessStrategy ; import org . apache . camel . component . file . strategy . RenameFileProcessStrategy ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileEndpoint . class ) ; private File file ; private FileProcessStrategy fileProcessStrategy ; private boolean autoCreate = true ; private boolean lock = true ; private boolean delete ; private boolean noop ; private boolean append = true ; private String moveNamePrefix ; private String moveNamePostfix ; private String [ ] excludedNamePrefixes = { "." } ; private String [ ] excludedNamePostfixes = { FileProcessStrategySupport . DEFAULT_LOCK_FILE_POSTFIX } ; private int bufferSize = 128 * 1024 ; private boolean ignoreFileNameHeader ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor file ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , file ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getContext ( ) , getExchangePattern ( ) , file ) ; } public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } public FileExchange createExchange ( ExchangePattern pattern ) { return new FileExchange ( getContext ( ) , pattern , file ) ; } public void configureMessage ( File file , Message message ) { message . setBody ( file ) ; String path = file . getPath ( ) ; String relativePath = path . substring ( path . length ( ) ) ; if ( relativePath . startsWith ( File . separator ) || relativePath . startsWith ( "/" ) ) { relativePath = relativePath . substring ( 1 ) ; } message . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } public File getFile ( ) { if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } public FileProcessStrategy getFileStrategy ( ) { if ( fileProcessStrategy == null ) { fileProcessStrategy = createFileStrategy ( ) ; LOG . debug ( "" + this + " using strategy: " + fileProcessStrategy ) ; } return fileProcessStrategy ; } public void setFileStrategy ( FileProcessStrategy fileProcessStrategy ) { this . fileProcessStrategy = fileProcessStrategy ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public boolean isLock ( ) { return lock ; } public void setLock ( boolean lock ) { this . lock = lock ; } public String getMoveNamePostfix ( ) { return moveNamePostfix ; } public void setMoveNamePostfix ( String moveNamePostfix ) { this . moveNamePostfix = moveNamePostfix ; } public String getMoveNamePrefix ( ) { return moveNamePrefix ; } public void setMoveNamePrefix ( String moveNamePrefix ) { this . moveNamePrefix = moveNamePrefix ; } public String [ ] getExcludedNamePrefixes ( ) { return excludedNamePrefixes ; } public void setExcludedNamePrefixes ( String [ ] excludedNamePrefixes ) { this . excludedNamePrefixes = excludedNamePrefixes ; } public String [ ] getExcludedNamePostfixes ( ) { return excludedNamePostfixes ; } public void setExcludedNamePostfixes ( String [ ] excludedNamePostfixes ) { this . excludedNamePostfixes = excludedNamePostfixes ; } public boolean isNoop ( ) { return noop ; } public void setNoop ( boolean noop ) { this . noop = noop ; } public boolean isAppend ( ) { return append ; } public void setAppend ( boolean append ) { this . append = append ; } public int getBufferSize ( ) { return bufferSize ; } public void setBufferSize ( int bufferSize ) { this . bufferSize = bufferSize ; } public boolean isIgnoreFileNameHeader ( ) { return ignoreFileNameHeader ; } public void setIgnoreFileNameHeader ( boolean ignoreFileNameHeader ) { this . ignoreFileNameHeader = ignoreFileNameHeader ; } protected FileProcessStrategy createFileStrategy ( ) { if ( isNoop ( ) ) { return new NoOpFileProcessStrategy ( ) ; } else if ( moveNamePostfix != null || moveNamePrefix != null ) { if ( isDelete ( ) ) { throw new IllegalArgumentException ( "You cannot set the deleteFiles property and a moveFilenamePostfix or moveFilenamePrefix" ) ; } return new RenameFileProcessStrategy ( isLock ( ) , moveNamePrefix , moveNamePostfix ) ; } else if ( isDelete ( ) ) { return new DeleteFileProcessStrategy ( isLock ( ) ) ; } else { return new RenameFileProcessStrategy ( isLock ( ) ) ; } } } 	1	['37', '3', '0', '21', '61', '598', '8', '19', '34', '0.932539683', '335', '1', '2', '0.375', '0.143939394', '1', '1', '7.675675676', '6', '1.2162', '8']
package org . apache . camel . component . quartz ; import org . quartz . Job ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; public class CamelJob implements Job { public void execute ( JobExecutionContext context ) throws JobExecutionException { QuartzEndpoint component = ( QuartzEndpoint ) context . getJobDetail ( ) . getJobDataMap ( ) . get ( QuartzEndpoint . ENDPOINT_KEY ) ; if ( component == null ) { throw new JobExecutionException ( "No quartz endpoint available for key: " + QuartzEndpoint . ENDPOINT_KEY + ". Bad job data map" ) ; } component . onJobExecute ( context ) ; } } 	0	['2', '1', '0', '6', '8', '1', '0', '6', '2', '2', '23', '0', '0', '0', '0.75', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import java . util . Collection ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "onException" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExceptionType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElement ( name = "redeliveryPolicy" , required = false ) private RedeliveryPolicyType redeliveryPolicy ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; @ XmlTransient private Processor errorHandler ; public ExceptionType ( ) { } public ExceptionType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public ExceptionType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Exception[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { if ( redeliveryPolicy != null ) { return redeliveryPolicy . createRedeliveryPolicy ( parentPolicy ) ; } else if ( errorHandler != null ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; answer . setMaximumRedeliveries ( 0 ) ; return answer ; } return parentPolicy ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { errorHandler = routeContext . createProcessor ( this ) ; ErrorHandlerBuilder builder = routeContext . getRoute ( ) . getErrorHandlerBuilder ( ) ; builder . addErrorHandlers ( this ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public ExceptionType backOffMultiplier ( double backOffMultiplier ) { getOrCreateRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public ExceptionType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public ExceptionType collisionAvoidancePercent ( short collisionAvoidancePercent ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public ExceptionType initialRedeliveryDelay ( long initialRedeliveryDelay ) { getOrCreateRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public ExceptionType maximumRedeliveries ( int maximumRedeliveries ) { getOrCreateRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public ExceptionType useCollisionAvoidance ( ) { getOrCreateRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public ExceptionType useExponentialBackOff ( ) { getOrCreateRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } public Processor getErrorHandler ( ) { return errorHandler ; } public RedeliveryPolicyType getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicyType redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } protected RedeliveryPolicyType getOrCreateRedeliveryPolicy ( ) { if ( redeliveryPolicy == null ) { redeliveryPolicy = new RedeliveryPolicyType ( ) ; } return redeliveryPolicy ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1	['28', '2', '0', '14', '58', '302', '7', '9', '26', '0.802469136', '303', '1', '2', '0.788135593', '0.146103896', '1', '4', '9.607142857', '3', '1.0714', '3']
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . view . RouteDotGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . ClassPathXmlApplicationContext ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public class Main extends ServiceSupport { private static final Log LOG = LogFactory . getLog ( Main . class ) ; private String applicationContextUri = "META-INF/spring/*.xml" ; private AbstractApplicationContext applicationContext ; private List < Option > options = new ArrayList < Option > ( ) ; private CountDownLatch latch = new CountDownLatch ( 1 ) ; private AtomicBoolean completed = new AtomicBoolean ( false ) ; private long duration = - 1 ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; private String dotOutputDir ; public Main ( ) { addOption ( new Option ( "h" , "help" , "Displays the help screen" ) { protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { showOptions ( ) ; completed ( ) ; } } ) ; addOption ( new ParameterOption ( "a" , "applicationContext" , "Sets the classpath based pring ApplicationContext" , "applicationContext" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setApplicationContextUri ( parameter ) ; } } ) ; addOption ( new ParameterOption ( "o" , "outdir" , "Sets the DOT output directory where the visual representations of the routes are generated" , "dot" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setDotOutputDir ( parameter ) ; } } ) ; addOption ( new ParameterOption ( "d" , "duration" , "Sets the time duration that the applicaiton will run for, by default in milliseconds. You can use '10s' for 10 seconds etc" , "duration" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { String value = parameter . toUpperCase ( ) ; if ( value . endsWith ( "S" ) ) { value = value . substring ( 0 , value . length ( ) - 1 ) ; setTimeUnit ( TimeUnit . SECONDS ) ; } setDuration ( Integer . parseInt ( value ) ) ; } } ) ; } public static void main ( String ... args ) { new Main ( ) . run ( args ) ; } public void run ( String [ ] args ) { parseArguments ( args ) ; run ( ) ; } public void run ( ) { if ( ! completed . get ( ) ) { try { start ( ) ; postProcessContext ( ) ; waitUntilCompleted ( ) ; stop ( ) ; } catch ( Exception e ) { LOG . error ( "Failed: " + e , e ) ; } } } public void completed ( ) { completed . set ( true ) ; latch . countDown ( ) ; } public void showOptions ( ) { System . out . println ( "Apache Camel Runner takes the following options" ) ; System . out . println ( ) ; for ( Option option : options ) { System . out . println ( "  " + option . getAbbreviation ( ) + " or " + option . getFullName ( ) + " = " + option . getDescription ( ) ) ; } } public void parseArguments ( String [ ] arguments ) { LinkedList < String > args = new LinkedList < String > ( Arrays . asList ( arguments ) ) ; boolean valid = true ; while ( ! args . isEmpty ( ) ) { String arg = args . removeFirst ( ) ; boolean handled = false ; for ( Option option : options ) { if ( option . processOption ( arg , args ) ) { handled = true ; break ; } } if ( ! handled ) { System . out . println ( "Unknown option: " + arg ) ; System . out . println ( ) ; valid = false ; break ; } } if ( ! valid ) { showOptions ( ) ; completed ( ) ; } } public void addOption ( Option option ) { options . add ( option ) ; } public abstract class Option { private String abbreviation ; private String fullName ; private String description ; protected Option ( String abbreviation , String fullName , String description ) { this . abbreviation = "-" + abbreviation ; this . fullName = "-" + fullName ; this . description = description ; } public boolean processOption ( String arg , LinkedList < String > remainingArgs ) { if ( arg . equalsIgnoreCase ( abbreviation ) || fullName . startsWith ( arg ) ) { doProcess ( arg , remainingArgs ) ; return true ; } return false ; } public String getAbbreviation ( ) { return abbreviation ; } public String getDescription ( ) { return description ; } public String getFullName ( ) { return fullName ; } protected abstract void doProcess ( String arg , LinkedList < String > remainingArgs ) ; } public abstract class ParameterOption extends Option { private String parameterName ; protected ParameterOption ( String abbreviation , String fullName , String description , String parameterName ) { super ( abbreviation , fullName , description ) ; this . parameterName = parameterName ; } protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { if ( remainingArgs . isEmpty ( ) ) { System . err . println ( "Expected fileName for " ) ; showOptions ( ) ; completed ( ) ; } else { String parameter = remainingArgs . removeFirst ( ) ; doProcess ( arg , parameter , remainingArgs ) ; } } protected abstract void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) ; } public AbstractApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( AbstractApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String getApplicationContextUri ( ) { return applicationContextUri ; } public void setApplicationContextUri ( String applicationContextUri ) { this . applicationContextUri = applicationContextUri ; } public long getDuration ( ) { return duration ; } public void setDuration ( long duration ) { this . duration = duration ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } public void setTimeUnit ( TimeUnit timeUnit ) { this . timeUnit = timeUnit ; } public String getDotOutputDir ( ) { return dotOutputDir ; } public void setDotOutputDir ( String dotOutputDir ) { this . dotOutputDir = dotOutputDir ; } protected void doStart ( ) throws Exception { LOG . info ( "Apache Camel " + getVersion ( ) + " starting" ) ; if ( applicationContext == null ) { applicationContext = createDefaultApplicationContext ( ) ; } applicationContext . start ( ) ; } protected AbstractApplicationContext createDefaultApplicationContext ( ) { String [ ] args = getApplicationContextUri ( ) . split ( ";" ) ; return new ClassPathXmlApplicationContext ( args ) ; } protected void doStop ( ) throws Exception { LOG . info ( "Apache Camel terminating" ) ; if ( applicationContext != null ) { applicationContext . close ( ) ; } } protected void waitUntilCompleted ( ) { while ( ! completed . get ( ) ) { try { if ( duration > 0 ) { TimeUnit unit = getTimeUnit ( ) ; LOG . info ( "Waiting for: " + duration + " " + unit ) ; latch . await ( duration , unit ) ; completed . set ( true ) ; } else { latch . await ( ) ; } } catch ( InterruptedException e ) { LOG . debug ( "Caught: " + e ) ; } } } protected void postProcessContext ( ) throws Exception { if ( ObjectHelper . isNotNullAndNonEmpty ( dotOutputDir ) ) { RouteDotGenerator generator = new RouteDotGenerator ( dotOutputDir ) ; CamelContext camelContext = SpringCamelContext . springCamelContext ( applicationContext ) ; LOG . info ( "Generating DOT file for routes: " + dotOutputDir + " for: " + camelContext ) ; generator . drawRoutes ( camelContext ) ; } } protected String getVersion ( ) { Package aPackage = Package . getPackage ( "org.apache.camel" ) ; if ( aPackage != null ) { String version = aPackage . getImplementationVersion ( ) ; if ( version == null ) { version = aPackage . getSpecificationVersion ( ) ; if ( version == null ) { version = "" ; } } return version ; } return "" ; } } 	0	['25', '2', '0', '16', '74', '206', '6', '15', '18', '0.800925926', '448', '1', '1', '0.361111111', '0.19047619', '1', '1', '16.56', '4', '1.32', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator DEFALT_ID_GENERATOR = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId = DEFALT_ID_GENERATOR . generateId ( ) ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , getBody ( ) ) ; } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object value , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T v = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; if ( v != null ) { value = v ; } } setBody ( value ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . copyFrom ( this ) ; return answer ; } public void copyFrom ( Message that ) { setMessageId ( that . getMessageId ( ) ) ; setBody ( that . getBody ( ) ) ; getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } } 	1	['14', '1', '1', '7', '26', '79', '2', '5', '12', '0.788461538', '118', '1', '2', '0', '0.256410256', '0', '0', '7.142857143', '3', '1.1429', '3']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public interface AggregationStrategy { Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) ; } 	0	['1', '1', '0', '6', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . Language ; public class ExpressionClause < T extends ProcessorType > { private T result ; private CamelContext camelContext ; public T el ( String text ) { return language ( "el" , text ) ; } public T groovy ( String text ) { return language ( "groovy" , text ) ; } public T javaScript ( String text ) { return language ( "js" , text ) ; } public T ognl ( String text ) { return language ( "ognl" , text ) ; } public T php ( String text ) { return language ( "php" , text ) ; } public T python ( String text ) { return language ( "python" , text ) ; } public T ruby ( String text ) { return language ( "ruby" , text ) ; } public T sql ( String text ) { return language ( "sql" , text ) ; } public T simple ( String text ) { return language ( "simple" , text ) ; } public T xpath ( String text ) { return language ( "xpath" , text ) ; } public T xqery ( String text ) { return language ( "xqery" , text ) ; } public T language ( String languageName , String text ) { Expression expression = createExpression ( "el" , text ) ; return result ; } protected Expression createExpression ( String languageName , String text ) { Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Could not resolve language: " + languageName ) ; } return language . createExpression ( text ) ; } } 	1	['14', '1', '0', '4', '21', '91', '0', '4', '13', '0.538461538', '105', '1', '2', '0', '0.964285714', '0', '0', '6.357142857', '2', '1', '5']
package org . apache . camel . component . ibatis ; import com . ibatis . sqlmap . client . SqlMapClient ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExchangeHelper ; public class IBatisProducer extends DefaultProducer { private SqlMapClient sqlClient ; private final IBatisEndpoint endpoint ; public IBatisProducer ( IBatisEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } @ Override public IBatisEndpoint getEndpoint ( ) { return ( IBatisEndpoint ) super . getEndpoint ( ) ; } public void process ( Exchange exchange ) throws Exception { if ( sqlClient == null ) { sqlClient = endpoint . getSqlClient ( ) ; } Object body = ExchangeHelper . getMandatoryInBody ( exchange ) ; String operation = getOperationName ( exchange ) ; sqlClient . insert ( operation , body ) ; } protected String getOperationName ( Exchange exchange ) { return endpoint . getEntityName ( ) ; } } 	0	['5', '3', '0', '6', '10', '4', '1', '6', '4', '0.75', '47', '1', '1', '0.826086957', '0.533333333', '0', '0', '8', '1', '0.8', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . IOException ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class RenameFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( RenameFileProcessStrategy . class ) ; private FileRenamer renamer ; public RenameFileProcessStrategy ( ) { this ( true ) ; } public RenameFileProcessStrategy ( boolean lock ) { this ( lock , ".camel/" , "" ) ; } public RenameFileProcessStrategy ( boolean lock , String namePrefix , String namePostfix ) { this ( lock , new DefaultFileRenamer ( namePrefix , namePostfix ) ) ; } public RenameFileProcessStrategy ( boolean lock , FileRenamer renamer ) { super ( lock ) ; this . renamer = renamer ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { File newName = renamer . renameFile ( file ) ; newName . getParentFile ( ) . mkdirs ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Renaming file: " + file + " to: " + newName ) ; } boolean renamed = file . renameTo ( newName ) ; if ( ! renamed ) { throw new IOException ( "Could not rename file from: " + file + " to " + newName ) ; } super . commit ( endpoint , exchange , file ) ; } public FileRenamer getRenamer ( ) { return renamer ; } public void setRenamer ( FileRenamer renamer ) { this . renamer = renamer ; } } 	1	['8', '2', '0', '7', '23', '14', '1', '7', '7', '0.642857143', '101', '1', '2', '0.666666667', '0.326530612', '0', '0', '11.375', '1', '0.375', '1']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . Policy ; import org . apache . camel . util . ServiceHelper ; public class DelegateProcessor extends ServiceSupport implements Processor { protected Processor processor ; public DelegateProcessor ( ) { } public DelegateProcessor ( Processor processor ) { this . processor = processor ; } public void process ( Exchange exchange ) throws Exception { processNext ( exchange ) ; } protected void processNext ( Exchange exchange ) throws Exception { if ( processor != null ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { return "Delegate(" + processor + ")" ; } public Processor getProcessor ( ) { return processor ; } public void setProcessor ( Processor processor ) { this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } public void proceed ( Exchange exchange ) throws Exception { processNext ( exchange ) ; } } 	0	['10', '2', '9', '20', '18', '3', '16', '4', '7', '0.111111111', '73', '1', '1', '0.619047619', '0.5', '1', '1', '6.2', '1', '0.8', '0']
package org . apache . camel ; public class NoTypeConversionAvailableException extends RuntimeCamelException { private final Object value ; private final Class type ; public NoTypeConversionAvailableException ( Object value , Class type ) { super ( "No converter available to convert value: " + value + " to the required type: " + type . getName ( ) ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class getType ( ) { return type ; } } 	1	['3', '5', '0', '1', '9', '0', '0', '1', '3', '0.5', '33', '1', '0', '0.894736842', '0.555555556', '0', '0', '9.333333333', '1', '0.6667', '1']
package org . apache . camel . component ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . validator . ValidatorComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . DefaultResourceLoader ; import org . springframework . core . io . Resource ; import org . springframework . core . io . ResourceLoader ; public abstract class ResourceBasedEndpoint extends ProcessorEndpoint { protected static final transient Log LOG = LogFactory . getLog ( ValidatorComponent . class ) ; private ResourceLoader resourceLoader = new DefaultResourceLoader ( ) ; private final String resourceUri ; private Resource resource ; public ResourceBasedEndpoint ( String endpointUri , Component component , String resourceUri , Processor processor ) { super ( endpointUri , component , processor ) ; this . resourceUri = resourceUri ; } public Resource getResource ( ) { if ( resource == null ) { resource = getResourceLoader ( ) . getResource ( resourceUri ) ; if ( resource == null ) { throw new IllegalArgumentException ( "Could not find resource for URI: " + resourceUri + " using: " + getResourceLoader ( ) ) ; } } return resource ; } public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } } 	0	['5', '5', '1', '9', '14', '2', '1', '8', '4', '0.75', '68', '1', '1', '0.9', '0.4', '0', '0', '11.8', '3', '1', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . TryProcessor ; @ XmlRootElement ( name = "try" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TryType extends OutputType < TryType > { @ XmlTransient private List < CatchType > catchClauses ; @ XmlTransient private FinallyType finallyClause ; @ XmlTransient private boolean initialized ; @ XmlTransient private List < ProcessorType < ? > > outputsWithoutCatches ; @ Override public String toString ( ) { return "Try[ " + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor tryProcessor = createOutputsProcessor ( routeContext , getOutputsWithoutCatches ( ) ) ; Processor finallyProcessor = null ; if ( finallyClause != null ) { finallyProcessor = finallyClause . createProcessor ( routeContext ) ; } List < CatchProcessor > catchProcessors = new ArrayList < CatchProcessor > ( ) ; if ( catchClauses != null ) { for ( CatchType catchClause : catchClauses ) { catchProcessors . add ( catchClause . createProcessor ( routeContext ) ) ; } } return new TryProcessor ( tryProcessor , catchProcessors , finallyProcessor ) ; } public CatchType handle ( Class < ? > exceptionType ) { CatchType answer = new CatchType ( exceptionType ) ; addOutput ( answer ) ; return answer ; } public FinallyType handleAll ( ) { FinallyType answer = new FinallyType ( ) ; addOutput ( answer ) ; return answer ; } public List < CatchType > getCatchClauses ( ) { if ( catchClauses == null ) { checkInitialized ( ) ; } return catchClauses ; } public FinallyType getFinallyClause ( ) { if ( finallyClause == null ) { checkInitialized ( ) ; } return finallyClause ; } public List < ProcessorType < ? > > getOutputsWithoutCatches ( ) { if ( outputsWithoutCatches == null ) { checkInitialized ( ) ; } return outputsWithoutCatches ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { initialized = false ; super . setOutputs ( outputs ) ; } public void addOutput ( ProcessorType output ) { initialized = false ; getOutputs ( ) . add ( output ) ; } protected void checkInitialized ( ) { if ( ! initialized ) { initialized = true ; outputsWithoutCatches = new ArrayList < ProcessorType < ? > > ( ) ; catchClauses = new ArrayList < CatchType > ( ) ; finallyClause = null ; for ( ProcessorType output : outputs ) { if ( output instanceof CatchType ) { catchClauses . add ( ( CatchType ) output ) ; } else if ( output instanceof FinallyType ) { if ( finallyClause != null ) { throw new IllegalArgumentException ( "Multiple finally clauses added: " + finallyClause + " and " + output ) ; } else { finallyClause = ( FinallyType ) output ; } } else { outputsWithoutCatches . add ( output ) ; } } } } } 	1	['11', '3', '0', '8', '30', '37', '1', '8', '10', '0.525', '212', '1', '1', '0.907407407', '0.272727273', '1', '14', '17.90909091', '6', '1.6364', '5']
package org . apache . camel . component . mail ; import javax . mail . Folder ; import javax . mail . MessagingException ; import javax . mail . Store ; import org . springframework . mail . MailSendException ; import org . springframework . mail . javamail . JavaMailSenderImpl ; public class JavaMailConnection extends JavaMailSenderImpl { public Folder getFolder ( String protocol , String folderName ) { try { Store store = getSession ( ) . getStore ( protocol ) ; store . connect ( getHost ( ) , getPort ( ) , getUsername ( ) , getPassword ( ) ) ; return store . getFolder ( folderName ) ; } catch ( MessagingException e ) { throw new MailSendException ( "Mail server connection failed" , e ) ; } } } 	0	['2', '2', '0', '4', '12', '1', '2', '2', '2', '2', '31', '0', '0', '0.964285714', '0.75', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . camel . impl . converter ; public interface TypeConverterLoader { void load ( TypeConverterRegistry registry ) throws Exception ; } 	1	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . processor . idempotent ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ExpressionHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class IdempotentConsumer extends ServiceSupport implements Processor { private static final transient Log LOG = LogFactory . getLog ( IdempotentConsumer . class ) ; private Expression < Exchange > messageIdExpression ; private Processor nextProcessor ; private MessageIdRepository messageIdRepository ; public IdempotentConsumer ( Expression < Exchange > messageIdExpression , MessageIdRepository messageIdRepository , Processor nextProcessor ) { this . messageIdExpression = messageIdExpression ; this . messageIdRepository = messageIdRepository ; this . nextProcessor = nextProcessor ; } @ Override public String toString ( ) { return "IdempotentConsumer[expression=" + messageIdExpression + ", repository=" + messageIdRepository + ", processor=" + nextProcessor + "]" ; } public void process ( Exchange exchange ) throws Exception { String messageId = ExpressionHelper . evaluateAsString ( messageIdExpression , exchange ) ; if ( messageId == null ) { throw new NoMessageIdException ( exchange , messageIdExpression ) ; } if ( ! messageIdRepository . contains ( messageId ) ) { nextProcessor . process ( exchange ) ; } else { onDuplicateMessage ( exchange , messageId ) ; } } public Expression < Exchange > getMessageIdExpression ( ) { return messageIdExpression ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public Processor getNextProcessor ( ) { return nextProcessor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( nextProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( nextProcessor ) ; } protected void onDuplicateMessage ( Exchange exchange , String messageId ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring duplicate message with id: " + messageId + " for exchange: " + exchange ) ; } } } 	0	['10', '2', '0', '11', '24', '1', '1', '10', '6', '0.638888889', '126', '1', '4', '0.619047619', '0.277777778', '1', '1', '11.2', '2', '0.9', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; public interface FileProcessStrategy { boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; } 	1	['2', '1', '0', '5', '2', '1', '4', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . event ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ConfigurableApplicationContext ; public class EventComponent extends DefaultComponent < Exchange > implements ApplicationContextAware { private ApplicationContext applicationContext ; public EventComponent ( ) { } public EventComponent ( ApplicationContext applicationContext ) { setApplicationContext ( applicationContext ) ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public ConfigurableApplicationContext getConfigurableApplicationContext ( ) { ApplicationContext applicationContext = getApplicationContext ( ) ; if ( applicationContext instanceof ConfigurableApplicationContext ) { return ( ConfigurableApplicationContext ) applicationContext ; } else { throw new IllegalArgumentException ( "Not created with a ConfigurableApplicationContext! Was: " + applicationContext ) ; } } protected EventEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { EventEndpoint answer = new EventEndpoint ( uri , this ) ; return answer ; } } 	0	['7', '3', '0', '8', '13', '19', '2', '7', '5', '0.5', '59', '1', '0', '0.821428571', '0.464285714', '1', '1', '7.285714286', '2', '0.8571', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ExchangeHelper ; public class MethodInfo { private Class type ; private Method method ; private final List < ParameterInfo > parameters ; private final List < ParameterInfo > bodyParameters ; private final boolean hasCustomAnnotation ; private Expression parametersExpression ; public MethodInfo ( Class type , Method method , List < ParameterInfo > parameters , List < ParameterInfo > bodyParameters , boolean hasCustomAnnotation ) { this . type = type ; this . method = method ; this . parameters = parameters ; this . bodyParameters = bodyParameters ; this . hasCustomAnnotation = hasCustomAnnotation ; this . parametersExpression = createParametersExpression ( ) ; } public String toString ( ) { return method . toString ( ) ; } public MethodInvocation createMethodInvocation ( final Object pojo , final Exchange messageExchange ) { final Object [ ] arguments = ( Object [ ] ) parametersExpression . evaluate ( messageExchange ) ; return new MethodInvocation ( ) { public Method getMethod ( ) { return method ; } public Object [ ] getArguments ( ) { return arguments ; } public Object proceed ( ) throws Throwable { return invoke ( method , pojo , arguments , messageExchange ) ; } public Object getThis ( ) { return pojo ; } public AccessibleObject getStaticPart ( ) { return method ; } } ; } public Class getType ( ) { return type ; } public Method getMethod ( ) { return method ; } public Expression getParametersExpression ( ) { return parametersExpression ; } public List < ParameterInfo > getBodyParameters ( ) { return bodyParameters ; } public Class getBodyParameterType ( ) { ParameterInfo parameterInfo = bodyParameters . get ( 0 ) ; return parameterInfo . getType ( ) ; } public boolean bodyParameterMatches ( Class bodyType ) { Class actualType = getBodyParameterType ( ) ; return actualType != null && ObjectHelper . isAssignableFrom ( bodyType , actualType ) ; } public List < ParameterInfo > getParameters ( ) { return parameters ; } public boolean hasBodyParameter ( ) { return ! bodyParameters . isEmpty ( ) ; } public boolean isHasCustomAnnotation ( ) { return hasCustomAnnotation ; } protected Object invoke ( Method mth , Object pojo , Object [ ] arguments , Exchange exchange ) throws IllegalAccessException , InvocationTargetException { return mth . invoke ( pojo , arguments ) ; } protected Expression createParametersExpression ( ) { final int size = parameters . size ( ) ; final Expression [ ] expressions = new Expression [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Expression parameterExpression = parameters . get ( i ) . getExpression ( ) ; expressions [ i ] = parameterExpression ; } return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object [ ] answer = new Object [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Object value = expressions [ i ] . evaluate ( exchange ) ; value = ExchangeHelper . convertToType ( exchange , parameters . get ( i ) . getType ( ) , value ) ; answer [ i ] = value ; } return answer ; } @ Override public String toString ( ) { return "ParametersExpression: " + Arrays . asList ( expressions ) ; } } ; } } 	1	['16', '1', '0', '8', '28', '74', '3', '7', '12', '0.844444444', '154', '1', '1', '0', '0.1875', '0', '0', '8.25', '3', '1.1875', '2']
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; public class ToStringTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( String . class ) ) { return ( T ) value . toString ( ) ; } } return null ; } } 	0	['2', '1', '0', '2', '5', '1', '1', '1', '2', '2', '16', '0', '0', '0', '0.666666667', '0', '0', '7', '3', '1.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; @ XmlRootElement ( name = "otherwise" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class OtherwiseType extends OutputType { @ Override public String toString ( ) { return "Otherwise[" + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProcessor ( this ) ; } @ Override public String getLabel ( ) { return "otherwise" ; } } 	1	['4', '3', '0', '9', '11', '6', '6', '4', '4', '2', '25', '0', '0', '0.97029703', '0.625', '1', '2', '5.25', '1', '0.75', '3']
package org . apache . camel . processor ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . AlreadyStoppedException ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class DelayProcessorSupport extends DelegateProcessor { private static final transient Log LOG = LogFactory . getLog ( Delayer . class ) ; private CountDownLatch stoppedLatch = new CountDownLatch ( 1 ) ; private boolean fastStop = true ; public DelayProcessorSupport ( Processor processor ) { super ( processor ) ; } public void process ( Exchange exchange ) throws Exception { delay ( exchange ) ; super . process ( exchange ) ; } public boolean isFastStop ( ) { return fastStop ; } public void setFastStop ( boolean fastStop ) { this . fastStop = fastStop ; } protected void doStop ( ) throws Exception { stoppedLatch . countDown ( ) ; super . doStop ( ) ; } protected abstract void delay ( Exchange exchange ) throws Exception ; protected void waitUntil ( long time , Exchange exchange ) throws Exception { while ( true ) { long delay = time - currentSystemTime ( ) ; if ( delay < 0 ) { return ; } else { if ( isFastStop ( ) && ! isRunAllowed ( ) ) { throw new AlreadyStoppedException ( ) ; } try { sleep ( delay ) ; } catch ( InterruptedException e ) { handleSleepInteruptedException ( e ) ; } } } } protected void sleep ( long delay ) throws InterruptedException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + delay + " millis" ) ; } if ( isFastStop ( ) ) { stoppedLatch . await ( delay , TimeUnit . MILLISECONDS ) ; } else { Thread . sleep ( delay ) ; } } protected void handleSleepInteruptedException ( InterruptedException e ) { LOG . debug ( "Sleep interupted: " + e , e ) ; } protected long currentSystemTime ( ) { return System . currentTimeMillis ( ) ; } } 	0	['11', '3', '2', '8', '30', '37', '2', '6', '4', '0.666666667', '122', '1', '1', '0.7', '0.3', '1', '1', '9.818181818', '1', '0.8182', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "bean" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class BeanRef extends OutputType { @ XmlAttribute ( required = true ) private String ref ; @ XmlAttribute ( required = false ) private String method ; @ XmlAttribute ( required = false ) private Class beanType ; @ XmlTransient private Object bean ; public BeanRef ( ) { } public BeanRef ( String ref ) { this . ref = ref ; } public BeanRef ( String ref , String method ) { this . ref = ref ; this . method = method ; } @ Override public String toString ( ) { return "Bean[" + getLabel ( ) + "]" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class getBeanType ( ) { return beanType ; } public void setBeanType ( Class beanType ) { this . beanType = beanType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( bean == null ) { String reference = getRef ( ) ; if ( reference != null ) { bean = routeContext . lookup ( reference , Object . class ) ; } else { ObjectHelper . notNull ( beanType , "bean, ref or beanType" ) ; bean = CamelContextHelper . newInstance ( routeContext . getCamelContext ( ) , beanType ) ; } } BeanProcessor answer = new BeanProcessor ( bean , routeContext . getCamelContext ( ) ) ; if ( method != null ) { answer . setMethodName ( method ) ; } return answer ; } @ Override public String getLabel ( ) { if ( ref != null ) { String methodText = "" ; if ( method != null ) { methodText = " method: " + method ; } return "ref: " + ref + methodText ; } else if ( bean != null ) { return bean . toString ( ) ; } else if ( beanType != null ) { return beanType . getName ( ) ; } else { return "" ; } } } 	1	['13', '3', '0', '8', '25', '26', '1', '7', '13', '0.625', '161', '1', '0', '0.907407407', '0.307692308', '1', '2', '11.07692308', '5', '1.3077', '3']
package org . apache . camel . component . jms ; import javax . jms . MessageListener ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; public class JmsConsumer extends DefaultConsumer < JmsExchange > { private final AbstractMessageListenerContainer listenerContainer ; public JmsConsumer ( JmsEndpoint endpoint , Processor processor , AbstractMessageListenerContainer listenerContainer ) { super ( endpoint , processor ) ; this . listenerContainer = listenerContainer ; MessageListener messageListener = createMessageListener ( endpoint , processor ) ; this . listenerContainer . setMessageListener ( messageListener ) ; } public AbstractMessageListenerContainer getListenerContainer ( ) { return listenerContainer ; } protected MessageListener createMessageListener ( JmsEndpoint endpoint , Processor processor ) { EndpointMessageListener < JmsExchange > messageListener = new EndpointMessageListener < JmsExchange > ( endpoint , processor ) ; messageListener . setBinding ( endpoint . getBinding ( ) ) ; return messageListener ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; listenerContainer . afterPropertiesSet ( ) ; listenerContainer . start ( ) ; } @ Override protected void doStop ( ) throws Exception { listenerContainer . stop ( ) ; listenerContainer . destroy ( ) ; super . doStop ( ) ; } } 	0	['5', '3', '0', '7', '16', '0', '1', '7', '2', '0.25', '56', '1', '0', '0.846153846', '0.5', '1', '1', '10', '1', '0.8', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; @ Converter public class ObjectConverter { private ObjectConverter ( ) { } public static boolean isCollection ( Object value ) { return value instanceof Collection || ( value != null && value . getClass ( ) . isArray ( ) ) ; } @ Converter public static Iterator iterator ( Object value ) { if ( value == null ) { return Collections . EMPTY_LIST . iterator ( ) ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { List < Object > list = Arrays . asList ( ( Object [ ] ) value ) ; return list . iterator ( ) ; } else if ( value instanceof NodeList ) { final NodeList nodeList = ( NodeList ) value ; return new Iterator < Node > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return ++ idx < nodeList . getLength ( ) ; } public Node next ( ) { return nodeList . item ( idx ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else { return Collections . singletonList ( value ) . iterator ( ) ; } } @ Converter public static boolean toBool ( Object value ) { Boolean answer = toBoolean ( value ) ; if ( answer != null ) { return answer . booleanValue ( ) ; } return false ; } @ Converter public static Boolean toBoolean ( Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ; } if ( value instanceof String ) { return "true" . equalsIgnoreCase ( value . toString ( ) ) ? Boolean . TRUE : Boolean . FALSE ; } return null ; } @ Converter public static Boolean toBoolean ( Boolean value ) { if ( value != null ) { return value . booleanValue ( ) ; } return false ; } } 	1	['6', '1', '0', '9', '18', '15', '8', '1', '5', '2', '102', '0', '0', '0', '0.333333333', '0', '0', '16', '5', '2.8333', '3']
package org . apache . camel . spi ; public interface ExceptionHandler { void handleException ( Throwable exception ) ; } 	0	['1', '1', '0', '5', '1', '0', '5', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . spi . Injector ; public class FactoryFinder { private final String path ; private final ConcurrentHashMap classMap = new ConcurrentHashMap ( ) ; public FactoryFinder ( ) { this ( "META-INF/services/org/apache/camel/" ) ; } public FactoryFinder ( String path ) { this . path = path ; } public Object newInstance ( String key ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { return newInstance ( key , ( String ) null ) ; } public Object newInstance ( String key , String propertyPrefix ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { Class clazz = findClass ( key , propertyPrefix ) ; return clazz . newInstance ( ) ; } public Object newInstance ( String key , Injector injector ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , ( String ) null ) ; } public Object newInstance ( String key , Injector injector , String propertyPrefix ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; return injector . newInstance ( type ) ; } public < T > T newInstance ( String key , Injector injector , Class < T > expectedType ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , null , expectedType ) ; } public < T > T newInstance ( String key , Injector injector , String propertyPrefix , Class < T > expectedType ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; Object value = injector . newInstance ( type ) ; if ( expectedType . isInstance ( value ) ) { return expectedType . cast ( value ) ; } else { throw new ClassCastException ( "Not instanceof " + expectedType . getName ( ) + " value: " + value ) ; } } public < T > List < T > newInstances ( String key , Injector injector , Class < T > type ) throws IOException , ClassNotFoundException { List < Class > list = findClasses ( key ) ; List < T > answer = new ArrayList < T > ( list . size ( ) ) ; answer . add ( newInstance ( key , injector , type ) ) ; return answer ; } public Class findClass ( String key ) throws ClassNotFoundException , IOException { return findClass ( key , null ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; if ( clazz == null ) { clazz = newInstance ( doFindFactoryProperies ( key ) , propertyPrefix ) ; classMap . put ( propertyPrefix + key , clazz ) ; } return clazz ; } public List < Class > findClasses ( String key ) throws ClassNotFoundException , IOException { return findClasses ( key , null ) ; } public List < Class > findClasses ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { Class type = findClass ( key , propertyPrefix ) ; return Collections . singletonList ( type ) ; } public String getPath ( ) { return path ; } private Class newInstance ( Properties properties , String propertyPrefix ) throws ClassNotFoundException , IOException { String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } Class clazz = null ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { clazz = loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { } } if ( clazz == null ) { clazz = FactoryFinder . class . getClassLoader ( ) . loadClass ( className ) ; } return clazz ; } private Properties doFindFactoryProperies ( String key ) throws IOException { String uri = path + key ; ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = getClass ( ) . getClassLoader ( ) ; } InputStream in = classLoader . getResourceAsStream ( uri ) ; if ( in == null ) { in = FactoryFinder . class . getClassLoader ( ) . getResourceAsStream ( uri ) ; if ( in == null ) { throw new NoFactoryAvailableException ( uri ) ; } } BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; } finally { try { reader . close ( ) ; } catch ( Exception ignore ) { } } } } 	1	['16', '1', '0', '6', '47', '112', '4', '2', '14', '0.6', '301', '1', '0', '0', '0.4875', '0', '0', '17.6875', '1', '0.875', '2']
package org . apache . camel . component . rmi ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . impl . DefaultComponent ; public class RmiComponent extends DefaultComponent < BeanExchange > { public RmiComponent ( ) { } public RmiComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < BeanExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new RmiEndpoint ( uri , this ) ; } } 	0	['3', '3', '0', '4', '6', '3', '1', '4', '2', '2', '16', '0', '0', '0.958333333', '0.5', '1', '1', '4.333333333', '1', '0.3333', '0']
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; public interface ComponentResolver < E extends Exchange > { Component < E > resolveComponent ( String name , CamelContext context ) throws Exception ; } 	1	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . cxf . transport ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . AbstractDestination ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import org . apache . cxf . wsdl . EndpointReferenceUtils ; public class CamelDestination extends AbstractDestination implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-destination-base" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelDestination . class ) ; CamelContext camelContext ; String camelUri ; final ConduitInitiator conduitInitiator ; private CamelTransportBase base ; private Endpoint endpoint ; public CamelDestination ( CamelContext camelContext , Bus bus , ConduitInitiator ci , EndpointInfo info ) throws IOException { super ( getTargetReference ( info , bus ) , info ) ; this . camelContext = camelContext ; base = new CamelTransportBase ( camelContext , bus , endpointInfo , true , BASE_BEAN_NAME_SUFFIX ) ; conduitInitiator = ci ; initConfig ( ) ; } protected Logger getLogger ( ) { return LOG ; } protected Conduit getInbuiltBackChannel ( Message inMessage ) { return new BackChannelConduit ( EndpointReferenceUtils . getAnonymousEndpointReference ( ) , inMessage ) ; } public void activate ( ) { getLogger ( ) . log ( Level . INFO , "CamelDestination activate().... " ) ; try { getLogger ( ) . log ( Level . FINE , "establishing Camel connection" ) ; endpoint = camelContext . getEndpoint ( camelUri ) ; } catch ( Exception ex ) { getLogger ( ) . log ( Level . SEVERE , "Camel connect failed with EException : " , ex ) ; } } public void deactivate ( ) { base . close ( ) ; } public void shutdown ( ) { getLogger ( ) . log ( Level . FINE , "CamelDestination shutdown()" ) ; this . deactivate ( ) ; } protected void incoming ( Exchange exchange ) { getLogger ( ) . log ( Level . FINE , "server received request: " , exchange ) ; byte [ ] bytes = base . unmarshal ( exchange ) ; MessageImpl inMessage = new MessageImpl ( ) ; inMessage . setContent ( InputStream . class , new ByteArrayInputStream ( bytes ) ) ; base . populateIncomingContext ( exchange , inMessage , CamelConstants . CAMEL_SERVER_REQUEST_HEADERS ) ; inMessage . put ( CamelConstants . CAMEL_REQUEST_MESSAGE , exchange ) ; inMessage . setDestination ( this ) ; incomingObserver . onMessage ( inMessage ) ; } public String getBeanName ( ) { return endpointInfo . getName ( ) . toString ( ) + ".camel-destination" ; } private void initConfig ( ) { } protected class ConsumerProcessor implements Processor { public void process ( Exchange exchange ) { try { incoming ( exchange ) ; } catch ( Throwable ex ) { getLogger ( ) . log ( Level . WARNING , "Failed to process incoming message : " , ex ) ; } } } protected class BackChannelConduit extends AbstractConduit { protected Message inMessage ; BackChannelConduit ( EndpointReferenceType ref , Message message ) { super ( ref ) ; inMessage = message ; } public void setMessageObserver ( MessageObserver observer ) { } public void prepare ( Message message ) throws IOException { message . put ( CamelConstants . CAMEL_REQUEST_MESSAGE , inMessage . get ( CamelConstants . CAMEL_REQUEST_MESSAGE ) ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( inMessage ) ) ; } protected Logger getLogger ( ) { return LOG ; } } private class CamelOutputStream extends CachedOutputStream { private Message inMessage ; private Producer < Exchange > replyTo ; private Producer < Exchange > sender ; public CamelOutputStream ( Message m ) { super ( ) ; inMessage = m ; } private void commitOutputMessage ( ) throws IOException { final String replyToUri = getReplyToDestination ( inMessage ) ; base . template . send ( replyToUri , new Processor ( ) { public void process ( Exchange reply ) { base . marshal ( currentStream . toString ( ) , replyToUri , reply ) ; setReplyCorrelationID ( inMessage , reply ) ; base . setMessageProperties ( inMessage , reply ) ; getLogger ( ) . log ( Level . FINE , "just server sending reply: " , reply ) ; } } ) ; } @ Override protected void doFlush ( ) throws IOException { } @ Override protected void doClose ( ) throws IOException { commitOutputMessage ( ) ; } @ Override protected void onWrite ( ) throws IOException { } } protected String getReplyToDestination ( Message inMessage ) { if ( inMessage . get ( CamelConstants . CAMEL_REBASED_REPLY_TO ) != null ) { return ( String ) inMessage . get ( CamelConstants . CAMEL_REBASED_REPLY_TO ) ; } else { return base . getReplyDestination ( ) ; } } protected void setReplyCorrelationID ( Message inMessage , Exchange reply ) { Object value = inMessage . get ( CamelConstants . CAMEL_CORRELATION_ID ) ; if ( value != null ) { reply . getIn ( ) . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , value ) ; } } } 	0	['14', '0', '0', '23', '42', '61', '5', '19', '5', '0.89010989', '182', '0.571428571', '3', '0', '0.201923077', '0', '0', '11.5', '2', '1', '0']
package org . apache . camel ; public class InvalidPayloadException extends CamelExchangeException { private final Class < ? > type ; public InvalidPayloadException ( Exchange exchange , Class < ? > type ) { super ( "No in body available of type: " + type . getName ( ) + NoSuchPropertyException . valueDescription ( exchange . getIn ( ) . getBody ( ) ) , exchange ) ; this . type = type ; } public Class < ? > getType ( ) { return type ; } } 	1	['2', '5', '0', '5', '10', '0', '1', '4', '2', '0', '27', '1', '0', '0.947368421', '0.666666667', '0', '0', '12', '1', '0.5', '1']
package org . apache . camel . util ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . converter . TypeConverterRegistry ; import org . apache . camel . spi . Injector ; public class ReportingTypeConverterRegistry implements TypeConverterRegistry { private List < String > errors = new ArrayList < String > ( ) ; public String [ ] getErrors ( ) { return errors . toArray ( new String [ errors . size ( ) ] ) ; } public void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) { if ( errors . size ( ) == 0 ) { errors . add ( "Method should not be invoked." ) ; } } public Injector getInjector ( ) { return null ; } } 	0	['4', '1', '0', '3', '9', '0', '0', '3', '4', '0.333333333', '34', '1', '0', '0', '0.5', '0', '0', '7.25', '2', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultUnitOfWork ; import org . apache . camel . spi . UnitOfWork ; public final class UnitOfWorkProcessor extends DelegateAsyncProcessor { public UnitOfWorkProcessor ( AsyncProcessor processor ) { super ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( exchange . getUnitOfWork ( ) == null ) { exchange . setUnitOfWork ( new DefaultUnitOfWork ( ) ) ; return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( sync ) ; exchange . getUnitOfWork ( ) . done ( exchange ) ; exchange . setUnitOfWork ( null ) ; } } ) ; } else { return processor . process ( exchange , callback ) ; } } } 	1	['2', '3', '0', '8', '8', '1', '2', '7', '2', '2', '31', '0', '0', '0.952380952', '0.625', '0', '0', '14.5', '2', '1', '1']
package org . apache . camel . spring . spi ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . Converter ; import org . apache . camel . component . bean . BeanInvocation ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; @ Converter public final class SpringConverters { private SpringConverters ( ) { } @ Converter public static InputStream toInputStream ( Resource resource ) throws IOException { return resource . getInputStream ( ) ; } @ Converter public static File toFile ( Resource resource ) throws IOException { return resource . getFile ( ) ; } @ Converter public static URL toUrl ( Resource resource ) throws IOException { return resource . getURL ( ) ; } @ Converter public static UrlResource toResource ( String uri ) throws IOException { return new UrlResource ( uri ) ; } @ Converter public static UrlResource toResource ( URL uri ) throws IOException { return new UrlResource ( uri ) ; } @ Converter public static FileSystemResource toResource ( File file ) throws IOException { return new FileSystemResource ( file ) ; } @ Converter public static ByteArrayResource toResource ( byte [ ] data ) throws IOException { return new ByteArrayResource ( data ) ; } @ Converter public static BeanInvocation toBeanInvocation ( MethodInvocation invocation ) { return new BeanInvocation ( invocation . getThis ( ) , invocation . getMethod ( ) , invocation . getArguments ( ) ) ; } } 	0	['9', '1', '0', '6', '21', '36', '0', '6', '8', '2', '51', '0', '0', '0', '0.142857143', '0', '0', '4.666666667', '1', '0.8889', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; public class SerializationDataFormat implements DataFormat { public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { ObjectOutput out = IOConverter . toObjectOutput ( stream ) ; out . writeObject ( graph ) ; out . flush ( ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { ObjectInput in = IOConverter . toObjectInput ( stream ) ; return in . readObject ( ) ; } } 	1	['3', '1', '0', '4', '9', '3', '1', '3', '3', '2', '21', '0', '0', '0', '0.533333333', '0', '0', '6', '1', '0.6667', '1']
package org . apache . camel ; public class RuntimeTransformException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; public RuntimeTransformException ( String message ) { super ( message ) ; } public RuntimeTransformException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeTransformException ( Throwable cause ) { super ( cause ) ; } } 	0	['3', '5', '0', '2', '6', '3', '1', '1', '3', '1.5', '17', '1', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class MulticastProcessor extends ServiceSupport implements Processor { private Collection < Processor > processors ; public MulticastProcessor ( Collection < Processor > processors ) { this . processors = processors ; } public static < E extends Exchange > Collection < Processor > toProducers ( Collection < Endpoint > endpoints ) throws Exception { Collection < Processor > answer = new ArrayList < Processor > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint . createProducer ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "Multicast" + getProcessors ( ) ; } public void process ( Exchange exchange ) throws Exception { for ( Processor producer : processors ) { Exchange copy = copyExchangeStrategy ( producer , exchange ) ; producer . process ( copy ) ; } } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	1	['8', '2', '1', '8', '23', '8', '2', '6', '5', '0.285714286', '82', '1', '0', '0.65', '0.375', '1', '1', '9.125', '1', '0.875', '5']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . concurrent . ScheduledExecutorService ; import org . apache . camel . Processor ; import org . apache . camel . component . file . FileComponent ; import org . apache . commons . net . ftp . FTPClient ; import org . apache . commons . net . ftp . FTPFile ; public class FtpConsumer extends RemoteFileConsumer < RemoteFileExchange > { private boolean recursive = true ; private String regexPattern = "" ; private long lastPollTime ; private final FtpEndpoint endpoint ; private FTPClient client ; private boolean setNames = false ; public FtpConsumer ( FtpEndpoint endpoint , Processor processor , FTPClient client ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . client = client ; } public FtpConsumer ( FtpEndpoint endpoint , Processor processor , FTPClient client , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; this . endpoint = endpoint ; this . client = client ; } protected void poll ( ) throws Exception { final String fileName = endpoint . getConfiguration ( ) . getFile ( ) ; if ( endpoint . getConfiguration ( ) . isDirectory ( ) ) { pollDirectory ( fileName ) ; } else { client . changeWorkingDirectory ( fileName . substring ( 0 , fileName . lastIndexOf ( '/' ) ) ) ; final FTPFile [ ] files = client . listFiles ( fileName . substring ( fileName . lastIndexOf ( '/' ) + 1 ) ) ; pollFile ( files [ 0 ] ) ; } lastPollTime = System . currentTimeMillis ( ) ; } protected void pollDirectory ( String dir ) throws Exception { client . changeWorkingDirectory ( dir ) ; for ( FTPFile ftpFile : client . listFiles ( ) ) { if ( ftpFile . isFile ( ) ) { pollFile ( ftpFile ) ; } else if ( ftpFile . isDirectory ( ) ) { if ( isRecursive ( ) ) { pollDirectory ( getFullFileName ( ftpFile ) ) ; } } else { throw new RuntimeException ( "" ) ; } } } protected String getFullFileName ( FTPFile ftpFile ) throws IOException { return client . printWorkingDirectory ( ) + "/" + ftpFile . getName ( ) ; } private void pollFile ( FTPFile ftpFile ) throws Exception { if ( ftpFile . getTimestamp ( ) . getTimeInMillis ( ) > lastPollTime ) { if ( isMatched ( ftpFile ) ) { final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; client . retrieveFile ( ftpFile . getName ( ) , byteArrayOutputStream ) ; RemoteFileExchange exchange = endpoint . createExchange ( getFullFileName ( ftpFile ) , byteArrayOutputStream ) ; if ( isSetNames ( ) ) { String relativePath = getFullFileName ( ftpFile ) . substring ( endpoint . getConfiguration ( ) . getFile ( ) . length ( ) ) ; if ( relativePath . startsWith ( "/" ) ) { relativePath = relativePath . substring ( 1 ) ; } exchange . getIn ( ) . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } getProcessor ( ) . process ( exchange ) ; } } } protected boolean isMatched ( FTPFile file ) { boolean result = true ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { result = file . getName ( ) . matches ( getRegexPattern ( ) ) ; } return result ; } public boolean isRecursive ( ) { return recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public long getLastPollTime ( ) { return lastPollTime ; } public void setLastPollTime ( long lastPollTime ) { this . lastPollTime = lastPollTime ; } public String getRegexPattern ( ) { return regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } public boolean isSetNames ( ) { return setNames ; } public void setSetNames ( boolean setNames ) { this . setNames = setNames ; } } 	0	['15', '5', '0', '10', '47', '27', '1', '10', '10', '0.69047619', '274', '1', '1', '0.723404255', '0.222222222', '1', '1', '16.86666667', '3', '1', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import javax . naming . Context ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Processor ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . model . RouteType ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private static final transient Log LOG = LogFactory . getLog ( DefaultCamelContext . class ) ; private static final String NAME_PREFIX = "camel-" ; private static int NAME_SUFFIX = 0 ; private String name ; private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; private LanguageResolver languageResolver = new DefaultLanguageResolver ( ) ; private Registry registry ; private LifecycleStrategy lifecycleStrategy = new DefaultLifecycleStrategy ( ) ; private List < RouteType > routeDefinitions = new ArrayList < RouteType > ( ) ; public DefaultCamelContext ( ) { name = NAME_PREFIX + ++ NAME_SUFFIX ; } public DefaultCamelContext ( Context jndiContext ) { this ( new JndiRegistry ( jndiContext ) ) ; } public DefaultCamelContext ( Registry registry ) { this ( ) ; this . registry = registry ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] != null ) { String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( uri + " converted to endpoint: " + answer + " by component: " + component ) ; } } } if ( answer == null ) { answer = createEndpoint ( uri ) ; } if ( answer != null && answer . isSingleton ( ) ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; lifecycleStrategy . onEndpointAdd ( answer ) ; } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } lifecycleStrategy . onRoutesAdd ( routes ) ; if ( shouldStartRoutes ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; List < Route > routeList = builder . getRouteList ( ) ; LOG . debug ( "Adding routes from: " + builder + " routes: " + routeList ) ; addRoutes ( routeList ) ; } public void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception { this . routeDefinitions . addAll ( routeDefinitions ) ; if ( shouldStartRoutes ( ) ) { startRouteDefinitions ( routeDefinitions ) ; } } public Language resolveLanguage ( String language ) { return getLanguageResolver ( ) . resolveLanguage ( language , this ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } public LanguageResolver getLanguageResolver ( ) { return languageResolver ; } public void setLanguageResolver ( LanguageResolver languageResolver ) { this . languageResolver = languageResolver ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } public Registry getRegistry ( ) { if ( registry == null ) { registry = createRegistry ( ) ; } return registry ; } public void setRegistry ( Registry registry ) { this . registry = registry ; } public LifecycleStrategy getLifecycleStrategy ( ) { return lifecycleStrategy ; } public void setLifecycleStrategy ( LifecycleStrategy lifecycleStrategy ) { this . lifecycleStrategy = lifecycleStrategy ; } public List < RouteType > getRouteDefinitions ( ) { return routeDefinitions ; } protected void doStart ( ) throws Exception { forceLazyInitialization ( ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRouteDefinitions ( routeDefinitions ) ; startRoutes ( routes ) ; } protected void startRouteDefinitions ( Collection < RouteType > list ) throws Exception { if ( list != null ) { for ( RouteType route : list ) { lifecycleStrategy . beforeStartRouteType ( this , route ) ; route . addRoutes ( this ) ; } } } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected void forceLazyInitialization ( ) { getExchangeConverter ( ) ; getInjector ( ) ; getLanguageResolver ( ) ; getTypeConverter ( ) ; } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( getInjector ( ) ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } protected Registry createRegistry ( ) { return new JndiRegistry ( ) ; } protected Endpoint createEndpoint ( String uri ) { Object value = getRegistry ( ) . lookup ( uri ) ; if ( value instanceof Endpoint ) { return ( Endpoint ) value ; } else if ( value instanceof Processor ) { return new ProcessorEndpoint ( uri , this , ( Processor ) value ) ; } else if ( value != null ) { return convertBeanToEndpoint ( uri , value ) ; } return null ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { throw new IllegalArgumentException ( "uri: " + uri + " bean: " + bean + " could not be converted to an Endpoint" ) ; } protected boolean shouldStartRoutes ( ) { return isStarted ( ) && ! isStarting ( ) ; } } 	1	['52', '2', '1', '36', '112', '1166', '4', '33', '38', '0.91349481', '993', '1', '8', '0.213114754', '0.08875129', '1', '1', '17.76923077', '7', '1.3846', '7']
package org . apache . camel . component . velocity ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . velocity . app . VelocityEngine ; public class VelocityComponent extends DefaultComponent { private VelocityEngine velocityEngine = new VelocityEngine ( ) ; public VelocityEngine getVelocityEngine ( ) { return velocityEngine ; } public void setVelocityEngine ( VelocityEngine velocityEngine ) { this . velocityEngine = velocityEngine ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new VelocityEndpoint ( uri , this , remaining , parameters ) ; } } 	0	['4', '3', '0', '4', '7', '0', '1', '4', '3', '0.333333333', '28', '1', '0', '0.884615385', '0.4375', '1', '1', '5.75', '1', '0.75', '0']
package org . apache . camel . processor ; import java . util . Iterator ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class Splitter extends ServiceSupport implements Processor { private final Processor processor ; private final Expression expression ; public Splitter ( Expression expression , Processor destination ) { this . processor = destination ; this . expression = expression ; notNull ( destination , "destination" ) ; notNull ( expression , "expression" ) ; } @ Override public String toString ( ) { return "Splitter[on: " + expression + " to: " + processor + "]" ; } public void process ( Exchange exchange ) throws Exception { Object value = expression . evaluate ( exchange ) ; Iterator iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { Object part = iter . next ( ) ; Exchange newExchange = exchange . copy ( ) ; newExchange . getIn ( ) . setBody ( part ) ; processor . process ( newExchange ) ; } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } } 	1	['5', '2', '0', '9', '21', '0', '1', '8', '3', '0.25', '84', '1', '2', '0.764705882', '0.4', '1', '1', '15.4', '1', '0.8', '2']
package org . apache . camel . builder . script ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "python" ) public @ interface Python { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import org . apache . camel . model . language . ExpressionType ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . ArrayList ; import java . util . List ; @ XmlRootElement ( name = "serviceActivation" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ServiceActivationType { @ XmlAttribute private String group = "default" ; @ XmlElementRef private List < ExpressionType > uris = new ArrayList < ExpressionType > ( ) ; public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public List < ExpressionType > getUris ( ) { return uris ; } public void setUris ( List < ExpressionType > uris ) { this . uris = uris ; } } 	1	['5', '1', '0', '0', '7', '0', '0', '0', '5', '0.5', '32', '1', '0', '0', '0.466666667', '0', '0', '5', '1', '0.8', '1']
package org . apache . camel . component . quartz ; import java . util . Date ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . JobDetail ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . SimpleTrigger ; import org . quartz . Trigger ; public class QuartzEndpoint extends DefaultEndpoint < QuartzExchange > { public static final String ENDPOINT_KEY = "org.apache.camel.quartz" ; private static final transient Log LOG = LogFactory . getLog ( QuartzEndpoint . class ) ; private Scheduler scheduler ; private LoadBalancer loadBalancer ; private Trigger trigger ; private JobDetail jobDetail ; private boolean started ; public QuartzEndpoint ( String endpointUri , QuartzComponent component , Scheduler scheduler ) { super ( endpointUri , component ) ; this . scheduler = scheduler ; } public void addTriggers ( Map < Trigger , JobDetail > triggerMap ) throws SchedulerException { if ( triggerMap != null ) { Set < Map . Entry < Trigger , JobDetail > > entries = triggerMap . entrySet ( ) ; for ( Map . Entry < Trigger , JobDetail > entry : entries ) { Trigger key = entry . getKey ( ) ; JobDetail value = entry . getValue ( ) ; ObjectHelper . notNull ( key , "key" ) ; ObjectHelper . notNull ( value , "value" ) ; addTrigger ( key , value ) ; } } } public void addTrigger ( Trigger trigger , JobDetail detail ) throws SchedulerException { if ( trigger . getName ( ) == null ) { trigger . setName ( detail . getName ( ) ) ; } if ( trigger . getGroup ( ) == null ) { trigger . setGroup ( detail . getGroup ( ) ) ; } if ( trigger . getStartTime ( ) == null ) { trigger . setStartTime ( new Date ( ) ) ; } detail . getJobDataMap ( ) . put ( ENDPOINT_KEY , this ) ; Class jobClass = detail . getJobClass ( ) ; if ( jobClass == null ) { detail . setJobClass ( CamelJob . class ) ; } if ( detail . getName ( ) == null ) { detail . setName ( getEndpointUri ( ) ) ; } getScheduler ( ) . scheduleJob ( detail , trigger ) ; } public void removeTrigger ( Trigger trigger , JobDetail jobDetail ) throws SchedulerException { getScheduler ( ) . unscheduleJob ( trigger . getName ( ) , trigger . getGroup ( ) ) ; } public void onJobExecute ( JobExecutionContext jobExecutionContext ) throws JobExecutionException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Firing Quartz Job with context: " + jobExecutionContext ) ; } QuartzExchange exchange = createExchange ( jobExecutionContext ) ; try { getLoadBalancer ( ) . process ( exchange ) ; } catch ( JobExecutionException e ) { throw e ; } catch ( Exception e ) { throw new JobExecutionException ( e ) ; } } @ Override public QuartzExchange createExchange ( ExchangePattern pattern ) { return new QuartzExchange ( getContext ( ) , pattern , null ) ; } public QuartzExchange createExchange ( JobExecutionContext jobExecutionContext ) { return new QuartzExchange ( getContext ( ) , getExchangePattern ( ) , jobExecutionContext ) ; } public Producer < QuartzExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "You cannot send messages to this endpoint" ) ; } public QuartzConsumer createConsumer ( Processor processor ) throws Exception { return new QuartzConsumer ( this , processor ) ; } @ Override public QuartzComponent getComponent ( ) { return ( QuartzComponent ) super . getComponent ( ) ; } public boolean isSingleton ( ) { return true ; } public Scheduler getScheduler ( ) { return scheduler ; } public LoadBalancer getLoadBalancer ( ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( ) ; } return loadBalancer ; } public void setLoadBalancer ( LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } public JobDetail getJobDetail ( ) { if ( jobDetail == null ) { jobDetail = createJobDetail ( ) ; } return jobDetail ; } public void setJobDetail ( JobDetail jobDetail ) { this . jobDetail = jobDetail ; } public Trigger getTrigger ( ) { if ( trigger == null ) { trigger = createTrigger ( ) ; } return trigger ; } public void setTrigger ( Trigger trigger ) { this . trigger = trigger ; } public synchronized void consumerStarted ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . addProcessor ( consumer . getProcessor ( ) ) ; if ( ! started ) { addTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = true ; } } public synchronized void consumerStopped ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . removeProcessor ( consumer . getProcessor ( ) ) ; if ( getLoadBalancer ( ) . getProcessors ( ) . isEmpty ( ) && started ) { removeTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = false ; } } protected LoadBalancer createLoadBalancer ( ) { return new RoundRobinLoadBalancer ( ) ; } protected JobDetail createJobDetail ( ) { return new JobDetail ( ) ; } protected Trigger createTrigger ( ) { return new SimpleTrigger ( ) ; } } 	0	['27', '2', '0', '25', '72', '339', '3', '24', '23', '0.912087912', '315', '0.857142857', '2', '0.404761905', '0.144230769', '1', '2', '10.40740741', '2', '1.037', '0']
package org . apache . camel . builder . xml ; public class StreamResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StreamResultHandler ( ) ; } } 	1	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '2']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "groovy" ) public class GroovyExpression extends ExpressionType { public GroovyExpression ( ) { } public GroovyExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "groovy" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . model ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . ObjectHelper ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; @ XmlRootElement ( name = "from" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FromType { @ XmlAttribute private String uri ; @ XmlAttribute private String ref ; @ XmlTransient private Endpoint endpoint ; public FromType ( ) { } public FromType ( String uri ) { setUri ( uri ) ; } public FromType ( Endpoint endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "From[" + getLabel ( ) + "]" ; } public String getLabel ( ) { return description ( getUri ( ) , getRef ( ) , getEndpoint ( ) ) ; } public Endpoint resolveEndpoint ( RouteContext context ) { if ( endpoint == null ) { endpoint = context . resolveEndpoint ( getUri ( ) , getRef ( ) ) ; } return endpoint ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public Object getUriOrRef ( ) { if ( ObjectHelper . isNullOrBlank ( uri ) ) { return uri ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } return ref ; } protected static String description ( String uri , String ref , Endpoint endpoint ) { if ( ref != null ) { return "ref:" + ref ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } else if ( uri != null ) { return uri ; } else { return "no uri or ref supplied!" ; } } } 	1	['14', '1', '0', '10', '21', '59', '8', '3', '13', '0.641025641', '126', '1', '1', '0', '0.375', '0', '0', '7.785714286', '4', '1.2143', '2']
package org . apache . camel . builder ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . impl . BinaryPredicateSupport ; import org . apache . camel . impl . PredicateSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . compare ; import static org . apache . camel . util . ObjectHelper . notNull ; public class PredicateBuilder { private PredicateBuilder ( ) { } public static < E extends Exchange > Predicate < E > toPredicate ( final Expression < E > expression ) { return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return evaluateValuePredicate ( value ) ; } @ Override public String toString ( ) { return expression . toString ( ) ; } } ; } public static boolean evaluateValuePredicate ( Object value ) { if ( value instanceof Boolean ) { Boolean aBoolean = ( Boolean ) value ; return aBoolean . booleanValue ( ) ; } return value != null ; } public static < E extends Exchange > Predicate < E > not ( final Predicate < E > predicate ) { notNull ( predicate , "predicate" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return ! predicate . matches ( exchange ) ; } @ Override public String toString ( ) { return "not " + predicate ; } } ; } public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) >= 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	0	['18', '1', '0', '21', '36', '153', '5', '17', '17', '2', '154', '0', '0', '0', '0.166666667', '0', '0', '7.555555556', '3', '1.0556', '0']
package org . apache . camel . builder . xml ; import java . io . StringReader ; import java . util . List ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpression ; import javax . xml . xpath . XPathExpressionException ; import javax . xml . xpath . XPathFactory ; import javax . xml . xpath . XPathFactoryConfigurationException ; import javax . xml . xpath . XPathFunction ; import javax . xml . xpath . XPathFunctionException ; import javax . xml . xpath . XPathFunctionResolver ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import static org . apache . camel . builder . xml . Namespaces . DEFAULT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . isMatchingNamespaceOrEmptyNamespace ; import static org . apache . camel . converter . ObjectConverter . toBoolean ; public class XPathBuilder < E extends Exchange > implements Expression < E > , Predicate < E > { private final String text ; private XPathFactory xpathFactory ; private Class documentType = Document . class ; private QName resultType = XPathConstants . NODESET ; private String objectModelUri ; private DefaultNamespaceContext namespaceContext ; private XPathFunctionResolver functionResolver ; private XPathExpression expression ; private MessageVariableResolver variableResolver = new MessageVariableResolver ( ) ; private E exchange ; private XPathFunction bodyFunction ; private XPathFunction headerFunction ; private XPathFunction outBodyFunction ; private XPathFunction outHeaderFunction ; public XPathBuilder ( String text ) { this . text = text ; } public static XPathBuilder xpath ( String text ) { return new XPathBuilder ( text ) ; } @ Override public String toString ( ) { return "XPath: " + text ; } public boolean matches ( E exchange ) { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; return toBoolean ( booleanResult ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; if ( ! toBoolean ( booleanResult ) ) { throw new AssertionError ( this + " failed on " + exchange + " as returned <" + booleanResult + ">" ) ; } } public Object evaluate ( E exchange ) { return evaluateAs ( exchange , resultType ) ; } public XPathBuilder < E > booleanResult ( ) { resultType = XPathConstants . BOOLEAN ; return this ; } public XPathBuilder < E > nodeResult ( ) { resultType = XPathConstants . NODE ; return this ; } public XPathBuilder < E > nodeSetResult ( ) { resultType = XPathConstants . NODESET ; return this ; } public XPathBuilder < E > numberResult ( ) { resultType = XPathConstants . NUMBER ; return this ; } public XPathBuilder < E > stringResult ( ) { resultType = XPathConstants . STRING ; return this ; } public XPathBuilder < E > objectModel ( String uri ) { this . objectModelUri = uri ; return this ; } public XPathBuilder < E > functionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; return this ; } public XPathBuilder < E > namespace ( String prefix , String uri ) { getNamespaceContext ( ) . add ( prefix , uri ) ; return this ; } public XPathBuilder < E > variable ( String name , Object value ) { variableResolver . addVariable ( name , value ) ; return this ; } public XPathFactory getXPathFactory ( ) throws XPathFactoryConfigurationException { if ( xpathFactory == null ) { if ( objectModelUri != null ) { xpathFactory = XPathFactory . newInstance ( objectModelUri ) ; } xpathFactory = XPathFactory . newInstance ( ) ; } return xpathFactory ; } public void setXPathFactory ( XPathFactory xpathFactory ) { this . xpathFactory = xpathFactory ; } public Class getDocumentType ( ) { return documentType ; } public void setDocumentType ( Class documentType ) { this . documentType = documentType ; } public String getText ( ) { return text ; } public QName getResultType ( ) { return resultType ; } public void setResultType ( QName resultType ) { this . resultType = resultType ; } public DefaultNamespaceContext getNamespaceContext ( ) { if ( namespaceContext == null ) { try { DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext ( getXPathFactory ( ) ) ; populateDefaultNamespaces ( defaultNamespaceContext ) ; namespaceContext = defaultNamespaceContext ; } catch ( XPathFactoryConfigurationException e ) { throw new RuntimeExpressionException ( e ) ; } } return namespaceContext ; } public void setNamespaceContext ( DefaultNamespaceContext namespaceContext ) { this . namespaceContext = namespaceContext ; } public XPathFunctionResolver getFunctionResolver ( ) { return functionResolver ; } public void setFunctionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; } public XPathExpression getExpression ( ) throws XPathFactoryConfigurationException , XPathExpressionException { if ( expression == null ) { expression = createXPathExpression ( ) ; } return expression ; } public void setNamespacesFromDom ( Element node ) { getNamespaceContext ( ) . setNamespacesFromDom ( node ) ; } public XPathFunction getBodyFunction ( ) { if ( bodyFunction == null ) { bodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getIn ( ) . getBody ( ) ; } } ; } return bodyFunction ; } public void setBodyFunction ( XPathFunction bodyFunction ) { this . bodyFunction = bodyFunction ; } public XPathFunction getHeaderFunction ( ) { if ( headerFunction == null ) { headerFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getIn ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return headerFunction ; } public void setHeaderFunction ( XPathFunction headerFunction ) { this . headerFunction = headerFunction ; } public XPathFunction getOutBodyFunction ( ) { if ( outBodyFunction == null ) { outBodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getOut ( ) . getBody ( ) ; } } ; } return outBodyFunction ; } public void setOutBodyFunction ( XPathFunction outBodyFunction ) { this . outBodyFunction = outBodyFunction ; } public XPathFunction getOutHeaderFunction ( ) { if ( outHeaderFunction == null ) { outHeaderFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getOut ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return outHeaderFunction ; } public void setOutHeaderFunction ( XPathFunction outHeaderFunction ) { this . outHeaderFunction = outHeaderFunction ; } protected synchronized Object evaluateAs ( E exchange , QName resultType ) { this . exchange = exchange ; variableResolver . setExchange ( exchange ) ; try { Object document = getDocument ( exchange ) ; if ( resultType != null ) { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource , resultType ) ; } else { return getExpression ( ) . evaluate ( document , resultType ) ; } } else { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource ) ; } else { return getExpression ( ) . evaluate ( document ) ; } } } catch ( XPathExpressionException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } catch ( XPathFactoryConfigurationException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } } protected XPathExpression createXPathExpression ( ) throws XPathExpressionException , XPathFactoryConfigurationException { XPath xPath = getXPathFactory ( ) . newXPath ( ) ; xpathFactory = null ; xPath . setNamespaceContext ( getNamespaceContext ( ) ) ; xPath . setXPathVariableResolver ( variableResolver ) ; XPathFunctionResolver parentResolver = getFunctionResolver ( ) ; if ( parentResolver == null ) { parentResolver = xPath . getXPathFunctionResolver ( ) ; } xPath . setXPathFunctionResolver ( createDefaultFunctionResolver ( parentResolver ) ) ; return xPath . compile ( text ) ; } protected void populateDefaultNamespaces ( DefaultNamespaceContext context ) { setNamespaceIfNotPresent ( context , "in" , IN_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "out" , OUT_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "env" , Namespaces . ENVIRONMENT_VARIABLES ) ; setNamespaceIfNotPresent ( context , "system" , Namespaces . SYSTEM_PROPERTIES_NAMESPACE ) ; } protected void setNamespaceIfNotPresent ( DefaultNamespaceContext context , String prefix , String uri ) { if ( context != null ) { String current = context . getNamespaceURI ( prefix ) ; if ( current == null ) { context . add ( prefix , uri ) ; } } } protected XPathFunctionResolver createDefaultFunctionResolver ( final XPathFunctionResolver parent ) { return new XPathFunctionResolver ( ) { public XPathFunction resolveFunction ( QName qName , int argumentCount ) { XPathFunction answer = null ; if ( parent != null ) { answer = parent . resolveFunction ( qName , argumentCount ) ; } if ( answer == null ) { if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , IN_NAMESPACE ) || isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , OUT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "out-body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "out-header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } } return answer ; } } ; } protected Object getDocument ( E exchange ) { Message in = exchange . getIn ( ) ; Class type = getDocumentType ( ) ; Object answer = null ; if ( type != null ) { answer = in . getBody ( type ) ; } if ( answer == null ) { answer = in . getBody ( ) ; } if ( answer instanceof String ) { answer = new InputSource ( new StringReader ( answer . toString ( ) ) ) ; } return answer ; } } 	1	['45', '1', '0', '17', '85', '864', '8', '14', '38', '0.907467532', '523', '1', '3', '0', '0.138888889', '0', '0', '10.31111111', '4', '1.2667', '2']
package org . apache . camel . processor . resequencer ; import java . util . Comparator ; public interface SequenceElementComparator < E > extends Comparator < E > { boolean predecessor ( E o1 , E o2 ) ; boolean successor ( E o1 , E o2 ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder . xml ; public interface ResultHandlerFactory { ResultHandler createResult ( ) ; } 	1	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . xmpp ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . jivesoftware . smack . packet . Message ; public class XmppBinding { public void populateXmppMessage ( Message message , Exchange exchange ) { message . setBody ( exchange . getIn ( ) . getBody ( String . class ) ) ; Set < Map . Entry < String , Object > > entries = exchange . getIn ( ) . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( shouldOutputHeader ( exchange , name , value ) ) { message . setProperty ( name , value ) ; } } String id = exchange . getExchangeId ( ) ; if ( id != null ) { message . setProperty ( "exchangeId" , id ) ; } } public Object extractBodyFromXmpp ( XmppExchange exchange , Message message ) { return message . getBody ( ) ; } protected boolean shouldOutputHeader ( Exchange exchange , String headerName , Object headerValue ) { return true ; } } 	0	['4', '1', '0', '8', '18', '6', '5', '4', '3', '2', '62', '0', '0', '0', '0.458333333', '0', '0', '14.5', '3', '1.25', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "sql" ) public class SqlExpression extends ExpressionType { public SqlExpression ( ) { } public SqlExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "sql" ; } } 	1	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '1']
package org . apache . camel . processor ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . resequencer . ResequencerEngine ; import org . apache . camel . processor . resequencer . SequenceElementComparator ; import org . apache . camel . processor . resequencer . SequenceSender ; public class StreamResequencer extends DelegateProcessor implements Processor { private ResequencerEngine < Exchange > reseq ; private BlockingQueue < Exchange > queue ; private SequenceSender sender ; public StreamResequencer ( Processor processor , SequenceElementComparator < Exchange > comparator , int capacity ) { super ( processor ) ; queue = new LinkedBlockingQueue < Exchange > ( ) ; reseq = new ResequencerEngine < Exchange > ( comparator , capacity ) ; reseq . setOutQueue ( queue ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; sender = new SequenceSender ( getProcessor ( ) ) ; sender . setQueue ( queue ) ; sender . start ( ) ; } @ Override protected void doStop ( ) throws Exception { reseq . stop ( ) ; sender . cancel ( ) ; super . doStop ( ) ; } @ Override public void process ( Exchange exchange ) throws Exception { reseq . put ( exchange ) ; } public long getTimeout ( ) { return reseq . getTimeout ( ) ; } public void setTimeout ( long timeout ) { reseq . setTimeout ( timeout ) ; } @ Override public String toString ( ) { return "StreamResequencer[to: " + getProcessor ( ) + "]" ; } } 	0	['7', '3', '0', '7', '26', '0', '1', '6', '5', '0.666666667', '84', '1', '2', '0.777777778', '0.285714286', '1', '1', '10.57142857', '1', '0.8571', '0']
package org . apache . camel . management ; import org . apache . camel . Exchange ; import org . apache . camel . processor . DelegateProcessor ; public class InstrumentationProcessor extends DelegateProcessor { private PerformanceCounter counter ; InstrumentationProcessor ( PerformanceCounter counter ) { this . counter = counter ; } public void process ( Exchange exchange ) throws Exception { long startTime = System . nanoTime ( ) ; super . process ( exchange ) ; if ( counter != null ) { if ( exchange . getException ( ) == null ) { counter . completedExchange ( ( System . nanoTime ( ) - startTime ) / 1000 ) ; } else { counter . completedExchange ( ) ; } } } } 	1	['2', '3', '0', '4', '8', '0', '1', '3', '1', '0', '33', '1', '1', '0.954545455', '0.666666667', '0', '0', '15', '1', '0.5', '3']
package org . apache . camel . component . jms ; import javax . jms . Message ; import javax . jms . MessageListener ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class EndpointMessageListener < E extends Exchange > implements MessageListener { private static final transient Log LOG = LogFactory . getLog ( EndpointMessageListener . class ) ; private JmsEndpoint endpoint ; private Processor processor ; private JmsBinding binding ; private boolean eagerLoadingOfProperties ; public EndpointMessageListener ( JmsEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } public void onMessage ( Message message ) { try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " receiving JMS message: " + message ) ; } JmsExchange exchange = createExchange ( message ) ; if ( eagerLoadingOfProperties ) { exchange . getIn ( ) . getHeaders ( ) ; } processor . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public JmsExchange createExchange ( Message message ) { return new JmsExchange ( endpoint . getContext ( ) , endpoint . getExchangePattern ( ) , getBinding ( ) , message ) ; } public JmsBinding getBinding ( ) { if ( binding == null ) { binding = new JmsBinding ( ) ; } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public boolean isEagerLoadingOfProperties ( ) { return eagerLoadingOfProperties ; } public void setEagerLoadingOfProperties ( boolean eagerLoadingOfProperties ) { this . eagerLoadingOfProperties = eagerLoadingOfProperties ; } } 	0	['8', '1', '0', '12', '24', '12', '1', '11', '7', '0.771428571', '100', '1', '4', '0', '0.30952381', '0', '0', '10.875', '3', '1.125', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . Converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . CachingInjector ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . reflect . Method ; import static java . lang . reflect . Modifier . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . StringTokenizer ; public class AnnotationTypeConverterLoader implements TypeConverterLoader { public static final String META_INF_SERVICES = "META-INF/services/org/apache/camel/TypeConverter" ; private static final transient Log LOG = LogFactory . getLog ( AnnotationTypeConverterLoader . class ) ; private ResolverUtil resolver = new ResolverUtil ( ) ; private Set < Class > visitedClasses = new HashSet < Class > ( ) ; public void load ( TypeConverterRegistry registry ) throws Exception { String [ ] packageNames = findPackageNames ( ) ; resolver . findAnnotated ( Converter . class , packageNames ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class type : classes ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading converter class: " + ObjectHelper . name ( type ) ) ; } loadConverterMethods ( registry , type ) ; } } protected String [ ] findPackageNames ( ) throws IOException { Set < String > packages = new HashSet < String > ( ) ; findPackages ( packages , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; findPackages ( packages , getClass ( ) . getClassLoader ( ) ) ; return packages . toArray ( new String [ packages . size ( ) ] ) ; } protected void findPackages ( Set < String > packages , ClassLoader classLoader ) throws IOException { Enumeration < URL > resources = classLoader . getResources ( META_INF_SERVICES ) ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; if ( url != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; try { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) { continue ; } tokenize ( packages , line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Caught exception closing stream: " + e , e ) ; } } } } } protected void tokenize ( Set < String > packages , String line ) { StringTokenizer iter = new StringTokenizer ( line , "," ) ; while ( iter . hasMoreTokens ( ) ) { String name = iter . nextToken ( ) . trim ( ) ; if ( name . length ( ) > 0 ) { packages . add ( name ) ; } } } protected void loadConverterMethods ( TypeConverterRegistry registry , Class type ) { if ( visitedClasses . contains ( type ) ) { return ; } visitedClasses . add ( type ) ; try { Method [ ] methods = type . getDeclaredMethods ( ) ; CachingInjector injector = null ; for ( Method method : methods ) { Converter annotation = method . getAnnotation ( Converter . class ) ; if ( annotation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes == null || parameterTypes . length != 1 ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method should have one parameter" ) ; } else { int modifiers = method . getModifiers ( ) ; if ( isAbstract ( modifiers ) || ! isPublic ( modifiers ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method is not a public and concrete method" ) ; } else { Class toType = method . getReturnType ( ) ; if ( toType . equals ( Void . class ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method returns a void method" ) ; } else { Class fromType = parameterTypes [ 0 ] ; if ( isStatic ( modifiers ) ) { registerTypeConverter ( registry , method , toType , fromType , new StaticMethodTypeConverter ( method ) ) ; } else { if ( injector == null ) { injector = new CachingInjector ( registry , type ) ; } registerTypeConverter ( registry , method , toType , fromType , new InstanceMethodTypeConverter ( injector , method ) ) ; } } } } } } Class superclass = type . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { loadConverterMethods ( registry , superclass ) ; } } catch ( NoClassDefFoundError e ) { LOG . debug ( "Ignoring converter type: " + type . getName ( ) + " as a dependent class could not be found: " + e , e ) ; } } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { registry . addTypeConverter ( toType , fromType , typeConverter ) ; } } 	1	['8', '1', '1', '13', '64', '12', '2', '11', '2', '0.785714286', '388', '0.75', '2', '0', '0.321428571', '0', '0', '47', '11', '2.125', '5']
package org . apache . camel ; public interface CamelContextAware { void setCamelContext ( CamelContext camelContext ) ; } 	0	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; public class PropertyEditorTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) == String . class ) { if ( toType == String . class ) { return ObjectHelper . cast ( toType , value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( toType ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return ObjectHelper . cast ( toType , editor . getValue ( ) ) ; } } else if ( toType == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( value . getClass ( ) ) ; if ( editor != null ) { editor . setValue ( value ) ; return ObjectHelper . cast ( toType , editor . getAsText ( ) ) ; } } return null ; } } 	1	['2', '1', '0', '3', '11', '1', '1', '2', '2', '2', '54', '0', '0', '0', '0.666666667', '0', '0', '26', '6', '3', '1']
package org . apache . camel . component . mina ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . support . BaseIoConnectorConfig ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . serialization . ObjectSerializationCodecFactory ; import org . apache . mina . filter . codec . textline . TextLineCodecFactory ; import org . apache . mina . transport . socket . nio . DatagramAcceptor ; import org . apache . mina . transport . socket . nio . DatagramConnector ; import org . apache . mina . transport . socket . nio . DatagramConnectorConfig ; import org . apache . mina . transport . socket . nio . SocketAcceptor ; import org . apache . mina . transport . socket . nio . SocketConnector ; import org . apache . mina . transport . socket . nio . SocketConnectorConfig ; import org . apache . mina . transport . vmpipe . VmPipeAcceptor ; import org . apache . mina . transport . vmpipe . VmPipeAddress ; import org . apache . mina . transport . vmpipe . VmPipeConnector ; public class MinaComponent extends DefaultComponent < MinaExchange > { public MinaComponent ( ) { } public MinaComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < MinaExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI u = new URI ( remaining ) ; String protocol = u . getScheme ( ) ; if ( protocol . equals ( "tcp" ) ) { return createSocketEndpoint ( uri , u , parameters ) ; } else if ( protocol . equals ( "udp" ) || protocol . equals ( "mcast" ) || protocol . equals ( "multicast" ) ) { return createDatagramEndpoint ( uri , u , parameters ) ; } else if ( protocol . equals ( "vm" ) ) { return createVmEndpoint ( uri , u ) ; } else { throw new IOException ( "Unrecognised MINA protocol: " + protocol + " for uri: " + uri ) ; } } protected MinaEndpoint createVmEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new VmPipeAcceptor ( ) ; SocketAddress address = new VmPipeAddress ( connectUri . getPort ( ) ) ; IoConnector connector = new VmPipeConnector ( ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , null ) ; } protected MinaEndpoint createSocketEndpoint ( String uri , URI connectUri , Map parameters ) { IoAcceptor acceptor = new SocketAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new SocketConnector ( ) ; SocketConnectorConfig config = new SocketConnectorConfig ( ) ; configureCodecFactory ( config , parameters ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } protected MinaEndpoint createDatagramEndpoint ( String uri , URI connectUri , Map parameters ) { IoAcceptor acceptor = new DatagramAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new DatagramConnector ( ) ; DatagramConnectorConfig config = new DatagramConnectorConfig ( ) ; configureCodecFactory ( config , parameters ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } protected void configureCodecFactory ( BaseIoConnectorConfig config , Map parameters ) { boolean textline = false ; if ( parameters != null ) { if ( parameters . containsKey ( "codec" ) ) { String value = ( String ) parameters . get ( "codec" ) ; if ( value . equals ( "textline" ) ) { textline = true ; } } else { textline = false ; } } if ( textline ) { config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new TextLineCodecFactory ( ) ) ) ; } else { config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new ObjectSerializationCodecFactory ( ) ) ) ; } } } 	0	['7', '3', '0', '23', '36', '21', '1', '23', '2', '2', '213', '0', '0', '0.821428571', '0.476190476', '2', '2', '29.42857143', '4', '1.1429', '0']
package org . apache . camel . impl ; import java . util . concurrent . Future ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class DefaultConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > { private Endpoint < E > endpoint ; private Processor processor ; private AsyncProcessor asyncProcessor ; private ExceptionHandler exceptionHandler ; public DefaultConsumer ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "Consumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } public AsyncProcessor getAsyncProcessor ( ) { if ( asyncProcessor == null ) { asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; } return asyncProcessor ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	1	['10', '2', '12', '22', '21', '17', '13', '9', '7', '0.777777778', '90', '1', '4', '0.590909091', '0.28', '1', '1', '7.6', '2', '1.1', '3']
package org . apache . camel . component . xmpp ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . GroupChat ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; public class XmppGroupChatProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( XmppGroupChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String room ; private GroupChat chat ; public XmppGroupChatProducer ( XmppEndpoint endpoint , String room ) { super ( endpoint ) ; this . endpoint = endpoint ; this . room = room ; if ( room == null ) { throw new IllegalArgumentException ( "No room property specified" ) ; } } public void process ( Exchange exchange ) { Message message = chat . createMessage ( ) ; message . setTo ( room ) ; message . setFrom ( endpoint . getUser ( ) ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> message: " + message . getBody ( ) ) ; } try { chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( chat == null ) { chat = endpoint . getConnection ( ) . createGroupChat ( room ) ; } } @ Override protected void doStop ( ) throws Exception { if ( chat != null ) { chat . leave ( ) ; chat = null ; } super . doStop ( ) ; } public GroupChat getChat ( ) { return chat ; } public void setChat ( GroupChat chat ) { this . chat = chat ; } public String getRoom ( ) { return room ; } } 	0	['8', '3', '0', '12', '30', '0', '1', '12', '5', '0.642857143', '114', '1', '2', '0.76', '0.314285714', '0', '0', '12.75', '2', '0.875', '0']
package org . apache . camel . component . bean ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BeanComponent extends DefaultComponent { private static final Log LOG = LogFactory . getLog ( BeanComponent . class ) ; private ParameterMappingStrategy parameterMappingStrategy ; public BeanComponent ( ) { } public ProcessorEndpoint createEndpoint ( Object bean ) { String uri = "bean:generated:" + bean ; return createEndpoint ( bean , uri ) ; } public ProcessorEndpoint createEndpoint ( Object bean , String uri ) { BeanProcessor processor = new BeanProcessor ( bean , getCamelContext ( ) , getParameterMappingStrategy ( ) ) ; return createEndpoint ( uri , processor ) ; } public ParameterMappingStrategy getParameterMappingStrategy ( ) { if ( parameterMappingStrategy == null ) { parameterMappingStrategy = createParameterMappingStrategy ( ) ; } return parameterMappingStrategy ; } public void setParameterMappingStrategy ( ParameterMappingStrategy parameterMappingStrategy ) { this . parameterMappingStrategy = parameterMappingStrategy ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Object bean = getBean ( remaining ) ; BeanProcessor processor = new BeanProcessor ( bean , getCamelContext ( ) , getParameterMappingStrategy ( ) ) ; setProperties ( processor , parameters ) ; return createEndpoint ( uri , processor ) ; } public Object getBean ( String remaining ) throws NoBeanAvailableException { Registry registry = getCamelContext ( ) . getRegistry ( ) ; Object bean = registry . lookup ( remaining ) ; if ( bean == null ) { throw new NoBeanAvailableException ( remaining ) ; } return bean ; } protected ProcessorEndpoint createEndpoint ( String uri , BeanProcessor processor ) { ProcessorEndpoint answer = new ProcessorEndpoint ( uri , this , processor ) ; answer . setExchangePattern ( ExchangePattern . InOut ) ; return answer ; } protected ParameterMappingStrategy createParameterMappingStrategy ( ) { return BeanProcessor . createParameterMappingStrategy ( getCamelContext ( ) ) ; } } 	1	['10', '3', '0', '13', '25', '43', '0', '13', '6', '0.833333333', '116', '1', '2', '0.741935484', '0.333333333', '1', '2', '10.4', '2', '0.9', '3']
package org . apache . camel . spring . spi ; import org . apache . camel . spi . Registry ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . context . ApplicationContext ; public class ApplicationContextRegistry implements Registry { private ApplicationContext applicationContext ; public ApplicationContextRegistry ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public < T > T lookup ( String name , Class < T > type ) { try { Object value = applicationContext . getBean ( name , type ) ; return type . cast ( value ) ; } catch ( NoSuchBeanDefinitionException e ) { return null ; } } public Object lookup ( String name ) { try { return applicationContext . getBean ( name ) ; } catch ( NoSuchBeanDefinitionException e ) { return null ; } } } 	0	['3', '1', '0', '4', '7', '0', '1', '3', '3', '0', '31', '1', '0', '0', '0.583333333', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Method ; public interface MethodInvocation { Method getMethod ( ) ; Object [ ] getArguments ( ) ; Object proceed ( ) throws Throwable ; Object getThis ( ) ; AccessibleObject getStaticPart ( ) ; } 	1	['5', '1', '0', '4', '5', '10', '4', '0', '5', '2', '5', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . file . remote ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . component . file . FileComponent ; import org . apache . camel . impl . DefaultProducer ; public abstract class RemoteFileProducer < T extends RemoteFileExchange > extends DefaultProducer < T > { protected RemoteFileProducer ( RemoteFileEndpoint < T > endpoint ) { super ( endpoint ) ; } protected String createFileName ( Message message , RemoteFileConfiguration fileConfig ) { String answer ; String endpointFileName = fileConfig . getFile ( ) ; String headerFileName = message . getHeader ( FileComponent . HEADER_FILE_NAME , String . class ) ; if ( fileConfig . isDirectory ( ) ) { if ( headerFileName != null ) { answer = endpointFileName + "/" + headerFileName ; } else { answer = endpointFileName + "/" + message . getMessageId ( ) ; } } else { answer = endpointFileName ; } return answer ; } } 	0	['2', '3', '2', '7', '10', '1', '2', '5', '0', '2', '49', '0', '0', '0.95', '0.625', '0', '0', '23.5', '3', '1.5', '0']
package org . apache . camel . model . config ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . processor . StreamResequencer ; import org . apache . camel . processor . resequencer . DefaultExchangeComparator ; import org . apache . camel . processor . resequencer . ExpressionResultComparator ; @ XmlRootElement @ XmlAccessorType ( XmlAccessType . FIELD ) public class StreamResequencerConfig { @ XmlAttribute private Integer capacity ; @ XmlAttribute private Long timeout ; @ XmlTransient private ExpressionResultComparator < Exchange > comparator ; public StreamResequencerConfig ( ) { this ( 100 , 1000L ) ; } public StreamResequencerConfig ( int capacity , long timeout ) { this ( capacity , timeout , new DefaultExchangeComparator ( ) ) ; } public StreamResequencerConfig ( int capacity , long timeout , ExpressionResultComparator < Exchange > comparator ) { this . capacity = capacity ; this . timeout = timeout ; this . comparator = comparator ; } public static StreamResequencerConfig getDefault ( ) { return new StreamResequencerConfig ( ) ; } public int getCapacity ( ) { return capacity ; } public void setCapacity ( int capacity ) { this . capacity = capacity ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public ExpressionResultComparator < Exchange > getComparator ( ) { return comparator ; } public void setComparator ( ExpressionResultComparator < Exchange > comparator ) { this . comparator = comparator ; } } 	1	['10', '1', '0', '3', '16', '27', '1', '2', '10', '0.666666667', '69', '1', '1', '0', '0.425', '0', '0', '5.6', '1', '0.7', '1']
package org . apache . camel . bam ; import java . util . Date ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . builder . ProcessorFactory ; import org . apache . camel . impl . EventDrivenConsumerRoute ; public class ActivityBuilder implements ProcessorFactory { private ProcessBuilder processBuilder ; private Endpoint endpoint ; private ActivityRules activityRules ; private Expression correlationExpression ; public ActivityBuilder ( ProcessBuilder processBuilder , Endpoint endpoint ) { this . processBuilder = processBuilder ; this . endpoint = endpoint ; this . activityRules = new ActivityRules ( processBuilder ) ; this . activityRules . setActivityName ( endpoint . getEndpointUri ( ) ) ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Processor createProcessor ( ) throws Exception { return processBuilder . createActivityProcessor ( this ) ; } public Route createRoute ( ) throws Exception { Processor processor = createProcessor ( ) ; if ( processor == null ) { throw new IllegalArgumentException ( "No processor created for ActivityBuilder: " + this ) ; } return new EventDrivenConsumerRoute ( getEndpoint ( ) , processor ) ; } public ActivityBuilder correlate ( Expression correlationExpression ) { this . correlationExpression = correlationExpression ; return this ; } public ActivityBuilder name ( String name ) { activityRules . setActivityName ( name ) ; return this ; } public TimeExpression starts ( ) { return new TimeExpression ( this , ActivityLifecycle . Started ) { public Date evaluate ( ProcessInstance instance , ActivityState state ) { return state . getTimeStarted ( ) ; } } ; } public TimeExpression completes ( ) { return new TimeExpression ( this , ActivityLifecycle . Completed ) { public Date evaluate ( ProcessInstance instance , ActivityState state ) { return state . getTimeCompleted ( ) ; } } ; } public Expression getCorrelationExpression ( ) { return correlationExpression ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ProcessBuilder getProcessBuilder ( ) { return processBuilder ; } } 	0	['11', '1', '0', '13', '24', '39', '5', '12', '11', '0.8', '101', '1', '4', '0', '0.272727273', '0', '0', '7.818181818', '1', '0.9091', '0']
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ProducerCache ; public class CamelTemplate < E extends Exchange > extends ServiceSupport implements ProducerTemplate < E > { private CamelContext context ; private ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public CamelTemplate ( CamelContext context ) { this . context = context ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , exchange ) ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( String endpointUri , Processor processor , AsyncCallback callback ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor , callback ) ; } public E send ( String endpointUri , ExchangePattern pattern , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , pattern , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = endpoint . createExchange ( exchange ) ; producerCache . send ( endpoint , convertedExchange ) ; return convertedExchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { return producerCache . send ( endpoint , processor , callback ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { return producerCache . send ( endpoint , pattern , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) { E result = send ( endpoint , pattern , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( Endpoint < E > endpoint , Object body ) { E result = send ( endpoint , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , body ) ; } public Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , pattern , body ) ; } public Object sendBodyAndHeader ( String endpointUri , final Object body , final String header , final Object headerValue ) { return sendBodyAndHeader ( resolveMandatoryEndpoint ( endpointUri ) , body , header , headerValue ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeaders ( String endpointUri , final Object body , final Map < String , Object > headers ) { return sendBodyAndHeaders ( resolveMandatoryEndpoint ( endpointUri ) , body , headers ) ; } public Object sendBodyAndHeaders ( Endpoint endpoint , final Object body , final Map < String , Object > headers ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public E request ( Endpoint < E > endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( Endpoint < E > endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public E request ( String endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( String endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Object sendBodyAndHeader ( Object body , String header , Object headerValue ) { return sendBodyAndHeader ( getMandatoryDefaultEndpoint ( ) , body , header , headerValue ) ; } public Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) { return sendBodyAndHeaders ( getMandatoryDefaultEndpoint ( ) , body , headers ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } protected Processor createBodyAndHeaderProcessor ( final Object body , final String header , final Object headerValue ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ; } protected Processor createSetBodyProcessor ( final Object body ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected Object extractResultBody ( E result ) { Object answer = null ; if ( result != null ) { answer = result . getOut ( ) . getBody ( ) ; if ( answer == null ) { answer = result . getIn ( ) . getBody ( ) ; } } return answer ; } } 	1	['45', '2', '0', '21', '67', '916', '8', '16', '38', '0.686363636', '461', '1', '3', '0.232142857', '0.252525253', '1', '1', '9.133333333', '5', '1.0889', '2']
package org . apache . camel . component . cxf ; public interface CxfConstants { String METHOD = "method" ; String SEI = "sei" ; String IMPL = "impl" ; String WSDL_URL = "wsdlURL" ; String ADDRESS = "address" ; String SERVICE_NAME = "serviceName" ; String PORT_NAME = "portName" ; String PROTOCOL_NAME_RES = "res" ; String OPERATION_NAME = "operationName" ; String SPRING_CONTEXT_ENDPOINT = "bean:" ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '10', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeleteFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( DeleteFileProcessStrategy . class ) ; public DeleteFileProcessStrategy ( ) { } public DeleteFileProcessStrategy ( boolean lockFile ) { super ( lockFile ) ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Deleting file: " + file ) ; } file . delete ( ) ; super . commit ( endpoint , exchange , file ) ; } } 	1	['4', '2', '0', '5', '15', '4', '1', '5', '3', '0.666666667', '38', '1', '1', '0.857142857', '0.466666667', '0', '0', '8.25', '1', '0.25', '1']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeExchangeException ; import org . apache . camel . util . ServiceHelper ; public class ProcessorPollingConsumer extends PollingConsumerSupport { private Processor processor ; public ProcessorPollingConsumer ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startService ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopService ( processor ) ; } public Exchange receive ( ) { Exchange exchange = getEndpoint ( ) . createExchange ( ) ; try { processor . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeExchangeException ( e , exchange ) ; } return exchange ; } public Exchange receiveNoWait ( ) { return receive ( ) ; } public Exchange receive ( long timeout ) { return receive ( ) ; } } 	0	['6', '3', '0', '7', '13', '3', '1', '6', '4', '0', '46', '1', '1', '0.782608696', '0.375', '1', '1', '6.5', '1', '0.8333', '0']
package org . apache . camel . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . lang . annotation . Annotation ; import java . net . URL ; import java . net . URLDecoder ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarInputStream ; public class ResolverUtil < T > { private static final transient Log LOG = LogFactory . getLog ( ResolverUtil . class ) ; public static interface Test { boolean matches ( Class type ) ; } public static class IsA implements Test { private Class parent ; public IsA ( Class parentType ) { this . parent = parentType ; } public boolean matches ( Class type ) { return type != null && parent . isAssignableFrom ( type ) ; } @ Override public String toString ( ) { return "is assignable to " + parent . getSimpleName ( ) ; } } public static class AnnotatedWith implements Test { private Class < ? extends Annotation > annotation ; public AnnotatedWith ( Class < ? extends Annotation > annotation ) { this . annotation = annotation ; } public boolean matches ( Class type ) { return type != null && type . isAnnotationPresent ( annotation ) ; } @ Override public String toString ( ) { return "annotated with @" + annotation . getSimpleName ( ) ; } } private Set < Class < ? extends T > > matches = new HashSet < Class < ? extends T > > ( ) ; private Set < ClassLoader > classLoaders ; public Set < Class < ? extends T > > getClasses ( ) { return matches ; } public Set < ClassLoader > getClassLoaders ( ) { if ( classLoaders == null ) { classLoaders = new HashSet < ClassLoader > ( ) ; classLoaders . add ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } return classLoaders ; } public void setClassLoaders ( Set < ClassLoader > classLoaders ) { this . classLoaders = classLoaders ; } public void findImplementations ( Class parent , String ... packageNames ) { if ( packageNames == null ) { return ; } LOG . debug ( "Searching for implementations of " + parent . getName ( ) + " in packages: " + Arrays . asList ( packageNames ) ) ; Test test = new IsA ( parent ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } LOG . debug ( "Found: " + getClasses ( ) ) ; } public void findAnnotated ( Class < ? extends Annotation > annotation , String ... packageNames ) { if ( packageNames == null ) { return ; } Test test = new AnnotatedWith ( annotation ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } } public void find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; for ( ClassLoader classLoader : set ) { LOG . trace ( "Searching: " + classLoader ) ; find ( test , packageName , classLoader ) ; } } protected void find ( Test test , String packageName , ClassLoader loader ) { Enumeration < URL > urls ; try { urls = loader . getResources ( packageName ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not read package: " + packageName , ioe ) ; return ; } while ( urls . hasMoreElements ( ) ) { try { URL url = urls . nextElement ( ) ; String urlPath = url . getFile ( ) ; urlPath = URLDecoder . decode ( urlPath , "UTF-8" ) ; if ( urlPath . startsWith ( "file:" ) ) { urlPath = urlPath . substring ( 5 ) ; } if ( urlPath . indexOf ( '!' ) > 0 ) { urlPath = urlPath . substring ( 0 , urlPath . indexOf ( '!' ) ) ; } LOG . debug ( "Scanning for classes in [" + urlPath + "] matching criteria: " + test ) ; File file = new File ( urlPath ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageName , file ) ; } else { loadImplementationsInJar ( test , packageName , file ) ; } } catch ( IOException ioe ) { LOG . warn ( "could not read entries" , ioe ) ; } } } private void loadImplementationsInDirectory ( Test test , String parent , File location ) { File [ ] files = location . listFiles ( ) ; StringBuilder builder = null ; for ( File file : files ) { builder = new StringBuilder ( 100 ) ; String name = file . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; } builder . append ( parent ) . append ( "/" ) . append ( name ) ; String packageOrClass = parent == null ? name : builder . toString ( ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageOrClass , file ) ; } else if ( name . endsWith ( ".class" ) ) { addIfMatching ( test , packageOrClass ) ; } } } private void loadImplementationsInJar ( Test test , String parent , File jarfile ) { try { JarEntry entry ; JarInputStream jarStream = new JarInputStream ( new FileInputStream ( jarfile ) ) ; while ( ( entry = jarStream . getNextJarEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; } if ( ! entry . isDirectory ( ) && name . startsWith ( parent ) && name . endsWith ( ".class" ) ) { addIfMatching ( test , name ) ; } } } catch ( IOException ioe ) { LOG . error ( "Could not search jar file '" + jarfile + "' for classes matching criteria: " + test + "due to an IOException: " + ioe . getMessage ( ) ) ; } } protected void addIfMatching ( Test test , String fqn ) { try { String externalName = fqn . substring ( 0 , fqn . indexOf ( '.' ) ) . replace ( '/' , '.' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; boolean found = false ; for ( ClassLoader classLoader : set ) { LOG . trace ( "Checking to see if class " + externalName + " matches criteria [" + test + "]" ) ; try { Class type = classLoader . loadClass ( externalName ) ; if ( test . matches ( type ) ) { matches . add ( ( Class < T > ) type ) ; } found = true ; break ; } catch ( ClassNotFoundException e ) { LOG . debug ( "Could not find class '" + fqn + "' in class loader: " + classLoader + ". Reason: " + e , e ) ; } } if ( ! found ) { LOG . warn ( "Could not find class '" + fqn + "' in any class loaders: " + set ) ; } } catch ( Throwable t ) { LOG . warn ( "Could not examine class '" + fqn + "' due to a " + t . getClass ( ) . getName ( ) + " with message: " + t . getMessage ( ) ) ; } } } 	1	['12', '1', '0', '7', '62', '28', '2', '5', '7', '0.545454545', '507', '1', '1', '0', '0.329545455', '0', '0', '41', '6', '2.3333', '6']
package org . apache . camel . processor . resequencer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class DefaultExchangeComparator implements ExpressionResultComparator < Exchange > { private Expression < Exchange > expression ; public Expression < Exchange > getExpression ( ) { return expression ; } public void setExpression ( Expression < Exchange > expression ) { this . expression = expression ; } @ SuppressWarnings ( "unchecked" ) public void setExpressions ( List < Expression > expressions ) { if ( expressions . isEmpty ( ) ) { throw new IllegalArgumentException ( "Expression required to resolve sequence number" ) ; } else if ( expressions . size ( ) > 1 ) { throw new IllegalArgumentException ( "More than one expression currently not supported" ) ; } expression = expressions . get ( 0 ) ; } public boolean predecessor ( Exchange o1 , Exchange o2 ) { long n1 = getSequenceNumber ( o1 ) ; long n2 = getSequenceNumber ( o2 ) ; return n1 == ( n2 - 1L ) ; } public boolean successor ( Exchange o1 , Exchange o2 ) { long n1 = getSequenceNumber ( o1 ) ; long n2 = getSequenceNumber ( o2 ) ; return n2 == ( n1 - 1L ) ; } public int compare ( Exchange o1 , Exchange o2 ) { Long n1 = getSequenceNumber ( o1 ) ; Long n2 = getSequenceNumber ( o2 ) ; return n1 . compareTo ( n2 ) ; } private long getSequenceNumber ( Exchange exchange ) { return ( Long ) expression . evaluate ( exchange ) ; } } 	0	['11', '1', '0', '4', '20', '43', '1', '3', '10', '0.1', '124', '1', '1', '0', '0.363636364', '0', '0', '10.18181818', '3', '1.2727', '0']
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; import javax . xml . namespace . QName ; public class XPathLanguage implements Language { private QName resultType ; public Predicate < Exchange > createPredicate ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public Expression < Exchange > createExpression ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public QName getResultType ( ) { return resultType ; } public void setResultType ( QName resultType ) { this . resultType = resultType ; } protected void configureBuilder ( XPathBuilder builder ) { if ( resultType != null ) { builder . setResultType ( resultType ) ; } } } 	1	['6', '1', '0', '4', '9', '9', '0', '4', '5', '0.2', '41', '1', '0', '0', '0.416666667', '0', '0', '5.666666667', '2', '1', '1']
package org . apache . camel . component . cxf . phase ; import java . util . SortedSet ; import org . apache . cxf . common . util . SortedArraySet ; import org . apache . cxf . phase . Phase ; public class FaultPayloadPhaseManagerImpl extends AbstractPhaseManagerImpl { protected SortedSet < Phase > createInPhases ( ) { SortedSet < Phase > inPhases = new SortedArraySet < Phase > ( ) ; int i = 0 ; inPhases . add ( new Phase ( Phase . RECEIVE , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . PRE_STREAM , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . USER_STREAM , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . POST_STREAM , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . READ , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . PRE_PROTOCOL , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . USER_PROTOCOL , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . POST_PROTOCOL , ++ i * 1000 ) ) ; inPhases . add ( new Phase ( Phase . UNMARSHAL , ++ i * 1000 ) ) ; return inPhases ; } protected SortedSet < Phase > createOutPhases ( ) { SortedSet < Phase > outPhases = new SortedArraySet < Phase > ( ) ; int i = 0 ; outPhases . add ( new Phase ( Phase . PREPARE_SEND , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_STREAM , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_PROTOCOL , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_PROTOCOL , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_PROTOCOL , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . WRITE , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . MARSHAL , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_STREAM , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_STREAM , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . SEND , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . SEND_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_STREAM_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_STREAM_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . POST_PROTOCOL_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . USER_PROTOCOL_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . WRITE_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_PROTOCOL_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PRE_STREAM_ENDING , ++ i * 1000 ) ) ; outPhases . add ( new Phase ( Phase . PREPARE_SEND_ENDING , ++ i * 1000 ) ) ; return outPhases ; } } 	0	['3', '2', '0', '4', '7', '3', '1', '3', '1', '2', '330', '0', '0', '0.666666667', '1', '1', '1', '109', '1', '0.6667', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . ExceptionType ; import java . util . IdentityHashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; public abstract class ErrorHandlerSupport extends ServiceSupport implements ErrorHandler { private Map < Class , ExceptionType > exceptionPolicices = new IdentityHashMap < Class , ExceptionType > ( ) ; public void addExceptionPolicy ( ExceptionType exception ) { Processor processor = exception . getErrorHandler ( ) ; addChildService ( processor ) ; List < Class > list = exception . getExceptionClasses ( ) ; for ( Class exceptionType : list ) { exceptionPolicices . put ( exceptionType , exception ) ; } } protected boolean customProcessorForException ( Exchange exchange , Throwable exception ) throws Exception { ExceptionType policy = getExceptionPolicy ( exchange , exception ) ; Processor processor = policy . getErrorHandler ( ) ; if ( processor != null ) { processor . process ( exchange ) ; return true ; } return false ; } protected ExceptionType getExceptionPolicy ( Exchange exchange , Throwable exception ) { Set < Map . Entry < Class , ExceptionType > > entries = exceptionPolicices . entrySet ( ) ; for ( Map . Entry < Class , ExceptionType > entry : entries ) { Class type = entry . getKey ( ) ; if ( type . isInstance ( exception ) ) { return entry . getValue ( ) ; } } return null ; } } 	1	['4', '2', '2', '10', '19', '0', '5', '5', '2', '0', '86', '1', '0', '0.8125', '0.5625', '0', '0', '20.25', '2', '1.25', '2']
package org . apache . camel . component . ibatis ; import java . io . IOException ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultPollingEndpoint ; import com . ibatis . sqlmap . client . SqlMapClient ; public class IBatisEndpoint extends DefaultPollingEndpoint { private final String entityName ; public IBatisEndpoint ( String endpointUri , IBatisComponent component , String entityName ) { super ( endpointUri , component ) ; this . entityName = entityName ; } @ Override public IBatisComponent getComponent ( ) { return ( IBatisComponent ) super . getComponent ( ) ; } public boolean isSingleton ( ) { return true ; } public Producer createProducer ( ) throws Exception { return new IBatisProducer ( this ) ; } @ Override public PollingConsumer createPollingConsumer ( ) throws Exception { return new IBatisPollingConsumer ( this ) ; } public SqlMapClient getSqlClient ( ) throws IOException { return getComponent ( ) . getSqlMapClient ( ) ; } public String getEntityName ( ) { return entityName ; } } 	0	['8', '4', '0', '8', '12', '26', '3', '8', '8', '0.857142857', '43', '1', '0', '0.75862069', '0.416666667', '1', '1', '4.25', '1', '0.875', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "catch" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CatchType extends ProcessorType { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; public CatchType ( ) { } public CatchType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public CatchType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Catch[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return getExceptionClasses ( ) . toString ( ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1	['16', '2', '0', '6', '33', '62', '1', '5', '15', '0.65', '190', '1', '0', '0.877358491', '0.375', '1', '4', '10.625', '2', '0.9375', '3']
package org . apache . camel . spi ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public interface Synchronization { void onComplete ( Exchange exchange ) ; void onFailure ( Exchange exchange ) ; } 	0	['2', '1', '0', '3', '2', '1', '2', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . util . * ; @ Converter public class CollectionConverter { private CollectionConverter ( ) { } @ Converter public static Object [ ] toArray ( Collection value ) { if ( value == null ) { return null ; } return value . toArray ( ) ; } @ Converter public static List toList ( Object [ ] array ) { return Arrays . asList ( array ) ; } @ Converter public static List toList ( Collection collection ) { return new ArrayList ( collection ) ; } @ Converter public static Set toSet ( Object [ ] array ) { Set answer = new HashSet ( ) ; for ( Object element : array ) { answer . add ( element ) ; } return answer ; } @ Converter public static Set toSet ( Collection collection ) { return new HashSet ( collection ) ; } @ Converter public static Set toSet ( Map map ) { return map . entrySet ( ) ; } @ Converter public static Properties toProperties ( Map map ) { Properties answer = new Properties ( ) ; answer . putAll ( map ) ; return answer ; } @ Converter public static Hashtable toHashtable ( Map map ) { return new Hashtable ( map ) ; } @ Converter public static HashMap toHashMap ( Map map ) { return new HashMap ( map ) ; } } 	1	['10', '1', '0', '0', '22', '45', '0', '0', '9', '2', '81', '0', '0', '0', '0.25', '0', '0', '7.1', '2', '1.1', '2']
package org . apache . camel . builder . xml ; import java . io . StringWriter ; import javax . xml . transform . Result ; import javax . xml . transform . stream . StreamResult ; import org . apache . camel . Message ; public class StringResultHandler implements ResultHandler { StringWriter buffer = new StringWriter ( ) ; StreamResult result = new StreamResult ( buffer ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( buffer . toString ( ) ) ; } } 	0	['3', '1', '0', '3', '8', '0', '1', '2', '3', '0.5', '29', '0', '0', '0', '0.666666667', '0', '0', '8', '1', '0.6667', '0']
package org . apache . camel . impl ; import org . apache . camel . Service ; import org . apache . camel . util . ServiceHelper ; import java . util . ArrayList ; import java . util . Collection ; import java . util . concurrent . atomic . AtomicBoolean ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; public abstract class ServiceSupport implements Service { private static int threadCounter ; private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean starting = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; private Collection childServices ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { starting . set ( true ) ; try { if ( childServices != null ) { ServiceHelper . startServices ( childServices ) ; } doStart ( ) ; } finally { starting . set ( false ) ; } } } public void stop ( ) throws Exception { if ( started . get ( ) && stopping . compareAndSet ( false , true ) ) { try { doStop ( ) ; } finally { if ( childServices != null ) { ServiceHelper . stopServices ( childServices ) ; } stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStarting ( ) { return starting . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } protected boolean isRunAllowed ( ) { return ! ( stopping . get ( ) || stopped . get ( ) ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; protected String getThreadName ( String prefix ) { return prefix + " thread:" + nextThreadCounter ( ) ; } protected static synchronized int nextThreadCounter ( ) { return ++ threadCounter ; } protected void addChildService ( Object childService ) { if ( childServices == null ) { childServices = new ArrayList ( ) ; } childServices . add ( childService ) ; } protected boolean removeChildService ( Object childService ) { if ( childServices != null ) { return childServices . remove ( childService ) ; } else { return false ; } } } 	1	['14', '1', '27', '31', '28', '49', '29', '2', '7', '0.807692308', '200', '1', '0', '0', '0.380952381', '0', '0', '12.85714286', '3', '1.2143', '1']
package org . apache . camel ; public interface Predicate < E > { boolean matches ( E exchange ) ; void assertMatches ( String text , E exchange ) throws AssertionError ; } 	0	['2', '1', '0', '31', '2', '1', '31', '0', '2', '2', '2', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . IntrospectionSupport ; @ XmlType ( name = "dataFormatType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DataFormatType { @ XmlTransient private DataFormat dataFormat ; @ XmlTransient private String dataFormatTypeName ; public DataFormatType ( ) { } public DataFormatType ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } protected DataFormatType ( String dataFormatTypeName ) { this . dataFormatTypeName = dataFormatTypeName ; } public DataFormat getDataFormat ( RouteContext routeContext ) { if ( dataFormat == null ) { dataFormat = createDataFormat ( routeContext ) ; ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; configureDataFormat ( dataFormat ) ; } return dataFormat ; } protected DataFormat createDataFormat ( RouteContext routeContext ) { if ( dataFormatTypeName != null ) { Class type = ObjectHelper . loadClass ( dataFormatTypeName , getClass ( ) . getClassLoader ( ) ) ; if ( type == null ) { throw new IllegalArgumentException ( "The class " + dataFormatTypeName + " is not on the classpath! Cannot use the dataFormat " + this ) ; } return ( DataFormat ) ObjectHelper . newInstance ( type ) ; } return null ; } protected void configureDataFormat ( DataFormat dataFormat ) { } protected void setProperty ( DataFormat dataFormat , String name , Object value ) { try { IntrospectionSupport . setProperty ( dataFormat , name , value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Failed to set property " + name + " on " + dataFormat + ". Reason: " + e , e ) ; } } } 	1	['7', '1', '4', '12', '20', '17', '8', '4', '3', '0.75', '108', '1', '1', '0', '0.428571429', '0', '0', '14.14285714', '3', '1', '2']
package org . apache . camel . bam . model ; import java . util . List ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . UniqueConstraint ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; @ Entity @ UniqueConstraint ( columnNames = { "name" } ) public class ProcessDefinition extends EntitySupport { private static final transient Log LOG = LogFactory . getLog ( ProcessDefinition . class ) ; private String name ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public static ProcessDefinition getRefreshedProcessDefinition ( JpaTemplate template , ProcessDefinition definition ) { ObjectHelper . notNull ( definition , "definition" ) ; Long id = definition . getId ( ) ; if ( id == null ) { LOG . warn ( "No primary key is available!" ) ; return findOrCreateProcessDefinition ( template , definition . getName ( ) ) ; } definition = template . find ( ProcessDefinition . class , id ) ; return definition ; } public static ProcessDefinition findOrCreateProcessDefinition ( JpaTemplate template , String processName ) { List < ProcessDefinition > list = template . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; template . persist ( answer ) ; return answer ; } } } 	0	['7', '2', '0', '11', '21', '17', '6', '5', '6', '0.666666667', '90', '1', '1', '0.375', '0.375', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import javax . xml . transform . stream . StreamSource ; public class BytesSource extends StreamSource { private byte [ ] data ; public BytesSource ( byte [ ] data ) { this . data = data ; } public BytesSource ( byte [ ] data , String systemId ) { this . data = data ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { return new ByteArrayInputStream ( data ) ; } public Reader getReader ( ) { return new InputStreamReader ( getInputStream ( ) ) ; } public byte [ ] getData ( ) { return data ; } public String toString ( ) { return "BytesSource[" + new String ( data ) + "]" ; } } 	1	['6', '2', '0', '1', '14', '0', '1', '0', '6', '0', '52', '1', '0', '0.692307692', '0.5', '0', '0', '7.5', '1', '0.6667', '1']
package org . apache . camel . spring . util ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . InitializingBean ; import static org . apache . camel . util . ObjectHelper . name ; public class MainRunner implements InitializingBean , Runnable { private static final Log LOG = LogFactory . getLog ( MainRunner . class ) ; private Class main ; private String [ ] args = { } ; private boolean asyncRun = true ; private long delay ; public String toString ( ) { return "MainRunner(" + name ( main ) + " " + Arrays . asList ( getArgs ( ) ) + ")" ; } public void run ( ) { try { runMethodWithoutCatchingExceptions ( ) ; } catch ( NoSuchMethodException e ) { LOG . error ( "Class: " + name ( main ) + " does not have a main method: " + e , e ) ; } catch ( IllegalAccessException e ) { LOG . error ( "Failed to run: " + this + ". Reason: " + e , e ) ; } catch ( InvocationTargetException e ) { Throwable throwable = e . getTargetException ( ) ; LOG . error ( "Failed to run: " + this + ". Reason: " + throwable , throwable ) ; } } public void runMethodWithoutCatchingExceptions ( ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( delay > 0 ) { try { Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { LOG . info ( "Caught: " + e , e ) ; } } Method method = main . getMethod ( "main" , String [ ] . class ) ; if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) { throw new IllegalArgumentException ( "The main method is not static!: " + method ) ; } Object [ ] arguments = { getArgs ( ) } ; method . invoke ( null , arguments ) ; } public String [ ] getArgs ( ) { return args ; } public void setArgs ( String [ ] args ) { this . args = args ; } public boolean isAsyncRun ( ) { return asyncRun ; } public void setAsyncRun ( boolean asyncRun ) { this . asyncRun = asyncRun ; } public Class getMain ( ) { return main ; } public void setMain ( Class main ) { this . main = main ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public void afterPropertiesSet ( ) throws Exception { if ( main == null ) { throw new IllegalArgumentException ( "You must specify a main class!" ) ; } if ( isAsyncRun ( ) ) { Thread thread = new Thread ( this , "Thread for: " + this ) ; thread . start ( ) ; } else { runMethodWithoutCatchingExceptions ( ) ; } } } 	0	['14', '1', '0', '4', '33', '39', '0', '4', '13', '0.692307692', '231', '1', '1', '0', '0.261538462', '0', '0', '15.14285714', '1', '0.8571', '0']
package org . apache . camel . builder ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . Route ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . InterceptType ; import org . apache . camel . model . OtherwiseType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . RoutesType ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . DelegateProcessor ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; public abstract class RouteBuilder extends BuilderSupport { private AtomicBoolean initalized = new AtomicBoolean ( false ) ; private RoutesType routeCollection = new RoutesType ( ) ; private List < Route > routes = new ArrayList < Route > ( ) ; public RouteBuilder ( ) { this ( null ) ; } public RouteBuilder ( CamelContext context ) { super ( context ) ; } @ Override public String toString ( ) { return routeCollection . toString ( ) ; } public abstract void configure ( ) throws Exception ; public RouteType from ( String uri ) { RouteType answer = routeCollection . from ( uri ) ; configureRoute ( answer ) ; return answer ; } public RouteType from ( Endpoint endpoint ) { RouteType answer = routeCollection . from ( endpoint ) ; configureRoute ( answer ) ; return answer ; } public RouteBuilder errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } public RouteBuilder inheritErrorHandler ( boolean value ) { routeCollection . setInheritErrorHandlerFlag ( value ) ; return this ; } public RouteBuilder intercept ( DelegateProcessor interceptor ) { routeCollection . intercept ( interceptor ) ; return this ; } public InterceptType intercept ( ) { return routeCollection . intercept ( ) ; } public OtherwiseType intercept ( Predicate predicate ) { return routeCollection . intercept ( predicate ) ; } public ExceptionType exception ( Class exceptionType ) { return routeCollection . exception ( exceptionType ) ; } public CamelContext getContext ( ) { CamelContext context = super . getContext ( ) ; if ( context == null ) { context = createContainer ( ) ; setContext ( context ) ; } return context ; } public List < Route > getRouteList ( ) throws Exception { checkInitialized ( ) ; return routes ; } protected void checkInitialized ( ) throws Exception { if ( initalized . compareAndSet ( false , true ) ) { configure ( ) ; populateRoutes ( routes ) ; } } protected void populateRoutes ( List < Route > routes ) throws Exception { CamelContext camelContext = getContext ( ) ; if ( camelContext == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } routeCollection . setCamelContext ( camelContext ) ; camelContext . addRouteDefinitions ( routeCollection . getRoutes ( ) ) ; } public void setRouteCollection ( RoutesType routeCollection ) { this . routeCollection = routeCollection ; } protected CamelContext createContainer ( ) { return new DefaultCamelContext ( ) ; } protected void configureRoute ( RouteType route ) { route . setGroup ( getClass ( ) . getName ( ) ) ; } } 	1	['19', '2', '3', '17', '44', '55', '7', '12', '15', '0.666666667', '168', '1', '1', '0.622222222', '0.131578947', '1', '3', '7.684210526', '2', '0.9474', '3']
package org . apache . camel . impl ; import org . apache . camel . Processor ; import org . apache . camel . spi . Policy ; public class NoPolicy < E > implements Policy < E > { public Processor wrap ( Processor processor ) { return processor ; } } 	0	['2', '1', '0', '2', '3', '1', '0', '2', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . UuidGenerator ; import java . util . HashMap ; import java . util . Map ; public class DefaultExchange implements Exchange { private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > properties ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId = DefaultExchange . DEFAULT_ID_GENERATOR . generateId ( ) ; private UnitOfWork unitOfWork ; private ExchangePattern pattern ; public DefaultExchange ( CamelContext context ) { this ( context , ExchangePattern . InOnly ) ; } public DefaultExchange ( CamelContext context , ExchangePattern pattern ) { this . context = context ; this . pattern = pattern ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setProperties ( safeCopy ( exchange . getProperties ( ) ) ) ; safeCopy ( getIn ( ) , exchange , exchange . getIn ( ) ) ; Message copyOut = exchange . getOut ( false ) ; if ( copyOut != null ) { safeCopy ( getOut ( true ) , exchange , copyOut ) ; } Message copyFault = exchange . getFault ( false ) ; if ( copyFault != null ) { safeCopy ( getFault ( true ) , exchange , copyFault ) ; } setException ( exchange . getException ( ) ) ; unitOfWork = exchange . getUnitOfWork ( ) ; pattern = exchange . getPattern ( ) ; } private static void safeCopy ( Message message , Exchange exchange , Message that ) { if ( message != null ) { message . copyFrom ( that ) ; } } private static Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) { return null ; } return new HashMap < String , Object > ( properties ) ; } private static Message safeCopy ( Exchange exchange , Message message ) { if ( message == null ) { return null ; } Message answer = message . copy ( ) ; if ( answer instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) answer ; messageSupport . setExchange ( exchange ) ; } return answer ; } public Exchange newInstance ( ) { return new DefaultExchange ( context ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( properties != null ) { return properties . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { getProperties ( ) . put ( name , value ) ; } public Object removeProperty ( String name ) { return getProperties ( ) . remove ( name ) ; } public Map < String , Object > getProperties ( ) { if ( properties == null ) { properties = new HashMap < String , Object > ( ) ; } return properties ; } public void setProperties ( Map < String , Object > properties ) { this . properties = properties ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } public void throwException ( ) throws Exception { if ( exception == null ) { return ; } if ( exception instanceof Exception ) { throw ( Exception ) exception ; } if ( exception instanceof RuntimeException ) { throw ( RuntimeException ) exception ; } throw new RuntimeCamelException ( exception ) ; } public Message getFault ( ) { return getFault ( true ) ; } public Message getFault ( boolean lazyCreate ) { if ( fault == null && lazyCreate ) { fault = createFaultMessage ( ) ; configureMessage ( fault ) ; } return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } public boolean isFailed ( ) { Message faultMessage = getFault ( false ) ; if ( faultMessage != null ) { Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { return true ; } } return getException ( ) != null ; } public UnitOfWork getUnitOfWork ( ) { return unitOfWork ; } public void setUnitOfWork ( UnitOfWork unitOfWork ) { this . unitOfWork = unitOfWork ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected Message createFaultMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1	['39', '1', '11', '23', '67', '687', '13', '10', '31', '0.897368421', '405', '1', '7', '0', '0.13377193', '0', '0', '9.128205128', '4', '1.3846', '4']
package org . apache . camel . component . jms ; import javax . jms . Message ; import org . apache . camel . impl . PollingConsumerSupport ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; public class JmsPollingConsumer extends PollingConsumerSupport < JmsExchange > { private JmsOperations template ; public JmsPollingConsumer ( JmsEndpoint endpoint , JmsOperations template ) { super ( endpoint ) ; this . template = template ; } @ Override public JmsEndpoint getEndpoint ( ) { return ( JmsEndpoint ) super . getEndpoint ( ) ; } public JmsExchange receiveNoWait ( ) { return receive ( 0 ) ; } public JmsExchange receive ( ) { return receive ( - 1 ) ; } public JmsExchange receive ( long timeout ) { setReceiveTimeout ( timeout ) ; Message message = template . receive ( ) ; if ( message != null ) { return getEndpoint ( ) . createExchange ( message ) ; } return null ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } protected void setReceiveTimeout ( long timeout ) { if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setReceiveTimeout ( timeout ) ; } else if ( template instanceof JmsTemplate102 ) { JmsTemplate102 jmsTemplate102 = ( JmsTemplate102 ) template ; jmsTemplate102 . setReceiveTimeout ( timeout ) ; } else { throw new IllegalArgumentException ( "Cannot set the receiveTimeout property on unknown JmsOperations type: " + template ) ; } } } 	0	['12', '3', '0', '8', '19', '60', '1', '8', '9', '0.363636364', '101', '1', '0', '0.620689655', '0.354166667', '1', '1', '7.333333333', '3', '1.1667', '0']
package org . apache . camel . builder . xml ; public class DomResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new DomResultHandler ( ) ; } } 	1	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '2']
package org . apache . camel . component . irc ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . schwering . irc . lib . IRCUser ; public class IrcMessage extends DefaultMessage { private String messageType ; private String target ; private IRCUser user ; private String whoWasKickedNick ; private String message ; public IrcMessage ( ) { } public IrcMessage ( String messageType , IRCUser user , String message ) { this . messageType = messageType ; this . user = user ; this . message = message ; } public IrcMessage ( String messageType , String target , IRCUser user , String message ) { this . messageType = messageType ; this . target = target ; this . user = user ; this . message = message ; } public IrcMessage ( String messageType , String target , IRCUser user , String whoWasKickedNick , String message ) { this . messageType = messageType ; this . target = target ; this . user = user ; this . whoWasKickedNick = whoWasKickedNick ; this . message = message ; } public IrcMessage ( String messageType , String target , IRCUser user ) { this . messageType = messageType ; this . target = target ; this . user = user ; } public String getMessageType ( ) { return messageType ; } public void setMessageType ( String messageType ) { this . messageType = messageType ; } public String getTarget ( ) { return target ; } public void setTarget ( String target ) { this . target = target ; } public IRCUser getUser ( ) { return user ; } public void setUser ( IRCUser user ) { this . user = user ; } public String getWhoWasKickedNick ( ) { return whoWasKickedNick ; } public void setWhoWasKickedNick ( String whoWasKickedNick ) { this . whoWasKickedNick = whoWasKickedNick ; } public String getMessage ( ) { return message ; } public void setMessage ( String message ) { this . message = message ; } @ Override public IrcExchange getExchange ( ) { return ( IrcExchange ) super . getExchange ( ) ; } @ Override protected Object createBody ( ) { IrcExchange ircExchange = getExchange ( ) ; IrcBinding binding = ircExchange . getBinding ( ) ; return binding . extractBodyFromIrc ( ircExchange , this ) ; } @ Override public IrcMessage newInstance ( ) { return new IrcMessage ( ) ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { map . put ( "irc.messageType" , messageType ) ; if ( target != null ) { map . put ( "irc.target" , target ) ; } if ( whoWasKickedNick != null ) { map . put ( "irc.user.kicked" , whoWasKickedNick ) ; } if ( user != null ) { map . put ( "irc.user.host" , user . getHost ( ) ) ; map . put ( "irc.user.nick" , user . getNick ( ) ) ; map . put ( "irc.user.servername" , user . getServername ( ) ) ; map . put ( "irc.user.username" , user . getUsername ( ) ) ; } } @ Override public String toString ( ) { if ( message != null ) { return "IrcMessage: " + message ; } else { return "IrcMessage: " + getBody ( ) ; } } } 	0	['23', '3', '0', '7', '34', '137', '3', '6', '21', '0.772727273', '230', '1', '0', '0.56097561', '0.402173913', '2', '6', '8.782608696', '4', '0.9565', '0']
package org . apache . camel . component . bean ; import org . apache . camel . * ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . language . LanguageAnnotation ; import static org . apache . camel . util . ExchangeHelper . convertToType ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; public class BeanInfo { private static final transient Log LOG = LogFactory . getLog ( BeanInfo . class ) ; private final CamelContext camelContext ; private Class type ; private ParameterMappingStrategy strategy ; private Map < String , MethodInfo > operations = new ConcurrentHashMap < String , MethodInfo > ( ) ; private MethodInfo defaultMethod ; private List < MethodInfo > operationsWithBody = new ArrayList < MethodInfo > ( ) ; public BeanInfo ( CamelContext camelContext , Class type , ParameterMappingStrategy strategy ) { this . camelContext = camelContext ; this . type = type ; this . strategy = strategy ; introspect ( getType ( ) ) ; if ( operations . size ( ) == 1 ) { Collection < MethodInfo > methodInfos = operations . values ( ) ; for ( MethodInfo methodInfo : methodInfos ) { defaultMethod = methodInfo ; } } } public Class getType ( ) { return type ; } public CamelContext getCamelContext ( ) { return camelContext ; } public MethodInvocation createInvocation ( Method method , Object pojo , Exchange exchange ) throws RuntimeCamelException { MethodInfo methodInfo = introspect ( type , method ) ; if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } public MethodInvocation createInvocation ( Object pojo , Exchange exchange ) throws RuntimeCamelException , AmbiguousMethodCallException { MethodInfo methodInfo = null ; String name = exchange . getIn ( ) . getHeader ( BeanProcessor . METHOD_NAME , String . class ) ; if ( name != null ) { methodInfo = operations . get ( name ) ; } if ( methodInfo == null ) { methodInfo = chooseMethod ( pojo , exchange ) ; } if ( methodInfo == null ) { methodInfo = defaultMethod ; } if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } protected void introspect ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( isValidMethod ( clazz , method ) ) { introspect ( clazz , method ) ; } } Class superclass = clazz . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { introspect ( superclass ) ; } } protected MethodInfo introspect ( Class clazz , Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parametersAnnotations = method . getParameterAnnotations ( ) ; final Expression [ ] parameterExpressions = new Expression [ parameterTypes . length ] ; List < ParameterInfo > parameters = new ArrayList < ParameterInfo > ( ) ; List < ParameterInfo > bodyParameters = new ArrayList < ParameterInfo > ( ) ; boolean hasCustomAnnotation = false ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { Class parameterType = parameterTypes [ i ] ; Annotation [ ] parameterAnnotations = parametersAnnotations [ i ] ; Expression expression = createParameterUnmarshalExpression ( clazz , method , parameterType , parameterAnnotations ) ; hasCustomAnnotation |= expression != null ; if ( expression == null ) { hasCustomAnnotation |= ObjectHelper . hasAnnotation ( parameterAnnotations , Body . class ) ; if ( bodyParameters . isEmpty ( ) ) { expression = ExpressionBuilder . bodyExpression ( parameterType ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No expression available for method: " + method . toString ( ) + " which already has a body so ignoring parameter: " + i + " so ignoring method" ) ; } return null ; } } ParameterInfo parameterInfo = new ParameterInfo ( i , parameterType , parameterAnnotations , expression ) ; parameters . add ( parameterInfo ) ; if ( isPossibleBodyParameter ( parameterAnnotations ) ) { bodyParameters . add ( parameterInfo ) ; } } String opName = method . getName ( ) ; MethodInfo methodInfo = new MethodInfo ( clazz , method , parameters , bodyParameters , hasCustomAnnotation ) ; operations . put ( opName , methodInfo ) ; if ( methodInfo . hasBodyParameter ( ) ) { operationsWithBody . add ( methodInfo ) ; } return methodInfo ; } protected MethodInfo chooseMethod ( Object pojo , Exchange exchange ) throws AmbiguousMethodCallException { if ( operationsWithBody . size ( ) == 1 ) { return operationsWithBody . get ( 0 ) ; } else if ( ! operationsWithBody . isEmpty ( ) ) { Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; if ( body != null ) { Class bodyType = body . getClass ( ) ; List < MethodInfo > possibles = new ArrayList < MethodInfo > ( ) ; for ( MethodInfo methodInfo : operationsWithBody ) { if ( methodInfo . bodyParameterMatches ( bodyType ) ) { possibles . add ( methodInfo ) ; } } if ( possibles . size ( ) == 1 ) { return possibles . get ( 0 ) ; } else if ( possibles . isEmpty ( ) ) { Object newBody = null ; MethodInfo matched = null ; for ( MethodInfo methodInfo : operationsWithBody ) { Object value = convertToType ( exchange , methodInfo . getBodyParameterType ( ) , body ) ; if ( value != null ) { if ( newBody != null ) { throw new AmbiguousMethodCallException ( exchange , Arrays . asList ( matched , methodInfo ) ) ; } else { newBody = value ; matched = methodInfo ; } } } if ( matched != null ) { in . setBody ( newBody ) ; return matched ; } } else { MethodInfo chosen = null ; for ( MethodInfo possible : possibles ) { if ( possible . isHasCustomAnnotation ( ) ) { if ( chosen != null ) { chosen = null ; break ; } else { chosen = possible ; } } } if ( chosen != null ) { return chosen ; } throw new AmbiguousMethodCallException ( exchange , possibles ) ; } } return null ; } return null ; } protected Expression createParameterUnmarshalExpression ( Class clazz , Method method , Class parameterType , Annotation [ ] parameterAnnotation ) { for ( Annotation annotation : parameterAnnotation ) { Expression answer = createParameterUnmarshalExpressionForAnnotation ( clazz , method , parameterType , annotation ) ; if ( answer != null ) { return answer ; } } return strategy . getDefaultParameterTypeExpression ( parameterType ) ; } protected boolean isPossibleBodyParameter ( Annotation [ ] annotations ) { if ( annotations != null ) { for ( Annotation annotation : annotations ) { if ( ( annotation instanceof Property ) || ( annotation instanceof Header ) ) { return false ; } } } return true ; } protected Expression createParameterUnmarshalExpressionForAnnotation ( Class clazz , Method method , Class parameterType , Annotation annotation ) { if ( annotation instanceof Property ) { Property propertyAnnotation = ( Property ) annotation ; return ExpressionBuilder . propertyExpression ( propertyAnnotation . name ( ) ) ; } else if ( annotation instanceof Properties ) { return ExpressionBuilder . propertiesExpresion ( ) ; } else if ( annotation instanceof Header ) { Header headerAnnotation = ( Header ) annotation ; return ExpressionBuilder . headerExpression ( headerAnnotation . name ( ) ) ; } else if ( annotation instanceof Headers ) { return ExpressionBuilder . headersExpresion ( ) ; } else { LanguageAnnotation languageAnnotation = annotation . annotationType ( ) . getAnnotation ( LanguageAnnotation . class ) ; if ( languageAnnotation != null ) { Class < ? > type = languageAnnotation . factory ( ) ; Object object = camelContext . getInjector ( ) . newInstance ( type ) ; if ( object instanceof AnnotationExpressionFactory ) { AnnotationExpressionFactory expressionFactory = ( AnnotationExpressionFactory ) object ; return expressionFactory . createExpression ( camelContext , annotation , languageAnnotation , parameterType ) ; } else { LOG . error ( "Ignoring bad annotation: " + languageAnnotation + "on method: " + method + " which declares a factory: " + type . getName ( ) + " which does not implement " + AnnotationExpressionFactory . class . getName ( ) ) ; } } } return null ; } protected boolean isValidMethod ( Class clazz , Method method ) { return Modifier . isPublic ( method . getModifiers ( ) ) ; } } 	1	['13', '1', '0', '23', '77', '48', '1', '22', '5', '0.738095238', '614', '1', '4', '0', '0.314814815', '0', '0', '45.69230769', '8', '2.6154', '9']
package org . apache . camel . processor . validation ; import java . util . ArrayList ; import java . util . List ; import javax . xml . transform . dom . DOMResult ; import javax . xml . validation . Schema ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public class DefaultValidationErrorHandler implements ValidatorErrorHandler { private static final transient Log log = LogFactory . getLog ( DefaultValidationErrorHandler . class ) ; private List < SAXParseException > warnings = new ArrayList < SAXParseException > ( ) ; private List < SAXParseException > errors = new ArrayList < SAXParseException > ( ) ; private List < SAXParseException > fatalErrors = new ArrayList < SAXParseException > ( ) ; public void warning ( SAXParseException e ) throws SAXException { if ( log . isDebugEnabled ( ) ) { log . debug ( "warning: " + e , e ) ; } warnings . add ( e ) ; } public void error ( SAXParseException e ) throws SAXException { if ( log . isDebugEnabled ( ) ) { log . debug ( "error: " + e , e ) ; } errors . add ( e ) ; } public void fatalError ( SAXParseException e ) throws SAXException { if ( log . isDebugEnabled ( ) ) { log . debug ( "fatalError: " + e , e ) ; } fatalErrors . add ( e ) ; } public void reset ( ) { } public boolean isValid ( ) { return errors . isEmpty ( ) && fatalErrors . isEmpty ( ) ; } public void handleErrors ( Exchange exchange , Schema schema , DOMResult result ) throws ValidationException { if ( ! isValid ( ) ) { throw new SchemaValidationException ( exchange , schema , fatalErrors , errors , warnings ) ; } } public void handleErrors ( Exchange exchange , Object schema ) throws ValidationException { if ( ! isValid ( ) ) { throw new SchemaValidationException ( exchange , schema , fatalErrors , errors , warnings ) ; } } } 	0	['9', '1', '0', '8', '21', '0', '2', '6', '8', '0.5625', '140', '1', '1', '0', '0.333333333', '0', '0', '14.11111111', '3', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlRootElement ( name = "filter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FilterType extends ExpressionNode { public FilterType ( ) { } public FilterType ( ExpressionType expression ) { super ( expression ) ; } public FilterType ( Predicate predicate ) { super ( predicate ) ; } @ Override public String toString ( ) { return "Filter[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1	['6', '3', '0', '9', '15', '15', '3', '6', '6', '2', '42', '0', '0', '0.971428571', '0.416666667', '2', '3', '6', '1', '0.5', '3']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . ArrayList ; import java . util . List ; @ XmlRootElement ( name = "exchange" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class ExchangeType { @ XmlElement ( name = "property" , required = false ) List < PropertyType > properties = new ArrayList < PropertyType > ( ) ; @ XmlAnyElement ( lax = true ) private Object body ; public Object getBody ( ) { return body ; } public void setBody ( Object body ) { this . body = body ; } public List < PropertyType > getProperties ( ) { return properties ; } public void setProperties ( List < PropertyType > properties ) { this . properties = properties ; } } 	0	['5', '1', '0', '0', '7', '2', '0', '0', '5', '0.625', '29', '0.5', '0', '0', '0.466666667', '0', '0', '4.4', '1', '0.8', '0']
package org . apache . camel . processor . idempotent ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . util . LRUCache ; public class MemoryMessageIdRepository implements MessageIdRepository { private Map cache ; public MemoryMessageIdRepository ( Map set ) { this . cache = set ; } public static MessageIdRepository memoryMessageIdRepository ( ) { return memoryMessageIdRepository ( new HashMap ( ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( int cacheSize ) { return memoryMessageIdRepository ( new LRUCache ( cacheSize ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( Map cache ) { return new MemoryMessageIdRepository ( cache ) ; } public boolean contains ( String messageId ) { synchronized ( cache ) { if ( cache . containsKey ( messageId ) ) { return true ; } else { cache . put ( messageId , messageId ) ; return false ; } } } } 	1	['5', '1', '0', '2', '10', '8', '0', '2', '5', '0.5', '57', '1', '0', '0', '0.3', '0', '0', '10.2', '2', '1', '1']
package org . apache . camel . impl ; import java . util . List ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Service ; public class EventDrivenConsumerRoute < E extends Exchange > extends Route < E > { private Processor processor ; public EventDrivenConsumerRoute ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } @ Override public String toString ( ) { return "EventDrivenConsumerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } public Processor getProcessor ( ) { return processor ; } public void setProcessor ( Processor processor ) { this . processor = processor ; } @ Override protected void addServices ( List < Service > services ) throws Exception { Processor processor = getProcessor ( ) ; if ( processor instanceof Service ) { Service service = ( Service ) processor ; services . add ( service ) ; } Endpoint < E > endpoint = getEndpoint ( ) ; Consumer < E > consumer = endpoint . createConsumer ( processor ) ; if ( consumer != null ) { services . add ( consumer ) ; } } } 	0	['5', '2', '0', '7', '13', '0', '2', '5', '4', '0', '64', '1', '1', '0.692307692', '0.45', '1', '1', '11.6', '1', '0.8', '0']
package org . apache . camel . language ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; public class ExpressionEvaluationException extends RuntimeCamelException { private final Expression < Exchange > expression ; private final Exchange exchange ; public ExpressionEvaluationException ( Expression < Exchange > expression , Exchange exchange , Throwable cause ) { super ( cause ) ; this . expression = expression ; this . exchange = exchange ; } public Expression < Exchange > getExpression ( ) { return expression ; } } 	1	['2', '5', '0', '4', '3', '0', '1', '3', '2', '0.5', '17', '1', '2', '0.944444444', '0.625', '0', '0', '6.5', '1', '0.5', '1']
package org . apache . camel . component . mail ; import java . io . IOException ; import javax . mail . BodyPart ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import org . apache . camel . Converter ; @ Converter public class MailConverters { @ Converter public String toString ( Message message ) throws MessagingException , IOException { Object content = message . getContent ( ) ; if ( content instanceof MimeMultipart ) { MimeMultipart multipart = ( MimeMultipart ) content ; if ( multipart . getCount ( ) > 0 ) { BodyPart part = multipart . getBodyPart ( 0 ) ; content = part . getContent ( ) ; } } if ( content != null ) { return content . toString ( ) ; } return null ; } @ Converter public static String toString ( Multipart multipart ) throws MessagingException , IOException { int size = multipart . getCount ( ) ; for ( int i = 0 ; i < size ; i ++ ) { BodyPart part = multipart . getBodyPart ( i ) ; if ( part . getContentType ( ) . startsWith ( "text" ) ) { return part . getContent ( ) . toString ( ) ; } } return null ; } } 	0	['3', '1', '0', '0', '13', '3', '0', '0', '3', '2', '57', '0', '0', '0', '0.444444444', '0', '0', '18', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . config . BatchResequencerConfig ; import org . apache . camel . model . config . StreamResequencerConfig ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Resequencer ; import org . apache . camel . processor . StreamResequencer ; @ XmlRootElement ( name = "resequencer" ) public class ResequencerType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < ExpressionType > expressions = new ArrayList < ExpressionType > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private BatchResequencerConfig batchConfig ; private StreamResequencerConfig streamConfig ; @ XmlTransient private List < Expression > expressionList ; public ResequencerType ( ) { this ( null ) ; } public ResequencerType ( List < Expression > expressions ) { this . expressionList = expressions ; this . batch ( ) ; } public ResequencerType stream ( ) { return stream ( StreamResequencerConfig . getDefault ( ) ) ; } public ResequencerType batch ( ) { return batch ( BatchResequencerConfig . getDefault ( ) ) ; } public ResequencerType stream ( StreamResequencerConfig config ) { this . streamConfig = config ; this . batchConfig = null ; return this ; } public ResequencerType batch ( BatchResequencerConfig config ) { this . batchConfig = config ; this . streamConfig = null ; return this ; } @ Override public String toString ( ) { return "Resequencer[ " + getExpressions ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return ExpressionType . getLabel ( getExpressions ( ) ) ; } public List < ExpressionType > getExpressions ( ) { return expressions ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public BatchResequencerConfig getBatchConfig ( ) { return batchConfig ; } public BatchResequencerConfig getBatchConfig ( BatchResequencerConfig defaultConfig ) { return batchConfig ; } public StreamResequencerConfig getStreamConfig ( ) { return streamConfig ; } @ XmlElement ( name = "batch-config" , required = false ) public void setBatchConfig ( BatchResequencerConfig batchConfig ) { batch ( batchConfig ) ; } @ XmlElement ( name = "stream-config" , required = false ) public void setStreamConfig ( StreamResequencerConfig streamConfig ) { stream ( streamConfig ) ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createStreamResequencer ( routeContext , streamConfig ) ; } @ Override public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { if ( batchConfig != null ) { routes . add ( createBatchResequencerRoute ( routeContext ) ) ; } else { super . addRoutes ( routeContext , routes ) ; } } private Route < Exchange > createBatchResequencerRoute ( RouteContext routeContext ) throws Exception { final Resequencer resequencer = createBatchResequencer ( routeContext , batchConfig ) ; return new Route < Exchange > ( routeContext . getEndpoint ( ) , resequencer ) { @ Override public String toString ( ) { return "BatchResequencerRoute[" + getEndpoint ( ) + " -> " + resequencer . getProcessor ( ) + "]" ; } } ; } protected Resequencer createBatchResequencer ( RouteContext routeContext , BatchResequencerConfig config ) throws Exception { Processor processor = routeContext . createProcessor ( this ) ; Resequencer resequencer = new Resequencer ( routeContext . getEndpoint ( ) , processor , resolveExpressionList ( routeContext ) ) ; resequencer . setBatchSize ( config . getBatchSize ( ) ) ; resequencer . setBatchTimeout ( config . getBatchTimeout ( ) ) ; return resequencer ; } protected StreamResequencer createStreamResequencer ( RouteContext routeContext , StreamResequencerConfig config ) throws Exception { config . getComparator ( ) . setExpressions ( resolveExpressionList ( routeContext ) ) ; Processor processor = routeContext . createProcessor ( this ) ; StreamResequencer resequencer = new StreamResequencer ( processor , config . getComparator ( ) , config . getCapacity ( ) ) ; resequencer . setTimeout ( config . getTimeout ( ) ) ; return resequencer ; } private List < Expression > resolveExpressionList ( RouteContext routeContext ) { if ( expressionList == null ) { expressionList = new ArrayList < Expression > ( ) ; for ( ExpressionType expression : expressions ) { expressionList . add ( expression . createExpression ( routeContext ) ) ; } } if ( expressionList . isEmpty ( ) ) { throw new IllegalArgumentException ( "No expressions configured for: " + this ) ; } return expressionList ; } } 	1	['24', '2', '0', '16', '56', '218', '3', '15', '20', '0.753623188', '275', '1', '2', '0.808695652', '0.284722222', '1', '4', '10.20833333', '4', '1.0417', '5']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . staxutils . StaxUtils ; public abstract class AbstractMessageInInterceptor < T extends Message > extends AbstractPhaseInterceptor < T > { private static final Logger LOG = LogUtils . getL7dLogger ( AbstractMessageInInterceptor . class ) ; public AbstractMessageInInterceptor ( String phase ) { super ( phase ) ; } protected boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } public void handleMessage ( T message ) throws Fault { Logger logger = getLogger ( ) ; if ( isFaultMessage ( message ) ) { message . getInterceptorChain ( ) . abort ( ) ; Endpoint ep = message . getExchange ( ) . get ( Endpoint . class ) ; if ( ep . getInFaultObserver ( ) != null ) { ep . getInFaultObserver ( ) . onMessage ( message ) ; return ; } } Document document = createDOMMessage ( message ) ; Element payloadEl = ( Element ) document . getChildNodes ( ) . item ( 0 ) ; Exchange ex = message . getExchange ( ) ; BindingOperationInfo boi = ex . get ( BindingOperationInfo . class ) ; if ( boi == null ) { BindingInfo bi = ex . get ( BindingInfo . class ) ; if ( bi == null ) { Endpoint ep = ex . get ( Endpoint . class ) ; bi = ep . getEndpointInfo ( ) . getBinding ( ) ; ex . put ( BindingInfo . class , bi ) ; } if ( logger . isLoggable ( Level . INFO ) ) { logger . info ( "AbstractRoutingMessageInInterceptor Infer BindingOperationInfo." ) ; } boi = getBindingOperation ( message , document ) ; if ( boi == null ) { QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; throw new Fault ( new org . apache . cxf . common . i18n . Message ( "REQ_NOT_UNDERSTOOD" , LOG , startQName ) ) ; } if ( boi != null ) { ex . put ( BindingOperationInfo . class , boi ) ; ex . put ( OperationInfo . class , boi . getOperationInfo ( ) ) ; ex . setOneWay ( boi . getOperationInfo ( ) . isOneWay ( ) ) ; if ( logger . isLoggable ( Level . INFO ) ) { logger . info ( "DOMInInterceptor- BindingOperation is:" + boi . getName ( ) ) ; } } } BindingMessageInfo bmi = isRequestor ( message ) ? boi . getOutput ( ) : boi . getInput ( ) ; List < Element > partList = getPartList ( message , payloadEl , bmi ) ; message . put ( List . class , partList ) ; Element header = getHeader ( message ) ; message . put ( Element . class , header ) ; } protected Document createDOMMessage ( T message ) { Document doc = null ; try { if ( getLogger ( ) . isLoggable ( Level . INFO ) ) { getLogger ( ) . info ( "AbstractMessageInInterceptor Converting Stax Stream to DOM" ) ; } XMLStreamReader xsr = message . getContent ( XMLStreamReader . class ) ; doc = StaxUtils . read ( xsr ) ; } catch ( XMLStreamException xe ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "STAX_READ_EXC" , LOG ) , xe ) ; } return doc ; } protected abstract Logger getLogger ( ) ; protected abstract boolean isFaultMessage ( T message ) ; protected abstract BindingOperationInfo getBindingOperation ( T inMessage , Document document ) ; protected abstract List < Element > getPartList ( T inMessage , Element rootElement , BindingMessageInfo boi ) ; protected abstract Element getHeader ( T inMessage ) ; } 	0	['10', '0', '2', '17', '46', '39', '2', '15', '2', '0.777777778', '221', '1', '0', '0', '0.37037037', '0', '0', '21', '2', '0.9', '0']
package org . apache . camel . impl ; import org . apache . camel . Message ; import java . util . HashMap ; import java . util . Map ; public class DefaultMessage extends MessageSupport { private Map < String , Object > headers ; @ Override public String toString ( ) { return "Message: " + getBody ( ) ; } public Object getHeader ( String name ) { return getHeaders ( ) . get ( name ) ; } public < T > T getHeader ( String name , Class < T > type ) { Object value = getHeader ( name ) ; return getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setHeader ( String name , Object value ) { if ( headers == null ) { headers = createHeaders ( ) ; } headers . put ( name , value ) ; } public Object removeHeader ( String name ) { if ( headers != null ) { return headers . remove ( name ) ; } else { return null ; } } public Map < String , Object > getHeaders ( ) { if ( headers == null ) { headers = createHeaders ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public DefaultMessage newInstance ( ) { return new DefaultMessage ( ) ; } protected Map < String , Object > createHeaders ( ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; populateInitialHeaders ( map ) ; return map ; } protected void populateInitialHeaders ( Map < String , Object > map ) { } } 	1	['12', '2', '9', '15', '25', '54', '10', '5', '10', '0.545454545', '98', '1', '0', '0.52173913', '0.333333333', '1', '2', '7.083333333', '2', '1.1667', '1']
package org . apache . camel . util ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionHelper { private ExpressionHelper ( ) { } public static < E extends Exchange > String evaluateAsString ( Expression < E > expression , E exchange ) { return evaluateAsType ( expression , exchange , String . class ) ; } public static < T , E extends Exchange > T evaluateAsType ( Expression < E > expression , E exchange , Class < T > resultType ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( resultType , value ) ; } } 	0	['3', '1', '0', '6', '8', '3', '2', '4', '2', '2', '23', '0', '0', '0', '0.5', '0', '0', '6.666666667', '1', '0.6667', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . SendProcessor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class BuilderSupport { private CamelContext context ; private ErrorHandlerBuilder errorHandlerBuilder ; private boolean inheritErrorHandler = true ; protected BuilderSupport ( CamelContext context ) { this . context = context ; } protected BuilderSupport ( BuilderSupport parent ) { this . context = parent . getContext ( ) ; this . inheritErrorHandler = parent . inheritErrorHandler ; if ( inheritErrorHandler && parent . errorHandlerBuilder != null ) { this . errorHandlerBuilder = parent . errorHandlerBuilder . copy ( ) ; } } public ValueBuilder header ( String name ) { return Builder . header ( name ) ; } public ValueBuilder body ( ) { return Builder . body ( ) ; } public < T > ValueBuilder body ( Class < T > type ) { return Builder . bodyAs ( type ) ; } public ValueBuilder outBody ( ) { return Builder . outBody ( ) ; } public < T > ValueBuilder outBody ( Class < T > type ) { return Builder . outBodyAs ( type ) ; } public ValueBuilder faultBody ( ) { return Builder . faultBody ( ) ; } public < T > ValueBuilder faultBodyAs ( Class < T > type ) { return Builder . faultBodyAs ( type ) ; } public ValueBuilder systemProperty ( String name ) { return Builder . systemProperty ( name ) ; } public ValueBuilder systemProperty ( String name , String defaultValue ) { return Builder . systemProperty ( name , defaultValue ) ; } public ValueBuilder constant ( Object value ) { return Builder . constant ( value ) ; } public Endpoint endpoint ( String uri ) throws NoSuchEndpointException { if ( uri == null ) { throw new IllegalArgumentException ( "uri parameter cannot be null" ) ; } Endpoint endpoint = getContext ( ) . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } public List < Endpoint > endpoints ( String ... uris ) throws NoSuchEndpointException { List < Endpoint > endpoints = new ArrayList < Endpoint > ( ) ; for ( String uri : uris ) { endpoints . add ( endpoint ( uri ) ) ; } return endpoints ; } public List < Endpoint > endpoints ( Endpoint ... endpoints ) { List < Endpoint > answer = new ArrayList < Endpoint > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint ) ; } return answer ; } public NoErrorHandlerBuilder noErrorHandler ( ) { return new NoErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( ) { return new LoggingErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( String log ) { return loggingErrorHandler ( LogFactory . getLog ( log ) ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log ) { return new LoggingErrorHandlerBuilder ( log ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log , LoggingLevel level ) { return new LoggingErrorHandlerBuilder ( log , level ) ; } public DeadLetterChannelBuilder deadLetterChannel ( ) { return new DeadLetterChannelBuilder ( ) ; } public DeadLetterChannelBuilder deadLetterChannel ( String deadLetterUri ) { return deadLetterChannel ( endpoint ( deadLetterUri ) ) ; } public DeadLetterChannelBuilder deadLetterChannel ( Endpoint deadLetterEndpoint ) { return new DeadLetterChannelBuilder ( new SendProcessor ( deadLetterEndpoint ) ) ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public boolean isInheritErrorHandler ( ) { return inheritErrorHandler ; } public void setInheritErrorHandler ( boolean inheritErrorHandler ) { this . inheritErrorHandler = inheritErrorHandler ; } } 	1	['30', '1', '1', '15', '55', '407', '1', '14', '27', '0.862068966', '251', '1', '2', '0', '0.130769231', '0', '0', '7.266666667', '2', '1.0333', '2']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface MessageDriven { String uri ( ) default "" ; String name ( ) default "" ; } 	0	['2', '1', '0', '1', '2', '1', '1', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class Route < E extends Exchange > { private final Map < String , Object > properties = new HashMap < String , Object > ( 16 ) ; private Endpoint < E > endpoint ; private List < Service > services = new ArrayList < Service > ( ) ; public Route ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Route ( Endpoint < E > endpoint , Service ... services ) { this ( endpoint ) ; for ( Service service : services ) { addService ( service ) ; } } @ Override public String toString ( ) { return "Route" ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Map < String , Object > getProperties ( ) { return properties ; } public List < Service > getServicesForRoute ( ) throws Exception { List < Service > servicesForRoute = new ArrayList < Service > ( getServices ( ) ) ; addServices ( servicesForRoute ) ; return servicesForRoute ; } public List < Service > getServices ( ) { return services ; } public void setServices ( List < Service > services ) { this . services = services ; } public void addService ( Service service ) { getServices ( ) . add ( service ) ; } protected void addServices ( List < Service > services ) throws Exception { } } 	1	['11', '1', '3', '12', '16', '41', '10', '2', '10', '0.666666667', '91', '1', '1', '0', '0.327272727', '0', '0', '7', '1', '0.8182', '2']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public interface Language { Predicate < Exchange > createPredicate ( String expression ) ; Expression < Exchange > createExpression ( String expression ) ; } 	0	['2', '1', '0', '17', '2', '1', '15', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import javax . xml . transform . stream . StreamSource ; public class StringSource extends StreamSource implements Serializable { private final String text ; private String encoding = "UTF-8" ; public StringSource ( String text ) { if ( text == null ) { throw new NullPointerException ( "text can not be null" ) ; } this . text = text ; } public StringSource ( String text , String systemId ) { this ( text ) ; setSystemId ( systemId ) ; } public StringSource ( String text , String systemId , String encoding ) { this . text = text ; this . encoding = encoding ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { try { return new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public Reader getReader ( ) { return new StringReader ( text ) ; } public String toString ( ) { return "StringSource[" + text + "]" ; } public String getText ( ) { return text ; } } 	1	['7', '2', '0', '1', '17', '0', '1', '0', '7', '0.25', '83', '1', '0', '0.692307692', '0.714285714', '0', '0', '10.57142857', '1', '0.5714', '2']
package org . apache . camel . spring . handler ; import org . apache . camel . util . ObjectHelper ; public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser { private String className ; private String moduleName ; public LazyLoadingBeanDefinitionParser ( String className , String moduleName ) { this . className = className ; this . moduleName = moduleName ; } @ Override protected Class loadType ( ) { Class < ? > answer = ObjectHelper . loadClass ( className , getClass ( ) . getClassLoader ( ) ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Class: " + className + " could not be found. You need to add Camel module: " + moduleName + " to your classpath" ) ; } return answer ; } } 	0	['2', '5', '1', '3', '10', '0', '1', '2', '1', '0', '44', '1', '0', '0.952380952', '0.75', '1', '1', '20', '2', '1', '0']
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Collection ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . * ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MockEndpoint extends DefaultEndpoint < Exchange > { private static final transient Log LOG = LogFactory . getLog ( MockEndpoint . class ) ; private int expectedCount = - 1 ; private int counter ; private Map < Integer , Processor > processors = new HashMap < Integer , Processor > ( ) ; private List < Exchange > receivedExchanges = new CopyOnWriteArrayList < Exchange > ( ) ; private List < Throwable > failures = new CopyOnWriteArrayList < Throwable > ( ) ; private List < Runnable > tests = new CopyOnWriteArrayList < Runnable > ( ) ; private CountDownLatch latch ; private long sleepForEmptyTest = 1000L ; private long defaulResultWaitMillis = 20000L ; private int expectedMinimumCount = - 1 ; private List expectedBodyValues ; private List actualBodyValues = new ArrayList ( ) ; public MockEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } public static void assertWait ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; long left = unit . toMillis ( timeout ) ; long end = start + left ; for ( MockEndpoint endpoint : endpoints ) { if ( ! endpoint . await ( left , TimeUnit . MILLISECONDS ) ) { throw new AssertionError ( "Timeout waiting for endpoints to receive enough messages. " + endpoint . getEndpointUri ( ) + " timed out." ) ; } left = end - System . currentTimeMillis ( ) ; if ( left <= 0 ) { left = 0 ; } } } public static void assertIsSatisfied ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { assertWait ( timeout , unit , endpoints ) ; for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( CamelContext context ) throws InterruptedException { Collection < Endpoint > endpoints = context . getSingletonEndpoints ( ) ; for ( Endpoint endpoint : endpoints ) { if ( endpoint instanceof MockEndpoint ) { MockEndpoint mockEndpoint = ( MockEndpoint ) endpoint ; mockEndpoint . assertIsSatisfied ( ) ; } } } public static void expectsMessageCount ( int count , MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . expectsMessageCount ( count ) ; } } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "You cannot consume from this endpoint" ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) { onExchange ( exchange ) ; } } ; } public void whenExchangeReceived ( int index , Processor processor ) { this . processors . put ( index , processor ) ; } public void assertIsSatisfied ( ) throws InterruptedException { assertIsSatisfied ( sleepForEmptyTest ) ; } public void assertIsSatisfied ( long timeoutForEmptyEndpoints ) throws InterruptedException { LOG . info ( "Asserting: " + this + " is satisfied" ) ; if ( expectedCount >= 0 ) { if ( expectedCount != getReceivedCounter ( ) ) { if ( expectedCount == 0 ) { if ( timeoutForEmptyEndpoints > 0 ) { LOG . debug ( "Sleeping for: " + timeoutForEmptyEndpoints + " millis to check there really are no messages received" ) ; Thread . sleep ( timeoutForEmptyEndpoints ) ; } } else { waitForCompleteLatch ( ) ; } } assertEquals ( "Received message count" , expectedCount , getReceivedCounter ( ) ) ; } else if ( expectedMinimumCount > 0 && getReceivedCounter ( ) < expectedMinimumCount ) { waitForCompleteLatch ( ) ; } if ( expectedMinimumCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertTrue ( "Received message count " + receivedCounter + ", expected at least " + expectedCount , expectedCount <= receivedCounter ) ; } for ( Runnable test : tests ) { test . run ( ) ; } for ( Throwable failure : failures ) { if ( failure != null ) { LOG . error ( "Caught on " + getEndpointUri ( ) + " Exception: " + failure , failure ) ; fail ( "Failed due to caught exception: " + failure ) ; } } } public void assertIsNotSatisfied ( ) throws InterruptedException { try { assertIsSatisfied ( ) ; fail ( "Expected assertion failure!" ) ; } catch ( AssertionError e ) { LOG . info ( "Caught expected failure: " + e ) ; } } public void expectedMessageCount ( int expectedCount ) { this . expectedCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedCount ) ; } } public void expectedMinimumMessageCount ( int expectedCount ) { this . expectedMinimumCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedMinimumCount ) ; } } public void expectedBodiesReceived ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; this . expectedBodyValues = bodies ; this . actualBodyValues = new ArrayList ( ) ; expects ( new Runnable ( ) { public void run ( ) { for ( int i = 0 ; i < expectedBodyValues . size ( ) ; i ++ ) { Exchange exchange = getReceivedExchanges ( ) . get ( i ) ; assertTrue ( "No exchange received for counter: " + i , exchange != null ) ; Object expectedBody = expectedBodyValues . get ( i ) ; Object actualBody = actualBodyValues . get ( i ) ; assertEquals ( "Body of message: " + i , expectedBody , actualBody ) ; } } } ) ; } public void expectedBodiesReceived ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; for ( Object body : bodies ) { bodyList . add ( body ) ; } expectedBodiesReceived ( bodyList ) ; } public void expectsAscending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesAscending ( expression ) ; } } ) ; } public void expectsDescending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesDescending ( expression ) ; } } ) ; } public void expectsNoDuplicates ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertNoDuplicates ( expression ) ; } } ) ; } public void assertMessagesAscending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , true ) ; } public void assertMessagesDescending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , false ) ; } protected void assertMessagesSorted ( Expression < Exchange > expression , boolean ascending ) { String type = ascending ? "ascending" : "descending" ; ExpressionComparator comparator = new ExpressionComparator ( expression ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 1 ; i < list . size ( ) ; i ++ ) { int j = i - 1 ; Exchange e1 = list . get ( j ) ; Exchange e2 = list . get ( i ) ; int result = comparator . compare ( e1 , e2 ) ; if ( result == 0 ) { fail ( "Messages not " + type + ". Messages" + j + " and " + i + " are equal with value: " + expression . evaluate ( e1 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { if ( ! ascending ) { result = result * - 1 ; } if ( result > 0 ) { fail ( "Messages not " + type + ". Message " + j + " has value: " + expression . evaluate ( e1 ) + " and message " + i + " has value: " + expression . evaluate ( e2 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } } } } public void assertNoDuplicates ( Expression < Exchange > expression ) { Map < Object , Exchange > map = new HashMap < Object , Exchange > ( ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Exchange e2 = list . get ( i ) ; Object key = expression . evaluate ( e2 ) ; Exchange e1 = map . get ( key ) ; if ( e1 != null ) { fail ( "Duplicate message found on message " + i + " has value: " + key + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { map . put ( key , e2 ) ; } } } public void expects ( Runnable runnable ) { tests . add ( runnable ) ; } public AssertionClause message ( final int messageIndex ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; return clause ; } public AssertionClause allMessages ( ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { applyAssertionOn ( MockEndpoint . this , index ++ , exchange ) ; } } } ; expects ( clause ) ; return clause ; } public Exchange assertExchangeReceived ( int index ) { int count = getReceivedCounter ( ) ; assertTrue ( "Not enough messages received. Was: " + count , count > index ) ; return getReceivedExchanges ( ) . get ( index ) ; } public List < Throwable > getFailures ( ) { return failures ; } public int getReceivedCounter ( ) { return getReceivedExchanges ( ) . size ( ) ; } public List < Exchange > getReceivedExchanges ( ) { return receivedExchanges ; } public int getExpectedCount ( ) { return expectedCount ; } public long getSleepForEmptyTest ( ) { return sleepForEmptyTest ; } public void setSleepForEmptyTest ( long sleepForEmptyTest ) { this . sleepForEmptyTest = sleepForEmptyTest ; } public long getDefaulResultWaitMillis ( ) { return defaulResultWaitMillis ; } public void setDefaulResultWaitMillis ( long defaulResultWaitMillis ) { this . defaulResultWaitMillis = defaulResultWaitMillis ; } protected synchronized void onExchange ( Exchange exchange ) { try { Message in = exchange . getIn ( ) ; Object actualBody = in . getBody ( ) ; if ( expectedBodyValues != null ) { int index = actualBodyValues . size ( ) ; if ( expectedBodyValues . size ( ) > index ) { Object expectedBody = expectedBodyValues . get ( index ) ; if ( expectedBody != null ) { actualBody = in . getBody ( expectedBody . getClass ( ) ) ; } actualBodyValues . add ( actualBody ) ; } } LOG . debug ( getEndpointUri ( ) + " >>>> " + ( ++ counter ) + " : " + exchange + " with body: " + actualBody ) ; receivedExchanges . add ( exchange ) ; Processor processor = processors . get ( getReceivedCounter ( ) ) ; if ( processor != null ) { processor . process ( exchange ) ; } if ( latch != null ) { latch . countDown ( ) ; } } catch ( Exception e ) { failures . add ( e ) ; } } protected void waitForCompleteLatch ( ) throws InterruptedException { if ( latch == null ) { fail ( "Should have a latch!" ) ; } LOG . debug ( "Waiting on the latch for: " + defaulResultWaitMillis + " millis" ) ; latch . await ( defaulResultWaitMillis , TimeUnit . MILLISECONDS ) ; } protected void assertEquals ( String message , Object expectedValue , Object actualValue ) { if ( ! ObjectHelper . equals ( expectedValue , actualValue ) ) { fail ( message + ". Expected: <" + expectedValue + "> but was: <" + actualValue + ">" ) ; } } protected void assertTrue ( String message , boolean predicate ) { if ( ! predicate ) { fail ( message ) ; } } protected void fail ( Object message ) { if ( LOG . isDebugEnabled ( ) ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { LOG . debug ( "Received[" + ( ++ index ) + "]: " + exchange ) ; } } throw new AssertionError ( getEndpointUri ( ) + " " + message ) ; } public int getExpectedMinimumCount ( ) { return expectedMinimumCount ; } public void await ( ) throws InterruptedException { if ( latch != null ) { latch . await ( ) ; } } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch != null ) { return latch . await ( timeout , unit ) ; } return true ; } public boolean isSingleton ( ) { return true ; } } 	1	['47', '2', '0', '23', '100', '943', '9', '22', '38', '0.87458194', '1056', '1', '1', '0.274193548', '0.104859335', '0', '0', '21.19148936', '6', '1.3617', '7']
package org . apache . camel . util ; public class CollectionStringBuffer { private StringBuffer buffer = new StringBuffer ( ) ; private String separator ; private boolean first = true ; public CollectionStringBuffer ( ) { this ( ", " ) ; } public CollectionStringBuffer ( String separator ) { this . separator = separator ; } @ Override public String toString ( ) { return buffer . toString ( ) ; } public void append ( Object value ) { if ( first ) { first = false ; } else { buffer . append ( separator ) ; } buffer . append ( value ) ; } public String getSeparator ( ) { return separator ; } public void setSeparator ( String separator ) { this . separator = separator ; } } 	0	['6', '1', '0', '4', '11', '0', '4', '0', '6', '0.4', '57', '1', '0', '0', '0.5', '0', '0', '8', '2', '0.8333', '0']
package org . apache . camel . builder . xml ; public class StringResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StringResultHandler ( ) ; } } 	1	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '1']
package org . apache . camel . language ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Language ; public class IllegalSyntaxException extends RuntimeCamelException { private final Language language ; private final String expression ; public IllegalSyntaxException ( Language language , String expression ) { super ( "Illegal syntax for language: " + language + ". Expression: " + expression ) ; this . language = language ; this . expression = expression ; } public String getExpression ( ) { return expression ; } public Language getLanguage ( ) { return language ; } } 	0	['3', '5', '0', '4', '8', '0', '2', '2', '3', '0.5', '32', '1', '1', '0.894736842', '0.555555556', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . builder . xml ; import javax . xml . transform . Result ; import org . apache . camel . Message ; public interface ResultHandler { Result getResult ( ) ; void setBody ( Message in ) ; } 	1	['2', '1', '0', '9', '2', '1', '8', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . cxf ; import java . net . URI ; import java . net . URISyntaxException ; import javax . xml . namespace . QName ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . cxf . configuration . spring . ConfigurerImpl ; import org . apache . cxf . message . Message ; public class CxfEndpoint extends DefaultEndpoint < CxfExchange > { private final CxfComponent component ; private final String address ; private String wsdlURL ; private String serviceClass ; private CxfBinding binding ; private String portName ; private String serviceName ; private String dataFormat ; private String beanId ; private boolean isSpringContextEndpoint ; private boolean inOut = true ; private ConfigurerImpl configurer ; private CxfEndpointBean cxfEndpointBean ; public CxfEndpoint ( String uri , String address , CxfComponent component ) { super ( uri , component ) ; this . component = component ; this . address = address ; if ( address . startsWith ( CxfConstants . SPRING_CONTEXT_ENDPOINT ) ) { isSpringContextEndpoint = true ; beanId = address . substring ( CxfConstants . SPRING_CONTEXT_ENDPOINT . length ( ) ) ; if ( beanId . startsWith ( "//" ) ) { beanId = beanId . substring ( 2 ) ; } SpringCamelContext context = ( SpringCamelContext ) this . getContext ( ) ; configurer = new ConfigurerImpl ( context . getApplicationContext ( ) ) ; cxfEndpointBean = ( CxfEndpointBean ) context . getApplicationContext ( ) . getBean ( beanId ) ; assert ( cxfEndpointBean != null ) ; } } public Producer < CxfExchange > createProducer ( ) throws Exception { return new CxfProducer ( this ) ; } public Consumer < CxfExchange > createConsumer ( Processor processor ) throws Exception { return new CxfConsumer ( this , processor ) ; } public CxfExchange createExchange ( ) { return new CxfExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) ) ; } public CxfExchange createExchange ( ExchangePattern pattern ) { return new CxfExchange ( getContext ( ) , pattern , getBinding ( ) ) ; } public CxfExchange createExchange ( Message inMessage ) { return new CxfExchange ( getContext ( ) , getExchangePattern ( ) , getBinding ( ) , inMessage ) ; } public String getDataFormat ( ) { return dataFormat ; } public void setDataFormat ( String format ) { dataFormat = format ; } public boolean isSpringContextEndpoint ( ) { return isSpringContextEndpoint ; } public String getAddress ( ) { return address ; } public String getWsdlURL ( ) { return wsdlURL ; } public void setWsdlURL ( String url ) { wsdlURL = url ; } public String getServiceClass ( ) { return serviceClass ; } public void setServiceClass ( String className ) { serviceClass = className ; } public void setPortName ( String port ) { portName = port ; } public void setServiceName ( String service ) { serviceName = service ; } public String getPortName ( ) { return portName ; } public String getServiceName ( ) { return serviceName ; } public CxfBinding getBinding ( ) { if ( binding == null ) { binding = new CxfBinding ( ) ; } return binding ; } public void setBinding ( CxfBinding binding ) { this . binding = binding ; } public boolean isInOut ( ) { return inOut ; } public void setInOut ( boolean inOut ) { this . inOut = inOut ; } public CxfComponent getComponent ( ) { return component ; } public boolean isSingleton ( ) { return true ; } public String getBeanId ( ) { return beanId ; } public CxfEndpointBean getCxfEndpointBean ( ) { return cxfEndpointBean ; } public void configure ( Object beanInstance ) { configurer . configureBean ( beanId , beanInstance ) ; } } 	0	['31', '2', '0', '20', '45', '431', '5', '18', '30', '0.947619048', '251', '0.928571429', '3', '0.369565217', '0.162962963', '1', '2', '6.64516129', '2', '0.9677', '0']
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Processor ; public class CatchProcessor extends DelegateProcessor { private List < Class > exceptions ; public CatchProcessor ( List < Class > exceptions , Processor processor ) { super ( processor ) ; this . exceptions = exceptions ; } @ Override public String toString ( ) { return "Catch[" + exceptions + " -> " + getProcessor ( ) + "]" ; } public boolean catches ( Throwable e ) { for ( Class type : exceptions ) { if ( type . isInstance ( e ) ) { return true ; } } return false ; } public List < Class > getExceptions ( ) { return exceptions ; } } 	1	['4', '3', '0', '6', '14', '0', '4', '2', '4', '0', '52', '1', '0', '0.875', '0.4375', '0', '0', '11.75', '2', '1', '1']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . dataformat ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel ; public interface AsyncProcessor extends Processor { boolean process ( Exchange exchange , AsyncCallback callback ) ; } 	1	['1', '1', '0', '22', '1', '0', '19', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class NamespaceBuilder { private Map < String , String > namespaces = new HashMap < String , String > ( ) ; public static NamespaceBuilder namespaceContext ( ) { return new NamespaceBuilder ( ) ; } public static NamespaceBuilder namespaceContext ( String prefix , String uri ) { return new NamespaceBuilder ( ) . namespace ( prefix , uri ) ; } public NamespaceBuilder namespace ( String prefix , String uri ) { namespaces . put ( prefix , uri ) ; return this ; } public XPathBuilder xpath ( String xpath ) { XPathBuilder answer = XPathBuilder . xpath ( xpath ) ; Set < Map . Entry < String , String > > entries = namespaces . entrySet ( ) ; for ( Map . Entry < String , String > entry : entries ) { answer . namespace ( entry . getKey ( ) , entry . getValue ( ) ) ; } return answer ; } } 	0	['5', '1', '0', '1', '16', '4', '0', '1', '5', '0', '62', '1', '0', '0', '0.6', '0', '0', '11.2', '2', '1', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ThreadProcessor ; @ XmlRootElement ( name = "thread" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThreadType extends ProcessorType { @ XmlAttribute private int coreSize = 1 ; @ XmlAttribute private boolean daemon = true ; @ XmlAttribute private long keepAliveTime ; @ XmlAttribute private int maxSize = 1 ; @ XmlAttribute private String name = "Thread Processor" ; @ XmlAttribute private int priority = Thread . NORM_PRIORITY ; @ XmlAttribute private long stackSize ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; @ XmlTransient private BlockingQueue < Runnable > taskQueue ; @ XmlTransient private ThreadGroup threadGroup ; @ XmlTransient private ThreadPoolExecutor executor ; public ThreadType ( ) { } public ThreadType ( int coreSize ) { this . coreSize = coreSize ; this . maxSize = coreSize ; } public ThreadType ( ThreadPoolExecutor executor ) { this . executor = executor ; } @ Override public List getInterceptors ( ) { return Collections . EMPTY_LIST ; } @ Override public List getOutputs ( ) { return outputs ; } @ Override public String toString ( ) { return "Thread[" + getLabel ( ) + "]" ; } @ Override public String getLabel ( ) { return "coreSize=" + coreSize ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ThreadProcessor thread = new ThreadProcessor ( ) ; thread . setExecutor ( executor ) ; thread . setCoreSize ( coreSize ) ; thread . setDaemon ( daemon ) ; thread . setKeepAliveTime ( keepAliveTime ) ; thread . setMaxSize ( maxSize ) ; thread . setName ( name ) ; thread . setPriority ( priority ) ; thread . setStackSize ( stackSize ) ; thread . setTaskQueue ( taskQueue ) ; thread . setThreadGroup ( threadGroup ) ; ArrayList < Processor > pipe = new ArrayList < Processor > ( 2 ) ; pipe . add ( thread ) ; pipe . add ( createOutputsProcessor ( routeContext , outputs ) ) ; return new Pipeline ( pipe ) ; } public ThreadType coreSize ( int coreSize ) { setCoreSize ( coreSize ) ; return this ; } public ThreadType daemon ( boolean daemon ) { setDaemon ( daemon ) ; return this ; } public ThreadType keepAliveTime ( long keepAliveTime ) { setKeepAliveTime ( keepAliveTime ) ; return this ; } public ThreadType maxSize ( int maxSize ) { setMaxSize ( maxSize ) ; return this ; } public ThreadType name ( String name ) { setName ( name ) ; return this ; } public ThreadType priority ( int priority ) { setPriority ( priority ) ; return this ; } public ThreadType stackSize ( long stackSize ) { setStackSize ( stackSize ) ; return this ; } public ThreadType taskQueue ( BlockingQueue < Runnable > taskQueue ) { setTaskQueue ( taskQueue ) ; return this ; } public ThreadType threadGroup ( ThreadGroup threadGroup ) { setThreadGroup ( threadGroup ) ; return this ; } public ThreadType executor ( ThreadPoolExecutor executor ) { setExecutor ( executor ) ; return this ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public void setName ( String name ) { this . name = name ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public ThreadPoolExecutor getExecutor ( ) { return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	1	['29', '2', '0', '5', '50', '318', '1', '5', '29', '0.86038961', '304', '1', '0', '0.781512605', '0.199233716', '1', '4', '9.103448276', '1', '0.8966', '2']
package org . apache . camel . component . mail ; import java . net . URI ; import java . util . Properties ; import javax . mail . Session ; import org . apache . camel . RuntimeCamelException ; public class MailConfiguration implements Cloneable { private String defaultEncoding ; private String host ; private Properties javaMailProperties ; private String password ; private String protocol ; private Session session ; private String username ; private int port = - 1 ; private String destination ; private String from = "camel@localhost" ; private boolean deleteProcessedMessages = true ; private String folderName = "INBOX" ; public MailConfiguration ( ) { } public MailConfiguration copy ( ) { try { return ( MailConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public void configure ( URI uri ) { String value = uri . getHost ( ) ; if ( value != null ) { setHost ( value ) ; } String scheme = uri . getScheme ( ) ; if ( scheme != null ) { setProtocol ( scheme ) ; } String userInfo = uri . getUserInfo ( ) ; if ( userInfo != null ) { setUsername ( userInfo ) ; } int port = uri . getPort ( ) ; if ( port >= 0 ) { setPort ( port ) ; } String fragment = uri . getFragment ( ) ; if ( fragment == null || fragment . length ( ) == 0 ) { fragment = userInfo + "@" + host ; } else { setFolderName ( fragment ) ; } setDestination ( fragment ) ; } public JavaMailConnection createJavaMailConnection ( MailEndpoint mailEndpoint ) { JavaMailConnection answer = new JavaMailConnection ( ) ; if ( defaultEncoding != null ) { answer . setDefaultEncoding ( defaultEncoding ) ; } if ( host != null ) { answer . setHost ( host ) ; } if ( javaMailProperties != null ) { answer . setJavaMailProperties ( javaMailProperties ) ; } if ( port >= 0 ) { answer . setPort ( port ) ; } if ( password != null ) { answer . setPassword ( password ) ; } if ( protocol != null ) { answer . setProtocol ( protocol ) ; } if ( session != null ) { answer . setSession ( session ) ; } if ( username != null ) { answer . setUsername ( username ) ; } return answer ; } public String getDefaultEncoding ( ) { return defaultEncoding ; } public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public Properties getJavaMailProperties ( ) { return javaMailProperties ; } public void setJavaMailProperties ( Properties javaMailProperties ) { this . javaMailProperties = javaMailProperties ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public Session getSession ( ) { return session ; } public void setSession ( Session session ) { this . session = session ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getDestination ( ) { return destination ; } public void setDestination ( String destination ) { this . destination = destination ; } public String getFrom ( ) { return from ; } public void setFrom ( String from ) { this . from = from ; } public boolean isDeleteProcessedMessages ( ) { return deleteProcessedMessages ; } public void setDeleteProcessedMessages ( boolean deleteProcessedMessages ) { this . deleteProcessedMessages = deleteProcessedMessages ; } public String getFolderName ( ) { return folderName ; } public void setFolderName ( String folderName ) { this . folderName = folderName ; } } 	0	['28', '1', '0', '6', '49', '298', '4', '3', '28', '0.907407407', '271', '1', '0', '0', '0.1875', '0', '0', '8.25', '9', '1.4643', '0']
package org . apache . camel . util ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . spi . Injector ; import static org . apache . camel . util . ObjectHelper . notNull ; public class CamelContextHelper { private CamelContextHelper ( ) { } public static Endpoint getMandatoryEndpoint ( CamelContext camelContext , String uri ) throws NoSuchEndpointException { Endpoint endpoint = camelContext . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } else { return endpoint ; } } public static < T > T convertTo ( CamelContext context , Class < T > type , Object value ) { notNull ( context , "camelContext" ) ; return context . getTypeConverter ( ) . convertTo ( type , value ) ; } public static < T > T mandatoryConvertTo ( CamelContext context , Class < T > type , Object value ) { T answer = convertTo ( context , type , value ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Value " + value + " converted to " + type . getName ( ) + " cannot be null" ) ; } return answer ; } public static < T > T newInstance ( CamelContext context , Class < T > beanType ) { return context . getInjector ( ) . newInstance ( beanType ) ; } } 	1	['5', '1', '0', '13', '19', '10', '7', '6', '4', '2', '63', '0', '0', '0', '0.44', '0', '0', '11.6', '2', '1', '3']
package org . apache . camel . component . cxf ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . cxf . invoker . InvokingContext ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . frontend . MethodDispatcher ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageContentsList ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . invoker . AbstractInvoker ; import org . apache . cxf . service . invoker . Invoker ; import org . apache . cxf . service . model . BindingOperationInfo ; public class CamelInvoker implements Invoker { private static final Logger LOG = Logger . getLogger ( CamelInvoker . class . getName ( ) ) ; private CxfConsumer cxfConsumer ; public CamelInvoker ( CxfConsumer consumer ) { cxfConsumer = consumer ; } public Message invoke ( Message inMessage ) { System . out . println ( "invoke the message " + inMessage ) ; Exchange exchange = inMessage . getExchange ( ) ; Map < String , Object > ctxContainer = new HashMap < String , Object > ( ) ; Map < String , Object > requestCtx = new HashMap < String , Object > ( ) ; ctxContainer . put ( Client . REQUEST_CONTEXT , requestCtx ) ; updateContext ( inMessage , requestCtx ) ; CxfEndpoint endpoint = ( CxfEndpoint ) cxfConsumer . getEndpoint ( ) ; CxfExchange cxfExchange = endpoint . createExchange ( inMessage ) ; try { cxfConsumer . getProcessor ( ) . process ( cxfExchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } Message outMessage = getCxfMessage ( cxfExchange , exchange ) ; return outMessage ; } public Message getCxfMessage ( CxfExchange result , Exchange exchange ) { Message outMessage = null ; if ( result . isFailed ( ) ) { CxfMessage fault = result . getFault ( ) ; outMessage = exchange . getInFaultMessage ( ) ; if ( outMessage == null ) { outMessage = new MessageImpl ( ) ; exchange . setInFaultMessage ( outMessage ) ; } Exception ex = ( Exception ) fault . getBody ( ) ; outMessage . setContent ( Exception . class , ex ) ; } else { if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "Payload is a response." ) ; } outMessage = result . getOutMessage ( ) ; if ( outMessage == null ) { Endpoint ep = exchange . get ( Endpoint . class ) ; outMessage = ep . getBinding ( ) . createMessage ( ) ; exchange . setOutMessage ( outMessage ) ; } } return outMessage ; } @ SuppressWarnings ( "unchecked" ) public void updateContext ( Map < String , Object > from , Map < String , Object > to ) { if ( to != null && from != null ) { for ( Iterator iter = from . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; String key = ( String ) entry . getKey ( ) ; if ( ! ( Message . INBOUND_MESSAGE . equals ( key ) || Message . REQUESTOR_ROLE . equals ( key ) || Message . PROTOCOL_HEADERS . equals ( key ) ) ) { to . put ( key , entry . getValue ( ) ) ; } } } } public Object invoke ( Exchange exchange , Object o ) { BindingOperationInfo bop = exchange . get ( BindingOperationInfo . class ) ; MethodDispatcher md = ( MethodDispatcher ) exchange . get ( Service . class ) . get ( MethodDispatcher . class . getName ( ) ) ; Method m = md . getMethod ( bop ) ; List < Object > params = null ; if ( o instanceof List ) { params = CastUtils . cast ( ( List < ? > ) o ) ; } else if ( o != null ) { params = new MessageContentsList ( o ) ; } CxfEndpoint endpoint = ( CxfEndpoint ) cxfConsumer . getEndpoint ( ) ; CxfExchange cxfExchange = endpoint . createExchange ( exchange . getInMessage ( ) ) ; cxfExchange . getIn ( ) . setHeader ( CxfConstants . OPERATION_NAME , m . getName ( ) ) ; cxfExchange . getIn ( ) . setBody ( params ) ; try { cxfConsumer . getProcessor ( ) . process ( cxfExchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } Object [ ] result ; if ( cxfExchange . isFailed ( ) ) { Exception ex = ( Exception ) cxfExchange . getFault ( ) . getBody ( ) ; throw new Fault ( ex ) ; } else { result = ( Object [ ] ) cxfExchange . getOut ( ) . getBody ( ) ; } return result ; } } 	0	['6', '1', '0', '20', '54', '7', '3', '18', '5', '0.6', '256', '1', '1', '0', '0.342857143', '0', '0', '41.33333333', '5', '2.3333', '0']
package org . apache . camel . spi ; public interface Injector { < T > T newInstance ( Class < T > type ) ; } 	1	['1', '1', '0', '18', '1', '0', '18', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class StaticMethodTypeConverter implements TypeConverter { private final Method method ; public StaticMethodTypeConverter ( Method method ) { this . method = method ; } @ Override public String toString ( ) { return "StaticMethodTypeConverter: " + method ; } public < T > T convertTo ( Class < T > type , Object value ) { return ( T ) ObjectHelper . invokeMethod ( method , null , value ) ; } } 	0	['3', '1', '0', '3', '9', '0', '1', '2', '3', '0', '31', '1', '0', '0', '0.5', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . component . bean ; import java . util . List ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; public class AmbiguousMethodCallException extends CamelExchangeException { private final List < MethodInfo > methods ; public AmbiguousMethodCallException ( Exchange exchange , List < MethodInfo > methods ) { super ( "Ambiguous method invocations possible: " + methods , exchange ) ; this . methods = methods ; } public List < MethodInfo > getMethods ( ) { return methods ; } } 	1	['2', '5', '0', '3', '7', '0', '1', '2', '2', '0', '21', '1', '0', '0.947368421', '0.666666667', '0', '0', '9', '1', '0.5', '1']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import javax . xml . namespace . NamespaceContext ; import javax . xml . xpath . XPathFactory ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; public class DefaultNamespaceContext implements NamespaceContext { private final Map map ; private final NamespaceContext parent ; public DefaultNamespaceContext ( ) { this ( XPathFactory . newInstance ( ) ) ; } public DefaultNamespaceContext ( XPathFactory factory ) { this . parent = factory . newXPath ( ) . getNamespaceContext ( ) ; this . map = new HashMap ( ) ; } public DefaultNamespaceContext ( NamespaceContext parent , Map map ) { this . parent = parent ; this . map = map ; } public DefaultNamespaceContext add ( String prefix , String uri ) { map . put ( prefix , uri ) ; return this ; } public String getNamespaceURI ( String prefix ) { String answer = ( String ) map . get ( prefix ) ; if ( answer == null && parent != null ) { return parent . getNamespaceURI ( prefix ) ; } return answer ; } public String getPrefix ( String namespaceURI ) { for ( Iterator iter = map . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( namespaceURI . equals ( entry . getValue ( ) ) ) { return ( String ) entry . getKey ( ) ; } } if ( parent != null ) { return parent . getPrefix ( namespaceURI ) ; } return null ; } public Iterator getPrefixes ( String namespaceURI ) { Set set = new HashSet ( ) ; for ( Iterator iter = map . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( namespaceURI . equals ( entry . getValue ( ) ) ) { set . add ( entry . getKey ( ) ) ; } } if ( parent != null ) { Iterator iter = parent . getPrefixes ( namespaceURI ) ; while ( iter . hasNext ( ) ) { set . add ( iter . next ( ) ) ; } } return set . iterator ( ) ; } public void setNamespacesFromDom ( Element element ) { Node parentNode = element . getParentNode ( ) ; if ( parentNode instanceof Element ) { setNamespacesFromDom ( ( Element ) parentNode ) ; } NamedNodeMap attributes = element . getAttributes ( ) ; int size = attributes . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Attr node = ( Attr ) attributes . item ( i ) ; String name = node . getName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { String prefix = name . substring ( "xmlns:" . length ( ) ) ; String uri = node . getValue ( ) ; add ( prefix , uri ) ; } } } } 	0	['8', '1', '0', '1', '36', '0', '1', '0', '8', '0.142857143', '190', '1', '0', '0', '0.333333333', '0', '0', '22.5', '4', '1.875', '0']
package org . apache . camel . builder . xml ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Transformer transformer ; private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Transformer transformer ) { this . transformer = transformer ; } @ Override public String toString ( ) { return "XSLT[" + transformer + "]" ; } public synchronized void process ( Exchange exchange ) throws Exception { Transformer transformer = getTransformer ( ) ; if ( transformer == null ) { throw new IllegalArgumentException ( "No transformer configured!" ) ; } configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; ResultHandler resultHandler = resultHandlerFactory . createResult ( ) ; Result result = resultHandler . getResult ( ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( exchange . getIn ( ) ) ; } public static XsltBuilder xslt ( Transformer transformer ) { return new XsltBuilder ( transformer ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandlerFactory ( new StreamResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandlerFactory ( new StringResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandlerFactory ( new DomResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Transformer getTransformer ( ) { return transformer ; } public void setTransformer ( Transformer transformer ) { this . transformer = transformer ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandlerFactory getResultHandlerFactory ( ) { return resultHandlerFactory ; } public void setResultHandlerFactory ( ResultHandlerFactory resultHandlerFactory ) { this . resultHandlerFactory = resultHandlerFactory ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { setTransformer ( converter . getTransformerFactory ( ) . newTransformer ( source ) ) ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { transformer . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	1	['25', '1', '0', '12', '64', '230', '0', '12', '22', '0.65', '318', '1', '2', '0', '0.13', '0', '0', '11.52', '3', '1.04', '3']
package org . apache . camel . bam . rules ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . bam . ProcessBuilder ; import org . apache . camel . bam . model . ActivityDefinition ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ActivityRules extends ServiceSupport { private static final transient Log LOG = LogFactory . getLog ( ActivityRules . class ) ; private int expectedMessages = 1 ; private ProcessRules processRules ; private List < TemporalRule > rules = new ArrayList < TemporalRule > ( ) ; private ActivityDefinition activityDefinition ; private String activityName ; private final org . apache . camel . bam . ProcessBuilder builder ; public ActivityRules ( ProcessBuilder builder ) { this . builder = builder ; this . processRules = builder . getProcessRules ( ) ; processRules . getActivities ( ) . add ( this ) ; } public void addRule ( TemporalRule rule ) { rules . add ( rule ) ; } public void processExpired ( ActivityState activityState ) throws Exception { for ( TemporalRule rule : rules ) { rule . processExpired ( activityState ) ; } } public void processExchange ( Exchange exchange , ProcessInstance process ) { for ( TemporalRule rule : rules ) { rule . processExchange ( exchange , process ) ; } } public ActivityDefinition getActivityDefinition ( ) { return builder . findOrCreateActivityDefinition ( activityName ) ; } public void setActivityDefinition ( ActivityDefinition activityDefinition ) { this . activityDefinition = activityDefinition ; } public int getExpectedMessages ( ) { return expectedMessages ; } public void setExpectedMessages ( int expectedMessages ) { this . expectedMessages = expectedMessages ; } public ProcessRules getProcessRules ( ) { return processRules ; } public void setActivityName ( String activityName ) { this . activityName = activityName ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( rules ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( rules ) ; } } 	0	['13', '2', '0', '16', '27', '36', '9', '11', '10', '0.880952381', '119', '1', '4', '0.541666667', '0.185185185', '1', '1', '7.615384615', '2', '0.9231', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . CachingInjector ; import org . apache . camel . util . ObjectHelper ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public synchronized < T > T convertTo ( Class < T > type , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate aninstance of: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	1	['3', '1', '0', '5', '12', '0', '1', '4', '3', '0.25', '54', '1', '1', '0', '0.466666667', '0', '0', '16.33333333', '2', '1', '1']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . util . HashSet ; import java . util . Set ; import javax . annotation . Resource ; import org . apache . camel . CamelContext ; import org . apache . cxf . Bus ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractTransportFactory ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . DestinationFactory ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator , DestinationFactory { private static final Set < String > URI_PREFIXES = new HashSet < String > ( ) ; static { URI_PREFIXES . add ( "camel://" ) ; } private Bus bus ; private CamelContext camelContext ; @ Resource public void setBus ( Bus b ) { bus = b ; } public Bus getBus ( ) { return bus ; } public CamelContext getCamelContext ( ) { return camelContext ; } @ Resource public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public Conduit getConduit ( EndpointInfo targetInfo ) throws IOException { return getConduit ( targetInfo , null ) ; } public Conduit getConduit ( EndpointInfo endpointInfo , EndpointReferenceType target ) throws IOException { return new CamelConduit ( camelContext , bus , endpointInfo , target ) ; } public Destination getDestination ( EndpointInfo endpointInfo ) throws IOException { CamelDestination destination = new CamelDestination ( camelContext , bus , this , endpointInfo ) ; Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( destination ) ; } return destination ; } public Set < String > getUriPrefixes ( ) { return URI_PREFIXES ; } } 	0	['10', '0', '0', '12', '17', '21', '0', '12', '9', '0.666666667', '80', '1', '1', '0', '0.333333333', '0', '0', '6.7', '1', '0.8', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "simple" ) public class SimpleExpression extends ExpressionType { public SimpleExpression ( ) { } public SimpleExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "simple" ; } } 	1	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '1']
package org . apache . camel . builder . script ; import org . apache . camel . CamelContext ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; public class ScriptLanguageResolver implements LanguageResolver { public Language resolveLanguage ( String name , CamelContext context ) { return new ScriptLanguage ( name ) ; } } 	0	['2', '1', '0', '4', '4', '1', '0', '4', '2', '2', '10', '0', '0', '0', '0.666666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . camel . processor ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . LoggingExceptionHandler ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BatchProcessor extends ServiceSupport implements Runnable { public static final long DEFAULT_BATCH_TIMEOUT = 1000L ; public static final int DEFAULT_BATCH_SIZE = 100 ; private static final transient Log LOG = LogFactory . getLog ( Resequencer . class ) ; private Endpoint endpoint ; private Processor processor ; private Collection < Exchange > collection ; private long batchTimeout = DEFAULT_BATCH_TIMEOUT ; private int batchSize = DEFAULT_BATCH_SIZE ; private PollingConsumer consumer ; private ExceptionHandler exceptionHandler ; public BatchProcessor ( Endpoint endpoint , Processor processor , Collection < Exchange > collection ) { this . endpoint = endpoint ; this . processor = processor ; this . collection = collection ; } @ Override public String toString ( ) { return "BatchProcessor[to: " + processor + "]" ; } public void run ( ) { LOG . debug ( "Starting thread for " + this ) ; while ( isRunAllowed ( ) ) { try { processBatch ( ) ; } catch ( Exception e ) { getExceptionHandler ( ) . handleException ( e ) ; } } collection . clear ( ) ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } protected synchronized void processBatch ( ) throws Exception { long start = System . currentTimeMillis ( ) ; long end = start + batchTimeout ; for ( int i = 0 ; i < batchSize ; i ++ ) { long timeout = end - System . currentTimeMillis ( ) ; Exchange exchange = consumer . receive ( timeout ) ; if ( exchange == null ) { break ; } collection . add ( exchange ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Finsihed batch size: " + batchSize + " timeout: " + batchTimeout + " so sending set: " + collection ) ; } Iterator < Exchange > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { Exchange exchange = iter . next ( ) ; iter . remove ( ) ; processExchange ( exchange ) ; } } protected void processExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; } protected void doStart ( ) throws Exception { consumer = endpoint . createPollingConsumer ( ) ; ServiceHelper . startServices ( processor , consumer ) ; Thread thread = new Thread ( this , this + " Polling Thread" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( consumer , processor ) ; collection . clear ( ) ; } protected Collection < Exchange > getCollection ( ) { return collection ; } } 	1	['17', '2', '2', '12', '45', '56', '2', '10', '11', '0.84375', '257', '0.8', '5', '0.464285714', '0.1796875', '1', '1', '13.52941176', '2', '1', '4']
package org . apache . camel . component . cxf . util ; import java . net . URI ; import java . net . URL ; import java . util . logging . Logger ; import javax . jws . WebService ; import javax . xml . namespace . QName ; import org . apache . camel . CamelException ; import org . apache . camel . component . cxf . CxfEndpoint ; import org . apache . camel . component . cxf . CxfMessage ; import org . apache . camel . component . cxf . DataFormat ; import org . apache . cxf . Bus ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . common . i18n . Message ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . frontend . ClientFactoryBean ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . jaxws . JaxWsClientFactoryBean ; import org . apache . cxf . jaxws . JaxWsServerFactoryBean ; import org . apache . cxf . jaxws . support . JaxWsServiceFactoryBean ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . factory . AbstractServiceFactoryBean ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . wsdl11 . WSDLServiceFactory ; public final class CxfEndpointUtils { public static final String PROP_NAME_PORT = "port" ; public static final String PROP_NAME_SERVICE = "service" ; public static final String PROP_NAME_SERVICECLASS = "serviceClass" ; public static final String PROP_NAME_DATAFORMAT = "dataFormat" ; public static final String DATAFORMAT_POJO = "pojo" ; public static final String DATAFORMAT_MESSAGE = "message" ; public static final String DATAFORMAT_PAYLOAD = "payload" ; private static final Logger LOG = LogUtils . getL7dLogger ( CxfEndpointUtils . class ) ; private CxfEndpointUtils ( ) { } static QName getQName ( final String name ) { QName qName = null ; if ( name != null ) { try { qName = QName . valueOf ( name ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return qName ; } public static QName getPortName ( final CxfEndpoint endpoint ) { return getQName ( endpoint . getPortName ( ) ) ; } public static QName getServiceName ( final CxfEndpoint endpoint ) { return getQName ( endpoint . getServiceName ( ) ) ; } public static EndpointInfo getEndpointInfo ( final Service service , final CxfEndpoint endpoint ) { EndpointInfo endpointInfo = null ; final java . util . Collection < EndpointInfo > endpoints = service . getServiceInfos ( ) . get ( 0 ) . getEndpoints ( ) ; if ( endpoints . size ( ) == 1 ) { endpointInfo = endpoints . iterator ( ) . next ( ) ; } else { final String port = endpoint . getPortName ( ) ; if ( port != null ) { final QName endpointName = QName . valueOf ( port ) ; endpointInfo = service . getServiceInfos ( ) . get ( 0 ) . getEndpoint ( endpointName ) ; } } return endpointInfo ; } public static boolean hasWebServiceAnnotation ( Class < ? > cls ) { if ( cls == null ) { return false ; } if ( null != cls . getAnnotation ( WebService . class ) ) { return true ; } for ( Class < ? > inf : cls . getInterfaces ( ) ) { if ( null != inf . getAnnotation ( WebService . class ) ) { return true ; } } return hasWebServiceAnnotation ( cls . getSuperclass ( ) ) ; } public static ServerFactoryBean getServerFactoryBean ( Class < ? > cls ) throws CamelException { try { boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; ServerFactoryBean serverFactory = isJSR181SEnabled ? new JaxWsServerFactoryBean ( ) : new ServerFactoryBean ( ) ; return serverFactory ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static ClientFactoryBean getClientFactoryBean ( Class < ? > cls ) throws CamelException { try { boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; ClientFactoryBean clientFactory = isJSR181SEnabled ? new JaxWsClientFactoryBean ( ) : new ClientFactoryBean ( ) ; return clientFactory ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static void checkEndpiontIntegration ( CxfEndpoint endpoint , Bus bus ) throws CamelException { String wsdlLocation = endpoint . getWsdlURL ( ) ; QName serviceQName = CxfEndpointUtils . getQName ( endpoint . getServiceName ( ) ) ; String serviceClassName = endpoint . getServiceClass ( ) ; DataFormat dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; URL wsdlUrl = null ; if ( wsdlLocation != null ) { try { wsdlUrl = UriUtils . getWsdlUrl ( new URI ( wsdlLocation ) ) ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } if ( serviceQName == null ) { throw new CamelException ( new Message ( "SVC_QNAME_NOT_FOUND_X" , LOG , endpoint . getServiceName ( ) ) . toString ( ) ) ; } if ( serviceClassName == null && dataFormat == DataFormat . POJO ) { throw new CamelException ( new Message ( "SVC_CLASS_PROP_IS_REQUIRED_X" , LOG ) . toString ( ) ) ; } AbstractServiceFactoryBean serviceFactory = null ; try { if ( serviceClassName != null ) { Class < ? > cls = ClassLoaderUtils . loadClass ( serviceClassName , CxfEndpointUtils . class ) ; boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; serviceFactory = isJSR181SEnabled ? new JaxWsServiceFactoryBean ( ) : new ReflectionServiceFactoryBean ( ) ; serviceFactory . setBus ( bus ) ; if ( wsdlUrl != null ) { ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setWsdlURL ( wsdlUrl ) ; } if ( serviceQName != null ) { ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setServiceName ( serviceQName ) ; } ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setServiceClass ( cls ) ; } else { if ( wsdlUrl == null ) { throw new CamelException ( new Message ( "SVC_WSDL_URL_IS_NULL_X" , LOG , wsdlLocation ) . toString ( ) ) ; } serviceFactory = new WSDLServiceFactory ( bus , wsdlUrl , serviceQName ) ; } } catch ( ClassNotFoundException cnfe ) { throw new CamelException ( new Message ( "CLASS_X_NOT_FOUND " , LOG , serviceClassName ) . toString ( ) , cnfe ) ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static DataFormat getDataFormat ( CxfEndpoint endpoint ) throws CamelException { String dataFormatString = endpoint . getDataFormat ( ) ; DataFormat retval = DataFormat . POJO ; if ( dataFormatString != null ) { try { retval = DataFormat . valueOf ( dataFormatString . toUpperCase ( ) ) ; } catch ( IllegalArgumentException iae ) { throw new CamelException ( new Message ( "INVALID_MESSAGE_FORMAT_XXXX" , LOG , dataFormatString ) . toString ( ) , iae ) ; } } return retval ; } } 	0	['11', '1', '0', '21', '51', '49', '2', '19', '8', '1.0625', '355', '0.125', '0', '0', '0.2', '0', '0', '30.54545455', '5', '1.4545', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . NoSuchLanguageException ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; public class DefaultLanguageResolver implements LanguageResolver { protected static final FactoryFinder LANGUAGE_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/language/" ) ; protected static final FactoryFinder LANGUAGE_RESOLVER = new FactoryFinder ( "META-INF/services/org/apache/camel/language/resolver/" ) ; public Language resolveLanguage ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( Language . class . isAssignableFrom ( type ) ) { return ( Language ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Language implementation. Found: " + type . getName ( ) ) ; } } return noSpecificLanguageFound ( name , context ) ; } protected Language noSpecificLanguageFound ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_RESOLVER . findClass ( "default" ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( LanguageResolver . class . isAssignableFrom ( type ) ) { LanguageResolver resolver = ( LanguageResolver ) context . getInjector ( ) . newInstance ( type ) ; return resolver . resolveLanguage ( name , context ) ; } else { throw new IllegalArgumentException ( "Type is not a LanguageResolver implementation. Found: " + type . getName ( ) ) ; } } throw new NoSuchLanguageException ( name ) ; } } 	1	['4', '1', '0', '8', '18', '2', '1', '7', '2', '0.5', '131', '1', '2', '0', '0.777777778', '0', '0', '31.25', '3', '1.5', '1']
package org . apache . camel . component . event ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class EventConsumer extends DefaultConsumer < Exchange > { private EventEndpoint endpoint ; public EventConsumer ( EventEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . consumerStarted ( this ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . consumerStopped ( this ) ; super . doStop ( ) ; } } 	0	['3', '3', '0', '4', '8', '0', '1', '4', '1', '0', '26', '1', '1', '0.916666667', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . camel ; public interface Endpoint < E extends Exchange > { boolean isSingleton ( ) ; String getEndpointUri ( ) ; E createExchange ( ) ; E createExchange ( ExchangePattern pattern ) ; E createExchange ( Exchange exchange ) ; CamelContext getContext ( ) ; Producer < E > createProducer ( ) throws Exception ; Consumer < E > createConsumer ( Processor processor ) throws Exception ; PollingConsumer < E > createPollingConsumer ( ) throws Exception ; } 	1	['9', '1', '0', '127', '9', '36', '122', '7', '9', '2', '9', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '2']
package org . apache . camel . spring . spi ; import org . springframework . beans . factory . wiring . BeanConfigurerSupport ; import org . springframework . context . ApplicationContext ; public class BeanInjector extends BeanConfigurerSupport { public BeanInjector ( ApplicationContext applicationContext ) throws Exception { setBeanFactory ( applicationContext ) ; afterPropertiesSet ( ) ; } public void inject ( Object bean ) { configureBean ( bean ) ; } } 	0	['2', '2', '0', '3', '6', '1', '0', '3', '2', '2', '14', '0', '0', '0.833333333', '0.666666667', '0', '0', '6', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "xquery" ) public class XQueryExpression extends ExpressionType { public XQueryExpression ( ) { } public XQueryExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "xquery" ; } } 	1	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '2']
package org . apache . camel . component . validator . jing ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; import java . util . Map ; public class JingComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { JingValidator validator = new JingValidator ( ) ; Resource resource = resolveMandatoryResource ( remaining ) ; validator . setSchemaResource ( resource ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( this + " using schema resource: " + resource ) ; } configureValidator ( validator , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , validator ) ; } protected void configureValidator ( JingValidator validator , String uri , String remaining , Map parameters ) throws Exception { setProperties ( validator , parameters ) ; } } 	0	['3', '4', '1', '9', '15', '3', '1', '8', '1', '2', '50', '0', '0', '0.928571429', '0.666666667', '2', '2', '15.66666667', '1', '0.6667', '0']
package org . apache . camel . processor ; import java . util . List ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . RejectedExecutionHandler ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . util . AsyncProcessorHelper ; public class ThreadProcessor implements AsyncProcessor , Service { private ThreadPoolExecutor executor ; private long stackSize ; private ThreadGroup threadGroup ; private int priority = Thread . NORM_PRIORITY ; private boolean daemon = true ; private String name = "Thread Processor" ; private BlockingQueue < Runnable > taskQueue ; private long keepAliveTime ; private int maxSize = 1 ; private int coreSize = 1 ; private final AtomicBoolean shutdown = new AtomicBoolean ( true ) ; ; class ProcessCall implements Runnable { private final Exchange exchange ; private final AsyncCallback callback ; public ProcessCall ( Exchange exchange , AsyncCallback callback ) { this . exchange = exchange ; this . callback = callback ; } public void run ( ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; callback . done ( false ) ; } else { callback . done ( false ) ; } } } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( shutdown . get ( ) ) { throw new IllegalStateException ( "ThreadProcessor is not running." ) ; } ProcessCall call = new ProcessCall ( exchange , callback ) ; executor . execute ( call ) ; return false ; } public void start ( ) throws Exception { shutdown . set ( false ) ; getExecutor ( ) . setRejectedExecutionHandler ( new RejectedExecutionHandler ( ) { public void rejectedExecution ( Runnable runnable , ThreadPoolExecutor executor ) { ProcessCall call = ( ProcessCall ) runnable ; call . exchange . setException ( new RejectedExecutionException ( ) ) ; call . callback . done ( false ) ; } } ) ; } public void stop ( ) throws Exception { shutdown . set ( true ) ; executor . shutdown ( ) ; executor . awaitTermination ( 0 , TimeUnit . SECONDS ) ; } public long getStackSize ( ) { return stackSize ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public ThreadGroup getThreadGroup ( ) { return threadGroup ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public long getKeepAliveTime ( ) { return keepAliveTime ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public int getMaxSize ( ) { return maxSize ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public int getCoreSize ( ) { return coreSize ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public BlockingQueue < Runnable > getTaskQueue ( ) { if ( taskQueue == null ) { taskQueue = new ArrayBlockingQueue < Runnable > ( 1000 ) ; } return taskQueue ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public ThreadPoolExecutor getExecutor ( ) { if ( executor == null ) { executor = new ThreadPoolExecutor ( getCoreSize ( ) , getMaxSize ( ) , getKeepAliveTime ( ) , TimeUnit . MILLISECONDS , getTaskQueue ( ) , new ThreadFactory ( ) { public Thread newThread ( Runnable runnable ) { Thread thread ; if ( getStackSize ( ) > 0 ) { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) , getStackSize ( ) ) ; } else { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) ) ; } thread . setDaemon ( isDaemon ( ) ) ; thread . setPriority ( getPriority ( ) ) ; return thread ; } } ) ; } return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	1	['26', '1', '0', '9', '41', '257', '4', '8', '25', '0.905454545', '216', '1', '0', '0', '0.136363636', '0', '0', '6.884615385', '2', '1.0769', '1']
package org . apache . camel . language ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "simple" ) public @ interface Simple { public String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class BeanExchange extends DefaultExchange { public BeanExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } public BeanInvocation getInvocation ( ) { return getIn ( ) . getBody ( BeanInvocation . class ) ; } public void setInvocation ( BeanInvocation invocation ) { getIn ( ) . setBody ( invocation ) ; } @ Override public Exchange newInstance ( ) { return new BeanExchange ( getContext ( ) , getPattern ( ) ) ; } } 	1	['4', '2', '0', '9', '10', '6', '3', '6', '4', '2', '28', '0', '0', '0.923076923', '0.4375', '1', '1', '6', '1', '0.75', '1']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class Builder { private Builder ( ) { } public static < E extends Exchange > ValueBuilder < E > constant ( Object value ) { Expression < E > expression = ExpressionBuilder . constantExpression ( value ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > header ( String name ) { Expression < E > expression = ExpressionBuilder . headerExpression ( name ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > body ( ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > bodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > bodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > outBody ( ) { Expression < E > expression = ExpressionBuilder . outBodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > outBodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > outBodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > faultBody ( ) { Expression < E > expression = ExpressionBuilder . faultBodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > faultBodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > faultBodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name , final String defaultValue ) { return new ValueBuilder < E > ( ExpressionBuilder . < E > systemProperty ( name , defaultValue ) ) ; } } 	0	['11', '1', '0', '5', '22', '55', '2', '3', '10', '2', '86', '0', '0', '0', '0.181818182', '0', '0', '6.818181818', '1', '0.9091', '0']
package org . apache . camel . model ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Predicate ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Interceptor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . Collection ; @ XmlRootElement ( name = "intercept" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InterceptType extends OutputType < ProcessorType > { @ Override public String toString ( ) { return "Intercept[" + getOutputs ( ) + "]" ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Interceptor interceptor = new Interceptor ( ) ; routeContext . intercept ( interceptor ) ; final Processor interceptRoute = routeContext . createProcessor ( this ) ; interceptor . setInterceptorLogic ( interceptRoute ) ; } public OtherwiseType when ( Predicate predicate ) { return choice ( ) . when ( PredicateBuilder . not ( predicate ) ) . proceed ( ) . otherwise ( ) ; } } 	1	['4', '3', '0', '11', '19', '6', '3', '9', '4', '2', '43', '0', '0', '0.97029703', '0.4375', '0', '0', '9.75', '1', '0.75', '7']
package org . apache . camel . bam . rules ; import java . util . ArrayList ; import java . util . Date ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . TimeExpression ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . OutputType ; import org . apache . camel . model . RouteType ; import org . apache . camel . util . Time ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; public class TemporalRule extends ServiceSupport { private static final transient Log LOG = LogFactory . getLog ( TemporalRule . class ) ; private TimeExpression first ; private TimeExpression second ; private long expectedMillis ; private long overdueMillis ; private Processor overdueAction ; private OutputType overdueProcessors = new OutputType ( ) ; public TemporalRule ( TimeExpression first , TimeExpression second ) { this . first = first ; this . second = second ; } public TemporalRule expectWithin ( Time builder ) { return expectWithin ( builder . toMillis ( ) ) ; } public TemporalRule expectWithin ( long millis ) { expectedMillis = millis ; return this ; } public OutputType errorIfOver ( Time builder ) { return errorIfOver ( builder . toMillis ( ) ) ; } public OutputType errorIfOver ( long millis ) { overdueMillis = millis ; if ( overdueProcessors == null ) { overdueProcessors = new OutputType ( ) ; } return overdueProcessors ; } public TimeExpression getFirst ( ) { return first ; } public TimeExpression getSecond ( ) { return second ; } public Processor getOverdueAction ( ) throws Exception { if ( overdueAction == null && overdueProcessors != null ) { ArrayList < Route > list = new ArrayList < Route > ( ) ; RouteType route = new RouteType ( ) ; route . setCamelContext ( first . getBuilder ( ) . getProcessBuilder ( ) . getContext ( ) ) ; RouteContext routeContext = new RouteContext ( route , null , list ) ; overdueAction = overdueProcessors . createOutputsProcessor ( routeContext ) ; } return overdueAction ; } public void processExchange ( Exchange exchange , ProcessInstance instance ) { Date firstTime = first . evaluate ( instance ) ; if ( firstTime == null ) { return ; } ActivityState secondState = second . getOrCreateActivityState ( instance ) ; if ( expectedMillis > 0L ) { Date expected = secondState . getTimeExpected ( ) ; if ( expected == null ) { expected = add ( firstTime , expectedMillis ) ; secondState . setTimeExpected ( expected ) ; } } if ( overdueMillis > 0L ) { Date overdue = secondState . getTimeOverdue ( ) ; if ( overdue == null ) { overdue = add ( firstTime , overdueMillis ) ; secondState . setTimeOverdue ( overdue ) ; } } } public void processExpired ( ActivityState activityState ) throws Exception { Processor processor = getOverdueAction ( ) ; if ( processor != null ) { Date now = new Date ( ) ; ActivityState secondState = activityState ; Date overdue = secondState . getTimeOverdue ( ) ; if ( now . compareTo ( overdue ) >= 0 ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( activityState ) ; processor . process ( exchange ) ; } else { LOG . warn ( "Process has not actually expired; the time is: " + now + " but the overdue time is: " + overdue ) ; } } } protected Exchange createExchange ( ) { return new DefaultExchange ( second . getBuilder ( ) . getProcessBuilder ( ) . getContext ( ) ) ; } protected Date add ( Date date , long millis ) { return new Date ( date . getTime ( ) + millis ) ; } protected void doStart ( ) throws Exception { startServices ( getOverdueAction ( ) ) ; } protected void doStop ( ) throws Exception { stopServices ( getOverdueAction ( ) ) ; } } 	0	['15', '2', '0', '20', '48', '73', '2', '19', '10', '0.755102041', '243', '1', '5', '0.5', '0.214285714', '1', '1', '14.73333333', '6', '1.2667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . RecipientList ; @ XmlRootElement ( name = "recipientList" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RecipientListType extends ExpressionNode { public RecipientListType ( ) { } public RecipientListType ( ExpressionType expression ) { super ( expression ) ; } public RecipientListType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "RecipientList[ " + getExpression ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new RecipientList ( getExpression ( ) . createExpression ( routeContext ) ) ; } } 	1	['5', '3', '0', '8', '15', '10', '2', '6', '5', '2', '36', '0', '0', '0.980769231', '0.4', '1', '2', '6.2', '1', '0.4', '2']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "artixDS" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ArtixDSDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private String elementTypeName ; @ XmlAttribute ( required = false ) private String format ; @ XmlAttribute ( required = false ) private Class < ? > elementType ; @ XmlAttribute ( required = false ) private ArtixDSContentType contentType ; public ArtixDSDataFormat ( ) { super ( "org.apache.camel.artix.ds.ArtixDSFormat" ) ; } public ArtixDSDataFormat ( Class < ? > elementType ) { this ( ) ; this . elementType = elementType ; } public ArtixDSDataFormat ( Class < ? > elementType , ArtixDSContentType contentType ) { this ( ) ; this . elementType = elementType ; this . contentType = contentType ; } public ArtixDSDataFormat ( ArtixDSContentType contentType ) { this ( ) ; this . contentType = contentType ; } public String getElementTypeName ( ) { return elementTypeName ; } public void setElementTypeName ( String elementTypeName ) { this . elementTypeName = elementTypeName ; } public ArtixDSContentType getContentType ( ) { return contentType ; } public void setContentType ( ArtixDSContentType contentType ) { this . contentType = contentType ; } public Class < ? > getElementType ( ) { if ( elementType == null ) { if ( elementTypeName != null ) { elementType = ObjectHelper . loadClass ( elementTypeName , getClass ( ) . getClassLoader ( ) ) ; } } return elementType ; } public void setElementType ( Class < ? > elementType ) { this . elementType = elementType ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; } @ Override protected void configureDataFormat ( DataFormat dataFormat ) { Class < ? > type = getElementType ( ) ; if ( type != null ) { setProperty ( dataFormat , "elementType" , type ) ; } ArtixDSContentType content = getContentType ( ) ; if ( content != null ) { setProperty ( dataFormat , "contentType" , content ) ; } } } 	0	['13', '2', '0', '5', '18', '46', '1', '4', '12', '0.75', '105', '1', '1', '0.307692308', '0.338461538', '1', '2', '6.769230769', '3', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ExchangeConverter ; public class DefaultExchangeConverter implements ExchangeConverter { public < T > T convertTo ( Class < T > type , Exchange exchange ) { return null ; } } 	1	['2', '1', '0', '3', '3', '1', '1', '2', '2', '2', '7', '0', '0', '0', '0.666666667', '0', '0', '2.5', '1', '0.5', '1']
package org . apache . camel ; public class NoSuchLanguageException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final String language ; public NoSuchLanguageException ( String language ) { super ( "No language could be found for: " + language ) ; this . language = language ; } public String getLanguage ( ) { return language ; } } 	0	['2', '5', '0', '2', '6', '0', '1', '1', '2', '1', '21', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; @ Converter public class NIOConverter { private NIOConverter ( ) { } @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static String toString ( ByteBuffer buffer ) { return IOConverter . toString ( buffer . array ( ) ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( File file ) throws IOException { byte [ ] buf = new byte [ ( int ) file . length ( ) ] ; InputStream in = new BufferedInputStream ( new FileInputStream ( file ) ) ; in . read ( buf ) ; return ByteBuffer . wrap ( buf ) ; } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } @ Converter public static InputStream toInputStream ( ByteBuffer bufferbuffer ) { return IOConverter . toInputStream ( toByteArray ( bufferbuffer ) ) ; } } 	1	['12', '1', '0', '3', '35', '66', '2', '1', '11', '2', '112', '0', '0', '0', '0.1', '0', '0', '8.333333333', '1', '0.9167', '1']
package org . apache . camel . bam . model ; import org . apache . camel . bam . processor . ProcessContext ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . ObjectHelper ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . Temporal ; import javax . persistence . TemporalType ; import javax . persistence . Transient ; import java . util . Date ; @ Entity public class ActivityState extends TemporalEntity { private ProcessInstance processInstance ; private Integer receivedMessageCount = 0 ; private ActivityDefinition activityDefinition ; private Date timeExpected ; @ Temporal ( TemporalType . TIME ) private Date timeOverdue ; private Integer escalationLevel = 0 ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "ActivityState[" + getId ( ) + " on " + getProcessInstance ( ) + " " + getActivityDefinition ( ) + "]" ; } public synchronized void processExchange ( ActivityRules activityRules , ProcessContext context ) throws Exception { int messageCount = 0 ; Integer count = getReceivedMessageCount ( ) ; if ( count != null ) { messageCount = count . intValue ( ) ; } setReceivedMessageCount ( ++ messageCount ) ; if ( messageCount == 1 ) { onFirstMessage ( context ) ; } int expectedMessages = activityRules . getExpectedMessages ( ) ; if ( messageCount == expectedMessages ) { onExpectedMessage ( context ) ; } else if ( messageCount > expectedMessages ) { onExcessMessage ( context ) ; } } public boolean isActivity ( ActivityRules activityRules ) { return ObjectHelper . equals ( getActivityDefinition ( ) , activityRules . getActivityDefinition ( ) ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; processInstance . getActivityStates ( ) . add ( this ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ActivityDefinition getActivityDefinition ( ) { return activityDefinition ; } public void setActivityDefinition ( ActivityDefinition activityDefinition ) { this . activityDefinition = activityDefinition ; } public Integer getEscalationLevel ( ) { return escalationLevel ; } public void setEscalationLevel ( Integer escalationLevel ) { this . escalationLevel = escalationLevel ; } public Integer getReceivedMessageCount ( ) { return receivedMessageCount ; } public void setReceivedMessageCount ( Integer receivedMessageCount ) { this . receivedMessageCount = receivedMessageCount ; } @ Temporal ( TemporalType . TIME ) public Date getTimeExpected ( ) { return timeExpected ; } public void setTimeExpected ( Date timeExpected ) { this . timeExpected = timeExpected ; } @ Temporal ( TemporalType . TIME ) public Date getTimeOverdue ( ) { return timeOverdue ; } public void setTimeOverdue ( Date timeOverdue ) { this . timeOverdue = timeOverdue ; } public void setTimeCompleted ( Date timeCompleted ) { super . setTimeCompleted ( timeCompleted ) ; if ( timeCompleted != null ) { setEscalationLevel ( - 1 ) ; } } @ Transient public String getCorrelationKey ( ) { ProcessInstance pi = getProcessInstance ( ) ; if ( pi == null ) { return null ; } return pi . getCorrelationKey ( ) ; } protected void onFirstMessage ( ProcessContext context ) { if ( ! isStarted ( ) ) { setTimeStarted ( currentTime ( ) ) ; context . onStarted ( this ) ; } } protected void onExpectedMessage ( ProcessContext context ) { if ( ! isCompleted ( ) ) { setTimeCompleted ( currentTime ( ) ) ; context . onCompleted ( this ) ; } } protected void onExcessMessage ( ProcessContext context ) { } protected Date currentTime ( ) { return new Date ( ) ; } } 	0	['23', '3', '0', '15', '44', '233', '12', '6', '19', '0.886363636', '203', '1', '2', '0.290322581', '0.223602484', '0', '0', '7.565217391', '2', '1.1304', '0']
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class URISupport { public static class CompositeData { public String host ; String scheme ; String path ; URI components [ ] ; Map parameters ; String fragment ; public URI [ ] getComponents ( ) { return components ; } public String getFragment ( ) { return fragment ; } public Map getParameters ( ) { return parameters ; } public String getScheme ( ) { return scheme ; } public String getPath ( ) { return path ; } public String getHost ( ) { return host ; } public URI toURI ( ) throws URISyntaxException { StringBuffer sb = new StringBuffer ( ) ; if ( scheme != null ) { sb . append ( scheme ) ; sb . append ( ':' ) ; } if ( host != null && host . length ( ) != 0 ) { sb . append ( host ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( ',' ) ; } sb . append ( components [ i ] . toString ( ) ) ; } sb . append ( ')' ) ; } if ( path != null ) { sb . append ( '/' ) ; sb . append ( path ) ; } if ( ! parameters . isEmpty ( ) ) { sb . append ( "?" ) ; sb . append ( createQueryString ( parameters ) ) ; } if ( fragment != null ) { sb . append ( "#" ) ; sb . append ( fragment ) ; } return new URI ( sb . toString ( ) ) ; } } public static Map parseQuery ( String uri ) throws URISyntaxException { try { Map rc = new HashMap ( ) ; if ( uri != null ) { String [ ] parameters = uri . split ( "&" ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { int p = parameters [ i ] . indexOf ( "=" ) ; if ( p >= 0 ) { String name = URLDecoder . decode ( parameters [ i ] . substring ( 0 , p ) , "UTF-8" ) ; String value = URLDecoder . decode ( parameters [ i ] . substring ( p + 1 ) , "UTF-8" ) ; rc . put ( name , value ) ; } else { rc . put ( parameters [ i ] , null ) ; } } } return rc ; } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static Map parseParamters ( URI uri ) throws URISyntaxException { String query = uri . getQuery ( ) ; if ( query == null ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; int idx = schemeSpecificPart . lastIndexOf ( '?' ) ; if ( idx < 0 ) { return Collections . EMPTY_MAP ; } else { query = schemeSpecificPart . substring ( idx + 1 ) ; } } else { query = stripPrefix ( query , "?" ) ; } return parseQuery ( query ) ; } public static URI removeQuery ( URI uri ) throws URISyntaxException { return createURIWithQuery ( uri , null ) ; } public static URI createURIWithQuery ( URI uri , String query ) throws URISyntaxException { return new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , query , uri . getFragment ( ) ) ; } public static CompositeData parseComposite ( URI uri ) throws URISyntaxException { CompositeData rc = new CompositeData ( ) ; rc . scheme = uri . getScheme ( ) ; String ssp = stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) . trim ( ) ; parseComposite ( uri , rc , ssp ) ; rc . fragment = uri . getFragment ( ) ; return rc ; } private static void parseComposite ( URI uri , CompositeData rc , String ssp ) throws URISyntaxException { String componentString ; String params ; if ( ! checkParenthesis ( ssp ) ) { throw new URISyntaxException ( uri . toString ( ) , "Not a matching number of '(' and ')' parenthesis" ) ; } int p ; int intialParen = ssp . indexOf ( "(" ) ; if ( intialParen == 0 ) { rc . host = ssp . substring ( 0 , intialParen ) ; p = rc . host . indexOf ( "/" ) ; if ( p >= 0 ) { rc . path = rc . host . substring ( p ) ; rc . host = rc . host . substring ( 0 , p ) ; } p = ssp . lastIndexOf ( ")" ) ; componentString = ssp . substring ( intialParen + 1 , p ) ; params = ssp . substring ( p + 1 ) . trim ( ) ; } else { componentString = ssp ; params = "" ; } String components [ ] = splitComponents ( componentString ) ; rc . components = new URI [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { rc . components [ i ] = new URI ( components [ i ] . trim ( ) ) ; } p = params . indexOf ( "?" ) ; if ( p >= 0 ) { if ( p > 0 ) { rc . path = stripPrefix ( params . substring ( 0 , p ) , "/" ) ; } rc . parameters = parseQuery ( params . substring ( p + 1 ) ) ; } else { if ( params . length ( ) > 0 ) { rc . path = stripPrefix ( params , "/" ) ; } rc . parameters = Collections . EMPTY_MAP ; } } private static String [ ] splitComponents ( String str ) { ArrayList l = new ArrayList ( ) ; int last = 0 ; int depth = 0 ; char chars [ ] = str . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '(' : depth ++ ; break ; case ')' : depth -- ; break ; case ',' : if ( depth == 0 ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + 1 ; } break ; default : } } String s = str . substring ( last ) ; if ( s . length ( ) != 0 ) { l . add ( s ) ; } String rc [ ] = new String [ l . size ( ) ] ; l . toArray ( rc ) ; return rc ; } public static String stripPrefix ( String value , String prefix ) { if ( value . startsWith ( prefix ) ) { return value . substring ( prefix . length ( ) ) ; } return value ; } public static URI stripScheme ( URI uri ) throws URISyntaxException { return new URI ( stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) ) ; } public static String createQueryString ( Map options ) throws URISyntaxException { try { if ( options . size ( ) > 0 ) { StringBuffer rc = new StringBuffer ( ) ; boolean first = true ; for ( Iterator iter = options . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { if ( first ) { first = false ; } else { rc . append ( "&" ) ; } String key = ( String ) iter . next ( ) ; String value = ( String ) options . get ( key ) ; rc . append ( URLEncoder . encode ( key , "UTF-8" ) ) ; rc . append ( "=" ) ; rc . append ( URLEncoder . encode ( value , "UTF-8" ) ) ; } return rc . toString ( ) ; } else { return "" ; } } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static URI createRemainingURI ( URI originalURI , Map params ) throws URISyntaxException { String s = createQueryString ( params ) ; if ( s . length ( ) == 0 ) { s = null ; } return createURIWithQuery ( originalURI , s ) ; } public static URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; } public static boolean checkParenthesis ( String str ) { boolean result = true ; if ( str != null ) { int open = 0 ; int closed = 0 ; int i = 0 ; while ( ( i = str . indexOf ( '(' , i ) ) >= 0 ) { i ++ ; open ++ ; } i = 0 ; while ( ( i = str . indexOf ( ')' , i ) ) >= 0 ) { i ++ ; closed ++ ; } result = open == closed ; } return result ; } public int indexOfParenthesisMatch ( String str ) { int result = - 1 ; return result ; } } 	1	['15', '1', '0', '3', '59', '105', '3', '1', '13', '2', '519', '0', '0', '0', '0.28', '0', '0', '33.6', '5', '1.5333', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . wsdl . Definition ; import javax . xml . namespace . QName ; import org . w3c . dom . Element ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . soap . SoapVersion ; import org . apache . cxf . binding . soap . model . SoapBindingInfo ; import org . apache . cxf . binding . soap . model . SoapHeaderInfo ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . MessagePartInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . wsdl11 . WSDLServiceBuilder ; public class SoapMessageOutInterceptor extends AbstractMessageOutInterceptor < SoapMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( SoapMessageInInterceptor . class ) ; public SoapMessageOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; addAfter ( DOMOutInterceptor . class . getName ( ) ) ; } protected Logger getLogger ( ) { return LOG ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( SoapMessage message ) throws Fault { Element header = message . get ( Element . class ) ; List < Element > payload = message . get ( List . class ) ; Exchange exchange = message . getExchange ( ) ; BindingMessageInfo bmi = exchange . get ( BindingMessageInfo . class ) ; List < SoapHeaderInfo > bindingHdr = bmi . getExtensors ( SoapHeaderInfo . class ) ; if ( bindingHdr != null && ! bindingHdr . isEmpty ( ) ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "SoapMessageOutInterceptor BindingOperation header processing." ) ; } List < Element > headerList = new ArrayList < Element > ( ) ; List < Element > newPayload = new ArrayList < Element > ( payload ) ; for ( SoapHeaderInfo shi : bindingHdr ) { List < Element > tmpList = new ArrayList < Element > ( ) ; MessagePartInfo mpi = shi . getPart ( ) ; QName hdrName = mpi . getConcreteName ( ) ; for ( Element el : payload ) { QName elName = new QName ( el . getNamespaceURI ( ) , el . getLocalName ( ) ) ; if ( elName . equals ( hdrName ) ) { newPayload . remove ( el ) ; tmpList . add ( el ) ; } } if ( tmpList . size ( ) > 1 ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "MULTIPLE_HDR_PARTS" , LOG , hdrName ) ) ; } headerList . addAll ( tmpList ) ; } if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "DOMOutInterceptor Copy Payload parts to SOAPHeaders" ) ; } if ( headerList . size ( ) != 0 ) { SoapVersion version = ( ( SoapMessage ) message ) . getVersion ( ) ; header = createElement ( version . getHeader ( ) , headerList ) ; } payload = newPayload ; } if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "SoapMessageOutInterceptor binding operation style processing." ) ; } SoapBindingInfo soapBinding = ( SoapBindingInfo ) exchange . get ( BindingInfo . class ) ; String style = soapBinding . getStyle ( bmi . getBindingOperation ( ) . getOperationInfo ( ) ) ; if ( "rpc" . equals ( style ) ) { OperationInfo oi = bmi . getBindingOperation ( ) . getOperationInfo ( ) ; Endpoint ep = exchange . get ( Endpoint . class ) ; Definition def = ep . getService ( ) . getServiceInfos ( ) . get ( 0 ) . getProperty ( WSDLServiceBuilder . WSDL_DEFINITION , Definition . class ) ; String prefix = def . getPrefix ( oi . getName ( ) . getNamespaceURI ( ) ) ; if ( "" . equals ( prefix ) ) { prefix = "tns" ; } QName opName = null ; boolean isClient = isRequestor ( message ) ; if ( isClient ) { opName = new QName ( oi . getName ( ) . getNamespaceURI ( ) , oi . getName ( ) . getLocalPart ( ) , prefix ) ; } else { opName = new QName ( oi . getName ( ) . getNamespaceURI ( ) , oi . getName ( ) . getLocalPart ( ) + "Response" , prefix ) ; } Element opEl = createElement ( opName , payload ) ; payload = new ArrayList < Element > ( ) ; payload . add ( opEl ) ; } message . put ( List . class , payload ) ; } } 	0	['5', '1', '0', '19', '54', '4', '1', '18', '3', '0.25', '274', '1', '0', '0.5', '0.5', '0', '0', '53.6', '1', '0.6', '0']
package org . apache . camel ; public class CamelException extends Exception { public CamelException ( ) { } public CamelException ( String message ) { super ( message ) ; } public CamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public CamelException ( Throwable cause ) { super ( cause ) ; } } 	1	['4', '3', '3', '5', '8', '6', '5', '0', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '1']
package org . apache . camel ; public interface Component < E extends Exchange > { CamelContext getCamelContext ( ) ; void setCamelContext ( CamelContext context ) ; Endpoint < E > createEndpoint ( String uri ) throws Exception ; } 	0	['3', '1', '0', '37', '3', '3', '36', '2', '3', '2', '3', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . spi . Synchronization ; import org . apache . camel . spi . UnitOfWork ; public class DefaultUnitOfWork implements UnitOfWork { private List < Synchronization > synchronizations ; private List < AsyncCallback > asyncCallbacks ; private CountDownLatch latch ; public DefaultUnitOfWork ( ) { } public synchronized void addSynchronization ( Synchronization synchronization ) { if ( synchronizations == null ) { synchronizations = new ArrayList < Synchronization > ( ) ; } synchronizations . add ( synchronization ) ; } public synchronized void removeSynchronization ( Synchronization synchronization ) { if ( synchronizations != null ) { synchronizations . remove ( synchronization ) ; } } public void reset ( ) { } public void done ( Exchange exchange ) { if ( synchronizations != null ) { boolean failed = exchange . isFailed ( ) ; for ( Synchronization synchronization : synchronizations ) { if ( failed ) { synchronization . onFailure ( exchange ) ; } else { synchronization . onComplete ( exchange ) ; } } } } public boolean isSynchronous ( ) { return asyncCallbacks == null || asyncCallbacks . isEmpty ( ) ; } } 	1	['6', '1', '0', '4', '17', '9', '1', '3', '6', '0.933333333', '75', '1', '0', '0', '0.5', '0', '0', '11', '4', '2', '1']
package org . apache . camel . component . quartz ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class QuartzConsumer extends DefaultConsumer < QuartzExchange > { public QuartzConsumer ( QuartzEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; } @ Override public QuartzEndpoint getEndpoint ( ) { return ( QuartzEndpoint ) super . getEndpoint ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getEndpoint ( ) . consumerStarted ( this ) ; } @ Override protected void doStop ( ) throws Exception { getEndpoint ( ) . consumerStopped ( this ) ; super . doStop ( ) ; } } 	0	['5', '3', '0', '4', '10', '10', '1', '4', '3', '2', '31', '0', '0', '0.846153846', '0.466666667', '1', '1', '5.2', '1', '0.8', '0']
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport { private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy ( ) ; private ProcessorFactory deadLetterFactory ; private Processor defaultDeadLetterEndpoint ; private Expression defaultDeadLetterEndpointExpression ; private String defaultDeadLetterEndpointUri = "log:org.apache.camel.DeadLetterChannel?level=error" ; private Logger logger = DeadLetterChannel . createDefaultLogger ( ) ; public DeadLetterChannelBuilder ( ) { } public DeadLetterChannelBuilder ( Processor processor ) { this ( new ConstantProcessorBuilder ( processor ) ) ; } public DeadLetterChannelBuilder ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public ErrorHandlerBuilder copy ( ) { DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder ( deadLetterFactory ) ; answer . setRedeliveryPolicy ( getRedeliveryPolicy ( ) . copy ( ) ) ; return answer ; } public Processor createErrorHandler ( Processor processor ) throws Exception { Processor deadLetter = getDeadLetterFactory ( ) . createProcessor ( ) ; DeadLetterChannel answer = new DeadLetterChannel ( processor , deadLetter , getRedeliveryPolicy ( ) , getLogger ( ) ) ; configure ( answer ) ; return answer ; } public DeadLetterChannelBuilder backOffMultiplier ( double backOffMultiplier ) { getRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public DeadLetterChannelBuilder collisionAvoidancePercent ( short collisionAvoidancePercent ) { getRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public DeadLetterChannelBuilder initialRedeliveryDelay ( long initialRedeliveryDelay ) { getRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveries ( int maximumRedeliveries ) { getRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public DeadLetterChannelBuilder useCollisionAvoidance ( ) { getRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public DeadLetterChannelBuilder useExponentialBackOff ( ) { getRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public DeadLetterChannelBuilder logger ( Logger logger ) { setLogger ( logger ) ; return this ; } public DeadLetterChannelBuilder loggingLevel ( LoggingLevel level ) { getLogger ( ) . setLevel ( level ) ; return this ; } public DeadLetterChannelBuilder log ( Log log ) { getLogger ( ) . setLog ( log ) ; return this ; } public DeadLetterChannelBuilder log ( String log ) { return log ( LogFactory . getLog ( log ) ) ; } public DeadLetterChannelBuilder log ( Class log ) { return log ( LogFactory . getLog ( log ) ) ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public ProcessorFactory getDeadLetterFactory ( ) { if ( deadLetterFactory == null ) { deadLetterFactory = new ProcessorFactory ( ) { public Processor createProcessor ( ) { return getDefaultDeadLetterEndpoint ( ) ; } } ; } return deadLetterFactory ; } public void setDeadLetterFactory ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public Processor getDefaultDeadLetterEndpoint ( ) { if ( defaultDeadLetterEndpoint == null ) { defaultDeadLetterEndpoint = new RecipientList ( getDefaultDeadLetterEndpointExpression ( ) ) ; } return defaultDeadLetterEndpoint ; } public void setDefaultDeadLetterEndpoint ( Processor defaultDeadLetterEndpoint ) { this . defaultDeadLetterEndpoint = defaultDeadLetterEndpoint ; } public Expression getDefaultDeadLetterEndpointExpression ( ) { if ( defaultDeadLetterEndpointExpression == null ) { defaultDeadLetterEndpointExpression = ExpressionBuilder . constantExpression ( getDefaultDeadLetterEndpointUri ( ) ) ; } return defaultDeadLetterEndpointExpression ; } public void setDefaultDeadLetterEndpointExpression ( Expression defaultDeadLetterEndpointExpression ) { this . defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression ; } public String getDefaultDeadLetterEndpointUri ( ) { return defaultDeadLetterEndpointUri ; } public void setDefaultDeadLetterEndpointUri ( String defaultDeadLetterEndpointUri ) { this . defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } } 	1	['28', '2', '0', '18', '49', '330', '3', '16', '28', '0.771604938', '241', '1', '5', '0.074074074', '0.117346939', '0', '0', '7.392857143', '2', '1', '1']
package org . apache . camel . spring . handler ; import java . util . HashSet ; import java . util . Set ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Unmarshaller ; import org . apache . camel . builder . xml . XPathBuilder ; import org . apache . camel . spring . CamelBeanPostProcessor ; import org . apache . camel . spring . CamelContextFactoryBean ; import org . apache . camel . spring . EndpointFactoryBean ; import org . apache . camel . spring . remoting . CamelProxyFactoryBean ; import org . apache . camel . spring . remoting . CamelServiceExporter ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import org . springframework . beans . factory . BeanDefinitionStoreException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . parsing . BeanComponentDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . xml . DomUtils ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class CamelNamespaceHandler extends NamespaceHandlerSupport { public static final String JAXB_PACKAGES = "org.apache.camel.spring:org.apache.camel.model:org.apache.camel.model.config:org.apache.camel.model.dataformat:org.apache.camel.model.language" ; protected BeanDefinitionParser endpointParser = new BeanDefinitionParser ( EndpointFactoryBean . class ) ; protected BeanDefinitionParser proxyParser = new BeanDefinitionParser ( CamelProxyFactoryBean . class ) ; protected BeanDefinitionParser exportParser = new BeanDefinitionParser ( CamelServiceExporter . class ) ; protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser ( CamelBeanPostProcessor . class ) ; protected Set < String > parserElementNames = new HashSet < String > ( ) ; private JAXBContext jaxbContext ; public void init ( ) { registerParser ( "endpoint" , endpointParser ) ; registerParser ( "proxy" , proxyParser ) ; registerParser ( "export" , exportParser ) ; registerParser ( "camelContext" , new CamelContextBeanDefinitionParser ( CamelContextFactoryBean . class ) ) ; registerParser ( "xpath" , new BeanDefinitionParser ( XPathBuilder . class ) { @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String xpath = DomUtils . getTextValue ( element ) ; builder . addConstructorArg ( xpath ) ; super . doParse ( element , parserContext , builder ) ; builder . addPropertyValue ( "namespacesFromDom" , element ) ; } } ) ; } protected void createBeanPostProcessor ( ParserContext parserContext , String contextId , Element childElement ) { String beanPostProcessorId = contextId + ":beanPostProcessor" ; childElement . setAttribute ( "id" , beanPostProcessorId ) ; BeanDefinition definition = beanPostProcessorParser . parse ( childElement , parserContext ) ; definition . getPropertyValues ( ) . addPropertyValue ( "camelContext" , new RuntimeBeanReference ( contextId ) ) ; } protected void registerScriptParser ( String elementName , String engineName ) { registerParser ( elementName , new ScriptDefinitionParser ( engineName ) ) ; } protected void registerParser ( String name , org . springframework . beans . factory . xml . BeanDefinitionParser parser ) { parserElementNames . add ( name ) ; registerBeanDefinitionParser ( name , parser ) ; } public Set < String > getParserElementNames ( ) { return parserElementNames ; } protected Object parseUsingJaxb ( Element element , ParserContext parserContext ) { try { Unmarshaller unmarshaller = getJaxbContext ( ) . createUnmarshaller ( ) ; return unmarshaller . unmarshal ( element ) ; } catch ( JAXBException e ) { throw new BeanDefinitionStoreException ( "Failed to parse JAXB element: " + e , e ) ; } } protected JAXBContext getJaxbContext ( ) throws JAXBException { if ( jaxbContext == null ) { jaxbContext = createJaxbContext ( ) ; } return jaxbContext ; } protected JAXBContext createJaxbContext ( ) throws JAXBException { return JAXBContext . newInstance ( JAXB_PACKAGES ) ; } protected class CamelContextBeanDefinitionParser extends BeanDefinitionParser { public CamelContextBeanDefinitionParser ( Class type ) { super ( type ) ; } @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { super . doParse ( element , parserContext , builder ) ; String contextId = element . getAttribute ( "id" ) ; if ( ObjectHelper . isNullOrBlank ( contextId ) ) { contextId = "camelContext" ; element . setAttribute ( "id" , contextId ) ; } Object value = parseUsingJaxb ( element , parserContext ) ; if ( value instanceof CamelContextFactoryBean ) { CamelContextFactoryBean factoryBean = ( CamelContextFactoryBean ) value ; builder . addPropertyValue ( "id" , contextId ) ; builder . addPropertyValue ( "routes" , factoryBean . getRoutes ( ) ) ; if ( factoryBean . getPackages ( ) . length > 0 ) { builder . addPropertyValue ( "packages" , factoryBean . getPackages ( ) ) ; } } boolean createdBeanPostProcessor = false ; NodeList list = element . getChildNodes ( ) ; int size = list . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node child = list . item ( i ) ; if ( child instanceof Element ) { Element childElement = ( Element ) child ; String localName = child . getLocalName ( ) ; if ( localName . equals ( "beanPostProcessor" ) ) { createBeanPostProcessor ( parserContext , contextId , childElement ) ; createdBeanPostProcessor = true ; } else if ( localName . equals ( "endpoint" ) ) { BeanDefinition definition = endpointParser . parse ( childElement , parserContext ) ; String id = childElement . getAttribute ( "id" ) ; if ( ObjectHelper . isNotNullAndNonEmpty ( id ) ) { definition . getPropertyValues ( ) . addPropertyValue ( "camelContext" , new RuntimeBeanReference ( contextId ) ) ; parserContext . registerComponent ( new BeanComponentDefinition ( definition , id ) ) ; } } else if ( localName . equals ( "proxy" ) ) { BeanDefinition definition = proxyParser . parse ( childElement , parserContext ) ; String id = childElement . getAttribute ( "id" ) ; if ( ObjectHelper . isNotNullAndNonEmpty ( id ) ) { parserContext . registerComponent ( new BeanComponentDefinition ( definition , id ) ) ; } } else if ( localName . equals ( "export" ) ) { BeanDefinition definition = exportParser . parse ( childElement , parserContext ) ; String id = childElement . getAttribute ( "id" ) ; if ( ObjectHelper . isNotNullAndNonEmpty ( id ) ) { parserContext . registerComponent ( new BeanComponentDefinition ( definition , id ) ) ; } } } } if ( ! createdBeanPostProcessor ) { Element childElement = element . getOwnerDocument ( ) . createElement ( "beanPostProcessor" ) ; element . appendChild ( childElement ) ; createBeanPostProcessor ( parserContext , contextId , childElement ) ; } } } } 	0	['9', '2', '0', '11', '30', '26', '2', '11', '3', '0.857142857', '164', '0.857142857', '4', '0.529411765', '0.377777778', '0', '0', '16.44444444', '1', '0.8889', '0']
package org . apache . camel . spi ; import org . apache . camel . TypeConverter ; public interface TypeConverterAware { void setTypeConverter ( TypeConverter parentTypeConverter ) ; } 	1	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . cxf ; import java . util . List ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . cxf . invoker . CxfClient ; import org . apache . camel . component . cxf . invoker . CxfClientFactoryBean ; import org . apache . camel . component . cxf . invoker . InvokingContext ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . binding . Binding ; import org . apache . cxf . binding . BindingFactory ; import org . apache . cxf . binding . BindingFactoryManager ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . frontend . ClientFactoryBean ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . transport . Conduit ; import java . io . InputStream ; import java . net . MalformedURLException ; public class CxfProducer extends DefaultProducer < CxfExchange > { private CxfEndpoint endpoint ; private Client client ; private DataFormat dataFormat ; public CxfProducer ( CxfEndpoint endpoint ) throws CamelException { super ( endpoint ) ; this . endpoint = endpoint ; dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; if ( dataFormat . equals ( DataFormat . POJO ) ) { client = createClientFormClientFactoryBean ( null ) ; } else { client = createClientForStreamMessge ( ) ; } } private Client createClientForStreamMessge ( ) throws CamelException { CxfClientFactoryBean cfb = new CxfClientFactoryBean ( ) ; if ( null != endpoint . getServiceClass ( ) ) { try { Class serviceClass = ClassLoaderUtils . loadClass ( endpoint . getServiceClass ( ) , this . getClass ( ) ) ; boolean jsr181Enabled = CxfEndpointUtils . hasWebServiceAnnotation ( serviceClass ) ; cfb . setJSR181Enabled ( jsr181Enabled ) ; } catch ( ClassNotFoundException e ) { throw new CamelException ( e ) ; } } return createClientFormClientFactoryBean ( cfb ) ; } private Client createClientFormClientFactoryBean ( ClientFactoryBean cfb ) throws CamelException { Bus bus = BusFactory . getDefaultBus ( ) ; if ( endpoint . isSpringContextEndpoint ( ) ) { CxfEndpointBean endpointBean = endpoint . getCxfEndpointBean ( ) ; if ( cfb == null ) { cfb = CxfEndpointUtils . getClientFactoryBean ( endpointBean . getServiceClass ( ) ) ; } endpoint . configure ( cfb ) ; CxfEndpointBean cxfEndpointBean = endpoint . getCxfEndpointBean ( ) ; if ( cxfEndpointBean . getServiceName ( ) != null ) { cfb . getServiceFactory ( ) . setServiceName ( cxfEndpointBean . getServiceName ( ) ) ; } if ( cxfEndpointBean . getEndpointName ( ) != null ) { cfb . getServiceFactory ( ) . setEndpointName ( cxfEndpointBean . getEndpointName ( ) ) ; } } else { if ( null != endpoint . getServiceClass ( ) ) { try { Class serviceClass = ClassLoaderUtils . loadClass ( endpoint . getServiceClass ( ) , this . getClass ( ) ) ; if ( cfb == null ) { cfb = CxfEndpointUtils . getClientFactoryBean ( serviceClass ) ; } cfb . setAddress ( endpoint . getAddress ( ) ) ; if ( null != endpoint . getServiceClass ( ) ) { cfb . setServiceClass ( ObjectHelper . loadClass ( endpoint . getServiceClass ( ) ) ) ; } if ( null != endpoint . getWsdlURL ( ) ) { cfb . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } } catch ( ClassNotFoundException e ) { throw new CamelException ( e ) ; } } else { if ( cfb == null ) { cfb = new ClientFactoryBean ( ) ; } if ( null != endpoint . getWsdlURL ( ) ) { cfb . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } else { throw new CamelException ( "Insufficiency of the endpoint info" ) ; } } if ( endpoint . getServiceName ( ) != null ) { cfb . getServiceFactory ( ) . setServiceName ( CxfEndpointUtils . getServiceName ( endpoint ) ) ; } if ( endpoint . getPortName ( ) != null ) { cfb . getServiceFactory ( ) . setEndpointName ( CxfEndpointUtils . getPortName ( endpoint ) ) ; } if ( endpoint . getWsdlURL ( ) != null ) { cfb . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } } cfb . setBus ( bus ) ; return cfb . create ( ) ; } public void process ( Exchange exchange ) { CxfExchange cxfExchange = endpoint . createExchange ( exchange ) ; process ( cxfExchange ) ; } public void process ( CxfExchange exchange ) { CxfBinding cxfBinding = endpoint . getBinding ( ) ; Message inMessage = cxfBinding . createCxfMessage ( exchange ) ; try { if ( dataFormat . equals ( DataFormat . POJO ) ) { List paraments = inMessage . getContent ( List . class ) ; String operation = inMessage . getContent ( String . class ) ; Message response = new MessageImpl ( ) ; if ( operation != null && paraments != null ) { try { Object [ ] result = client . invoke ( operation , paraments . toArray ( ) ) ; response . setContent ( Object [ ] . class , result ) ; cxfBinding . storeCxfResponse ( exchange , response ) ; } catch ( Exception ex ) { response . setContent ( Exception . class , ex ) ; cxfBinding . storeCxfFault ( exchange , response ) ; } } } else { org . apache . cxf . message . Exchange ex = exchange . getExchange ( ) ; InvokingContext invokingContext = ex . get ( InvokingContext . class ) ; Object params = invokingContext . getRequestContent ( inMessage ) ; CxfClient cxfClient = ( CxfClient ) client ; Object result = cxfClient . dispatch ( params , null , ex ) ; BindingOperationInfo boi = ex . get ( BindingOperationInfo . class ) ; Message response = null ; if ( boi == null ) { response = new MessageImpl ( ) ; } else { Endpoint ep = ex . get ( Endpoint . class ) ; response = ep . getBinding ( ) . createMessage ( ) ; } response . setExchange ( ex ) ; ex . setOutMessage ( response ) ; invokingContext . setResponseContent ( response , result ) ; cxfBinding . storeCxfResponse ( exchange , response ) ; } } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; } } 	0	['7', '3', '0', '27', '64', '1', '1', '27', '3', '0.555555556', '357', '1', '2', '0.76', '0.314285714', '0', '0', '49.57142857', '3', '1.1429', '0']
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; public class FileProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( FileProducer . class ) ; private final FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public FileEndpoint getEndpoint ( ) { return ( FileEndpoint ) super . getEndpoint ( ) ; } public void process ( Exchange exchange ) throws Exception { FileExchange fileExchange = endpoint . createExchange ( exchange ) ; process ( fileExchange ) ; ExchangeHelper . copyResults ( exchange , fileExchange ) ; } public void process ( FileExchange exchange ) throws Exception { if ( ExchangeHelper . isOutCapable ( exchange ) ) { Message out = exchange . getOut ( true ) ; endpoint . configureMessage ( endpoint . getFile ( ) , out ) ; return ; } InputStream in = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; File file = createFileName ( exchange . getIn ( ) ) ; buildDirectory ( file ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to write to: " + file + " from exchange: " + exchange ) ; } FileChannel fc = null ; try { if ( getEndpoint ( ) . isAppend ( ) ) { fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . position ( fc . size ( ) ) ; } else { fc = new FileOutputStream ( file ) . getChannel ( ) ; } int size = getEndpoint ( ) . getBufferSize ( ) ; byte [ ] buffer = new byte [ size ] ; ByteBuffer byteBuffer = ByteBuffer . wrap ( buffer ) ; while ( true ) { int count = in . read ( buffer ) ; if ( count <= 0 ) { break ; } else if ( count < size ) { byteBuffer = ByteBuffer . wrap ( buffer , 0 , count ) ; fc . write ( byteBuffer ) ; break ; } else { fc . write ( byteBuffer ) ; byteBuffer . clear ( ) ; } } } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close input: " + e , e ) ; } } if ( fc != null ) { try { fc . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close output: " + e , e ) ; } } } } protected File createFileName ( Message message ) { File answer ; File endpointFile = endpoint . getFile ( ) ; String name = null ; if ( ! endpoint . isIgnoreFileNameHeader ( ) ) { name = message . getHeader ( FileComponent . HEADER_FILE_NAME , String . class ) ; } if ( endpointFile . isDirectory ( ) ) { if ( name != null ) { answer = new File ( endpointFile , name ) ; if ( answer . isDirectory ( ) ) { answer = new File ( answer , message . getMessageId ( ) ) ; } } else { answer = new File ( endpointFile , message . getMessageId ( ) ) ; } } else { answer = endpointFile ; } return answer ; } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	1	['8', '3', '0', '9', '50', '14', '1', '9', '5', '0.642857143', '295', '1', '2', '0.76', '0.285714286', '0', '0', '35.625', '5', '1.375', '4']
package org . apache . camel . component . mail ; import javax . mail . Message ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class MailExchange extends DefaultExchange { private MailBinding binding ; public MailExchange ( CamelContext context , ExchangePattern pattern , MailBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public MailExchange ( CamelContext context , ExchangePattern pattern , MailBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new MailMessage ( message ) ) ; } @ Override public MailMessage getIn ( ) { return ( MailMessage ) super . getIn ( ) ; } @ Override public MailMessage getOut ( ) { return ( MailMessage ) super . getOut ( ) ; } @ Override public MailMessage getOut ( boolean lazyCreate ) { return ( MailMessage ) super . getOut ( lazyCreate ) ; } @ Override public MailMessage getFault ( ) { return ( MailMessage ) super . getFault ( ) ; } public MailBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new MailExchange ( getContext ( ) , getPattern ( ) , binding ) ; } @ Override protected MailMessage createInMessage ( ) { return new MailMessage ( ) ; } @ Override protected MailMessage createOutMessage ( ) { return new MailMessage ( ) ; } } 	0	['16', '2', '0', '9', '20', '114', '4', '7', '12', '0.8', '94', '1', '1', '0.72', '0.260416667', '1', '3', '4.8125', '1', '0.875', '0']
package org . apache . camel . component . bean ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . builder . ExpressionBuilder ; public class DefaultParameterMappingStrategy implements ParameterMappingStrategy { private Map < Class , Expression > parameterTypeToExpressionMap = new ConcurrentHashMap < Class , Expression > ( ) ; public DefaultParameterMappingStrategy ( ) { } public synchronized Expression getDefaultParameterTypeExpression ( Class parameterType ) { return parameterTypeToExpressionMap . get ( parameterType ) ; } public synchronized void addParameterMapping ( Class parameterType , Expression expression ) { parameterTypeToExpressionMap . put ( parameterType , expression ) ; } public void loadDefaultRegistry ( ) { addParameterMapping ( Exchange . class , ExpressionBuilder . exchangeExpression ( ) ) ; addParameterMapping ( Message . class , ExpressionBuilder . inMessageExpression ( ) ) ; } } 	1	['4', '1', '0', '4', '10', '0', '1', '3', '4', '0', '35', '1', '0', '0', '0.583333333', '0', '0', '7.5', '1', '0.75', '1']
package org . apache . camel . component . cxf . invoker ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . SortedSet ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . w3c . dom . Element ; import org . apache . camel . component . cxf . interceptors . DOMInInterceptor ; import org . apache . camel . component . cxf . interceptors . DOMOutInterceptor ; import org . apache . camel . component . cxf . interceptors . PayloadContentRedirectInterceptor ; import org . apache . camel . component . cxf . interceptors . PayloadInInterceptor ; import org . apache . camel . component . cxf . phase . FaultPayloadPhaseManagerImpl ; import org . apache . camel . component . cxf . phase . PayloadPhaseManagerImpl ; import org . apache . cxf . Bus ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . endpoint . EndpointImpl ; import org . apache . cxf . interceptor . Interceptor ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . phase . PhaseInterceptorChain ; import org . apache . cxf . phase . PhaseManager ; import org . apache . cxf . transport . MessageObserver ; public class PayloadInvokingContext extends AbstractInvokingContext { private static final Logger LOG = Logger . getLogger ( PayloadInvokingContext . class . getName ( ) ) ; private PhaseManager phaseManager ; private PhaseManager faultPhaseManager ; private MessageObserver inFaultObserver ; private MessageObserver outFaultObserver ; public PayloadInvokingContext ( ) { phaseManager = new PayloadPhaseManagerImpl ( ) ; faultPhaseManager = new FaultPayloadPhaseManagerImpl ( ) ; } public PhaseInterceptorChain getRequestOutInterceptorChain ( Exchange exchange ) { return getOutIntercepterChain ( exchange ) ; } public PhaseInterceptorChain getResponseOutInterceptorChain ( Exchange exchange ) { return getOutIntercepterChain ( exchange ) ; } private PhaseInterceptorChain getOutIntercepterChain ( Exchange exchange ) { PhaseInterceptorChain chain = new PhaseInterceptorChain ( new PayloadPhaseManagerImpl ( ) . getOutPhases ( ) ) ; Bus bus = exchange . get ( Bus . class ) ; assert bus != null ; List < Interceptor > list = bus . getOutInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by bus: " + list ) ; } chain . add ( list ) ; Endpoint endpoint = exchange . get ( Endpoint . class ) ; if ( endpoint != null ) { list = endpoint . getOutInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by endpoint: " + list ) ; } chain . add ( list ) ; list = endpoint . getBinding ( ) . getOutInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by binding: " + list ) ; } chain . add ( list ) ; } chain . add ( new DOMOutInterceptor ( ) ) ; chain . add ( new PayloadContentRedirectInterceptor ( ) ) ; return chain ; } public void setRequestOutMessageContent ( Message message , Object content ) { PayloadMessage request = ( PayloadMessage ) content ; Element header = request . getHeader ( ) ; List < Element > payload = request . getPayload ( ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "header = " + header + ", paylaod = " + payload ) ; } message . put ( Element . class , header ) ; message . put ( List . class , payload ) ; } @ Override protected SortedSet < Phase > getInPhases ( ) { return phaseManager . getInPhases ( ) ; } protected SortedSet < Phase > getOutPhases ( ) { return phaseManager . getOutPhases ( ) ; } @ Override protected List < Interceptor > getRoutingInterceptors ( ) { List < Interceptor > list = new ArrayList < Interceptor > ( ) ; list . add ( new DOMInInterceptor ( ) ) ; list . add ( new PayloadInInterceptor ( ) ) ; return list ; } @ SuppressWarnings ( "unchecked" ) public Object getResponseObject ( Exchange exchange , Map < String , Object > responseContext ) { PayloadMessage payloadMsg = null ; Message msg = exchange . getInMessage ( ) ; List < Element > payload = getResponseObject ( msg , responseContext , List . class ) ; Element header = exchange . getInMessage ( ) . get ( Element . class ) ; payloadMsg = new PayloadMessage ( payload , header ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( payloadMsg . toString ( ) ) ; } return payloadMsg ; } @ Override protected < T > T getResponseObject ( Message inMessage , Map < String , Object > responseContext , Class < T > clazz ) { T retval = null ; if ( inMessage != null ) { if ( null != responseContext ) { responseContext . putAll ( inMessage ) ; LOG . info ( "set responseContext to be" + responseContext ) ; } retval = inMessage . get ( clazz ) ; } return retval ; } protected PhaseInterceptorChain getInInterceptorChain ( Exchange exchange , boolean isResponse ) { Bus bus = exchange . get ( Bus . class ) ; assert bus != null ; PhaseInterceptorChain chain = new PhaseInterceptorChain ( getInPhases ( ) ) ; List < Interceptor > routingInterceptors = getRoutingInterceptors ( ) ; chain . add ( routingInterceptors ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Injected " + routingInterceptors ) ; } List < Interceptor > list = bus . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by bus: " + list ) ; } chain . add ( list ) ; Endpoint ep = exchange . get ( Endpoint . class ) ; if ( ep != null ) { list = ep . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by endpoint: " + list ) ; } chain . add ( list ) ; list = ep . getBinding ( ) . getInInterceptors ( ) ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Interceptors contributed by binding: " + list ) ; } chain . add ( list ) ; } return chain ; } @ Override public void setEndpointFaultObservers ( EndpointImpl endpointImpl , Bus bus ) { if ( inFaultObserver == null ) { inFaultObserver = new FaultChainInitiatorObserver ( bus , faultPhaseManager . getInPhases ( ) , false ) ; } endpointImpl . setInFaultObserver ( inFaultObserver ) ; if ( outFaultObserver == null ) { outFaultObserver = new FaultChainInitiatorObserver ( bus , faultPhaseManager . getOutPhases ( ) , true ) ; } endpointImpl . setOutFaultObserver ( outFaultObserver ) ; } public void setResponseContent ( Message outMessage , Object resultPayload ) { if ( resultPayload != null ) { PayloadMessage payloadMessage = ( PayloadMessage ) resultPayload ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( payloadMessage . toString ( ) ) ; } outMessage . put ( List . class , payloadMessage . getPayload ( ) ) ; outMessage . put ( Element . class , payloadMessage . getHeader ( ) ) ; } } @ SuppressWarnings ( "unchecked" ) public Object getRequestContent ( Message inMessage ) { List < Element > payload = inMessage . get ( List . class ) ; Element header = inMessage . get ( Element . class ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "Header = " + header + ", Payload = " + payload ) ; } return new PayloadMessage ( payload , header ) ; } } 	0	['15', '2', '0', '20', '61', '41', '1', '19', '8', '0.797619048', '479', '0.833333333', '0', '0.35', '0.246031746', '1', '2', '30.53333333', '8', '2.3333', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElementRef ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExpressionNode extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private ExpressionType expression ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; public ExpressionNode ( ) { } public ExpressionNode ( ExpressionType expression ) { this . expression = expression ; } public ExpressionNode ( Expression expression ) { setExpression ( new ExpressionType ( expression ) ) ; } public ExpressionNode ( Predicate predicate ) { setExpression ( new ExpressionType ( predicate ) ) ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public ExpressionType getExpression ( ) { return expression ; } public void setExpression ( ExpressionType expression ) { this . expression = expression ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } @ Override public String getLabel ( ) { if ( getExpression ( ) == null ) { return "" ; } return getExpression ( ) . getLabel ( ) ; } protected FilterProcessor createFilterProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new FilterProcessor ( getExpression ( ) . createPredicate ( routeContext ) , childProcessor ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } } 	1	['13', '2', '7', '15', '25', '24', '7', '8', '11', '0.555555556', '137', '1', '1', '0.911764706', '0.230769231', '1', '5', '9.307692308', '2', '0.8462', '3']
package org . apache . camel . bam ; public enum ActivityLifecycle { Started , Completed } 	0	['4', '2', '0', '5', '7', '4', '4', '1', '2', '0.888888889', '45', '0.333333333', '3', '0.857142857', '0.444444444', '1', '1', '9.5', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; @ XmlRootElement ( name = "idempotentConsumer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class IdempotentConsumerType extends ExpressionNode { @ XmlAttribute private String messageIdRepositoryRef ; @ XmlTransient private MessageIdRepository messageIdRepository ; public IdempotentConsumerType ( ) { } public IdempotentConsumerType ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { super ( messageIdExpression ) ; this . messageIdRepository = messageIdRepository ; } @ Override public String toString ( ) { return "IdempotentConsumer[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } public String getMessageIdRepositoryRef ( ) { return messageIdRepositoryRef ; } public void setMessageIdRepositoryRef ( String messageIdRepositoryRef ) { this . messageIdRepositoryRef = messageIdRepositoryRef ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public void setMessageIdRepository ( MessageIdRepository messageIdRepository ) { this . messageIdRepository = messageIdRepository ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; MessageIdRepository messageIdRepository = resolveMessageIdRepository ( routeContext ) ; return new IdempotentConsumer ( getExpression ( ) . createExpression ( routeContext ) , messageIdRepository , childProcessor ) ; } public MessageIdRepository resolveMessageIdRepository ( RouteContext routeContext ) { if ( messageIdRepository == null ) { messageIdRepository = routeContext . lookup ( messageIdRepositoryRef , MessageIdRepository . class ) ; } return messageIdRepository ; } } 	1	['9', '3', '0', '8', '21', '18', '1', '8', '9', '0.5625', '84', '1', '1', '0.935779817', '0.333333333', '1', '2', '8.111111111', '2', '0.8889', '2']
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; public class JpaBamProcessor extends JpaBamProcessorSupport < ProcessInstance > { private static final transient Log LOG = LogFactory . getLog ( JpaBamProcessor . class ) ; public JpaBamProcessor ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , template , correlationKeyExpression , activityRules ) ; } public JpaBamProcessor ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < ProcessInstance > entitytype ) { super ( transactionTemplate , template , correlationKeyExpression , activityRules , entitytype ) ; } protected void processEntity ( Exchange exchange , ProcessInstance process ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Processing process instance: " + process ) ; } ActivityRules rules = getActivityRules ( ) ; ActivityState state = process . getOrCreateActivityState ( rules ) ; state . processExchange ( rules , new ProcessContext ( exchange , rules , state ) ) ; rules . getProcessRules ( ) . processExchange ( exchange , process ) ; } } 	0	['5', '3', '0', '13', '20', '8', '1', '12', '2', '0.5', '66', '1', '1', '0.9375', '0.472222222', '0', '0', '12', '1', '0.4', '0']
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; public class Aggregator extends BatchProcessor { public Aggregator ( Endpoint endpoint , Processor processor , Expression correlationExpression , AggregationStrategy aggregationStrategy ) { this ( endpoint , processor , new AggregationCollection ( correlationExpression , aggregationStrategy ) ) ; } public Aggregator ( Endpoint endpoint , Processor processor , AggregationCollection collection ) { super ( endpoint , processor , collection ) ; } @ Override public String toString ( ) { return "Aggregator[to: " + getProcessor ( ) + "]" ; } } 	1	['3', '3', '0', '7', '10', '3', '1', '6', '3', '2', '31', '0', '0', '0.965517241', '0.555555556', '0', '0', '9.333333333', '1', '0.3333', '2']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; public class Pipeline extends MulticastProcessor implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( Pipeline . class ) ; public Pipeline ( Collection < Processor > processors ) { super ( processors ) ; } public static Processor newInstance ( List < Processor > processors ) { if ( processors . isEmpty ( ) ) { return null ; } else if ( processors . size ( ) == 1 ) { return processors . get ( 0 ) ; } return new Pipeline ( processors ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange original , AsyncCallback callback ) { Iterator < Processor > processors = getProcessors ( ) . iterator ( ) ; Exchange nextExchange = original ; boolean first = true ; while ( true ) { if ( nextExchange . isFailed ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Mesage exchange has failed so breaking out of pipeline: " + nextExchange + " exception: " + nextExchange . getException ( ) + " fault: " + nextExchange . getFault ( false ) ) ; } break ; } if ( ! processors . hasNext ( ) ) { break ; } AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( processors . next ( ) ) ; if ( first ) { first = false ; } else { nextExchange = createNextExchange ( processor , nextExchange ) ; } boolean sync = process ( original , nextExchange , callback , processors , processor ) ; if ( ! sync ) { return false ; } } ExchangeHelper . copyResults ( original , nextExchange ) ; callback . done ( true ) ; return true ; } private boolean process ( final Exchange original , final Exchange exchange , final AsyncCallback callback , final Iterator < Processor > processors , AsyncProcessor processor ) { return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } Exchange nextExchange = exchange ; while ( processors . hasNext ( ) ) { AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( processors . next ( ) ) ; if ( nextExchange . isFailed ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Mesage exchange has failed so breaking out of pipeline: " + nextExchange + " exception: " + nextExchange . getException ( ) + " fault: " + nextExchange . getFault ( false ) ) ; } break ; } nextExchange = createNextExchange ( processor , exchange ) ; sync = process ( original , nextExchange , callback , processors , processor ) ; if ( ! sync ) { return ; } } ExchangeHelper . copyResults ( original , nextExchange ) ; callback . done ( false ) ; } } ) ; } protected Exchange createNextExchange ( Processor producer , Exchange previousExchange ) { Exchange answer = copyExchangeStrategy ( previousExchange ) ; Message previousOut = previousExchange . getOut ( false ) ; Object output = previousOut != null ? previousOut . getBody ( ) : null ; Message in = answer . getIn ( ) ; if ( output != null ) { in . setBody ( output ) ; Set < Map . Entry < String , Object > > entries = previousOut . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { in . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } } else { Object previousInBody = previousExchange . getIn ( ) . getBody ( ) ; if ( in . getBody ( ) == null && previousInBody != null ) { LOG . warn ( "Bad exchange implementation; the copy() method did not copy across the in body: " + previousExchange + " of type: " + previousExchange . getClass ( ) ) ; in . setBody ( previousInBody ) ; } } return answer ; } protected Exchange copyExchangeStrategy ( Exchange exchange ) { return exchange . copy ( ) ; } @ Override public String toString ( ) { return "Pipeline" + getProcessors ( ) ; } } 	0	['11', '3', '0', '16', '48', '43', '5', '12', '5', '0.7', '229', '1', '1', '0.689655172', '0.266666667', '0', '0', '19.72727273', '5', '1.7273', '0']
package org . apache . camel . management ; import java . net . InetAddress ; import java . net . UnknownHostException ; import javax . management . MalformedObjectNameException ; import javax . management . ObjectName ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; public class CamelNamingStrategy { public static final String VALUE_UNKNOWN = "unknown" ; public static final String VALUE_ROUTE = "route" ; public static final String KEY_NAME = "name" ; public static final String KEY_TYPE = "type" ; public static final String KEY_CONTEXT = "context" ; public static final String KEY_GROUP = "group" ; public static final String KEY_COMPONENT = "component" ; public static final String KEY_ROUTE_TYPE = "routeType" ; public static final String KEY_ROUTE = "route" ; public static final String GROUP_ENDPOINTS = "endpoints" ; public static final String GROUP_SERVICES = "services" ; public static final String GROUP_ROUTE_BUILDER = "routeBuilder" ; public static final String GROUP_ROUTE_TYPE = "routeType" ; protected String domainName ; protected String hostName = "locahost" ; public CamelNamingStrategy ( ) { this ( "org.apache.camel" ) ; } public CamelNamingStrategy ( String domainName ) { if ( domainName != null ) { this . domainName = domainName ; } try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException ex ) { } } public ObjectName getObjectName ( CamelContext context ) throws MalformedObjectNameException { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( context ) + "," ) ; buffer . append ( KEY_NAME + "=" + "context" ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( ManagedEndpoint mbean ) throws MalformedObjectNameException { Endpoint ep = mbean . getEndpoint ( ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( ep . getContext ( ) ) + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_ENDPOINTS + "," ) ; buffer . append ( KEY_COMPONENT + "=" + getComponentId ( ep ) + "," ) ; buffer . append ( KEY_NAME + "=" + getEndpointId ( ep ) ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( CamelContext context , ManagedService mbean ) throws MalformedObjectNameException { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( context ) + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_SERVICES + "," ) ; buffer . append ( KEY_NAME + "=" + Integer . toHexString ( mbean . getService ( ) . hashCode ( ) ) ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( ManagedRoute mbean ) throws MalformedObjectNameException { Endpoint ep = mbean . getRoute ( ) . getEndpoint ( ) ; String ctxid = ep != null ? getContextId ( ep . getContext ( ) ) : VALUE_UNKNOWN ; String cid = getComponentId ( ep ) ; String id = VALUE_UNKNOWN . equals ( cid ) ? getEndpointId ( ep ) : "[" + cid + "]" + getEndpointId ( ep ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + ctxid + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_ROUTE_BUILDER + "," ) ; buffer . append ( KEY_ROUTE_TYPE + "=" + GROUP_ROUTE_TYPE + "," ) ; buffer . append ( KEY_ROUTE + "=" + id + "," ) ; buffer . append ( KEY_NAME + "=" + VALUE_ROUTE ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( CamelContext context , PerformanceCounter mbean ) throws MalformedObjectNameException { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName + ":" ) ; buffer . append ( KEY_CONTEXT + "=" + getContextId ( context ) + "," ) ; buffer . append ( KEY_GROUP + "=" + GROUP_ENDPOINTS + "," ) ; buffer . append ( KEY_ROUTE + "=" + "Route.Counter" + "," ) ; buffer . append ( KEY_NAME + "=" + "Stats" ) ; return createObjectName ( buffer ) ; } public String getDomainName ( ) { return domainName ; } public void setDomainName ( String domainName ) { this . domainName = domainName ; } public String getHostName ( ) { return hostName ; } public void setHostName ( String hostName ) { this . hostName = hostName ; } protected String getContextId ( CamelContext context ) { String id = context != null ? context . getName ( ) : VALUE_UNKNOWN ; return hostName + "/" + id ; } protected String getComponentId ( Endpoint ep ) { String uri = ep . getEndpointUri ( ) ; int pos = uri . indexOf ( ':' ) ; return ( pos == - 1 ) ? VALUE_UNKNOWN : uri . substring ( 0 , pos ) ; } protected String getEndpointId ( Endpoint ep ) { String uri = ep . getEndpointUri ( ) ; int pos = uri . indexOf ( ':' ) ; String id = ( pos == - 1 ) ? uri : uri . substring ( pos + 1 ) ; if ( ! ep . isSingleton ( ) ) { id += "." + Integer . toString ( ep . hashCode ( ) ) ; } id = id . replace ( "=" , "_eq_" ) ; id = id . replace ( "," , "_cm_" ) ; return id ; } protected ObjectName createObjectName ( StringBuffer buffer ) throws MalformedObjectNameException { String text = buffer . toString ( ) ; try { text = text . replace ( "?" , "_qe_" ) ; return new ObjectName ( text ) ; } catch ( MalformedObjectNameException e ) { throw new MalformedObjectNameException ( "Could not create ObjectName from: " + text + ". Reason: " + e ) ; } } } 	1	['15', '1', '0', '11', '43', '37', '3', '8', '11', '0.980952381', '485', '0.133333333', '0', '0', '0.214814815', '0', '0', '30.33333333', '3', '1.1333', '10']
package org . apache . camel . builder . script ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class ScriptLanguage implements Language { private final String language ; public ScriptLanguage ( String language ) { this . language = language ; } public Predicate < Exchange > createPredicate ( String expression ) { return new ScriptBuilder ( language , expression ) ; } public Expression < Exchange > createExpression ( String expression ) { return new ScriptBuilder ( language , expression ) ; } } 	0	['3', '1', '0', '5', '5', '0', '1', '4', '3', '0', '24', '1', '0', '0', '1', '0', '0', '6.666666667', '1', '0.6667', '0']
package org . apache . camel . model ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; @ XmlRootElement ( name = "process" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ProcessorRef extends OutputType { @ XmlAttribute ( required = true ) private String ref ; @ XmlTransient private Processor processor ; public ProcessorRef ( ) { } public ProcessorRef ( Processor processor ) { this . processor = processor ; } @ Override public String toString ( ) { return "Processor[ref:  " + ref + "]" ; } @ Override public String getLabel ( ) { if ( ref != null ) { return "ref:  " + ref ; } else if ( processor != null ) { return processor . toString ( ) ; } else { return "" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( processor == null ) { processor = routeContext . lookup ( getRef ( ) , Processor . class ) ; } return processor ; } } 	1	['7', '3', '0', '4', '13', '3', '1', '3', '7', '0.5', '73', '1', '1', '0.951456311', '0.357142857', '1', '2', '9.142857143', '3', '1.1429', '2']
package org . apache . camel . component . mail ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import java . net . URI ; import java . util . Map ; public class MailComponent extends DefaultComponent < MailExchange > { private MailConfiguration configuration ; public MailComponent ( ) { this . configuration = new MailConfiguration ( ) ; } public MailComponent ( MailConfiguration configuration ) { this . configuration = configuration ; } public MailComponent ( CamelContext context ) { super ( context ) ; this . configuration = new MailConfiguration ( ) ; } public static MailComponent mailComponent ( ) { return new MailComponent ( ) ; } public static MailComponent mailComponent ( MailConfiguration configuration ) { return new MailComponent ( configuration ) ; } @ Override protected Endpoint < MailExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { MailConfiguration config = getConfiguration ( ) . copy ( ) ; config . configure ( new URI ( uri ) ) ; MailEndpoint endpoint = new MailEndpoint ( uri , this , config ) ; setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public MailConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( MailConfiguration configuration ) { this . configuration = configuration ; } protected String convertPathToActualDestination ( String path ) { return path ; } } 	0	['9', '3', '0', '5', '18', '16', '1', '5', '7', '0.125', '75', '1', '1', '0.793103448', '0.311111111', '1', '2', '7.222222222', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlType ( name = "outputType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class OutputType < Type extends ProcessorType > extends ProcessorType < Type > { private static final transient Log LOG = LogFactory . getLog ( OutputType . class ) ; @ XmlElementRef protected List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } } 	1	['7', '2', '10', '15', '17', '9', '11', '4', '5', '0.777777778', '68', '1', '1', '0.948979592', '0.5', '1', '5', '8.285714286', '3', '1.1429', '1']
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ValueBuilder ; import static org . apache . camel . builder . ExpressionBuilder . bodyExpression ; import static org . apache . camel . builder . ExpressionBuilder . headerExpression ; public abstract class AssertionClause < E extends Exchange > implements Runnable { private List < Predicate < E > > predicates = new ArrayList < Predicate < E > > ( ) ; public AssertionClause < E > predicate ( Predicate < E > predicate ) { addPredicate ( predicate ) ; return this ; } public ValueBuilder < E > header ( String name ) { Expression < E > expression = headerExpression ( name ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder body ( ) { Expression < E > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder bodyAs ( Class < T > type ) { Expression < E > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder outBody ( ) { Expression < E > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder outBody ( Class < T > type ) { Expression < E > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } protected void applyAssertionOn ( MockEndpoint endpoint , int index , E exchange ) { for ( Predicate < E > predicate : predicates ) { predicate . assertMatches ( endpoint . getEndpointUri ( ) + " " , exchange ) ; } } protected void addPredicate ( Predicate < E > predicate ) { predicates . add ( predicate ) ; } public class PredicateValueBuilder extends ValueBuilder < E > { public PredicateValueBuilder ( Expression < E > expression ) { super ( expression ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { addPredicate ( predicate ) ; return predicate ; } } } 	0	['9', '1', '2', '9', '24', '30', '4', '7', '7', '0.625', '97', '1', '0', '0', '0.26984127', '0', '0', '9.666666667', '2', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . Policy ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; public class DelegateAsyncProcessor extends ServiceSupport implements AsyncProcessor { protected AsyncProcessor processor ; public DelegateAsyncProcessor ( ) { } public DelegateAsyncProcessor ( AsyncProcessor processor ) { this . processor = processor ; } @ Override public String toString ( ) { return "Delegate(" + processor + ")" ; } public AsyncProcessor getProcessor ( ) { return processor ; } public void setProcessor ( AsyncProcessor processor ) { this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { return processor . process ( exchange , callback ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } } 	1	['9', '2', '1', '7', '18', '0', '1', '6', '7', '0.25', '66', '1', '1', '0.65', '0.388888889', '1', '1', '6.222222222', '1', '0.7778', '1']
package org . apache . camel . component . cxf ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . component . cxf . invoker . InvokingContext ; import org . apache . camel . component . cxf . invoker . InvokingContextFactory ; import org . apache . cxf . Bus ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . endpoint . EndpointImpl ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . PhaseInterceptorChain ; import org . apache . cxf . transport . ChainInitiationObserver ; public class CxfMessageObserver extends ChainInitiationObserver { private static final Logger LOG = Logger . getLogger ( ChainInitiationObserver . class . getName ( ) ) ; private CxfConsumer cxfConsumer ; private DataFormat dataFormat ; private CamelInvoker invoker ; public CxfMessageObserver ( CxfConsumer consumer , Endpoint endpoint , Bus bus , DataFormat dataFormat ) { super ( endpoint , bus ) ; cxfConsumer = consumer ; this . dataFormat = dataFormat ; invoker = new CamelInvoker ( consumer ) ; } protected void setExchangeProperties ( Exchange exchange , Message m ) { super . setExchangeProperties ( exchange , m ) ; exchange . put ( CxfConsumer . class , cxfConsumer ) ; exchange . put ( Bus . class , bus ) ; exchange . put ( Endpoint . class , endpoint ) ; exchange . put ( InvokingContext . class , InvokingContextFactory . createContext ( dataFormat ) ) ; exchange . put ( CamelInvoker . class , invoker ) ; } public void onMessage ( Message m ) { if ( LOG . isLoggable ( Level . FINER ) ) { LOG . fine ( "Observed Client request at router's endpoint.  Request message: " + m ) ; } Message message = endpoint . getBinding ( ) . createMessage ( m ) ; message . put ( Message . INBOUND_MESSAGE , Boolean . TRUE ) ; Exchange exchange = message . getExchange ( ) ; if ( exchange == null ) { exchange = new ExchangeImpl ( ) ; exchange . setInMessage ( message ) ; } setExchangeProperties ( exchange , message ) ; InvokingContext invokingContext = exchange . get ( InvokingContext . class ) ; assert invokingContext != null ; invokingContext . setEndpointFaultObservers ( ( EndpointImpl ) endpoint , bus ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "Build inbound interceptor chain and inject routing interceptor" ) ; } PhaseInterceptorChain chain = invokingContext . getRequestInInterceptorChain ( exchange ) ; message . setInterceptorChain ( chain ) ; chain . setFaultObserver ( endpoint . getOutFaultObserver ( ) ) ; chain . doIntercept ( message ) ; } } 	0	['4', '0', '0', '16', '33', '0', '1', '16', '2', '0.466666667', '154', '0.8', '3', '0', '0.476190476', '0', '0', '36.25', '6', '1.75', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . Builder ; import org . apache . camel . builder . DataTypeExpression ; import org . apache . camel . builder . DeadLetterChannelBuilder ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . NoErrorHandlerBuilder ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . model . language . LanguageExpression ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . MulticastProcessor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . Policy ; import org . apache . camel . spi . Registry ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class ProcessorType < Type extends ProcessorType > { public static final String DEFAULT_TRACE_CATEGORY = "org.apache.camel.TRACE" ; private ErrorHandlerBuilder errorHandlerBuilder ; private Boolean inheritErrorHandlerFlag = Boolean . TRUE ; private DelegateProcessor lastInterceptor ; private NodeFactory nodeFactory ; public abstract List < ProcessorType < ? > > getOutputs ( ) ; public abstract List < InterceptorType > getInterceptors ( ) ; public Processor createProcessor ( RouteContext routeContext ) throws Exception { throw new UnsupportedOperationException ( "Not implemented yet for class: " + getClass ( ) . getName ( ) ) ; } public Processor createOutputsProcessor ( RouteContext routeContext ) throws Exception { Collection < ProcessorType < ? > > outputs = getOutputs ( ) ; return createOutputsProcessor ( routeContext , outputs ) ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Processor processor = makeProcessor ( routeContext ) ; routeContext . addEventDrivenProcessor ( processor ) ; } public Processor wrapProcessor ( RouteContext routeContext , Processor processor ) throws Exception { processor = wrapProcessorInInterceptors ( routeContext , processor ) ; return wrapInErrorHandler ( processor ) ; } public Type to ( String uri ) { addOutput ( new ToType ( uri ) ) ; return ( Type ) this ; } public Type to ( Endpoint endpoint ) { addOutput ( new ToType ( endpoint ) ) ; return ( Type ) this ; } public Type to ( String ... uris ) { for ( String uri : uris ) { addOutput ( new ToType ( uri ) ) ; } return ( Type ) this ; } public Type to ( Endpoint ... endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public Type to ( Collection < Endpoint > endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public MulticastType multicast ( ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; return answer ; } public Type pipeline ( String ... uris ) { return to ( uris ) ; } public Type pipeline ( Endpoint ... endpoints ) { return to ( endpoints ) ; } public Type pipeline ( Collection < Endpoint > endpoints ) { return to ( endpoints ) ; } public IdempotentConsumerType idempotentConsumer ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { IdempotentConsumerType answer = new IdempotentConsumerType ( messageIdExpression , messageIdRepository ) ; addOutput ( answer ) ; return answer ; } public FilterType filter ( Predicate predicate ) { FilterType filter = new FilterType ( predicate ) ; addOutput ( filter ) ; return filter ; } public ChoiceType choice ( ) { ChoiceType answer = new ChoiceType ( ) ; addOutput ( answer ) ; return answer ; } public TryType tryBlock ( ) { TryType answer = new TryType ( ) ; addOutput ( answer ) ; return answer ; } public Type recipientList ( Expression receipients ) { RecipientListType answer = new RecipientListType ( receipients ) ; addOutput ( answer ) ; return ( Type ) this ; } public SplitterType splitter ( Expression receipients ) { SplitterType answer = new SplitterType ( receipients ) ; addOutput ( answer ) ; return answer ; } public ResequencerType resequencer ( Expression < Exchange > expression ) { return resequencer ( Collections . < Expression > singletonList ( expression ) ) ; } public ResequencerType resequencer ( List < Expression > expressions ) { ResequencerType answer = new ResequencerType ( expressions ) ; addOutput ( answer ) ; return answer ; } public ResequencerType resequencer ( Expression ... expressions ) { List < Expression > list = new ArrayList < Expression > ( ) ; for ( Expression expression : expressions ) { list . add ( expression ) ; } return resequencer ( list ) ; } public AggregatorType aggregator ( Expression correlationExpression ) { AggregatorType answer = new AggregatorType ( correlationExpression ) ; addOutput ( answer ) ; return answer ; } public AggregatorType aggregator ( Expression correlationExpression , AggregationStrategy aggregationStrategy ) { AggregatorType answer = new AggregatorType ( correlationExpression , aggregationStrategy ) ; addOutput ( answer ) ; return answer ; } public DelayerType delayer ( Expression < Exchange > processAtExpression ) { return delayer ( processAtExpression , 0L ) ; } public DelayerType delayer ( Expression < Exchange > processAtExpression , long delay ) { DelayerType answer = new DelayerType ( processAtExpression , delay ) ; addOutput ( answer ) ; return answer ; } public DelayerType delayer ( long delay ) { return delayer ( null , delay ) ; } public ThrottlerType throttler ( long maximumRequestCount ) { ThrottlerType answer = new ThrottlerType ( maximumRequestCount ) ; addOutput ( answer ) ; return answer ; } public Type interceptor ( String ref ) { getInterceptors ( ) . add ( new InterceptorRef ( ref ) ) ; return ( Type ) this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer ; } public Type proceed ( ) { addOutput ( new ProceedType ( ) ) ; return ( Type ) this ; } public ExceptionType exception ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; addOutput ( answer ) ; return answer ; } public OtherwiseType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer . when ( predicate ) ; } public Type interceptors ( String ... refs ) { for ( String ref : refs ) { interceptor ( ref ) ; } return ( Type ) this ; } public FilterType filter ( ExpressionType expression ) { FilterType filter = getNodeFactory ( ) . createFilter ( ) ; filter . setExpression ( expression ) ; addOutput ( filter ) ; return filter ; } public FilterType filter ( String language , String expression ) { return filter ( new LanguageExpression ( language , expression ) ) ; } public Type trace ( ) { return trace ( DEFAULT_TRACE_CATEGORY ) ; } public Type trace ( String category ) { final Log log = LogFactory . getLog ( category ) ; return intercept ( new DelegateProcessor ( ) { @ Override public void process ( Exchange exchange ) throws Exception { log . trace ( exchange ) ; processNext ( exchange ) ; } } ) ; } public PolicyRef policies ( ) { PolicyRef answer = new PolicyRef ( ) ; addOutput ( answer ) ; return answer ; } public PolicyRef policy ( Policy policy ) { PolicyRef answer = new PolicyRef ( policy ) ; addOutput ( answer ) ; return answer ; } public Type intercept ( DelegateProcessor interceptor ) { getInterceptors ( ) . add ( new InterceptorRef ( interceptor ) ) ; lastInterceptor = interceptor ; return ( Type ) this ; } public Type errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return ( Type ) this ; } public Type inheritErrorHandler ( boolean condition ) { setInheritErrorHandlerFlag ( condition ) ; return ( Type ) this ; } public Type process ( Processor processor ) { ProcessorRef answer = new ProcessorRef ( processor ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type processRef ( String ref ) { ProcessorRef answer = new ProcessorRef ( ) ; answer . setRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref ) { BeanRef answer = new BeanRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref , String method ) { BeanRef answer = new BeanRef ( ref , method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type setBody ( Expression expression ) { return process ( ProcessorBuilder . setBody ( expression ) ) ; } public Type setOutBody ( Expression expression ) { return process ( ProcessorBuilder . setOutBody ( expression ) ) ; } public Type setFaultBody ( Expression expression ) { return process ( ProcessorBuilder . setFaultBody ( expression ) ) ; } public Type setHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setHeader ( name , expression ) ) ; } public Type setOutHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setOutHeader ( name , expression ) ) ; } public Type setFaultHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setFaultHeader ( name , expression ) ) ; } public Type setProperty ( String name , Expression expression ) { return process ( ProcessorBuilder . setProperty ( name , expression ) ) ; } public Type removeHeader ( String name ) { return process ( ProcessorBuilder . removeHeader ( name ) ) ; } public Type removeOutHeader ( String name ) { return process ( ProcessorBuilder . removeOutHeader ( name ) ) ; } public Type removeFaultHeader ( String name ) { return process ( ProcessorBuilder . removeFaultHeader ( name ) ) ; } public Type removeProperty ( String name ) { return process ( ProcessorBuilder . removeProperty ( name ) ) ; } public Type convertBodyTo ( Class type ) { return process ( ProcessorBuilder . setBody ( Builder . body ( ) . convertTo ( type ) ) ) ; } public Type convertOutBodyTo ( Class type ) { return process ( ProcessorBuilder . setOutBody ( Builder . outBody ( ) . convertTo ( type ) ) ) ; } public Type convertFaultBodyTo ( Class type ) { return process ( ProcessorBuilder . setFaultBody ( Builder . faultBody ( ) . convertTo ( type ) ) ) ; } public DataTypeExpression < Type > unmarshal ( ) { return new DataTypeExpression < Type > ( this , DataTypeExpression . Operation . Unmarshal ) ; } public Type unmarshal ( DataFormatType dataFormatType ) { addOutput ( new UnmarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type unmarshal ( DataFormat dataFormat ) { return unmarshal ( new DataFormatType ( dataFormat ) ) ; } public Type unmarshal ( String dataTypeRef ) { addOutput ( new UnmarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } public DataTypeExpression < Type > marshal ( ) { return new DataTypeExpression < Type > ( this , DataTypeExpression . Operation . Marshal ) ; } public Type marshal ( DataFormatType dataFormatType ) { addOutput ( new MarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type marshal ( DataFormat dataFormat ) { return marshal ( new DataFormatType ( dataFormat ) ) ; } public Type marshal ( String dataTypeRef ) { addOutput ( new MarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } @ XmlTransient public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } @ XmlTransient public boolean isInheritErrorHandler ( ) { return ObjectConverter . toBoolean ( getInheritErrorHandlerFlag ( ) ) ; } @ XmlAttribute ( name = "inheritErrorHandler" , required = false ) public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } @ XmlTransient public NodeFactory getNodeFactory ( ) { if ( nodeFactory == null ) { nodeFactory = new NodeFactory ( ) ; } return nodeFactory ; } public void setNodeFactory ( NodeFactory nodeFactory ) { this . nodeFactory = nodeFactory ; } public String getLabel ( ) { return "" ; } protected Processor makeProcessor ( RouteContext routeContext ) throws Exception { Processor processor = createProcessor ( routeContext ) ; return wrapProcessor ( routeContext , processor ) ; } protected Processor wrapProcessorInInterceptors ( RouteContext routeContext , Processor target ) throws Exception { if ( target == null ) { throw new RuntimeCamelException ( "target provided." ) ; } DelegateProcessor first = null ; DelegateProcessor last = null ; List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( routeContext . getRoute ( ) . getInterceptors ( ) ) ; List < InterceptorType > list = getInterceptors ( ) ; for ( InterceptorType interceptorType : list ) { if ( ! interceptors . contains ( interceptorType ) ) { interceptors . add ( interceptorType ) ; } } for ( InterceptorType interceptorRef : interceptors ) { DelegateProcessor p = interceptorRef . createInterceptor ( routeContext ) ; if ( first == null ) { first = p ; } if ( last != null ) { last . setProcessor ( p ) ; } last = p ; } if ( last != null ) { last . setProcessor ( target ) ; } return first == null ? target : first ; } protected Processor wrapInErrorHandler ( Processor processor ) throws Exception { return getErrorHandlerBuilder ( ) . createErrorHandler ( processor ) ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } protected void configureChild ( ProcessorType output ) { output . setNodeFactory ( getNodeFactory ( ) ) ; } protected void addOutput ( ProcessorType processorType ) { configureChild ( processorType ) ; getOutputs ( ) . add ( processorType ) ; } protected Processor createCompositeProcessor ( List < Processor > list ) { return new Pipeline ( list ) ; } protected Processor createOutputsProcessor ( RouteContext routeContext , Collection < ProcessorType < ? > > outputs ) throws Exception { List < Processor > list = new ArrayList < Processor > ( ) ; for ( ProcessorType output : outputs ) { Processor processor = output . createProcessor ( routeContext ) ; list . add ( processor ) ; } Processor processor = null ; if ( ! list . isEmpty ( ) ) { if ( list . size ( ) == 1 ) { processor = list . get ( 0 ) ; } else { processor = createCompositeProcessor ( list ) ; } } return processor ; } public ThreadType thread ( int coreSize ) { ThreadType answer = new ThreadType ( coreSize ) ; addOutput ( answer ) ; return answer ; } public ProcessorType < Type > thread ( ThreadPoolExecutor executor ) { ThreadType answer = new ThreadType ( executor ) ; addOutput ( answer ) ; return this ; } } 	1	['94', '1', '11', '63', '186', '4361', '28', '53', '86', '0.967741935', '1012', '0.8', '3', '0', '0.067131328', '0', '0', '9.712765957', '2', '1.0745', '28']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . concurrent . ScheduledExecutorService ; import com . jcraft . jsch . ChannelSftp ; import org . apache . camel . Processor ; import org . apache . camel . component . file . FileComponent ; public class SftpConsumer extends RemoteFileConsumer < RemoteFileExchange > { private boolean recursive = true ; private String regexPattern = "" ; private long lastPollTime ; private final SftpEndpoint endpoint ; private ChannelSftp channel ; private boolean setNames = false ; public SftpConsumer ( SftpEndpoint endpoint , Processor processor , ChannelSftp channel ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . channel = channel ; } public SftpConsumer ( SftpEndpoint endpoint , Processor processor , ChannelSftp channel , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; this . endpoint = endpoint ; this . channel = channel ; } protected void poll ( ) throws Exception { final String fileName = endpoint . getConfiguration ( ) . getFile ( ) ; if ( endpoint . getConfiguration ( ) . isDirectory ( ) ) { pollDirectory ( fileName ) ; } else { channel . cd ( fileName . substring ( 0 , fileName . lastIndexOf ( '/' ) ) ) ; final ChannelSftp . LsEntry file = ( ChannelSftp . LsEntry ) channel . ls ( fileName . substring ( fileName . lastIndexOf ( '/' ) + 1 ) ) . get ( 0 ) ; pollFile ( file ) ; } lastPollTime = System . currentTimeMillis ( ) ; } protected void pollDirectory ( String dir ) throws Exception { channel . cd ( dir ) ; for ( ChannelSftp . LsEntry sftpFile : ( ChannelSftp . LsEntry [ ] ) channel . ls ( "." ) . toArray ( new ChannelSftp . LsEntry [ ] { } ) ) { if ( sftpFile . getFilename ( ) . startsWith ( "." ) ) { } else if ( sftpFile . getAttrs ( ) . isDir ( ) ) { if ( isRecursive ( ) ) { pollDirectory ( getFullFileName ( sftpFile ) ) ; } } else { pollFile ( sftpFile ) ; } } } protected String getFullFileName ( ChannelSftp . LsEntry sftpFile ) throws IOException { return channel . pwd ( ) + "/" + sftpFile . getFilename ( ) ; } private void pollFile ( ChannelSftp . LsEntry sftpFile ) throws Exception { if ( sftpFile . getAttrs ( ) . getMTime ( ) * 1000 > lastPollTime ) { if ( isMatched ( sftpFile ) ) { final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; channel . get ( sftpFile . getFilename ( ) , byteArrayOutputStream ) ; RemoteFileExchange exchange = endpoint . createExchange ( getFullFileName ( sftpFile ) , byteArrayOutputStream ) ; if ( isSetNames ( ) ) { String relativePath = getFullFileName ( sftpFile ) . substring ( endpoint . getConfiguration ( ) . getFile ( ) . length ( ) ) ; if ( relativePath . startsWith ( "/" ) ) { relativePath = relativePath . substring ( 1 ) ; } exchange . getIn ( ) . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } getProcessor ( ) . process ( exchange ) ; } } } protected boolean isMatched ( ChannelSftp . LsEntry sftpFile ) { boolean result = true ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { result = sftpFile . getFilename ( ) . matches ( getRegexPattern ( ) ) ; } return result ; } public boolean isRecursive ( ) { return recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public long getLastPollTime ( ) { return lastPollTime ; } public void setLastPollTime ( long lastPollTime ) { this . lastPollTime = lastPollTime ; } public String getRegexPattern ( ) { return regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } public boolean isSetNames ( ) { return setNames ; } public void setSetNames ( boolean setNames ) { this . setNames = setNames ; } } 	0	['15', '5', '0', '11', '46', '27', '1', '11', '10', '0.69047619', '279', '1', '1', '0.723404255', '0.222222222', '1', '1', '17.2', '3', '1', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import org . apache . camel . Expression ; public class ParameterInfo { private final int index ; private final Class type ; private final Annotation [ ] annotations ; private final Expression expression ; public ParameterInfo ( int index , Class type , Annotation [ ] annotations , Expression expression ) { this . index = index ; this . type = type ; this . annotations = annotations ; this . expression = expression ; } public Annotation [ ] getAnnotations ( ) { return annotations ; } public Expression getExpression ( ) { return expression ; } public int getIndex ( ) { return index ; } public Class getType ( ) { return type ; } } 	1	['5', '1', '0', '4', '6', '2', '3', '1', '5', '0.75', '36', '1', '1', '0', '0.36', '0', '0', '5.4', '1', '0.8', '2']
package org . apache . camel . processor ; import java . util . Collection ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class CompositeProcessor extends ServiceSupport implements Processor { private final Collection < Processor > processors ; public CompositeProcessor ( Collection < Processor > processors ) { this . processors = processors ; } public void process ( Exchange exchange ) throws Exception { for ( Processor processor : processors ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "[ " ) ; boolean first = true ; for ( Processor processor : processors ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( processor . toString ( ) ) ; } builder . append ( " ]" ) ; return builder . toString ( ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } } 	0	['6', '2', '0', '4', '17', '0', '0', '4', '4', '0', '80', '1', '0', '0.722222222', '0.444444444', '1', '1', '12.16666667', '3', '1.1667', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; public class FilterProcessor extends DelegateProcessor { private Predicate < Exchange > predicate ; public FilterProcessor ( Predicate < Exchange > predicate , Processor processor ) { super ( processor ) ; this . predicate = predicate ; } public void process ( Exchange exchange ) throws Exception { if ( predicate . matches ( exchange ) ) { super . process ( exchange ) ; } } @ Override public String toString ( ) { return "Filter[if: " + predicate + " do: " + getProcessor ( ) + "]" ; } public Predicate < Exchange > getPredicate ( ) { return predicate ; } } 	1	['4', '3', '0', '9', '12', '0', '5', '4', '4', '0', '41', '1', '1', '0.875', '0.4375', '0', '0', '9', '1', '0.75', '1']
package org . apache . camel . processor ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . processor . Interceptor ; public class ProceedProcessor implements Processor { private final Interceptor interceptor ; public ProceedProcessor ( Interceptor interceptor ) { this . interceptor = interceptor ; } public String toString ( ) { return "Proceed[" + interceptor + "]" ; } public void process ( Exchange exchange ) throws Exception { interceptor . proceed ( exchange ) ; } } 	0	['3', '1', '0', '4', '9', '0', '1', '3', '3', '0', '27', '1', '1', '0', '0.555555556', '0', '0', '7.666666667', '1', '0.6667', '0']
package org . apache . camel . processor . aggregate ; import java . util . AbstractCollection ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class AggregationCollection extends AbstractCollection < Exchange > { private final Expression < Exchange > correlationExpression ; private final AggregationStrategy aggregationStrategy ; private Map < Object , Exchange > map = new LinkedHashMap < Object , Exchange > ( ) ; public AggregationCollection ( Expression < Exchange > correlationExpression , AggregationStrategy aggregationStrategy ) { this . correlationExpression = correlationExpression ; this . aggregationStrategy = aggregationStrategy ; } @ Override public boolean add ( Exchange exchange ) { Object correlationKey = correlationExpression . evaluate ( exchange ) ; Exchange oldExchange = map . get ( correlationKey ) ; Exchange newExchange = exchange ; if ( oldExchange != null ) { newExchange = aggregationStrategy . aggregate ( oldExchange , newExchange ) ; } if ( newExchange != oldExchange ) { map . put ( correlationKey , newExchange ) ; } return true ; } public Iterator < Exchange > iterator ( ) { return map . values ( ) . iterator ( ) ; } public int size ( ) { return map . size ( ) ; } } 	1	['5', '2', '0', '4', '14', '0', '1', '3', '5', '0.333333333', '68', '1', '2', '0.777777778', '0.36', '1', '5', '12', '3', '1.2', '4']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessageJMSPropertyAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 6744171518099741324L ; public MessageJMSPropertyAccessException ( JMSException e ) { super ( "Failed to access a JMS property: " + e , e ) ; } } 	0	['1', '5', '0', '2', '6', '0', '1', '1', '1', '2', '14', '1', '0', '1', '1', '0', '0', '12', '0', '0', '0']
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultMessage ; import java . io . File ; public class FileMessage extends DefaultMessage { private File file ; public FileMessage ( ) { this ( new File ( "." ) ) ; } public FileMessage ( File file ) { this . file = file ; } @ Override public String toString ( ) { return "FileMessage: " + file ; } @ Override public FileExchange getExchange ( ) { return ( FileExchange ) super . getExchange ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } @ Override public FileMessage newInstance ( ) { return new FileMessage ( ) ; } @ Override protected Object createBody ( ) { return file ; } } 	1	['11', '3', '0', '4', '15', '35', '1', '4', '10', '0.2', '62', '1', '0', '0.71875', '0.590909091', '2', '5', '4.545454545', '1', '0.8182', '1']
package org . apache . camel . component . file . remote ; import java . io . OutputStream ; public class RemoteFileBinding { public Object extractBodyFromOutputStream ( RemoteFileExchange exchange , OutputStream outputStream ) { return outputStream ; } } 	0	['2', '1', '0', '3', '3', '1', '3', '1', '2', '2', '7', '0', '0', '0', '0.666666667', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelException ; public class NoBeanAvailableException extends CamelException { private final String name ; public NoBeanAvailableException ( String name ) { super ( "No bean available for endpoint: " + name ) ; this . name = name ; } public String getName ( ) { return name ; } } 	1	['2', '4', '0', '2', '6', '0', '1', '1', '2', '0', '20', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '1']
package org . apache . camel . component . file . remote ; import org . apache . camel . RuntimeCamelException ; public class FtpOperationFailedException extends RuntimeCamelException { private final int code ; private final String reason ; public FtpOperationFailedException ( int code , String reason ) { super ( "Ftp Operation failed: " + reason . trim ( ) + " Code: " + code ) ; this . code = code ; this . reason = reason ; } public int getCode ( ) { return code ; } public String getReason ( ) { return reason ; } } 	0	['3', '5', '0', '1', '9', '0', '0', '1', '3', '0.5', '33', '1', '0', '0.894736842', '0.555555556', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . camel ; public class InvalidHeaderTypeException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; private final Object headerValue ; public InvalidHeaderTypeException ( Throwable cause , Object headerValue ) { super ( cause . getMessage ( ) + " headerValue is: " + headerValue + " of type: " + typeName ( headerValue ) , cause ) ; this . headerValue = headerValue ; } public InvalidHeaderTypeException ( String message , Object headerValue ) { super ( message ) ; this . headerValue = headerValue ; } public Object getHeaderValue ( ) { return headerValue ; } protected static String typeName ( Object headerValue ) { return ( headerValue != null ) ? headerValue . getClass ( ) . getName ( ) : "null" ; } } 	1	['4', '5', '0', '1', '13', '0', '0', '1', '3', '0.833333333', '47', '1', '0', '0.894736842', '0.5', '0', '0', '10.25', '2', '0.75', '1']
package org . apache . camel . component . ibatis ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import com . ibatis . sqlmap . client . SqlMapClient ; import com . ibatis . sqlmap . client . SqlMapClientBuilder ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . ClassPathResource ; import org . springframework . core . io . Resource ; public class IBatisComponent extends DefaultComponent { private static final transient Log LOG = LogFactory . getLog ( IBatisComponent . class ) ; public static final String DEFAULT_CONFIG_URI = "SqlMapConfig.xml" ; private SqlMapClient sqlMapClient ; private Resource sqlMapResource ; public IBatisComponent ( ) { } public IBatisComponent ( SqlMapClient sqlMapClient ) { this . sqlMapClient = sqlMapClient ; } public SqlMapClient getSqlMapClient ( ) throws IOException { if ( sqlMapClient == null ) { sqlMapClient = createSqlMapClient ( ) ; } return sqlMapClient ; } public void setSqlMapClient ( SqlMapClient sqlMapClient ) { this . sqlMapClient = sqlMapClient ; } public Resource getSqlMapResource ( ) { if ( sqlMapResource == null ) { sqlMapResource = new ClassPathResource ( DEFAULT_CONFIG_URI ) ; LOG . debug ( "Defaulting to use the iBatis configuration from: " + sqlMapResource ) ; } return sqlMapResource ; } public void setSqlMapResource ( Resource sqlMapResource ) { this . sqlMapResource = sqlMapResource ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new IBatisEndpoint ( uri , this , remaining ) ; } protected SqlMapClient createSqlMapClient ( ) throws IOException { InputStream in = getSqlMapResource ( ) . getInputStream ( ) ; return SqlMapClientBuilder . buildSqlMapClient ( in ) ; } } 	0	['9', '3', '0', '9', '20', '26', '1', '9', '6', '0.84375', '81', '0.75', '1', '0.793103448', '0.325', '1', '1', '7.555555556', '2', '0.7778', '0']
package org . apache . camel ; import org . apache . camel . spi . UnitOfWork ; import java . util . Map ; public interface Exchange { ExchangePattern getPattern ( ) ; Object getProperty ( String name ) ; < T > T getProperty ( String name , Class < T > type ) ; void setProperty ( String name , Object value ) ; Object removeProperty ( String name ) ; Map < String , Object > getProperties ( ) ; Message getIn ( ) ; Message getOut ( ) ; Message getOut ( boolean lazyCreate ) ; Message getFault ( ) ; Message getFault ( boolean lazyCreate ) ; Throwable getException ( ) ; void setException ( Throwable e ) ; boolean isFailed ( ) ; CamelContext getContext ( ) ; Exchange copy ( ) ; void copyFrom ( Exchange source ) ; UnitOfWork getUnitOfWork ( ) ; void setUnitOfWork ( UnitOfWork unitOfWork ) ; String getExchangeId ( ) ; void setExchangeId ( String id ) ; } 	1	['21', '1', '0', '272', '21', '210', '270', '4', '21', '2', '21', '0', '0', '0', '0.196428571', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . jms ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import javax . jms . Message ; public class JmsExchange extends DefaultExchange { private JmsBinding binding ; public JmsExchange ( CamelContext context , ExchangePattern pattern , JmsBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public JmsExchange ( CamelContext context , ExchangePattern pattern , JmsBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new JmsMessage ( message ) ) ; } @ Override public JmsMessage getIn ( ) { return ( JmsMessage ) super . getIn ( ) ; } @ Override public JmsMessage getOut ( ) { return ( JmsMessage ) super . getOut ( ) ; } @ Override public JmsMessage getOut ( boolean lazyCreate ) { return ( JmsMessage ) super . getOut ( lazyCreate ) ; } @ Override public JmsMessage getFault ( ) { return ( JmsMessage ) super . getFault ( ) ; } public JmsBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new JmsExchange ( getContext ( ) , getPattern ( ) , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getJmsMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } @ Override protected JmsMessage createInMessage ( ) { return new JmsMessage ( ) ; } @ Override protected JmsMessage createOutMessage ( ) { return new JmsMessage ( ) ; } @ Override protected org . apache . camel . Message createFaultMessage ( ) { return new JmsMessage ( ) ; } } 	0	['20', '2', '0', '11', '25', '184', '6', '7', '15', '0.842105263', '114', '1', '1', '0.666666667', '0.241666667', '1', '3', '4.65', '1', '0.9', '0']
package org . apache . camel . language ; import org . apache . camel . component . bean . DefaultAnnotationExpressionFactory ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . ANNOTATION_TYPE } ) public @ interface LanguageAnnotation { public abstract String language ( ) ; public abstract Class < ? > factory ( ) default DefaultAnnotationExpressionFactory . class ; } 	1	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . spi ; public interface Provider < T > { T get ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; import java . util . Collections ; import java . util . List ; @ XmlRootElement ( name = "proceed" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ProceedType extends ProcessorType { public List < ProcessorType > getOutputs ( ) { return Collections . EMPTY_LIST ; } public List < InterceptorType > getInterceptors ( ) { return Collections . EMPTY_LIST ; } public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProceedProcessor ( ) ; } } 	1	['4', '2', '0', '3', '6', '6', '1', '3', '4', '2', '14', '0', '0', '0.96875', '0.625', '1', '4', '2.5', '1', '0.75', '4']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; @ XmlRootElement ( name = "intHeader" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class IntegerHeader extends HeaderType { @ XmlAttribute ( name = "value" ) private Integer number ; public IntegerHeader ( ) { } public IntegerHeader ( String name , Integer number ) { super ( name ) ; this . number = number ; } public Integer getNumber ( ) { return number ; } public void setNumber ( Integer number ) { this . number = number ; } public Object getValue ( ) { return getNumber ( ) ; } public void setValue ( Object value ) { if ( value instanceof Number ) { Number n = ( Number ) value ; setNumber ( n . intValue ( ) ) ; } else { throw new IllegalArgumentException ( "Value must be an Integer" ) ; } } } 	0	['6', '2', '0', '2', '11', '9', '1', '1', '6', '0.2', '45', '1', '0', '0.5', '0.416666667', '0', '0', '6.333333333', '2', '0.8333', '0']
package org . apache . camel ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; import org . apache . camel . model . RouteType ; public interface CamelContext extends Service { String getName ( ) ; void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < RouteType > getRouteDefinitions ( ) ; List < Route > getRoutes ( ) ; void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( RouteBuilder builder ) throws Exception ; void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Registry getRegistry ( ) ; Injector getInjector ( ) ; LifecycleStrategy getLifecycleStrategy ( ) ; Language resolveLanguage ( String language ) ; } 	1	['23', '1', '0', '111', '23', '253', '105', '10', '23', '2', '23', '0', '0', '0', '0.202898551', '0', '0', '0', '1', '1', '1']
package org . apache . camel ; public interface PollingConsumer < E extends Exchange > extends Consumer < E > { E receive ( ) ; E receiveNoWait ( ) ; E receive ( long timeout ) ; } 	0	['3', '1', '0', '12', '3', '3', '10', '2', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public class UseLatestAggregationStrategy implements AggregationStrategy { public Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) { return newExchange ; } } 	1	['2', '1', '0', '3', '3', '1', '1', '2', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '1']
package org . apache . camel . component . file . remote ; import java . util . concurrent . ScheduledExecutorService ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; public abstract class RemoteFileConsumer < T extends RemoteFileExchange > extends ScheduledPollConsumer < T > { RemoteFileEndpoint < T > endpoint ; public RemoteFileConsumer ( RemoteFileEndpoint < T > endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } public RemoteFileConsumer ( RemoteFileEndpoint < T > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; } } 	0	['2', '4', '2', '7', '4', '1', '2', '5', '2', '1', '17', '0', '1', '1', '0.875', '0', '0', '7', '0', '0', '0']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . Map ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPathVariableResolver ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . builder . xml . Namespaces . ENVIRONMENT_VARIABLES ; import static org . apache . camel . builder . xml . Namespaces . EXCHANGE_PROPERTY ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . SYSTEM_PROPERTIES_NAMESPACE ; public class MessageVariableResolver implements XPathVariableResolver { private static final transient Log LOG = LogFactory . getLog ( MessageVariableResolver . class ) ; private Exchange exchange ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public Object resolveVariable ( QName name ) { String uri = name . getNamespaceURI ( ) ; String localPart = name . getLocalPart ( ) ; Object answer = null ; Message in = exchange . getIn ( ) ; if ( uri == null || uri . length ( ) == 0 ) { answer = variables . get ( localPart ) ; if ( answer == null ) { Message message = in ; if ( message != null ) { answer = message . getHeader ( localPart ) ; } if ( answer == null ) { answer = exchange . getProperty ( localPart ) ; } } } else if ( uri . equals ( SYSTEM_PROPERTIES_NAMESPACE ) ) { try { answer = System . getProperty ( localPart ) ; } catch ( Exception e ) { LOG . debug ( "Security exception evaluating system property: " + localPart + ". Reason: " + e , e ) ; } } else if ( uri . equals ( ENVIRONMENT_VARIABLES ) ) { answer = System . getenv ( ) . get ( localPart ) ; } else if ( uri . equals ( EXCHANGE_PROPERTY ) ) { answer = exchange . getProperty ( localPart ) ; } else if ( uri . equals ( IN_NAMESPACE ) ) { answer = in . getHeader ( localPart ) ; if ( answer == null && localPart . equals ( "body" ) ) { answer = in . getBody ( ) ; } } else if ( uri . equals ( OUT_NAMESPACE ) ) { Message out = exchange . getOut ( ) ; answer = out . getHeader ( localPart ) ; if ( answer == null && localPart . equals ( "body" ) ) { answer = out . getBody ( ) ; } } return answer ; } public void addVariable ( String localPart , Object value ) { variables . put ( localPart , value ) ; } } 	1	['6', '1', '0', '5', '27', '1', '1', '4', '5', '0.666666667', '160', '1', '2', '0', '0.36', '0', '0', '25.16666667', '14', '2.8333', '2']
package org . apache . camel ; public interface Processor { void process ( Exchange exchange ) throws Exception ; } 	0	['1', '1', '0', '188', '1', '0', '187', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Delayer ; @ XmlRootElement ( name = "delayer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DelayerType extends ExpressionNode { private Long delay = 0L ; public DelayerType ( ) { } public DelayerType ( Expression processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( ExpressionType processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( Expression processAtExpression , long delay ) { super ( processAtExpression ) ; this . delay = delay ; } @ Override public String toString ( ) { return "Delayer[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } public Long getDelay ( ) { return delay ; } public void setDelay ( Long delay ) { this . delay = delay ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; Expression processAtExpression = getExpression ( ) . createExpression ( routeContext ) ; return new Delayer ( childProcessor , processAtExpression , delay ) ; } } 	1	['8', '3', '0', '7', '22', '0', '1', '7', '8', '0.142857143', '86', '1', '0', '0.962264151', '0.291666667', '1', '2', '9.625', '1', '0.5', '3']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Header { String name ( ) ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; public class ProcessorBuilder { private ProcessorBuilder ( ) { } public static Processor setBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setBody(" + expression + ")" ; } } ; } public static Processor setOutBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setOutBody(" + expression + ")" ; } } ; } public static Processor setFaultBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setFaultBody(" + expression + ")" ; } } ; } public static Processor setHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setOutHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setOutHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setFaultHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setFaultHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setProperty ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . setProperty ( name , value ) ; } @ Override public String toString ( ) { return "setProperty(" + name + ", " + expression + ")" ; } } ; } public static Processor removeHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getIn ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeHeader(" + name + ")" ; } } ; } public static Processor removeOutHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getOut ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeOutHeader(" + name + ")" ; } } ; } public static Processor removeFaultHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getFault ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeFaultHeader(" + name + ")" ; } } ; } public static Processor removeProperty ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . removeProperty ( name ) ; } @ Override public String toString ( ) { return "removeProperty(" + name + ")" ; } } ; } } 	1	['12', '1', '0', '14', '24', '66', '1', '13', '11', '2', '74', '0', '0', '0', '0.444444444', '0', '0', '5.166666667', '1', '0.9167', '1']
package org . apache . camel . component . bean ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; public class CamelInvocationHandler implements InvocationHandler { private final Endpoint endpoint ; private final Producer producer ; public CamelInvocationHandler ( Endpoint endpoint , Producer producer ) { this . endpoint = endpoint ; this . producer = producer ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { BeanInvocation invocation = new BeanInvocation ( proxy , method , args ) ; BeanExchange exchange = new BeanExchange ( endpoint . getContext ( ) , ExchangePattern . InOut ) ; exchange . setInvocation ( invocation ) ; producer . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( ) . getBody ( ) ; } } 	0	['2', '1', '0', '10', '12', '0', '2', '8', '2', '0', '49', '1', '2', '0', '0.583333333', '0', '0', '22.5', '1', '0.5', '0']
package org . apache . camel . model ; import org . apache . camel . * ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . bind . annotation . * ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; @ XmlRootElement ( name = "route" ) @ XmlType ( propOrder = { "interceptors" , "inputs" , "outputs" } ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RouteType extends ProcessorType implements CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( RouteType . class ) ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < FromType > inputs = new ArrayList < FromType > ( ) ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; @ XmlAttribute private String group ; @ XmlTransient private CamelContext camelContext ; public RouteType ( ) { } public RouteType ( String uri ) { from ( uri ) ; } public RouteType ( Endpoint endpoint ) { from ( endpoint ) ; } @ Override public String toString ( ) { return "Route[ " + inputs + " -> " + outputs + "]" ; } public void addRoutes ( CamelContext context ) throws Exception { Collection < Route > routes = new ArrayList < Route > ( ) ; addRoutes ( context , routes ) ; context . addRoutes ( routes ) ; } public void addRoutes ( CamelContext context , Collection < Route > routes ) throws Exception { setCamelContext ( context ) ; for ( FromType fromType : inputs ) { addRoutes ( routes , fromType ) ; } } public Endpoint resolveEndpoint ( String uri ) throws NoSuchEndpointException { CamelContext context = getCamelContext ( ) ; if ( context == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } return CamelContextHelper . getMandatoryEndpoint ( context , uri ) ; } public RouteType from ( String uri ) { getInputs ( ) . add ( new FromType ( uri ) ) ; return this ; } public RouteType from ( Endpoint endpoint ) { getInputs ( ) . add ( new FromType ( endpoint ) ) ; return this ; } public RouteType group ( String name ) { setGroup ( name ) ; return this ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < FromType > getInputs ( ) { return inputs ; } public void setInputs ( List < FromType > inputs ) { this . inputs = inputs ; } public List < ProcessorType > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } protected void addRoutes ( Collection < Route > routes , FromType fromType ) throws Exception { RouteContext routeContext = new RouteContext ( this , fromType , routes ) ; Endpoint endpoint = routeContext . getEndpoint ( ) ; for ( ProcessorType output : outputs ) { output . addRoutes ( routeContext , routes ) ; } routeContext . commit ( ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } List < InterceptorType > list = output . getInterceptors ( ) ; if ( list == null ) { LOG . warn ( "No interceptor collection: " + output ) ; } else { list . addAll ( getInterceptors ( ) ) ; } } } 	1	['23', '2', '0', '23', '50', '161', '14', '11', '20', '0.787878788', '295', '1', '2', '0.830357143', '0.221590909', '1', '6', '11.56521739', '3', '1', '4']
package org . apache . camel . component . file . remote ; import java . net . URI ; import org . apache . camel . RuntimeCamelException ; public class RemoteFileConfiguration implements Cloneable { private String protocol ; private String username ; private String host ; private int port ; private String password ; private String file ; private boolean binary ; private boolean directory = true ; public RemoteFileConfiguration ( ) { } public RemoteFileConfiguration ( URI uri ) { configure ( uri ) ; } public RemoteFileConfiguration copy ( ) { try { return ( RemoteFileConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public String toString ( ) { return protocol + ":\\" + username + "@" + host + ":" + port + "/" + directory ; } public void configure ( URI uri ) { setProtocol ( uri . getScheme ( ) ) ; setDefaultPort ( ) ; setUsername ( uri . getUserInfo ( ) ) ; setHost ( uri . getHost ( ) ) ; setPort ( uri . getPort ( ) ) ; setFile ( uri . getPath ( ) ) ; } protected void setDefaultPort ( ) { if ( "ftp" . equalsIgnoreCase ( protocol ) ) { setPort ( 21 ) ; } else if ( "sftp" . equalsIgnoreCase ( protocol ) ) { setPort ( 22 ) ; } } public String getFile ( ) { return file ; } public void setFile ( String file ) { this . file = file ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { if ( port != - 1 ) { this . port = port ; } } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public boolean isBinary ( ) { return binary ; } public void setBinary ( boolean binary ) { this . binary = binary ; } public boolean isDirectory ( ) { return directory ; } public void setDirectory ( boolean directory ) { this . directory = directory ; } public String dump ( ) { return "RemoteFileConfiguration{" + "protocol='" + protocol + '\'' + ", username='" + username + '\'' + ", host='" + host + '\'' + ", port=" + port + ", password='" + password + '\'' + ", file='" + file + '\'' + ", binary=" + binary + ", directory=" + directory + '}' ; } } 	0	['23', '1', '0', '11', '38', '157', '10', '1', '22', '0.829545455', '241', '1', '0', '0', '0.286956522', '0', '0', '9.130434783', '3', '1.0435', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Logger implements Processor { private Log log ; private LoggingLevel level ; public Logger ( ) { this ( LogFactory . getLog ( Logger . class ) ) ; } public Logger ( Log log ) { this ( log , LoggingLevel . INFO ) ; } public Logger ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public Logger ( String logName ) { this ( LogFactory . getLog ( logName ) ) ; } public Logger ( String logName , LoggingLevel level ) { this ( LogFactory . getLog ( logName ) , level ) ; } @ Override public String toString ( ) { return "Logger[" + log + "]" ; } public void process ( Exchange exchange ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange ) ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange ) ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange ) ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ( exchange ) ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange ) ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange ) ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange ) ) ; } } public void log ( String message ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message ) ; } } public void log ( String message , Throwable exception ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message , exception ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message , exception ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message , exception ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message , exception ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message , exception ) ; } } protected Object logMessage ( Exchange exchange ) { return exchange ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } } 	1	['14', '1', '0', '11', '39', '31', '5', '6', '13', '0.346153846', '326', '1', '2', '0', '0.321428571', '0', '0', '22.14285714', '8', '2.1429', '1']
package org . apache . camel . component . mail ; import javax . mail . Flags ; import javax . mail . Folder ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . event . MessageCountEvent ; import javax . mail . event . MessageCountListener ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MailConsumer extends ScheduledPollConsumer < MailExchange > implements MessageCountListener { private static final transient Log LOG = LogFactory . getLog ( MailConsumer . class ) ; private final MailEndpoint endpoint ; private final Folder folder ; public MailConsumer ( MailEndpoint endpoint , Processor processor , Folder folder ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . folder = folder ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; ensureFolderIsOpen ( ) ; folder . addMessageCountListener ( this ) ; } @ Override protected void doStop ( ) throws Exception { folder . removeMessageCountListener ( this ) ; folder . close ( true ) ; super . doStop ( ) ; } public void messagesAdded ( MessageCountEvent event ) { Message [ ] messages = event . getMessages ( ) ; for ( Message message : messages ) { try { if ( ! message . getFlags ( ) . contains ( Flags . Flag . DELETED ) ) { processMessage ( message ) ; flagMessageDeleted ( message ) ; } } catch ( MessagingException e ) { handleException ( e ) ; } } } public void messagesRemoved ( MessageCountEvent event ) { Message [ ] messages = event . getMessages ( ) ; for ( Message message : messages ) { if ( LOG . isDebugEnabled ( ) ) { try { LOG . debug ( "Removing message: " + message . getSubject ( ) ) ; } catch ( MessagingException e ) { LOG . debug ( "Ignored: " + e ) ; } } } } protected void poll ( ) throws Exception { ensureFolderIsOpen ( ) ; int count = folder . getMessageCount ( ) ; if ( count > 0 ) { Message [ ] messages = folder . getMessages ( ) ; MessageCountEvent event = new MessageCountEvent ( folder , MessageCountEvent . ADDED , true , messages ) ; messagesAdded ( event ) ; } else if ( count == - 1 ) { throw new MessagingException ( "Folder: " + folder . getFullName ( ) + " is closed" ) ; } folder . close ( true ) ; } protected void processMessage ( Message message ) { try { MailExchange exchange = endpoint . createExchange ( message ) ; getProcessor ( ) . process ( exchange ) ; } catch ( Throwable e ) { handleException ( e ) ; } } protected void ensureFolderIsOpen ( ) throws MessagingException { if ( ! folder . isOpen ( ) ) { folder . open ( Folder . READ_WRITE ) ; } } protected void flagMessageDeleted ( Message message ) throws MessagingException { if ( endpoint . getConfiguration ( ) . isDeleteProcessedMessages ( ) ) { message . setFlag ( Flags . Flag . DELETED , true ) ; } else { message . setFlag ( Flags . Flag . SEEN , true ) ; } } } 	0	['10', '4', '0', '9', '41', '17', '1', '9', '3', '0.666666667', '218', '1', '2', '0.80952381', '0.296296296', '2', '4', '20.5', '3', '1.1', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlElementRef ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . SendProcessor ; @ XmlRootElement ( name = "to" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ToType extends ProcessorType { @ XmlAttribute private String uri ; @ XmlAttribute private String ref ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlTransient private Endpoint endpoint ; public ToType ( ) { } public ToType ( String uri ) { setUri ( uri ) ; } public ToType ( Endpoint endpoint ) { setEndpoint ( endpoint ) ; } @ Override public String toString ( ) { return "To[" + getLabel ( ) + "]" ; } @ Override public String getLabel ( ) { return FromType . description ( getUri ( ) , getRef ( ) , getEndpoint ( ) ) ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Endpoint endpoint = resolveEndpoint ( routeContext ) ; return new SendProcessor ( endpoint ) ; } public Endpoint resolveEndpoint ( RouteContext context ) { if ( endpoint == null ) { endpoint = context . resolveEndpoint ( getUri ( ) , getRef ( ) ) ; } return endpoint ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public List < ProcessorType > getOutputs ( ) { return Collections . EMPTY_LIST ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public Object getUriOrRef ( ) { if ( ObjectHelper . isNullOrBlank ( uri ) ) { return uri ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } return ref ; } } 	1	['17', '2', '0', '9', '27', '92', '3', '7', '17', '0.703125', '141', '1', '1', '0.869158879', '0.294117647', '1', '4', '7.058823529', '3', '1', '2']
package org . apache . camel . builder . script ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "groovy" ) public @ interface Groovy { public abstract String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . file . strategy . FileProcessStrategy ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileConsumer . class ) ; private final FileEndpoint endpoint ; private boolean recursive = true ; private String regexPattern = "" ; private long lastPollTime ; boolean generateEmptyExchangeWhenIdle ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected void poll ( ) throws Exception { int rc = pollFileOrDirectory ( endpoint . getFile ( ) , isRecursive ( ) ) ; if ( rc == 0 && generateEmptyExchangeWhenIdle ) { final FileExchange exchange = endpoint . createExchange ( ( File ) null ) ; getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } lastPollTime = System . currentTimeMillis ( ) ; } protected int pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { return pollFile ( fileOrDirectory ) ; } else if ( processDir ) { int rc = 0 ; if ( isValidFile ( fileOrDirectory ) ) { LOG . debug ( "Polling directory " + fileOrDirectory ) ; File [ ] files = fileOrDirectory . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { rc += pollFileOrDirectory ( files [ i ] , isRecursive ( ) ) ; } } return rc ; } else { LOG . debug ( "Skipping directory " + fileOrDirectory ) ; return 0 ; } } ConcurrentHashMap < File , File > filesBeingProcessed = new ConcurrentHashMap < File , File > ( ) ; protected int pollFile ( final File file ) { if ( ! file . exists ( ) ) { return 0 ; } if ( ! isValidFile ( file ) ) { return 0 ; } if ( endpoint . isNoop ( ) ) { long fileModified = file . lastModified ( ) ; if ( fileModified <= lastPollTime ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring file: " + file + " as modified time: " + fileModified + " less than last poll time: " + lastPollTime ) ; } return 0 ; } } else { if ( filesBeingProcessed . contains ( file ) ) { return 1 ; } filesBeingProcessed . put ( file , file ) ; } final FileProcessStrategy processStrategy = endpoint . getFileStrategy ( ) ; final FileExchange exchange = endpoint . createExchange ( file ) ; endpoint . configureMessage ( file , exchange . getIn ( ) ) ; try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to process file:  " + file + " using exchange: " + exchange ) ; } if ( processStrategy . begin ( endpoint , exchange , file ) ) { getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( exchange . getException ( ) == null ) { try { processStrategy . commit ( endpoint , ( FileExchange ) exchange , file ) ; } catch ( Exception e ) { handleException ( e ) ; } } else { handleException ( exchange . getException ( ) ) ; } filesBeingProcessed . remove ( file ) ; } } ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " cannot process file: " + file ) ; } } } catch ( Throwable e ) { handleException ( e ) ; } return 1 ; } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) ) { result = true ; } } return result ; } protected boolean isMatched ( File file ) { String name = file . getName ( ) ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { if ( ! name . matches ( getRegexPattern ( ) ) ) { return false ; } } String [ ] prefixes = endpoint . getExcludedNamePrefixes ( ) ; if ( prefixes != null ) { for ( String prefix : prefixes ) { if ( name . startsWith ( prefix ) ) { return false ; } } } String [ ] postfixes = endpoint . getExcludedNamePostfixes ( ) ; if ( postfixes != null ) { for ( String postfix : postfixes ) { if ( name . endsWith ( postfix ) ) { return false ; } } } return true ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } public boolean isGenerateEmptyExchangeWhenIdle ( ) { return generateEmptyExchangeWhenIdle ; } public void setGenerateEmptyExchangeWhenIdle ( boolean generateEmptyExchangeWhenIdle ) { this . generateEmptyExchangeWhenIdle = generateEmptyExchangeWhenIdle ; } } 	1	['16', '4', '0', '14', '52', '72', '3', '14', '7', '0.780952381', '396', '0.714285714', '2', '0.708333333', '0.225', '1', '1', '23.3125', '10', '2.3125', '6']
package org . apache . camel . util ; import java . util . Date ; import java . util . concurrent . TimeUnit ; public class Time { private long number ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; public Time ( long number , TimeUnit timeUnit ) { this . number = number ; this . timeUnit = timeUnit ; } public static Time millis ( long value ) { return new Time ( value , TimeUnit . MILLISECONDS ) ; } public static Time micros ( long value ) { return new Time ( value , TimeUnit . MICROSECONDS ) ; } public static Time nanos ( long value ) { return new Time ( value , TimeUnit . NANOSECONDS ) ; } public static Time seconds ( long value ) { return new Time ( value , TimeUnit . SECONDS ) ; } public static Time minutes ( long value ) { return new Time ( minutesAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time hours ( long value ) { return new Time ( hoursAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time days ( long value ) { return new Time ( daysAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public long toMillis ( ) { return timeUnit . toMillis ( number ) ; } public Date toDate ( ) { return new Date ( toMillis ( ) ) ; } public long getNumber ( ) { return number ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } protected static long minutesAsSeconds ( long value ) { return value * 60 ; } protected static long hoursAsSeconds ( long value ) { return minutesAsSeconds ( value ) * 60 ; } protected static long daysAsSeconds ( long value ) { return hoursAsSeconds ( value ) * 24 ; } } 	0	['15', '1', '0', '1', '18', '95', '1', '0', '12', '0.285714286', '106', '1', '0', '0', '0.377777778', '0', '0', '5.933333333', '1', '0.9333', '0']
package org . apache . camel . component . jmx ; import javax . management . MBeanServer ; import javax . management . Notification ; import javax . management . ObjectName ; import javax . management . monitor . CounterMonitor ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JMXEndpoint extends DefaultEndpoint < JMXExchange > { private static final Log LOG = LogFactory . getLog ( JMXEndpoint . class ) ; private String name ; private ObjectName ourName ; private String observedObjectName ; private String attributeName ; private long granularityPeriod = 5000 ; private Number threshold ; private Number offset ; private MBeanServer mbeanServer ; private CounterMonitor counterMonitor = new CounterMonitor ( ) ; protected JMXEndpoint ( String endpointUri , JMXComponent component ) { super ( endpointUri , component ) ; observedObjectName = endpointUri ; } public Producer < JMXExchange > createProducer ( ) throws Exception { throw new RuntimeException ( "Not supported" ) ; } public Consumer < JMXExchange > createConsumer ( Processor proc ) throws Exception { ObjectName observedName = new ObjectName ( observedObjectName ) ; if ( name == null ) { String type = observedName . getKeyProperty ( "type" ) ; type = type != null ? type : "UNKNOWN" ; name = mbeanServer . getDefaultDomain ( ) + ":type=CounterMonitor_" + type ; } JMXConsumer result = new JMXConsumer ( this , proc ) ; ourName = new ObjectName ( name ) ; counterMonitor . setNotify ( true ) ; counterMonitor . addObservedObject ( observedName ) ; counterMonitor . setObservedAttribute ( attributeName ) ; counterMonitor . setGranularityPeriod ( granularityPeriod ) ; counterMonitor . setDifferenceMode ( false ) ; counterMonitor . setInitThreshold ( threshold ) ; counterMonitor . setOffset ( offset ) ; mbeanServer . registerMBean ( counterMonitor , ourName ) ; mbeanServer . addNotificationListener ( ourName , result , null , new Object ( ) ) ; return result ; } public boolean isSingleton ( ) { return true ; } public JMXExchange createExchange ( Notification notification ) { return new JMXExchange ( getContext ( ) , getExchangePattern ( ) , notification ) ; } public JMXExchange createExchange ( ) { return new JMXExchange ( getContext ( ) , getExchangePattern ( ) , null ) ; } public JMXExchange createExchange ( ExchangePattern pattern ) { return new JMXExchange ( getContext ( ) , pattern , null ) ; } public String getAttributeName ( ) { return attributeName ; } public void setAttributeName ( String attributeName ) { this . attributeName = attributeName ; } public long getGranularityPeriod ( ) { return granularityPeriod ; } public void setGranularityPeriod ( long granularityPeriod ) { this . granularityPeriod = granularityPeriod ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Number getOffset ( ) { return offset ; } public void setOffset ( Number offset ) { this . offset = offset ; } public Number getThreshold ( ) { return threshold ; } public void setThreshold ( Number threshold ) { this . threshold = threshold ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	1	['22', '2', '0', '13', '44', '189', '2', '13', '20', '0.928571429', '232', '1', '1', '0.459459459', '0.174603175', '1', '1', '9.090909091', '1', '0.9091', '2']
package org . apache . camel . spring . spi ; import org . apache . camel . spi . Injector ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . config . AutowireCapableBeanFactory ; import org . springframework . context . support . AbstractRefreshableApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; public class SpringInjector implements Injector { private final ConfigurableApplicationContext applicationContext ; private int autowireMode = AutowireCapableBeanFactory . AUTOWIRE_CONSTRUCTOR ; private boolean dependencyCheck ; public SpringInjector ( ConfigurableApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public < T > T newInstance ( Class < T > type ) { Object value = applicationContext . getBeanFactory ( ) . createBean ( type , autowireMode , dependencyCheck ) ; return type . cast ( value ) ; } public int getAutowireMode ( ) { return autowireMode ; } public void setAutowireMode ( int autowireMode ) { this . autowireMode = autowireMode ; } public boolean isDependencyCheck ( ) { return dependencyCheck ; } public void setDependencyCheck ( boolean dependencyCheck ) { this . dependencyCheck = dependencyCheck ; } } 	0	['6', '1', '0', '4', '10', '0', '1', '3', '6', '0.6', '46', '1', '0', '0', '0.333333333', '0', '0', '6.166666667', '1', '0.8333', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; public class DefaultAnnotationExpressionFactory implements AnnotationExpressionFactory { public Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) { String languageName = languageAnnotation . language ( ) ; if ( languageName == null ) { throw new IllegalArgumentException ( "Cannot determine the language from the annotation: " + annotation ) ; } Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Cannot find the language: " + languageName + " on the classpath" ) ; } String expression = getExpressionFromAnnotation ( annotation ) ; return language . createExpression ( expression ) ; } protected String getExpressionFromAnnotation ( Annotation annotation ) { try { Method method = annotation . getClass ( ) . getMethod ( "value" ) ; Object value = ObjectHelper . invokeMethod ( method , annotation ) ; if ( value == null ) { throw new IllegalArgumentException ( "Cannot determine the expression from the annotation: " + annotation ) ; } return value . toString ( ) ; } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( "Cannot determine the expression of the annotation: " + annotation + " as it does not have an value() method" ) ; } } } 	1	['3', '1', '1', '7', '16', '3', '1', '6', '2', '2', '96', '0', '0', '0', '0.533333333', '0', '0', '31', '3', '1.6667', '2']
package org . apache . camel . component . bean ; import org . apache . camel . Expression ; import org . apache . camel . CamelContext ; import org . apache . camel . language . LanguageAnnotation ; import java . lang . annotation . Annotation ; public interface AnnotationExpressionFactory { Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) ; } 	0	['1', '1', '0', '5', '1', '0', '2', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; public class StickyLoadBalancer extends QueueLoadBalancer { private Expression < Exchange > correlationExpression ; private QueueLoadBalancer loadBalancer ; private int numberOfHashGroups = 64 * 1024 ; private Map < Object , Processor > stickyMap = new HashMap < Object , Processor > ( ) ; public StickyLoadBalancer ( Expression < Exchange > correlationExpression ) { this ( correlationExpression , new RoundRobinLoadBalancer ( ) ) ; } public StickyLoadBalancer ( Expression < Exchange > correlationExpression , QueueLoadBalancer loadBalancer ) { this . correlationExpression = correlationExpression ; this . loadBalancer = loadBalancer ; } protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { Object value = correlationExpression . evaluate ( exchange ) ; Object key = getStickyKey ( value ) ; Processor processor ; synchronized ( stickyMap ) { processor = stickyMap . get ( key ) ; if ( processor == null ) { processor = loadBalancer . chooseProcessor ( processors , exchange ) ; stickyMap . put ( key , processor ) ; } } return processor ; } @ Override public void removeProcessor ( Processor processor ) { synchronized ( stickyMap ) { Iterator < Map . Entry < Object , Processor > > iter = stickyMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Object , Processor > entry = iter . next ( ) ; if ( processor . equals ( entry . getValue ( ) ) ) { iter . remove ( ) ; } } } super . removeProcessor ( processor ) ; } public int getNumberOfHashGroups ( ) { return numberOfHashGroups ; } public void setNumberOfHashGroups ( int numberOfHashGroups ) { this . numberOfHashGroups = numberOfHashGroups ; } protected Object getStickyKey ( Object value ) { int hashCode = 37 ; if ( value != null ) { hashCode = value . hashCode ( ) ; } if ( numberOfHashGroups > 0 ) { hashCode = hashCode % numberOfHashGroups ; } return hashCode ; } } 	1	['7', '3', '0', '5', '24', '3', '0', '5', '5', '0.5', '141', '1', '2', '0.5', '0.267857143', '2', '2', '18.57142857', '3', '1.2857', '2']
package org . apache . camel . spi ; import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import org . apache . camel . Exchange ; public interface DataFormat { void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws Exception ; Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception ; } 	0	['2', '1', '0', '12', '2', '1', '11', '1', '2', '2', '2', '0', '0', '0', '0.7', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . processor . DelegateProcessor ; public class AsyncProcessorTypeConverter implements TypeConverter { public static final class ProcessorToAsynProcessorBridge extends DelegateProcessor implements AsyncProcessor { private ProcessorToAsynProcessorBridge ( Processor processor ) { super ( processor ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { try { processor . process ( exchange ) ; } catch ( Throwable e ) { exchange . setException ( e ) ; } callback . done ( true ) ; return true ; } } public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( AsyncProcessor . class ) ) { if ( value instanceof AsyncProcessor ) { return toType . cast ( value ) ; } else if ( value instanceof Processor ) { final Processor processor = ( Processor ) value ; return toType . cast ( new ProcessorToAsynProcessorBridge ( processor ) ) ; } } } return null ; } public static AsyncProcessor convert ( Processor value ) { if ( value instanceof AsyncProcessor ) { return ( AsyncProcessor ) value ; } return new ProcessorToAsynProcessorBridge ( value ) ; } } 	1	['3', '1', '0', '16', '7', '3', '11', '5', '3', '2', '47', '0', '0', '0', '0.416666667', '0', '0', '14.66666667', '5', '2.3333', '2']
package org . apache . camel . converter . jaxb ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . TypeConverterAware ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . Unmarshaller ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . util . JAXBSource ; import javax . xml . transform . Source ; import java . io . InputStream ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; public class FallbackTypeConverter implements TypeConverter , TypeConverterAware { private static final transient Log LOG = LogFactory . getLog ( FallbackTypeConverter . class ) ; private TypeConverter parentTypeConverter ; private boolean prettyPrint = true ; public boolean isPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } public void setTypeConverter ( TypeConverter parentTypeConverter ) { this . parentTypeConverter = parentTypeConverter ; } public < T > T convertTo ( Class < T > type , Object value ) { try { if ( isJaxbType ( type ) ) { return unmarshall ( type , value ) ; } if ( value != null ) { if ( isJaxbType ( value . getClass ( ) ) ) { return marshall ( type , value ) ; } } return null ; } catch ( JAXBException e ) { throw new RuntimeCamelException ( e ) ; } } protected < T > boolean isJaxbType ( Class < T > type ) { XmlRootElement element = type . getAnnotation ( XmlRootElement . class ) ; boolean jaxbType = element != null ; return jaxbType ; } protected < T > T unmarshall ( Class < T > type , Object value ) throws JAXBException { JAXBContext context = createContext ( type ) ; Unmarshaller unmarshaller = context . createUnmarshaller ( ) ; if ( parentTypeConverter != null ) { InputStream inputStream = parentTypeConverter . convertTo ( InputStream . class , value ) ; if ( inputStream != null ) { Object unmarshalled = unmarshaller . unmarshal ( inputStream ) ; return type . cast ( unmarshalled ) ; } Reader reader = parentTypeConverter . convertTo ( Reader . class , value ) ; if ( reader != null ) { Object unmarshalled = unmarshaller . unmarshal ( reader ) ; return type . cast ( unmarshalled ) ; } Source source = parentTypeConverter . convertTo ( Source . class , value ) ; if ( source != null ) { Object unmarshalled = unmarshaller . unmarshal ( source ) ; return type . cast ( unmarshalled ) ; } } if ( value instanceof String ) { value = new StringReader ( ( String ) value ) ; } if ( value instanceof InputStream ) { Object unmarshalled = unmarshaller . unmarshal ( ( InputStream ) value ) ; return type . cast ( unmarshalled ) ; } if ( value instanceof Reader ) { Object unmarshalled = unmarshaller . unmarshal ( ( Reader ) value ) ; return type . cast ( unmarshalled ) ; } return null ; } protected < T > T marshall ( Class < T > type , Object value ) throws JAXBException { if ( parentTypeConverter != null ) { JAXBContext context = createContext ( value . getClass ( ) ) ; JAXBSource source = new JAXBSource ( context , value ) ; T answer = parentTypeConverter . convertTo ( type , source ) ; if ( answer == null ) { StringWriter buffer = new StringWriter ( ) ; Marshaller marshaller = context . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , isPrettyPrint ( ) ? Boolean . TRUE : Boolean . FALSE ) ; marshaller . marshal ( value , buffer ) ; return parentTypeConverter . convertTo ( type , buffer . toString ( ) ) ; } return answer ; } return null ; } protected < T > JAXBContext createContext ( Class < T > type ) throws JAXBException { JAXBContext context = JAXBContext . newInstance ( type ) ; return context ; } } 	0	['10', '1', '0', '5', '29', '33', '0', '5', '5', '0.777777778', '235', '1', '2', '0', '0.422222222', '0', '0', '22.2', '4', '1.2', '0']
package org . apache . camel . management ; import java . io . IOException ; import org . apache . camel . Endpoint ; import org . apache . camel . Route ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Route" , currencyTimeLimit = 15 ) public class ManagedRoute { public static final String VALUE_UNKNOWN = "Unknown" ; private Route route ; private String description ; ManagedRoute ( Route route ) { this . route = route ; this . description = route . toString ( ) ; } public Route getRoute ( ) { return route ; } @ ManagedAttribute ( description = "Route Endpoint Uri" ) public String getEndpointUri ( ) { Endpoint ep = route . getEndpoint ( ) ; return ep != null ? ep . getEndpointUri ( ) : VALUE_UNKNOWN ; } @ ManagedAttribute ( description = "Route description" ) public String getDescription ( ) { return description ; } @ ManagedOperation ( description = "Start Route" ) public void start ( ) throws IOException { throw new IOException ( "Not supported" ) ; } @ ManagedOperation ( description = "Stop Route" ) public void stop ( ) throws IOException { throw new IOException ( "Not supported" ) ; } } 	1	['6', '1', '0', '4', '11', '7', '2', '2', '5', '0.866666667', '46', '0.666666667', '1', '0', '0.583333333', '0', '0', '6.166666667', '2', '1', '1']
package org . apache . camel . component . mina ; import java . net . SocketAddress ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoHandler ; import org . apache . mina . common . IoHandlerAdapter ; import org . apache . mina . common . IoSession ; public class MinaConsumer extends DefaultConsumer < MinaExchange > { private static final transient Log LOG = LogFactory . getLog ( MinaConsumer . class ) ; private final MinaEndpoint endpoint ; private final SocketAddress address ; private final IoAcceptor acceptor ; public MinaConsumer ( final MinaEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; address = endpoint . getAddress ( ) ; acceptor = endpoint . getAcceptor ( ) ; } @ Override protected void doStart ( ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Binding to server address: " + address + " using acceptor: " + acceptor ) ; } IoHandler handler = new IoHandlerAdapter ( ) { @ Override public void messageReceived ( IoSession session , Object object ) throws Exception { getProcessor ( ) . process ( endpoint . createExchange ( session , object ) ) ; } } ; acceptor . bind ( address , handler , endpoint . getConfig ( ) ) ; } @ Override protected void doStop ( ) throws Exception { acceptor . unbind ( address ) ; super . doStop ( ) ; } } 	0	['5', '3', '0', '10', '20', '0', '2', '10', '1', '0.5625', '74', '1', '2', '0.88', '0.375', '1', '1', '13', '1', '0.6', '0']
package org . apache . camel . util ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Body ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . io . OutputStream ; import java . io . Closeable ; import java . io . IOException ; public class ObjectHelper { private static final transient Log LOG = LogFactory . getLog ( ObjectHelper . class ) ; private ObjectHelper ( ) { } public static boolean equals ( Object a , Object b ) { if ( a == b ) { return true ; } return a != null && b != null && a . equals ( b ) ; } public static boolean isEqualToAny ( Object object , Object ... values ) { for ( Object value : values ) { if ( equals ( object , value ) ) { return true ; } } return false ; } public static int compare ( Object a , Object b ) { if ( a == b ) { return 0 ; } if ( a == null ) { return - 1 ; } if ( b == null ) { return 1 ; } if ( a instanceof Comparable ) { Comparable comparable = ( Comparable ) a ; return comparable . compareTo ( b ) ; } else { int answer = a . getClass ( ) . getName ( ) . compareTo ( b . getClass ( ) . getName ( ) ) ; if ( answer == 0 ) { answer = a . hashCode ( ) - b . hashCode ( ) ; } return answer ; } } public static void notNull ( Object value , String name ) { if ( value == null ) { throw new IllegalArgumentException ( name + " must be specified" ) ; } } public static String [ ] splitOnCharacter ( String value , String needle , int count ) { String rc [ ] = new String [ count ] ; rc [ 0 ] = value ; for ( int i = 1 ; i < count ; i ++ ) { String v = rc [ i - 1 ] ; int p = v . indexOf ( needle ) ; if ( p < 0 ) { return rc ; } rc [ i - 1 ] = v . substring ( 0 , p ) ; rc [ i ] = v . substring ( p + 1 ) ; } return rc ; } public static String removeStartingCharacters ( String text , char ch ) { int idx = 0 ; while ( text . charAt ( idx ) == ch ) { idx ++ ; } if ( idx > 0 ) { return text . substring ( idx ) ; } return text ; } public static String capitalize ( String text ) { int length = text . length ( ) ; if ( text == null || length == 0 ) { return text ; } String answer = text . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( length > 1 ) { answer += text . substring ( 1 , length ) ; } return answer ; } public static boolean contains ( Object collectionOrArray , Object value ) { if ( collectionOrArray instanceof Collection ) { Collection collection = ( Collection ) collectionOrArray ; return collection . contains ( value ) ; } else { Iterator iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { if ( equals ( value , iter . next ( ) ) ) { return true ; } } return false ; } } public static boolean matches ( List list ) { if ( ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value instanceof Boolean ) { Boolean flag = ( Boolean ) value ; return flag . booleanValue ( ) ; } else { return true ; } } return false ; } public static boolean isNotNullAndNonEmpty ( String text ) { return text != null && text . trim ( ) . length ( ) > 0 ; } public static boolean isNullOrBlank ( String text ) { return text == null || text . trim ( ) . length ( ) <= 0 ; } public static String getSystemProperty ( String name , String defaultValue ) { try { return System . getProperty ( name , defaultValue ) ; } catch ( Exception e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Caught security exception accessing system property: " + name + ". Reason: " + e , e ) ; } return defaultValue ; } } public static String name ( Class type ) { return type != null ? type . getName ( ) : null ; } public static String className ( Object value ) { return name ( value != null ? value . getClass ( ) : null ) ; } public static Class < ? > loadClass ( String name ) { return loadClass ( name , ObjectHelper . class . getClassLoader ( ) ) ; } public static Class < ? > loadClass ( String name , ClassLoader loader ) { ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( contextClassLoader != null ) { try { return contextClassLoader . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { try { return loader . loadClass ( name ) ; } catch ( ClassNotFoundException e1 ) { LOG . debug ( "Could not find class: " + name + ". Reason: " + e ) ; } } } return null ; } public static Object invokeMethod ( Method method , Object instance , Object ... parameters ) { try { return method . invoke ( instance , parameters ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } } public static List < Method > findMethodsWithAnnotation ( Class < ? > type , Class < ? extends Annotation > annotationType ) { List < Method > answer = new ArrayList < Method > ( ) ; do { Method [ ] methods = type . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotationType ) != null ) { answer . add ( method ) ; } } type = type . getSuperclass ( ) ; } while ( type != null ) ; return answer ; } public static String asString ( Object [ ] objects ) { if ( objects == null ) { return "null" ; } else { StringBuffer buffer = new StringBuffer ( "{" ) ; int counter = 0 ; for ( Object object : objects ) { if ( counter ++ > 0 ) { buffer . append ( ", " ) ; } String text = ( object == null ) ? "null" : object . toString ( ) ; buffer . append ( text ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } } public static boolean isAssignableFrom ( Class a , Class b ) { a = convertPrimitiveTypeToWrapperType ( a ) ; b = convertPrimitiveTypeToWrapperType ( b ) ; return a . isAssignableFrom ( b ) ; } public static Class convertPrimitiveTypeToWrapperType ( Class type ) { Class rc = type ; if ( type . isPrimitive ( ) ) { if ( type == int . class ) { rc = Integer . class ; } else if ( type == long . class ) { rc = Long . class ; } else if ( type == double . class ) { rc = Double . class ; } else if ( type == float . class ) { rc = Float . class ; } else if ( type == short . class ) { rc = Short . class ; } else if ( type == byte . class ) { rc = Byte . class ; } } return rc ; } public static String getDefaultCharacterSet ( ) { return Charset . defaultCharset ( ) . name ( ) ; } public static String getPropertyName ( Method method ) { String propertyName = method . getName ( ) ; if ( propertyName . startsWith ( "set" ) && method . getParameterTypes ( ) . length == 1 ) { propertyName = propertyName . substring ( 3 , 4 ) . toLowerCase ( ) + propertyName . substring ( 4 ) ; } return propertyName ; } public static boolean hasAnnotation ( Annotation [ ] annotations , Class < ? > type ) { for ( Annotation annotation : annotations ) { if ( type . isInstance ( annotation ) ) { return true ; } } return false ; } public static void close ( Closeable closeable , String name , Log log ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException e ) { log . warn ( "Could not close " + name + ". Reason: " + e , e ) ; } } } public static < T > T cast ( Class < T > toType , Object value ) { if ( toType == boolean . class ) { return ( T ) cast ( Boolean . class , value ) ; } else if ( toType . isPrimitive ( ) ) { Class newType = convertPrimitiveTypeToWrapperType ( toType ) ; if ( newType != toType ) { return ( T ) cast ( newType , value ) ; } } try { return toType . cast ( value ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( "Failed to convert: " + value + " to type: " + toType . getName ( ) + " due to: " + e , e ) ; } } public static < T > T newInstance ( Class < T > type ) { try { return type . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } public static < T > T newInstance ( Class < ? > actualType , Class < T > expectedType ) { try { Object value = actualType . newInstance ( ) ; return cast ( expectedType , value ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } } 	1	['30', '1', '0', '73', '92', '429', '69', '4', '28', '0.896551724', '693', '1', '1', '0', '0.103448276', '1', '1', '22.06666667', '8', '2.7333', '8']
package org . apache . camel . converter . jaxb ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . converter . HasAnnotation ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . w3c . dom . Document ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . util . JAXBSource ; import javax . xml . parsers . ParserConfigurationException ; public class JaxbConverter { private XmlConverter jaxbConverter ; public XmlConverter getJaxbConverter ( ) { if ( jaxbConverter == null ) { jaxbConverter = new XmlConverter ( ) ; } return jaxbConverter ; } public void setJaxbConverter ( XmlConverter jaxbConverter ) { this . jaxbConverter = jaxbConverter ; } @ Converter public static JAXBSource toSource ( @ HasAnnotation ( XmlRootElement . class ) Object value ) throws JAXBException { JAXBContext context = createJaxbContext ( value ) ; return new JAXBSource ( context , value ) ; } @ Converter public Document toDocument ( @ HasAnnotation ( XmlRootElement . class ) Object value ) throws JAXBException , ParserConfigurationException { JAXBContext context = createJaxbContext ( value ) ; Marshaller marshaller = context . createMarshaller ( ) ; Document doc = getJaxbConverter ( ) . createDocument ( ) ; marshaller . marshal ( value , doc ) ; return doc ; } @ Converter public static MessageType toMessageType ( Exchange exchange ) { return toMessageType ( exchange . getIn ( ) ) ; } @ Converter public static MessageType toMessageType ( Message in ) { MessageType answer = new MessageType ( ) ; answer . copyFrom ( in ) ; return answer ; } protected static JAXBContext createJaxbContext ( Object value ) throws JAXBException { if ( value == null ) { throw new IllegalArgumentException ( "Cannot convert from null value to JAXBSource" ) ; } JAXBContext context = JAXBContext . newInstance ( value . getClass ( ) ) ; return context ; } } 	0	['8', '1', '0', '4', '20', '26', '0', '4', '7', '0.714285714', '83', '1', '1', '0', '0.25', '0', '0', '9.25', '2', '1', '0']
package org . apache . camel . view ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . model . * ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; public class NodeData { public String id ; private final String imagePrefix ; public String image ; public String label ; public String shape ; public String edgeLabel ; public String tooltop ; public String nodeType ; public boolean nodeWritten ; public String url ; public List < ProcessorType > outputs ; public String association = "property" ; public NodeData ( String id , Object node , String imagePrefix ) { this . id = id ; this . imagePrefix = imagePrefix ; if ( node instanceof ProcessorType ) { ProcessorType processorType = ( ProcessorType ) node ; this . edgeLabel = processorType . getLabel ( ) ; } if ( node instanceof FromType ) { FromType fromType = ( FromType ) node ; this . tooltop = fromType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof ToType ) { ToType toType = ( ToType ) node ; this . tooltop = toType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof FilterType ) { this . image = imagePrefix + "MessageFilterIcon.gif" ; this . nodeType = "Message Filter" ; } else if ( node instanceof WhenType ) { this . image = imagePrefix + "MessageFilterIcon.gif" ; this . nodeType = "When Filter" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; } else if ( node instanceof OtherwiseType ) { this . nodeType = "Otherwise" ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; this . tooltop = "Otherwise" ; } else if ( node instanceof ChoiceType ) { this . image = imagePrefix + "ContentBasedRouterIcon.gif" ; this . nodeType = "Content Based Router" ; this . label = "" ; this . edgeLabel = "" ; ChoiceType choice = ( ChoiceType ) node ; List < ProcessorType > outputs = new ArrayList < ProcessorType > ( choice . getWhenClauses ( ) ) ; outputs . add ( choice . getOtherwise ( ) ) ; this . outputs = outputs ; } else if ( node instanceof RecipientListType ) { this . image = imagePrefix + "RecipientListIcon.gif" ; this . nodeType = "Recipient List" ; } else if ( node instanceof SplitterType ) { this . image = imagePrefix + "SplitterIcon.gif" ; this . nodeType = "Splitter" ; } else if ( node instanceof AggregatorType ) { this . image = imagePrefix + "AggregatorIcon.gif" ; this . nodeType = "Aggregator" ; } else if ( node instanceof ResequencerType ) { this . image = imagePrefix + "ResequencerIcon.gif" ; this . nodeType = "Resequencer" ; } if ( isNullOrBlank ( this . nodeType ) ) { String name = node . getClass ( ) . getName ( ) ; int idx = name . lastIndexOf ( '.' ) ; if ( idx > 0 ) { name = name . substring ( idx + 1 ) ; } if ( name . endsWith ( "Type" ) ) { name = name . substring ( 0 , name . length ( ) - 4 ) ; } this . nodeType = insertSpacesBetweenCamelCase ( name ) ; } if ( this . label == null ) { if ( isNullOrBlank ( this . image ) ) { this . label = this . nodeType ; this . shape = "box" ; } else if ( isNotNullAndNonEmpty ( this . edgeLabel ) ) { this . label = "" ; } else { this . label = node . toString ( ) ; } } if ( isNullOrBlank ( this . tooltop ) ) { if ( isNotNullAndNonEmpty ( this . nodeType ) ) { String description = isNotNullAndNonEmpty ( this . edgeLabel ) ? this . edgeLabel : this . label ; this . tooltop = this . nodeType + ": " + description ; } else { this . tooltop = this . label ; } } if ( isNullOrBlank ( this . url ) && isNotNullAndNonEmpty ( this . nodeType ) ) { this . url = "http://activemq.apache.org/camel/" + this . nodeType . toLowerCase ( ) . replace ( ' ' , '-' ) + ".html" ; } if ( node instanceof ProcessorType && this . outputs == null ) { ProcessorType processorType = ( ProcessorType ) node ; this . outputs = processorType . getOutputs ( ) ; } } protected String removeQueryString ( String text ) { int idx = text . indexOf ( "?" ) ; if ( idx <= 0 ) { return text ; } else { return text . substring ( 0 , idx ) ; } } public static String insertSpacesBetweenCamelCase ( String name ) { boolean lastCharacterLowerCase = false ; StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 , size = name . length ( ) ; i < size ; i ++ ) { char ch = name . charAt ( i ) ; if ( Character . isUpperCase ( ch ) ) { if ( lastCharacterLowerCase ) { buffer . append ( ' ' ) ; } lastCharacterLowerCase = false ; } else { lastCharacterLowerCase = true ; } buffer . append ( ch ) ; } return buffer . toString ( ) ; } } 	1	['3', '1', '0', '15', '33', '3', '3', '12', '2', '1.041666667', '431', '0.083333333', '0', '0', '0.666666667', '0', '0', '138.6666667', '4', '2', '4']
package org . apache . camel . component . mina ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . ConnectFuture ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoHandler ; import org . apache . mina . common . IoHandlerAdapter ; import org . apache . mina . common . IoSession ; import org . apache . mina . common . WriteFuture ; import java . net . SocketAddress ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; public class MinaProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( MinaProducer . class ) ; private static final long MAX_WAIT_RESPONSE = 10000 ; private IoSession session ; private MinaEndpoint endpoint ; private CountDownLatch latch ; public MinaProducer ( MinaEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) throws Exception { if ( session == null ) { throw new IllegalStateException ( "Not started yet!" ) ; } if ( ! session . isConnected ( ) ) { doStart ( ) ; } Object body = exchange . getIn ( ) . getBody ( ) ; if ( body == null ) { LOG . warn ( "No payload for exchange: " + exchange ) ; } else { if ( ExchangeHelper . isOutCapable ( exchange ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Writing body : " + body ) ; } latch = new CountDownLatch ( 1 ) ; WriteFuture future = session . write ( body ) ; future . join ( ) ; if ( ! future . isWritten ( ) ) { throw new RuntimeException ( "Timed out waiting for response: " + exchange ) ; } latch . await ( MAX_WAIT_RESPONSE , TimeUnit . MILLISECONDS ) ; if ( latch . getCount ( ) == 1 ) { throw new RuntimeException ( "No response from server within " + MAX_WAIT_RESPONSE + " millisecs" ) ; } ResponseHandler handler = ( ResponseHandler ) session . getHandler ( ) ; if ( handler . getCause ( ) != null ) { throw new Exception ( "Response Handler had an exception" , handler . getCause ( ) ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Handler message: " + handler . getMessage ( ) ) ; } exchange . getOut ( ) . setBody ( handler . getMessage ( ) ) ; } } else { session . write ( body ) ; } } } @ Override protected void doStart ( ) throws Exception { SocketAddress address = endpoint . getAddress ( ) ; IoConnector connector = endpoint . getConnector ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Creating connector to address: " + address + " using connector: " + connector ) ; } IoHandler ioHandler = new ResponseHandler ( endpoint ) ; ConnectFuture future = connector . connect ( address , ioHandler , endpoint . getConfig ( ) ) ; future . join ( ) ; session = future . getSession ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( session != null ) { session . close ( ) . join ( 2000 ) ; } } private final class ResponseHandler extends IoHandlerAdapter { private MinaEndpoint endpoint ; private Object message ; private Throwable cause ; private ResponseHandler ( MinaEndpoint endpoint ) { this . endpoint = endpoint ; } @ Override public void messageReceived ( IoSession ioSession , Object message ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Message received: " + message ) ; } cause = null ; this . message = message ; latch . countDown ( ) ; } @ Override public void exceptionCaught ( IoSession ioSession , Throwable cause ) { LOG . error ( "Exception on receiving message from address: " + this . endpoint . getAddress ( ) + " using connector: " + this . endpoint . getConnector ( ) , cause ) ; this . message = null ; this . cause = cause ; ioSession . close ( ) ; latch . countDown ( ) ; } public Throwable getCause ( ) { return this . cause ; } public Object getMessage ( ) { return this . message ; } } } 	0	['7', '3', '0', '17', '43', '1', '2', '17', '2', '0.766666667', '219', '1', '2', '0.791666667', '0.291666667', '0', '0', '29.57142857', '1', '0.7143', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . impl . DefaultMessage ; public class JMXMessage extends DefaultMessage { private Notification notification ; public JMXMessage ( ) { this ( null ) ; } public JMXMessage ( Notification notification ) { this . notification = notification ; } @ Override public String toString ( ) { return "JMXMessage: " + notification ; } @ Override public JMXExchange getExchange ( ) { return ( JMXExchange ) super . getExchange ( ) ; } @ Override public JMXMessage newInstance ( ) { return new JMXMessage ( ) ; } public Notification getNotification ( ) { return notification ; } } 	1	['9', '3', '0', '4', '12', '30', '1', '4', '9', '0.25', '50', '1', '0', '0.766666667', '0.555555556', '2', '5', '4.444444444', '1', '0.7778', '1']
package org . apache . camel . component . cxf ; import org . apache . camel . * ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . helpers . DOMUtils ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import javax . wsdl . Definition ; import javax . wsdl . xml . WSDLReader ; import javax . wsdl . factory . WSDLFactory ; import javax . xml . namespace . QName ; public class CxfSoapEndpoint implements Endpoint { private final Endpoint endpoint ; private Resource wsdl ; private org . w3c . dom . Document description ; private Definition definition ; private QName service ; private Bus bus ; public CxfSoapEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } protected Endpoint getInnerEndpoint ( ) { return endpoint ; } public boolean isSingleton ( ) { return endpoint . isSingleton ( ) ; } public String getEndpointUri ( ) { return endpoint . getEndpointUri ( ) ; } public Exchange createExchange ( ) { return endpoint . createExchange ( ) ; } public Exchange createExchange ( ExchangePattern pattern ) { return endpoint . createExchange ( pattern ) ; } public Exchange createExchange ( Exchange exchange ) { return endpoint . createExchange ( exchange ) ; } public CamelContext getContext ( ) { return endpoint . getContext ( ) ; } public Producer createProducer ( ) throws Exception { return new CxfSoapProducer ( this ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new CxfSoapConsumer ( this , processor ) ; } public PollingConsumer createPollingConsumer ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } public void setWsdl ( Resource wsdl ) { this . wsdl = wsdl ; } public void init ( ) throws Exception { Assert . notNull ( wsdl , "soap.wsdl parameter must be set on the uri" ) ; description = DOMUtils . readXml ( wsdl . getInputStream ( ) ) ; WSDLFactory wsdlFactory = WSDLFactory . newInstance ( ) ; WSDLReader reader = wsdlFactory . newWSDLReader ( ) ; reader . setFeature ( "javax.wsdl.verbose" , false ) ; definition = reader . readWSDL ( wsdl . getURL ( ) . toString ( ) , description ) ; service = ( QName ) definition . getServices ( ) . keySet ( ) . iterator ( ) . next ( ) ; } protected Bus getBus ( ) { if ( bus == null ) { bus = BusFactory . newInstance ( ) . createBus ( ) ; } return bus ; } public Definition getDefinition ( ) { return definition ; } public QName getService ( ) { return service ; } } 	0	['16', '1', '0', '16', '41', '58', '3', '15', '14', '0.888888889', '131', '1', '1', '0', '0.21875', '0', '0', '6.8125', '2', '1', '0']
package org . apache . camel . language ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface LanguageExpression { String language ( ) ; String expression ( ) ; } 	1	['2', '1', '0', '0', '2', '1', '0', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . impl ; import org . apache . camel . builder . RouteBuilder ; public class NoRouteBuilder extends RouteBuilder { private static final NoRouteBuilder INSTANCE = new NoRouteBuilder ( ) ; public static NoRouteBuilder getInstance ( ) { return INSTANCE ; } public void configure ( ) throws Exception { } } 	0	['4', '3', '0', '1', '5', '4', '0', '1', '3', '0.666666667', '16', '1', '1', '0.957446809', '0.666666667', '1', '1', '2.75', '1', '0.5', '0']
package org . apache . camel . management ; import org . apache . camel . Endpoint ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Endpoint" , currencyTimeLimit = 15 ) public class ManagedEndpoint { private Endpoint endpoint ; public ManagedEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public Endpoint getEndpoint ( ) { return endpoint ; } @ ManagedAttribute ( description = "Endpoint Uri" ) public String getUri ( ) throws Exception { return endpoint . getEndpointUri ( ) ; } } 	1	['3', '1', '0', '3', '5', '0', '2', '1', '3', '0', '17', '1', '1', '0', '0.666666667', '0', '0', '4.333333333', '1', '0.6667', '1']
package org . apache . camel . component . rmi ; import java . rmi . NotBoundException ; import java . rmi . Remote ; import java . rmi . RemoteException ; import java . rmi . registry . Registry ; import org . apache . camel . Exchange ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . impl . DefaultProducer ; public class RmiProducer extends DefaultProducer { private final RmiEndpoint endpoint ; private Remote remote ; private BeanProcessor beanProcessor ; public RmiProducer ( RmiEndpoint endpoint ) throws RemoteException , NotBoundException { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) throws Exception { if ( beanProcessor == null ) { beanProcessor = new BeanProcessor ( getRemote ( ) , getEndpoint ( ) . getContext ( ) ) ; } beanProcessor . process ( exchange ) ; } public Remote getRemote ( ) throws RemoteException , NotBoundException { if ( remote == null ) { Registry registry = endpoint . getRegistry ( ) ; remote = registry . lookup ( endpoint . getName ( ) ) ; } return remote ; } } 	0	['3', '3', '0', '6', '11', '1', '1', '6', '3', '0.5', '48', '1', '2', '0.904761905', '0.555555556', '0', '0', '14', '1', '0.6667', '0']
package org . apache . camel . processor . validation ; import javax . xml . transform . dom . DOMResult ; import javax . xml . validation . Schema ; import org . xml . sax . ErrorHandler ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public interface ValidatorErrorHandler extends ErrorHandler { void reset ( ) ; void handleErrors ( Exchange exchange , Schema schema , DOMResult result ) throws ValidationException ; } 	1	['2', '1', '0', '4', '2', '1', '2', '2', '2', '2', '2', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '1']
package org . apache . camel ; public class ValidationException extends CamelExchangeException { public ValidationException ( Exchange exchange , String message ) { super ( message , exchange ) ; } } 	0	['1', '5', '2', '6', '2', '0', '4', '2', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultComponentResolver < E extends Exchange > implements ComponentResolver < E > { private static final transient Log LOG = LogFactory . getLog ( DefaultComponentResolver . class ) ; protected static final FactoryFinder COMPONENT_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; public Component < E > resolveComponent ( String name , CamelContext context ) { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } else { throw new IllegalArgumentException ( "Bean with name: " + name + " in registry is not a Component: " + bean ) ; } } Class type ; try { type = COMPONENT_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { return null ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Component registered for scheme : " + name , e ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " via type: " + type . getName ( ) + " via " + COMPONENT_FACTORY . getPath ( ) + name ) ; } if ( type == null ) { return null ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component < E > ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	1	['3', '1', '0', '10', '22', '1', '1', '9', '2', '0.5', '157', '1', '2', '0', '0.666666667', '0', '0', '50.66666667', '6', '2', '1']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Body { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . processor . MarshalProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . dataformat . DataFormatType ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlRootElement ( name = "marshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MarshalType extends OutputType { @ XmlAttribute ( required = false ) private String ref ; @ XmlElementRef private DataFormatType dataFormatType ; public MarshalType ( ) { } public MarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public MarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref:  " + ref + "]" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormatType type = getDataFormatType ( ) ; if ( type == null ) { notNull ( ref , "ref or dataFormatType" ) ; type = routeContext . lookup ( ref , DataFormatType . class ) ; } DataFormat dataFormat = type . getDataFormat ( routeContext ) ; return new MarshalProcessor ( dataFormat ) ; } } 	1	['9', '3', '0', '8', '18', '4', '1', '7', '9', '0.5', '92', '1', '1', '0.942307692', '0.388888889', '1', '2', '9', '2', '0.8889', '3']
package org . apache . camel . bam . processor ; import java . util . Date ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . LockModeType ; import javax . persistence . PersistenceException ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . rules . ProcessRules ; import org . apache . camel . impl . ServiceSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaCallback ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; public class ActivityMonitorEngine extends ServiceSupport implements Runnable { private static final Log LOG = LogFactory . getLog ( ActivityMonitorEngine . class ) ; private JpaTemplate template ; private TransactionTemplate transactionTemplate ; private ProcessRules rules ; private int escalateLevel ; private long windowMillis = 1000L ; private Thread thread ; private boolean useLocking ; public ActivityMonitorEngine ( JpaTemplate template , TransactionTemplate transactionTemplate , ProcessRules rules ) { this . template = template ; this . transactionTemplate = transactionTemplate ; this . rules = rules ; } public boolean isUseLocking ( ) { return useLocking ; } public void setUseLocking ( boolean useLocking ) { this . useLocking = useLocking ; } public void run ( ) { LOG . debug ( "Starting to poll for timeout events" ) ; while ( ! isStopped ( ) ) { try { long now = System . currentTimeMillis ( ) ; long nextPoll = now + windowMillis ; final Date timeNow = new Date ( now ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { List < ActivityState > list = template . find ( "select x from " + ActivityState . class . getName ( ) + " x where x.escalationLevel = ?1 and x.timeOverdue < ?2" , escalateLevel , timeNow ) ; for ( ActivityState activityState : list ) { fireExpiredEvent ( activityState ) ; } } } ) ; long timeToSleep = nextPoll - System . currentTimeMillis ( ) ; if ( timeToSleep > 0 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for " + timeToSleep + " millis" ) ; } try { Thread . sleep ( timeToSleep ) ; } catch ( InterruptedException e ) { LOG . debug ( "Caught: " + e , e ) ; } } } catch ( Exception e ) { LOG . error ( "Caught: " + e , e ) ; } } } protected void fireExpiredEvent ( final ActivityState activityState ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Trying to fire expiration of: " + activityState ) ; } template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { if ( isUseLocking ( ) ) { LOG . info ( "Attempting to lock: " + activityState ) ; entityManager . lock ( activityState , LockModeType . WRITE ) ; LOG . info ( "Grabbed lock: " + activityState ) ; } try { rules . processExpired ( activityState ) ; } catch ( Exception e ) { LOG . error ( "Failed to process expiration of: " + activityState + ". Reason: " + e , e ) ; } activityState . setEscalationLevel ( escalateLevel + 1 ) ; return null ; } } ) ; } protected void doStart ( ) throws Exception { rules . start ( ) ; thread = new Thread ( this , "ActivityMonitorEngine" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { if ( thread != null ) { thread = null ; } rules . stop ( ) ; } } 	0	['12', '2', '0', '12', '35', '32', '3', '11', '4', '0.863636364', '184', '1', '2', '0.565217391', '0.194805195', '1', '1', '13.66666667', '3', '1.0833', '0']
package org . apache . camel . impl ; import java . net . URI ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; public abstract class DefaultComponent < E extends Exchange > extends ServiceSupport implements Component < E > { private int defaultThreadPoolSize = 5 ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; public DefaultComponent ( ) { } public DefaultComponent ( CamelContext context ) { this . camelContext = context ; } public Endpoint < E > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( uri ) ) ; String path = u . getSchemeSpecificPart ( ) ; if ( path . startsWith ( "//" ) ) { path = path . substring ( 2 ) ; } int idx = path . indexOf ( '?' ) ; if ( idx > 0 ) { path = path . substring ( 0 , idx ) ; } Map parameters = URISupport . parseParamters ( u ) ; Endpoint < E > endpoint = createEndpoint ( uri , path , parameters ) ; if ( endpoint == null ) { return null ; } if ( parameters != null ) { if ( endpoint instanceof ScheduledPollEndpoint ) { ScheduledPollEndpoint scheduledPollEndpoint = ( ScheduledPollEndpoint ) endpoint ; scheduledPollEndpoint . configureProperties ( parameters ) ; } setProperties ( endpoint , parameters ) ; } return endpoint ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext context ) { this . camelContext = context ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = createExecutorService ( ) ; } return executorService ; } public void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } protected ScheduledExecutorService createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( defaultThreadPoolSize , new ThreadFactory ( ) { int counter ; public synchronized Thread newThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setName ( "Thread: " + ( ++ counter ) + " " + DefaultComponent . this . toString ( ) ) ; return thread ; } } ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { if ( executorService != null ) { executorService . shutdown ( ) ; } } protected abstract Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception ; protected void setProperties ( Object bean , Map parameters ) throws Exception { IntrospectionSupport . setProperties ( getCamelContext ( ) . getTypeConverter ( ) , bean , parameters ) ; } } 	1	['12', '2', '24', '36', '28', '48', '26', '11', '7', '0.727272727', '139', '1', '1', '0.565217391', '0.277777778', '1', '1', '10.33333333', '2', '0.9167', '3']
package org . apache . camel . component . cxf . interceptors ; import java . io . IOException ; import java . util . logging . Logger ; import org . apache . camel . component . cxf . CamelInvoker ; import org . apache . camel . component . cxf . invoker . InvokingContext ; import org . apache . cxf . endpoint . ConduitSelector ; import org . apache . cxf . endpoint . PreexistingConduitSelector ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . interceptor . InterceptorChain ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public abstract class AbstractInvokerInterceptor extends AbstractPhaseInterceptor < Message > { public static final String ROUTING_INERCEPTOR_PHASE = "Routing-Phase" ; public static final String BUNDLE = "wsdl-cxf" ; public AbstractInvokerInterceptor ( String phase ) { super ( phase ) ; } private boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message inMessage ) throws Fault { if ( isRequestor ( inMessage ) ) { return ; } Exchange exchange = inMessage . getExchange ( ) ; Message outMessage = null ; try { CamelInvoker invoker = exchange . get ( CamelInvoker . class ) ; outMessage = invoker . invoke ( inMessage ) ; } catch ( Exception e ) { throw new Fault ( e ) ; } setBackChannelConduit ( exchange , outMessage ) ; Exception ex = outMessage . getContent ( Exception . class ) ; if ( ex != null ) { if ( ! ( ex instanceof Fault ) ) { ex = new Fault ( ex ) ; } throw ( Fault ) ex ; } outMessage . put ( Message . INBOUND_MESSAGE , Boolean . FALSE ) ; BindingOperationInfo boi = exchange . get ( BindingOperationInfo . class ) ; if ( boi != null ) { exchange . put ( BindingMessageInfo . class , boi . getOutput ( ) ) ; } InvokingContext invokingContext = exchange . get ( InvokingContext . class ) ; assert invokingContext != null ; InterceptorChain chain = invokingContext . getResponseOutInterceptorChain ( exchange ) ; if ( chain != null ) { outMessage . setInterceptorChain ( chain ) ; chain . doIntercept ( outMessage ) ; } } protected void setBackChannelConduit ( Exchange ex , Message message ) throws Fault { Conduit conduit = ex . getConduit ( message ) ; if ( conduit == null ) { try { EndpointReferenceType target = ex . get ( EndpointReferenceType . class ) ; conduit = ex . getDestination ( ) . getBackChannel ( ex . getInMessage ( ) , null , target ) ; ex . put ( ConduitSelector . class , new PreexistingConduitSelector ( conduit ) ) ; } catch ( IOException e ) { throw new Fault ( e ) ; } } assert conduit != null ; } protected abstract Logger getLogger ( ) ; } 	0	['6', '0', '2', '16', '27', '9', '2', '14', '2', '1', '161', '0', '0', '0', '0.5', '0', '0', '25.33333333', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . List ; import javax . xml . bind . annotation . XmlElementRef ; public interface RouteContainer { @ XmlElementRef List < RouteType > getRoutes ( ) ; void setRoutes ( List < RouteType > routes ) ; } 	1	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . jms ; public enum ConsumerType { Simple , Default , ServerSessionPool } 	0	['4', '2', '0', '4', '7', '4', '3', '1', '2', '0.916666667', '56', '0.25', '4', '0.857142857', '0.444444444', '1', '1', '12', '1', '0.5', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . channels . Channel ; import java . nio . channels . FileChannel ; import java . nio . channels . FileLock ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class FileProcessStrategySupport implements FileProcessStrategy { public static final String DEFAULT_LOCK_FILE_POSTFIX = ".cameLock" ; private static final transient Log LOG = LogFactory . getLog ( FileProcessStrategySupport . class ) ; private boolean lockFile ; private FileRenamer lockFileRenamer ; protected FileProcessStrategySupport ( ) { this ( true ) ; } protected FileProcessStrategySupport ( boolean lockFile ) { this ( lockFile , new DefaultFileRenamer ( null , DEFAULT_LOCK_FILE_POSTFIX ) ) ; } protected FileProcessStrategySupport ( boolean lockFile , FileRenamer lockFileRenamer ) { this . lockFile = lockFile ; this . lockFileRenamer = lockFileRenamer ; } public boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { File newFile = lockFileRenamer . renameFile ( file ) ; String lockFileName = newFile . getAbsolutePath ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Locking the file: " + file + " using the lock file name: " + lockFileName ) ; } FileChannel channel = new RandomAccessFile ( lockFileName , "rw" ) . getChannel ( ) ; FileLock lock = channel . lock ( ) ; if ( lock != null ) { exchange . setProperty ( "org.apache.camel.fileChannel" , channel ) ; exchange . setProperty ( "org.apache.camel.file.lock" , lock ) ; exchange . setProperty ( "org.apache.camel.file.lock.name" , lockFileName ) ; return true ; } return false ; } return true ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { Channel channel = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.fileChannel" , Channel . class ) ; String lockfile = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.file.lock.name" , String . class ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Unlocking file: " + file ) ; } channel . close ( ) ; File lock = new File ( lockfile ) ; lock . delete ( ) ; } } public boolean isLockFile ( ) { return lockFile ; } public void setLockFile ( boolean lockFile ) { this . lockFile = lockFile ; } public FileRenamer getLockFileRenamer ( ) { return lockFileRenamer ; } public void setLockFileRenamer ( FileRenamer lockFileRenamer ) { this . lockFileRenamer = lockFileRenamer ; } } 	1	['10', '1', '3', '12', '29', '21', '3', '9', '6', '0.722222222', '151', '0.75', '2', '0', '0.37037037', '0', '0', '13.7', '1', '0.6', '1']
package org . apache . camel . component . jdbc ; import java . net . URI ; import java . net . URISyntaxException ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; public class JdbcEndpoint extends DefaultEndpoint < DefaultExchange > { private URI uri ; private String remaining ; private int readSize = 20000 ; protected JdbcEndpoint ( String endpointUri , String remaining , JdbcComponent component ) throws URISyntaxException { super ( endpointUri , component ) ; this . uri = new URI ( endpointUri ) ; this . remaining = remaining ; } public boolean isSingleton ( ) { return false ; } public Consumer < DefaultExchange > createConsumer ( Processor processor ) throws Exception { throw new RuntimeCamelException ( "A JDBC Consumer would be the server side of database! No such support here" ) ; } public Producer < DefaultExchange > createProducer ( ) throws Exception { return new JdbcProducer ( this , remaining , readSize ) ; } public String getName ( ) { String path = uri . getPath ( ) ; if ( path == null ) { path = uri . getSchemeSpecificPart ( ) ; } return path ; } public int getReadSize ( ) { return this . readSize ; } public void setReadSize ( int readSize ) { this . readSize = readSize ; } } 	0	['7', '2', '0', '8', '13', '7', '2', '8', '6', '0.722222222', '62', '1', '0', '0.739130435', '0.314285714', '0', '0', '7.428571429', '2', '1', '0']
package org . apache . camel . management ; import java . util . Collection ; import javax . management . JMException ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . RouteType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class InstrumentationLifecycleStrategy implements LifecycleStrategy { private static final transient Log LOG = LogFactory . getLog ( InstrumentationProcessor . class ) ; private InstrumentationAgent agent ; private CamelNamingStrategy namingStrategy ; public InstrumentationLifecycleStrategy ( InstrumentationAgent agent ) { this . agent = agent ; setNamingStrategy ( agent . getNamingStrategy ( ) ) ; } public void onContextCreate ( CamelContext context ) { if ( context instanceof DefaultCamelContext ) { try { DefaultCamelContext dc = ( DefaultCamelContext ) context ; ManagedService ms = new ManagedService ( dc ) ; agent . register ( ms , getNamingStrategy ( ) . getObjectName ( dc ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register CamelContext MBean" , e ) ; } } } public void onEndpointAdd ( Endpoint endpoint ) { try { ManagedEndpoint me = new ManagedEndpoint ( endpoint ) ; agent . register ( me , getNamingStrategy ( ) . getObjectName ( me ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Endpoint MBean" , e ) ; } } public void onRoutesAdd ( Collection < Route > routes ) { for ( Route route : routes ) { try { ManagedRoute mr = new ManagedRoute ( route ) ; agent . register ( mr , getNamingStrategy ( ) . getObjectName ( mr ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Route MBean" , e ) ; } } } public void onServiceAdd ( CamelContext context , Service service ) { if ( service instanceof ServiceSupport ) { try { ManagedService ms = new ManagedService ( ( ServiceSupport ) service ) ; agent . register ( ms , getNamingStrategy ( ) . getObjectName ( context , ms ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Service MBean" , e ) ; } } } public void beforeStartRouteType ( CamelContext context , RouteType routeType ) { PerformanceCounter mc = new PerformanceCounter ( ) ; routeType . intercept ( new InstrumentationProcessor ( mc ) ) ; } public CamelNamingStrategy getNamingStrategy ( ) { return namingStrategy ; } public void setNamingStrategy ( CamelNamingStrategy namingStrategy ) { this . namingStrategy = namingStrategy ; } } 	1	['9', '1', '0', '20', '27', '6', '1', '19', '8', '0.416666667', '147', '1', '3', '0', '0.265625', '0', '0', '15', '2', '1.1111', '9']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "header" ) public class HeaderExpression extends ExpressionType { public HeaderExpression ( ) { } public HeaderExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "header" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . spi ; import java . util . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . model . RouteType ; public interface LifecycleStrategy { void onContextCreate ( CamelContext context ) ; void onEndpointAdd ( Endpoint endpoint ) ; void onServiceAdd ( CamelContext context , Service service ) ; void onRoutesAdd ( Collection < Route > routes ) ; void beforeStartRouteType ( CamelContext context , RouteType routeType ) ; } 	1	['5', '1', '0', '8', '5', '10', '5', '4', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '4']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class RoundRobinLoadBalancer extends QueueLoadBalancer { private int counter = - 1 ; protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; if ( ++ counter >= size ) { counter = 0 ; } return processors . get ( counter ) ; } } 	0	['2', '3', '0', '5', '5', '0', '2', '3', '1', '0', '30', '1', '0', '0.833333333', '0.666666667', '1', '1', '13.5', '2', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . dataformat . ArtixDSContentType ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . spi . DataFormat ; public class DataTypeExpression < T extends ProcessorType > { private final ProcessorType < T > processorType ; private final Operation operation ; public enum Operation { Marshal , Unmarshal } ; public DataTypeExpression ( ProcessorType < T > processorType , Operation operation ) { this . processorType = processorType ; this . operation = operation ; } public T serialization ( ) { return dataFormat ( new SerializationDataFormat ( ) ) ; } public T jaxb ( ) { return dataFormat ( new JaxbDataFormat ( ) ) ; } public T jaxb ( boolean prettyPrint ) { return dataFormat ( new JaxbDataFormat ( prettyPrint ) ) ; } public T xmlBeans ( ) { return dataFormat ( new XMLBeansDataFormat ( ) ) ; } public T artixDS ( ) { return dataFormat ( new ArtixDSDataFormat ( ) ) ; } public T artixDS ( Class < ? > dataObjectType ) { return dataFormat ( new ArtixDSDataFormat ( dataObjectType ) ) ; } public T artixDS ( Class < ? > elementType , ArtixDSContentType contentType ) { return dataFormat ( new ArtixDSDataFormat ( elementType , contentType ) ) ; } public T artixDS ( ArtixDSContentType contentType ) { return dataFormat ( new ArtixDSDataFormat ( contentType ) ) ; } private T dataFormat ( DataFormatType dataFormatType ) { switch ( operation ) { case Unmarshal : return processorType . unmarshal ( dataFormatType ) ; case Marshal : return processorType . marshal ( dataFormatType ) ; default : throw new IllegalArgumentException ( "Unknown value: " + operation ) ; } } } 	1	['10', '1', '0', '9', '27', '43', '1', '9', '9', '0', '103', '1', '2', '0', '0.257142857', '0', '0', '9.1', '4', '1.2', '3']
package org . apache . camel . bam . model ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . UniqueConstraint ; @ Entity @ UniqueConstraint ( columnNames = { "name" } ) public class ActivityDefinition extends EntitySupport { private String name ; private ProcessDefinition processDefinition ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "Activity[" + getId ( ) + " name: " + getName ( ) + "]" ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } } 	0	['7', '2', '0', '6', '13', '17', '4', '2', '7', '0.75', '46', '1', '1', '0.333333333', '0.428571429', '0', '0', '5.285714286', '1', '0.8571', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . Injector ; public interface TypeConverterRegistry { void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) ; Injector getInjector ( ) ; } 	1	['2', '1', '0', '8', '2', '1', '6', '2', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '2']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "ognl" ) public class OgnlExpression extends ExpressionType { public OgnlExpression ( ) { } public OgnlExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "ognl" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.923076923', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . TimeUnit ; import org . apache . camel . AlreadyStoppedException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SedaConsumer extends ServiceSupport implements Consumer , Runnable { private static final Log LOG = LogFactory . getLog ( SedaConsumer . class ) ; private SedaEndpoint endpoint ; private AsyncProcessor processor ; private Thread thread ; public SedaConsumer ( SedaEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = AsyncProcessorTypeConverter . convert ( processor ) ; } @ Override public String toString ( ) { return "SedaConsumer: " + endpoint . getEndpointUri ( ) ; } public void run ( ) { while ( isRunAllowed ( ) ) { final Exchange exchange ; try { exchange = endpoint . getQueue ( ) . poll ( 1000 , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { break ; } if ( exchange != null && isRunAllowed ( ) ) { processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } } } protected void doStart ( ) throws Exception { thread = new Thread ( this , getThreadName ( endpoint . getEndpointUri ( ) ) ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { thread . join ( ) ; } } 	1	['6', '2', '0', '11', '23', '1', '2', '11', '3', '0.75', '88', '1', '3', '0.764705882', '0.466666667', '1', '2', '13', '2', '0.8333', '2']
package org . apache . camel . component . file . remote ; import java . io . IOException ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . commons . net . ftp . FTPClient ; public class FtpEndpoint extends RemoteFileEndpoint < RemoteFileExchange > { private static final transient Log LOG = LogFactory . getLog ( FtpEndpoint . class ) ; public FtpEndpoint ( String uri , RemoteFileComponent remoteFileComponent , RemoteFileConfiguration configuration ) { super ( uri , remoteFileComponent , configuration ) ; } public FtpProducer createProducer ( ) throws Exception { return new FtpProducer ( this , createFtpClient ( ) ) ; } public FtpConsumer createConsumer ( Processor processor ) throws Exception { final FtpConsumer consumer = new FtpConsumer ( this , processor , createFtpClient ( ) ) ; configureConsumer ( consumer ) ; return consumer ; } protected FTPClient createFtpClient ( ) throws IOException { final FTPClient client = new FTPClient ( ) ; RemoteFileConfiguration config = getConfiguration ( ) ; String host = config . getHost ( ) ; int port = config . getPort ( ) ; LOG . debug ( "Connecting to host: " + host + " port: " + port ) ; client . connect ( host , port ) ; client . login ( config . getUsername ( ) , config . getPassword ( ) ) ; client . setFileType ( config . isBinary ( ) ? FTPClient . BINARY_FILE_TYPE : FTPClient . ASCII_FILE_TYPE ) ; return client ; } } 	0	['7', '4', '0', '11', '25', '19', '3', '11', '5', '0.166666667', '94', '1', '1', '0.861111111', '0.366666667', '0', '0', '12.28571429', '1', '0.7143', '0']
package org . apache . camel . component . vm ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . seda . SedaComponent ; import org . apache . camel . component . seda . SedaEndpoint ; public class VmComponent extends SedaComponent { private static final AtomicInteger START_COUNTER = new AtomicInteger ( ) ; protected static Map < String , BlockingQueue > queues = new HashMap < String , BlockingQueue > ( ) ; @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { BlockingQueue < Exchange > blockingQueue = getBlockingQueue ( uri ) ; return new SedaEndpoint ( uri , this , blockingQueue ) ; } protected BlockingQueue < Exchange > getBlockingQueue ( String uri ) { synchronized ( queues ) { BlockingQueue < Exchange > answer = queues . get ( uri ) ; if ( answer == null ) { answer = createQueue ( ) ; queues . put ( uri , answer ) ; } return answer ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; START_COUNTER . incrementAndGet ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( START_COUNTER . decrementAndGet ( ) == 0 ) { synchronized ( queues ) { for ( BlockingQueue q : queues . values ( ) ) { q . clear ( ) ; } queues . clear ( ) ; } } } } 	1	['6', '4', '0', '4', '23', '5', '0', '4', '1', '0.5', '99', '1', '0', '0.862068966', '0.533333333', '2', '2', '15.16666667', '2', '0.8333', '4']
package org . apache . camel . component . cxf . invoker ; import java . util . List ; import org . w3c . dom . Element ; public class PayloadMessage { private List < Element > payload ; private Element header ; public PayloadMessage ( List < Element > payload , Element header ) { this . payload = payload ; this . header = header ; } public List < Element > getPayload ( ) { return payload ; } public Element getHeader ( ) { return header ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "payload: " + payload ) ; buf . append ( " header: " + header ) ; return buf . toString ( ) ; } } 	0	['4', '1', '0', '1', '12', '0', '1', '0', '4', '0.333333333', '52', '1', '0', '0', '0.5', '0', '0', '11.5', '1', '0.75', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . FromType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . processor . Interceptor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ProceedProcessor ; import org . apache . camel . processor . UnitOfWorkProcessor ; public class RouteContext { private final RouteType route ; private final FromType from ; private final Collection < Route > routes ; private Endpoint endpoint ; private List < Processor > eventDrivenProcessors = new ArrayList < Processor > ( ) ; private Interceptor lastInterceptor ; public RouteContext ( RouteType route , FromType from , Collection < Route > routes ) { this . route = route ; this . from = from ; this . routes = routes ; } public Endpoint getEndpoint ( ) { if ( endpoint == null ) { endpoint = from . resolveEndpoint ( this ) ; } return endpoint ; } public FromType getFrom ( ) { return from ; } public RouteType getRoute ( ) { return route ; } public CamelContext getCamelContext ( ) { return getRoute ( ) . getCamelContext ( ) ; } public Processor createProcessor ( ProcessorType node ) throws Exception { return node . createOutputsProcessor ( this ) ; } public Endpoint resolveEndpoint ( String uri ) { return route . resolveEndpoint ( uri ) ; } public Endpoint resolveEndpoint ( String uri , String ref ) { Endpoint endpoint = null ; if ( uri != null ) { endpoint = resolveEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } } if ( ref != null ) { endpoint = lookup ( ref , Endpoint . class ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( "ref:" + ref ) ; } } if ( endpoint == null ) { throw new IllegalArgumentException ( "Either 'uri' or 'ref' must be specified on: " + this ) ; } else { return endpoint ; } } public < T > T lookup ( String name , Class < T > type ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name , type ) ; } public void commit ( ) { if ( ! eventDrivenProcessors . isEmpty ( ) ) { Processor processor = Pipeline . newInstance ( eventDrivenProcessors ) ; final AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; Processor unitOfWorkProcessor = new UnitOfWorkProcessor ( asyncProcessor ) ; routes . add ( new EventDrivenConsumerRoute ( getEndpoint ( ) , unitOfWorkProcessor ) ) ; } } public void addEventDrivenProcessor ( Processor processor ) { eventDrivenProcessors . add ( processor ) ; } public void intercept ( Interceptor interceptor ) { getRoute ( ) . intercept ( interceptor ) ; lastInterceptor = interceptor ; } public Processor createProceedProcessor ( ) { if ( lastInterceptor == null ) { throw new IllegalArgumentException ( "Cannot proceed() from outside of an interceptor!" ) ; } else { return new ProceedProcessor ( lastInterceptor ) ; } } } 	1	['13', '1', '0', '48', '36', '58', '35', '16', '13', '0.805555556', '183', '1', '4', '0', '0.196581197', '0', '0', '12.61538462', '6', '1.5385', '4']
package org . apache . camel . processor ; import java . io . Serializable ; import java . util . Random ; public class RedeliveryPolicy implements Cloneable , Serializable { protected static transient Random randomNumberGenerator ; protected int maximumRedeliveries = 6 ; protected long initialRedeliveryDelay = 1000L ; protected double backOffMultiplier = 2 ; protected boolean useExponentialBackOff ; protected double collisionAvoidanceFactor = 0.15d ; protected boolean useCollisionAvoidance ; public RedeliveryPolicy ( ) { } @ Override public String toString ( ) { return "RedeliveryPolicy[maximumRedeliveries=" + maximumRedeliveries + "]" ; } public RedeliveryPolicy copy ( ) { try { return ( RedeliveryPolicy ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( "Could not clone: " + e , e ) ; } } public boolean shouldRedeliver ( int redeliveryCounter ) { return redeliveryCounter < getMaximumRedeliveries ( ) ; } public RedeliveryPolicy maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicy initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicy useCollisionAvoidance ( ) { setUseCollisionAvoidance ( true ) ; return this ; } public RedeliveryPolicy useExponentialBackOff ( ) { setUseExponentialBackOff ( true ) ; return this ; } public RedeliveryPolicy backOffMultiplier ( double multiplier ) { useExponentialBackOff ( ) ; setBackOffMultiplier ( multiplier ) ; return this ; } public RedeliveryPolicy collisionAvoidancePercent ( double collisionAvoidancePercent ) { useCollisionAvoidance ( ) ; setCollisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public short getCollisionAvoidancePercent ( ) { return ( short ) Math . round ( collisionAvoidanceFactor * 100 ) ; } public void setCollisionAvoidancePercent ( double collisionAvoidancePercent ) { this . collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d ; } public double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public int getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( int maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public long getRedeliveryDelay ( long previousDelay ) { long redeliveryDelay ; if ( previousDelay == 0 ) { redeliveryDelay = initialRedeliveryDelay ; } else if ( useExponentialBackOff && backOffMultiplier > 1 ) { redeliveryDelay = Math . round ( backOffMultiplier * previousDelay ) ; } else { redeliveryDelay = previousDelay ; } if ( useCollisionAvoidance ) { Random random = getRandomNumberGenerator ( ) ; double variance = ( random . nextBoolean ( ) ? collisionAvoidanceFactor : - collisionAvoidanceFactor ) * random . nextDouble ( ) ; redeliveryDelay += redeliveryDelay * variance ; } return redeliveryDelay ; } public boolean isUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public boolean isUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } protected static synchronized Random getRandomNumberGenerator ( ) { if ( randomNumberGenerator == null ) { randomNumberGenerator = new Random ( ) ; } return randomNumberGenerator ; } } 	0	['26', '1', '0', '5', '38', '251', '5', '0', '25', '0.84', '241', '1', '0', '0', '0.292307692', '0', '0', '8', '6', '1.2308', '0']
package org . apache . camel . util ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . FailedToCreateProducerException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ProducerCache < E extends Exchange > extends ServiceSupport { private static final Log LOG = LogFactory . getLog ( ProducerCache . class ) ; private Map < String , Producer < E > > producers = new HashMap < String , Producer < E > > ( ) ; public synchronized Producer < E > getProducer ( Endpoint < E > endpoint ) { String key = endpoint . getEndpointUri ( ) ; Producer < E > answer = producers . get ( key ) ; if ( answer == null ) { try { answer = endpoint . createProducer ( ) ; answer . start ( ) ; } catch ( Exception e ) { throw new FailedToCreateProducerException ( endpoint , e ) ; } producers . put ( key , answer ) ; } return answer ; } public void send ( Endpoint < E > endpoint , E exchange ) { try { Producer < E > producer = getProducer ( endpoint ) ; producer . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public E send ( Endpoint < E > endpoint , Processor processor ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( ) ; return sendExchange ( endpoint , producer , processor , exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( ) ; boolean sync = sendExchange ( endpoint , producer , processor , exchange , callback ) ; setProcessedSync ( exchange , sync ) ; return exchange ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public static boolean isProcessedSync ( Exchange exchange ) { Boolean rc = exchange . getProperty ( ProducerCache . class . getName ( ) + ".SYNC" , Boolean . class ) ; return rc == null ? false : rc ; } public static void setProcessedSync ( Exchange exchange , boolean b ) { exchange . setProperty ( ProducerCache . class . getName ( ) + ".SYNC" , b ? Boolean . TRUE : Boolean . FALSE ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( pattern ) ; return sendExchange ( endpoint , producer , processor , exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } protected E sendExchange ( Endpoint < E > endpoint , Producer < E > producer , Processor processor , E exchange ) throws Exception { processor . process ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> " + endpoint + " " + exchange ) ; } producer . process ( exchange ) ; return exchange ; } protected boolean sendExchange ( Endpoint < E > endpoint , Producer < E > producer , Processor processor , E exchange , AsyncCallback callback ) throws Exception { processor . process ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> " + endpoint + " " + exchange ) ; } return AsyncProcessorTypeConverter . convert ( producer ) . process ( exchange , callback ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( producers . values ( ) ) ; } protected void doStart ( ) throws Exception { } } 	1	['13', '2', '0', '16', '41', '66', '2', '14', '8', '0.541666667', '236', '1', '1', '0.541666667', '0.34375', '1', '1', '17', '2', '1.0769', '1']
package org . apache . camel . model ; public class NodeFactory { public FilterType createFilter ( ) { return new FilterType ( ) ; } public RouteType createRoute ( ) { return new RouteType ( ) ; } } 	0	['3', '1', '0', '3', '6', '3', '1', '2', '3', '2', '14', '0', '0', '0', '1', '0', '0', '3.666666667', '1', '0.6667', '0']
package org . apache . camel . component . seda ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class SedaComponent extends DefaultComponent { public BlockingQueue < Exchange > createQueue ( ) { return new LinkedBlockingQueue < Exchange > ( 1000 ) ; } @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new SedaEndpoint ( uri , this ) ; } } 	1	['3', '3', '2', '5', '6', '3', '3', '3', '2', '2', '17', '0', '0', '0.92', '0.555555556', '1', '1', '4.666666667', '1', '0.6667', '1']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlTransient ; import javax . management . MBeanServer ; import org . apache . camel . management . InstrumentationAgentImpl ; import org . apache . camel . CamelContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; public class SpringInstrumentationAgent extends InstrumentationAgentImpl implements InitializingBean , DisposableBean { private static final transient Log LOG = LogFactory . getLog ( SpringInstrumentationAgent . class ) ; public void afterPropertiesSet ( ) throws Exception { LOG . debug ( "Starting JMX agent on server: " + getMBeanServer ( ) ) ; start ( ) ; } public void destroy ( ) throws Exception { } } 	0	['4', '3', '0', '6', '13', '4', '1', '5', '3', '0.666666667', '27', '1', '1', '0.939393939', '1', '0', '0', '5.5', '1', '0.5', '0']
package org . apache . camel . component . timer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . component . bean . BeanInvocation ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . Timer ; import java . util . TimerTask ; public class TimerConsumer extends DefaultConsumer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( TimerConsumer . class ) ; private final TimerEndpoint endpoint ; private TimerTask task ; public TimerConsumer ( TimerEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { task = new TimerTask ( ) { @ Override public void run ( ) { sendTimerExchange ( ) ; } } ; Timer timer = endpoint . getTimer ( ) ; configureTask ( task , timer ) ; } @ Override protected void doStop ( ) throws Exception { task . cancel ( ) ; } protected void configureTask ( TimerTask task , Timer timer ) { if ( endpoint . isFixedRate ( ) ) { if ( endpoint . getTime ( ) != null ) { timer . scheduleAtFixedRate ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { timer . scheduleAtFixedRate ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } } else { if ( endpoint . getTime ( ) != null ) { if ( endpoint . getPeriod ( ) >= 0 ) { timer . schedule ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { timer . schedule ( task , endpoint . getTime ( ) ) ; } } else { if ( endpoint . getPeriod ( ) >= 0 ) { timer . schedule ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } else { timer . schedule ( task , endpoint . getDelay ( ) ) ; } } } } protected void sendTimerExchange ( ) { Exchange exchange = endpoint . createExchange ( ) ; exchange . setProperty ( "org.apache.camel.timer.name" , endpoint . getTimerName ( ) ) ; exchange . setProperty ( "org.apache.camel.timer.time" , endpoint . getTime ( ) ) ; exchange . setProperty ( "org.apache.camel.timer.period" , endpoint . getPeriod ( ) ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { LOG . error ( "Caught: " + e , e ) ; } } } 	1	['6', '3', '0', '8', '32', '0', '2', '8', '1', '0.666666667', '161', '1', '2', '0.846153846', '0.36', '1', '1', '25.33333333', '6', '1.5', '1']
