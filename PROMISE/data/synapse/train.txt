package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . InMediator ; import javax . xml . namespace . QName ; public class InMediatorFactory extends AbstractListMediatorFactory { private static final QName IN_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "in" ) ; public Mediator createMediator ( OMElement elem ) { InMediator filter = new InMediator ( ) ; initMediator ( filter , elem ) ; addChildren ( elem , filter ) ; return filter ; } public QName getTagQName ( ) { return IN_Q ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . builtin . ValidateMediator ; import org . apache . synapse . config . xml . MediatorSerializer ; import org . apache . synapse . config . xml . AbstractListMediatorSerializer ; import java . util . Iterator ; public class ValidateMediatorSerializer extends AbstractListMediatorSerializer implements MediatorSerializer { private static final Log log = LogFactory . getLog ( ValidateMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof ValidateMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } ValidateMediator mediator = ( ValidateMediator ) m ; OMElement validate = fac . createOMElement ( "validate" , synNS ) ; finalizeSerialization ( validate , mediator ) ; if ( mediator . getSource ( ) != null ) { validate . addAttribute ( fac . createOMAttribute ( "source" , nullNS , mediator . getSource ( ) . toString ( ) ) ) ; serializeNamespaces ( validate , mediator . getSource ( ) ) ; } Iterator iter = mediator . getSchemaKeys ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = ( String ) iter . next ( ) ; OMElement schema = fac . createOMElement ( "schema" , synNS , validate ) ; schema . addAttribute ( fac . createOMAttribute ( "key" , nullNS , key ) ) ; } serializeProperties ( validate , mediator . getProperties ( ) ) ; OMElement onFail = fac . createOMElement ( "on-fail" , synNS , validate ) ; serializeChildren ( onFail , mediator . getList ( ) ) ; if ( parent != null ) { parent . addChild ( validate ) ; } return validate ; } public String getMediatorClassName ( ) { return ValidateMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . config ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . XMLConfigurationBuilder ; import org . apache . synapse . mediators . base . SynapseMediator ; import org . apache . synapse . mediators . builtin . SendMediator ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . File ; public class SynapseConfigurationBuilder implements Constants { private static Log log = LogFactory . getLog ( SynapseConfigurationBuilder . class ) ; public static SynapseConfiguration getDefaultConfiguration ( ) { SynapseConfiguration config = new SynapseConfiguration ( ) ; SynapseMediator mainmediator = new SynapseMediator ( ) ; mainmediator . addChild ( new SendMediator ( ) ) ; config . addSequence ( "main" , mainmediator ) ; return config ; } public static SynapseConfiguration getConfiguration ( String configFile ) { try { SynapseConfiguration synCfg = XMLConfigurationBuilder . getConfiguration ( new FileInputStream ( configFile ) ) ; log . info ( "Loaded Synapse configuration from : " + configFile ) ; synCfg . setPathToConfigFile ( new File ( configFile ) . getAbsolutePath ( ) ) ; return synCfg ; } catch ( FileNotFoundException fnf ) { handleException ( "Cannot load Synapse configuration from : " + configFile , fnf ) ; } catch ( Exception e ) { handleException ( "Could not initialize Synapse : " + e . getMessage ( ) , e ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . jaxen . JaxenException ; import java . util . Iterator ; public class OMElementUtils { private static final Log log = LogFactory . getLog ( OMElementUtils . class ) ; public static String getNameSpaceWithPrefix ( String prefix , OMElement elem ) { if ( prefix == null || elem == null ) { log . warn ( "Searching for null NS prefix and/or using null OMElement" ) ; return null ; } Iterator iter = elem . getAllDeclaredNamespaces ( ) ; while ( iter . hasNext ( ) ) { OMNamespace ns = ( OMNamespace ) iter . next ( ) ; if ( prefix . equals ( ns . getPrefix ( ) ) ) { return ns . getNamespaceURI ( ) ; } } return null ; } public static void addNameSpaces ( AXIOMXPath xpath , OMElement elem , Log log ) { try { Iterator it = elem . getAllDeclaredNamespaces ( ) ; while ( it . hasNext ( ) ) { OMNamespace n = ( OMNamespace ) it . next ( ) ; xpath . addNamespace ( n . getPrefix ( ) , n . getNamespaceURI ( ) ) ; } } catch ( JaxenException je ) { String msg = "Error adding declared name spaces of " + elem + " to the XPath : " + xpath ; log . error ( msg ) ; throw new SynapseException ( msg , je ) ; } } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . WSDLEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class WSDLEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( WSDLEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof WSDLEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; WSDLEndpoint wsdlEndpoint = ( WSDLEndpoint ) endpoint ; String name = wsdlEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } OMElement wsdlElement = fac . createOMElement ( "wsdl" , Constants . SYNAPSE_OMNAMESPACE ) ; String serviceName = wsdlEndpoint . getServiceName ( ) ; if ( serviceName != null ) { wsdlElement . addAttribute ( "service" , serviceName , null ) ; } String portName = wsdlEndpoint . getPortName ( ) ; if ( portName != null ) { wsdlElement . addAttribute ( "port" , portName , null ) ; } String uri = wsdlEndpoint . getWsdlURI ( ) ; if ( uri != null ) { wsdlElement . addAttribute ( "uri" , uri , null ) ; } OMElement wsdlDoc = wsdlEndpoint . getWsdlDoc ( ) ; if ( wsdlDoc != null ) { wsdlElement . addChild ( wsdlDoc ) ; } long suspendDuration = wsdlEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; wsdlElement . addChild ( suspendElement ) ; } EndpointDefinition epAddress = wsdlEndpoint . getEndpointDefinition ( ) ; serializeQOSInformation ( epAddress , wsdlElement ) ; endpointElement . addChild ( wsdlElement ) ; return endpointElement ; } public void serializeQOSInformation ( EndpointDefinition endpointDefinition , OMElement wsdlElement ) { if ( endpointDefinition . isForcePOX ( ) ) { wsdlElement . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpointDefinition . isForceSOAP ( ) ) { wsdlElement . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } int isEnableStatistics = endpointDefinition . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { wsdlElement . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpointDefinition . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } wsdlElement . addChild ( addressing ) ; } if ( endpointDefinition . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpointDefinition . getWsRMPolicyKey ( ) ) ) ; } wsdlElement . addChild ( rm ) ; } if ( endpointDefinition . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpointDefinition . getWsSecPolicyKey ( ) ) ) ; } wsdlElement . addChild ( sec ) ; } if ( endpointDefinition . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; wsdlElement . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpointDefinition . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpointDefinition . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . HeaderMediator ; import javax . xml . namespace . QName ; public class HeaderMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( FilterMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof HeaderMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } HeaderMediator mediator = ( HeaderMediator ) m ; OMElement header = fac . createOMElement ( "header" , synNS ) ; finalizeSerialization ( header , mediator ) ; QName qName = mediator . getQName ( ) ; if ( qName != null ) { if ( qName . getNamespaceURI ( ) != null ) { header . addAttribute ( fac . createOMAttribute ( "name" , nullNS , ( qName . getPrefix ( ) != null && ! "" . equals ( qName . getPrefix ( ) ) ? qName . getPrefix ( ) + ":" : "" ) + qName . getLocalPart ( ) ) ) ; header . declareNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ; } else { header . addAttribute ( fac . createOMAttribute ( "name" , nullNS , qName . getLocalPart ( ) ) ) ; } } if ( mediator . getAction ( ) == HeaderMediator . ACTION_REMOVE ) { header . addAttribute ( fac . createOMAttribute ( "action" , nullNS , "remove" ) ) ; } else { if ( mediator . getValue ( ) != null ) { header . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mediator . getValue ( ) ) ) ; } else if ( mediator . getExpression ( ) != null ) { header . addAttribute ( fac . createOMAttribute ( "expression" , nullNS , mediator . getExpression ( ) . toString ( ) ) ) ; super . serializeNamespaces ( header , mediator . getExpression ( ) ) ; } else { handleException ( "Value or expression required for a set header mediator" ) ; } } if ( parent != null ) { parent . addChild ( header ) ; } return header ; } public String getMediatorClassName ( ) { return HeaderMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class MediatorPropertyFactory { private static final Log log = LogFactory . getLog ( MediatorPropertyFactory . class ) ; public static List getMediatorProperties ( OMElement elem ) { List propertyList = new ArrayList ( ) ; Iterator iter = elem . getChildrenWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ) ; while ( iter . hasNext ( ) ) { OMElement propEle = ( OMElement ) iter . next ( ) ; OMAttribute attName = propEle . getAttribute ( MediatorProperty . ATT_NAME_Q ) ; OMAttribute attValue = propEle . getAttribute ( MediatorProperty . ATT_VALUE_Q ) ; OMAttribute attExpr = propEle . getAttribute ( MediatorProperty . ATT_EXPR_Q ) ; MediatorProperty prop = new MediatorProperty ( ) ; if ( attName == null || attName . getAttributeValue ( ) == null || attName . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) { String msg = "Entry name is a required attribute for a Log property" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { prop . setName ( attName . getAttributeValue ( ) ) ; } if ( attValue != null ) { if ( attValue . getAttributeValue ( ) == null || attValue . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) { String msg = "Entry attribute value (if specified) is required for a Log property" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { prop . setValue ( attValue . getAttributeValue ( ) ) ; } } else if ( attExpr != null ) { if ( attExpr . getAttributeValue ( ) == null || attExpr . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) { String msg = "Entry attribute expression (if specified) is required for a mediator property" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { try { AXIOMXPath xp = new AXIOMXPath ( attExpr . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , propEle , log ) ; prop . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPapth expression : " + attExpr . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg , e ) ; } } } else { String msg = "Entry attribute value OR expression must be specified for a mediator property" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propertyList . add ( prop ) ; } return propertyList ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . FailoverEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . util . ArrayList ; import java . util . Iterator ; public class FailoverEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( FailoverEndpointFactory . class ) ; private static FailoverEndpointFactory instance = new FailoverEndpointFactory ( ) ; private FailoverEndpointFactory ( ) { } public static FailoverEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { OMElement failoverElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "failover" ) ) ; if ( failoverElement != null ) { FailoverEndpoint failoverEndpoint = new FailoverEndpoint ( ) ; String name = epConfig . getAttributeValue ( new QName ( "name" ) ) ; if ( name != null ) { failoverEndpoint . setName ( name ) ; } ArrayList endpoints = getEndpoints ( failoverElement , failoverEndpoint ) ; failoverEndpoint . setEndpoints ( endpoints ) ; return failoverEndpoint ; } return null ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } private ArrayList getEndpoints ( OMElement failoverElement , Endpoint parent ) { ArrayList endpoints = new ArrayList ( ) ; Iterator iter = failoverElement . getChildrenWithName ( org . apache . synapse . config . xml . Constants . ENDPOINT_ELT ) ; while ( iter . hasNext ( ) ) { OMElement endptElem = ( OMElement ) iter . next ( ) ; EndpointFactory epFac = EndpointAbstractFactory . getEndpointFactroy ( endptElem ) ; Endpoint endpoint = epFac . createEndpoint ( endptElem , true ) ; endpoint . setParentEndpoint ( parent ) ; endpoints . add ( endpoint ) ; } return endpoints ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . base . SynapseMediator ; import javax . xml . namespace . QName ; public class SynapseMediatorFactory extends AbstractListMediatorFactory { private final static QName RULES_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "rules" ) ; public QName getTagQName ( ) { return RULES_Q ; } public Mediator createMediator ( OMElement elem ) { SynapseMediator sm = new SynapseMediator ( ) ; initMediator ( sm , elem ) ; addChildren ( elem , sm ) ; return sm ; } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . endpoints . dispatch ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . MessageContext ; public interface Dispatcher { public Endpoint getEndpoint ( MessageContext synCtx ) ; public void updateSession ( MessageContext synCtx , Endpoint endpoint ) ; public void unbind ( MessageContext synCtx ) ; public boolean isServerInitiatedSession ( ) ; } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . registry . url ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . registry . AbstractRegistry ; import org . apache . synapse . registry . Registry ; import org . apache . synapse . registry . RegistryEntry ; import javax . xml . stream . XMLInputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import java . io . * ; import java . net . * ; import java . util . ArrayList ; public class SimpleURLRegistry extends AbstractRegistry implements Registry { private static final Log log = LogFactory . getLog ( SimpleURLRegistry . class ) ; private static final int MAX_KEYS = 200 ; public OMNode lookup ( String key ) { log . info ( "==> Repository fetch of resource with key : " + key ) ; URLConnection urlc = null ; try { URL url = new URL ( getRoot ( ) + key ) ; urlc = url . openConnection ( ) ; urlc . connect ( ) ; } catch ( IOException e ) { return null ; } try { XMLStreamReader parser = XMLInputFactory . newInstance ( ) . createXMLStreamReader ( urlc . getInputStream ( ) ) ; StAXOMBuilder builder = new StAXOMBuilder ( parser ) ; return builder . getDocumentElement ( ) ; } catch ( MalformedURLException e ) { handleException ( "Invalid URL reference " + getRoot ( ) + key , e ) ; } catch ( FileNotFoundException fnf ) { return null ; } catch ( IOException e ) { handleException ( "IO Error reading from URL " + getRoot ( ) + key , e ) ; } catch ( XMLStreamException e ) { handleException ( "XML Error reading from URL " + getRoot ( ) + key , e ) ; } return null ; } public RegistryEntry getRegistryEntry ( String key ) { log . debug ( "Perform RegistryEntry lookup for key : " + key ) ; try { URL url = new URL ( getRoot ( ) + key ) ; URLConnection urlc = url . openConnection ( ) ; urlc . setReadTimeout ( 30000 ) ; urlc . setRequestProperty ( "Connection" , "Close" ) ; URLRegistryEntry wre = new URLRegistryEntry ( ) ; wre . setKey ( key ) ; wre . setName ( url . getFile ( ) ) ; wre . setType ( new URI ( urlc . getContentType ( ) ) ) ; wre . setDescription ( "Resource at : " + url . toString ( ) ) ; wre . setLastModified ( urlc . getLastModified ( ) ) ; wre . setVersion ( urlc . getLastModified ( ) ) ; if ( urlc . getExpiration ( ) > 0 ) { wre . setCachableDuration ( urlc . getExpiration ( ) - System . currentTimeMillis ( ) ) ; } else { wre . setCachableDuration ( getCachableDuration ( ) ) ; } return wre ; } catch ( MalformedURLException e ) { handleException ( "Invalid URL reference " + getRoot ( ) + key , e ) ; } catch ( IOException e ) { handleException ( "IO Error reading from URL " + getRoot ( ) + key , e ) ; } catch ( URISyntaxException e ) { handleException ( "URI Syntax error reading from URL " + getRoot ( ) + key , e ) ; } return null ; } public void addConfigProperty ( String name , String value ) { if ( name . equals ( "root" ) ) { try { URL url = new URL ( value ) ; if ( url . getProtocol ( ) . equals ( "file" ) ) { if ( ! value . endsWith ( "/" ) ) { value = value + "/" ; } } } catch ( MalformedURLException e ) { } } super . addConfigProperty ( name , value ) ; } public String getRoot ( ) { String root = ( String ) properties . get ( "root" ) ; if ( root == null ) { return "" ; } else { return root ; } } public long getCachableDuration ( ) { String cachableDuration = ( String ) properties . get ( "cachableDuration" ) ; return cachableDuration == null ? 1500 : Long . parseLong ( cachableDuration ) ; } public RegistryEntry [ ] getChildren ( RegistryEntry entry ) { try { URL url ; if ( entry == null ) { URLRegistryEntry urlEntry = new URLRegistryEntry ( ) ; urlEntry . setKey ( "" ) ; entry = urlEntry ; } url = new URL ( getRoot ( ) + entry . getKey ( ) ) ; if ( url . getProtocol ( ) . equals ( "file" ) ) { File file = new File ( url . getFile ( ) ) ; if ( file . isDirectory ( ) == false ) { return null ; } InputStream inStream = null ; try { inStream = ( InputStream ) url . getContent ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inStream ) ) ; ArrayList entryList = new ArrayList ( ) ; String key = "" ; while ( ( key = reader . readLine ( ) ) != null ) { URLRegistryEntry registryEntry = new URLRegistryEntry ( ) ; if ( entry . getKey ( ) . equals ( "" ) ) { registryEntry . setKey ( key ) ; } else { if ( entry . getKey ( ) . endsWith ( "/" ) ) { registryEntry . setKey ( entry . getKey ( ) + key ) ; } else { registryEntry . setKey ( entry . getKey ( ) + "/" + key ) ; } } entryList . add ( registryEntry ) ; } RegistryEntry [ ] entries = new RegistryEntry [ entryList . size ( ) ] ; for ( int i = 0 ; i < entryList . size ( ) ; i ++ ) { entries [ i ] = ( RegistryEntry ) entryList . get ( i ) ; } return entries ; } catch ( Exception e ) { throw new SynapseException ( "Error in reading the URL." ) ; } } else { throw new SynapseException ( "Invalid protocol." ) ; } } catch ( MalformedURLException e ) { handleException ( "Invalid URL reference " + getRoot ( ) + entry . getKey ( ) , e ) ; } return null ; } public RegistryEntry [ ] getDescendants ( RegistryEntry entry ) { ArrayList list = new ArrayList ( ) ; RegistryEntry [ ] entries = getChildren ( entry ) ; if ( entries != null ) { for ( int i = 0 ; i < entries . length ; i ++ ) { if ( list . size ( ) > MAX_KEYS ) { break ; } fillDescendants ( entries [ i ] , list ) ; } } RegistryEntry [ ] descendants = new RegistryEntry [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { descendants [ i ] = ( RegistryEntry ) list . get ( i ) ; } return descendants ; } private void fillDescendants ( RegistryEntry parent , ArrayList list ) { RegistryEntry [ ] entries = getChildren ( parent ) ; if ( entries != null ) { for ( int i = 0 ; i < entries . length ; i ++ ) { if ( list . size ( ) > MAX_KEYS ) { break ; } fillDescendants ( entries [ i ] , list ) ; } } else { list . add ( parent ) ; } } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; public interface MediatorSerializer { public OMElement serializeMediator ( OMElement parent , Mediator m ) ; public String getMediatorClassName ( ) ; } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . endpoints . algorithms ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . Endpoint ; import java . util . ArrayList ; public class RoundRobin implements LoadbalanceAlgorithm { private ArrayList endpoints = null ; private int currentEPR = 0 ; public RoundRobin ( ArrayList endpoints ) { this . endpoints = endpoints ; } public Endpoint getNextEndpoint ( MessageContext synapseMessageContext ) { Endpoint nextEndpoint = null ; int attempts = 0 ; do { synchronized ( this ) { nextEndpoint = ( Endpoint ) endpoints . get ( currentEPR ) ; if ( currentEPR == endpoints . size ( ) - 1 ) { currentEPR = 0 ; } else { currentEPR ++ ; } } attempts ++ ; if ( attempts > endpoints . size ( ) ) { return null ; } } while ( ! nextEndpoint . isActive ( synapseMessageContext ) ) ; return nextEndpoint ; } public void reset ( ) { currentEPR = 0 ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . HeaderMediator ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . util . Iterator ; public class HeaderMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( HeaderMediatorFactory . class ) ; private static final QName HEADER_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "header" ) ; public Mediator createMediator ( OMElement elem ) { HeaderMediator headerMediator = new HeaderMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute exprn = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null || name . getAttributeValue ( ) == null ) { String msg = "A valid name attribute is required for the header mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { String nameAtt = name . getAttributeValue ( ) ; int colonPos = nameAtt . indexOf ( ":" ) ; if ( colonPos != - 1 ) { String prefix = nameAtt . substring ( 0 , colonPos ) ; Iterator it = elem . getAllDeclaredNamespaces ( ) ; while ( it . hasNext ( ) ) { OMNamespace n = ( OMNamespace ) it . next ( ) ; if ( prefix . equals ( n . getPrefix ( ) ) ) { headerMediator . setQName ( new QName ( n . getNamespaceURI ( ) , nameAtt . substring ( colonPos + 1 ) , prefix ) ) ; } } } else { headerMediator . setQName ( new QName ( nameAtt ) ) ; } } initMediator ( headerMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { headerMediator . setAction ( HeaderMediator . ACTION_REMOVE ) ; } if ( headerMediator . getAction ( ) == HeaderMediator . ACTION_SET && value == null && exprn == null ) { String msg = "A 'value' or 'expression' attribute is required for a [set] header mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } if ( value != null && value . getAttributeValue ( ) != null ) { headerMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( exprn != null && exprn . getAttributeValue ( ) != null ) { try { AXIOMXPath xp = new AXIOMXPath ( exprn . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; headerMediator . setExpression ( xp ) ; } catch ( JaxenException je ) { String msg = "Invalid XPath expression : " + exprn . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg , je ) ; } } return headerMediator ; } public QName getTagQName ( ) { return HEADER_Q ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . registry ; import org . apache . axiom . om . OMNode ; import org . apache . synapse . config . Entry ; import java . util . Map ; public interface Registry { public OMNode lookup ( String key ) ; public Object getResource ( Entry entry ) ; public RegistryEntry getRegistryEntry ( String key ) ; public void addConfigProperty ( String name , String value ) ; public RegistryEntry [ ] getChildren ( RegistryEntry entry ) ; public RegistryEntry [ ] getDescendants ( RegistryEntry entry ) ; public String getProviderClass ( ) ; public Map getConfigProperties ( ) ; } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . LoadbalanceEndpoint ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . algorithms . RoundRobin ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import java . util . ArrayList ; import java . util . List ; public class LoadbalanceEndpointSerializer implements EndpointSerializer { private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof LoadbalanceEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; LoadbalanceEndpoint loadbalanceEndpoint = ( LoadbalanceEndpoint ) endpoint ; String name = loadbalanceEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } OMElement loadbalanceElement = fac . createOMElement ( "loadbalance" , Constants . SYNAPSE_OMNAMESPACE ) ; endpointElement . addChild ( loadbalanceElement ) ; LoadbalanceAlgorithm algorithm = loadbalanceEndpoint . getAlgorithm ( ) ; String algorithmName = "roundRobin" ; if ( algorithm instanceof RoundRobin ) { algorithmName = "roundRobin" ; } loadbalanceElement . addAttribute ( org . apache . synapse . config . xml . Constants . ALGORITHM_NAME , algorithmName , null ) ; if ( ! loadbalanceEndpoint . isFailover ( ) ) { loadbalanceElement . addAttribute ( "failover" , "false" , null ) ; } List endpoints = loadbalanceEndpoint . getEndpoints ( ) ; for ( int i = 0 ; i < endpoints . size ( ) ; i ++ ) { Endpoint childEndpoint = ( Endpoint ) endpoints . get ( i ) ; EndpointSerializer serializer = EndpointAbstractSerializer . getEndpointSerializer ( childEndpoint ) ; OMElement aeElement = serializer . serializeEndpoint ( childEndpoint ) ; loadbalanceElement . addChild ( aeElement ) ; } return endpointElement ; } } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . OMElementUtils ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . builtin . ValidateMediator ; import org . apache . synapse . config . xml . AbstractListMediatorFactory ; import org . apache . synapse . config . xml . Constants ; import org . apache . synapse . config . xml . MediatorPropertyFactory ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class ValidateMediatorFactory extends AbstractListMediatorFactory { private static final Log log = LogFactory . getLog ( ValidateMediatorFactory . class ) ; private static final QName VALIDATE_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "validate" ) ; private static final QName ON_FAIL_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "on-fail" ) ; private static final QName SCHEMA_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "schema" ) ; private static final QName KEY_Q = new QName ( Constants . NULL_NAMESPACE , "key" ) ; private static final QName SOURCE_Q = new QName ( Constants . NULL_NAMESPACE , "source" ) ; public Mediator createMediator ( OMElement elem ) { ValidateMediator validateMediator = new ValidateMediator ( ) ; List schemaKeys = new ArrayList ( ) ; Iterator schemas = elem . getChildrenWithName ( SCHEMA_Q ) ; while ( schemas . hasNext ( ) ) { Object o = schemas . next ( ) ; if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; OMAttribute keyAtt = omElem . getAttribute ( KEY_Q ) ; if ( keyAtt != null ) { schemaKeys . add ( keyAtt . getAttributeValue ( ) ) ; } else { handleException ( "A 'schema' definition must contain a local property 'key'" ) ; } } else { handleException ( "Invalid 'schema' declaration for validate mediator" ) ; } } if ( schemaKeys . size ( ) == 0 ) { handleException ( "No schemas specified for the validate mediator" ) ; } else { validateMediator . setSchemaKeys ( schemaKeys ) ; } OMAttribute attSource = elem . getAttribute ( SOURCE_Q ) ; if ( attSource != null ) { try { AXIOMXPath xp = new AXIOMXPath ( attSource . getAttributeValue ( ) ) ; validateMediator . setSource ( xp ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; } catch ( JaxenException e ) { handleException ( "Invalid XPath expression specified for attribute 'source'" , e ) ; } } OMElement onFail = null ; Iterator iter = elem . getChildrenWithName ( ON_FAIL_Q ) ; if ( iter . hasNext ( ) ) { onFail = ( OMElement ) iter . next ( ) ; } if ( onFail != null && onFail . getChildElements ( ) . hasNext ( ) ) { addChildren ( onFail , validateMediator ) ; } else { handleException ( "A non-empty <on-fail> child element is required for " + "the <validate> mediator" ) ; } initMediator ( validateMediator , elem ) ; validateMediator . addAllProperties ( MediatorPropertyFactory . getMediatorProperties ( elem ) ) ; return validateMediator ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public QName getTagQName ( ) { return VALIDATE_Q ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . synapse . Mediator ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import javax . xml . namespace . QName ; public abstract class AbstractMediatorFactory implements MediatorFactory { protected void initMediator ( Mediator mediator , OMElement mediatorOmElement ) { OMAttribute trace = mediatorOmElement . getAttribute ( new QName ( Constants . NULL_NAMESPACE , Constants . TRACE_ATTRIB_NAME ) ) ; if ( trace != null ) { String traceValue = trace . getAttributeValue ( ) ; if ( traceValue != null ) { if ( traceValue . equals ( Constants . TRACE_ENABLE ) ) { mediator . setTraceState ( org . apache . synapse . Constants . TRACING_ON ) ; } else if ( traceValue . equals ( Constants . TRACE_DISABLE ) ) { mediator . setTraceState ( org . apache . synapse . Constants . TRACING_OFF ) ; } } } } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . mediators . base ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . impl . SequenceStatisticsStack ; import java . util . Stack ; public class SequenceMediator extends AbstractListMediator { private static final Log log = LogFactory . getLog ( SequenceMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String name = null ; private String key = null ; private String errorHandler = null ; private boolean dynamic = false ; private String registryKey = null ; private int statisticsEnable = Constants . STATISTICS_UNSET ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Sequence mediator <" + ( name == null ? "anonymous" : name ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( key == null ) { boolean isStatisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == statisticsEnable ) ; if ( isStatisticsEnable ) { StatisticsStack sequenceStack = ( StatisticsStack ) synCtx . getProperty ( Constants . SEQUENCE_STATISTICS_STACK ) ; if ( sequenceStack == null ) { sequenceStack = new SequenceStatisticsStack ( ) ; synCtx . setProperty ( Constants . SEQUENCE_STATISTICS_STACK , sequenceStack ) ; } String seqName = ( name == null ? Constants . ANONYMOUS_SEQUENCES : name ) ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; sequenceStack . put ( seqName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , isStatisticsEnable , isFault ) ; } try { if ( shouldTrace ) { trace . trace ( "Start : Sequence <" + ( name == null ? "anonymous" : name ) + ">" ) ; } if ( errorHandler != null ) { log . debug ( "Setting the onError handler for the sequence" ) ; synCtx . pushFaultHandler ( new MediatorFaultHandler ( synCtx . getSequence ( errorHandler ) ) ) ; } boolean ret = super . mediate ( synCtx ) ; Stack faultStack = synCtx . getFaultStack ( ) ; if ( errorHandler != null && ! faultStack . isEmpty ( ) ) { Object o = faultStack . peek ( ) ; if ( o instanceof MediatorFaultHandler && synCtx . getSequence ( errorHandler ) . equals ( ( ( MediatorFaultHandler ) o ) . getFaultMediator ( ) ) ) { faultStack . pop ( ) ; } } return ret ; } finally { if ( isStatisticsEnable ) { StatisticsUtils . processSequenceStatistics ( synCtx ) ; } StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; if ( shouldTrace ) { trace . trace ( "End : Sequence <" + ( name == null ? "anonymous" : name ) + ">" ) ; } } } else { Mediator m = synCtx . getSequence ( key ) ; if ( m == null ) { if ( shouldTrace ) { trace . trace ( "Sequence named " + key + " cannot be found." ) ; } handleException ( "Sequence named " + key + " cannot be found." ) ; } else { if ( shouldTrace ) { trace . trace ( "Executing sequence named " + key ) ; } return m . mediate ( synCtx ) ; } } return false ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getErrorHandler ( ) { return errorHandler ; } public void setErrorHandler ( String errorHandler ) { this . errorHandler = errorHandler ; } public int getStatisticsEnable ( ) { return statisticsEnable ; } public void setStatisticsEnable ( int statisticsEnable ) { this . statisticsEnable = statisticsEnable ; } public boolean isDynamic ( ) { return dynamic ; } public void setDynamic ( boolean dynamic ) { this . dynamic = dynamic ; } public String getRegistryKey ( ) { return registryKey ; } public void setRegistryKey ( String registryKey ) { this . registryKey = registryKey ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMNamespace ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . xml . endpoints . EndpointAbstractSerializer ; import org . apache . synapse . core . axis2 . ProxyService ; import javax . xml . stream . XMLStreamException ; import java . io . OutputStream ; import java . util . Iterator ; import java . util . Map ; import java . util . HashMap ; public class XMLConfigurationSerializer { private static final Log log = LogFactory . getLog ( XMLConfigurationSerializer . class ) ; private static final OMFactory fac = OMAbstractFactory . getOMFactory ( ) ; private static final OMNamespace synNS = fac . createOMNamespace ( Constants . SYNAPSE_NAMESPACE , "syn" ) ; private static final OMNamespace nullNS = fac . createOMNamespace ( Constants . NULL_NAMESPACE , "" ) ; public static void serializeConfiguration ( SynapseConfiguration synCfg , OutputStream outputStream ) throws XMLStreamException { OMElement definitions = fac . createOMElement ( "definitions" , synNS ) ; if ( synCfg . getRegistry ( ) != null ) { RegistrySerializer . serializeRegistry ( definitions , synCfg . getRegistry ( ) ) ; } Iterator iter = synCfg . getProxyServices ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ProxyService service = ( ProxyService ) iter . next ( ) ; ProxyServiceSerializer . serializeProxy ( definitions , service ) ; } Map entries = new HashMap ( ) ; Map endpoints = new HashMap ( ) ; Map sequences = new HashMap ( ) ; iter = synCfg . getLocalRegistry ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; Object o = synCfg . getLocalRegistry ( ) . get ( key ) ; if ( o instanceof Mediator ) { sequences . put ( key , o ) ; } else if ( o instanceof Endpoint ) { endpoints . put ( key , o ) ; } else if ( o instanceof Entry ) { entries . put ( key , o ) ; } else { handleException ( "Unknown object : " + o . getClass ( ) + " for serialization into Synapse configuration" ) ; } } serializeEntries ( definitions , entries ) ; serializeEndpoints ( definitions , endpoints ) ; serializeSequences ( definitions , sequences ) ; definitions . serialize ( outputStream ) ; } private static void serializeEntries ( OMElement definitions , Map entries ) { Iterator iter = entries . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = ( String ) iter . next ( ) ; EntrySerializer . serializeEntry ( ( Entry ) entries . get ( key ) , definitions ) ; } } private static void serializeEndpoints ( OMElement definitions , Map endpoints ) { Iterator iter = endpoints . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = ( String ) iter . next ( ) ; Object o = endpoints . get ( key ) ; if ( o instanceof Endpoint ) { Endpoint endpoint = ( Endpoint ) o ; OMElement epElement = EndpointAbstractSerializer . getEndpointSerializer ( endpoint ) . serializeEndpoint ( endpoint ) ; definitions . addChild ( epElement ) ; } } } private static void serializeSequences ( OMElement definitions , Map sequences ) { Iterator iter = sequences . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = ( String ) iter . next ( ) ; Mediator mediator = ( Mediator ) sequences . get ( key ) ; MediatorSerializerFinder . getInstance ( ) . getSerializer ( mediator ) . serializeMediator ( definitions , mediator ) ; } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse . statistics . impl ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . StatisticsCollector ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class SequenceStatisticsStack implements StatisticsStack { private List sequenceStatisticsList = new ArrayList ( ) ; public void put ( String sequenceName , long initTime , boolean isInFlow , boolean isStatisticsEnable , boolean isFault ) { sequenceStatisticsList . add ( new SequenceStatistics ( sequenceName , initTime , isInFlow , isStatisticsEnable , isFault ) ) ; } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { int top = sequenceStatisticsList . size ( ) ; if ( top > 0 ) { popSequenceStatistics ( sequenceStatisticsList . size ( ) - 1 , statisticsCollector ) ; } } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault , String name ) { if ( ! sequenceStatisticsList . isEmpty ( ) ) { List tobeRemoved = new ArrayList ( ) ; for ( Iterator seqIterator = sequenceStatisticsList . iterator ( ) ; seqIterator . hasNext ( ) ; ) { SequenceStatistics sequenceStatistics = ( SequenceStatistics ) seqIterator . next ( ) ; if ( sequenceStatistics != null ) { if ( sequenceStatistics . isStatisticsEnable && sequenceStatistics . sequenceName != null && sequenceStatistics . sequenceName . equals ( name ) ) { statisticsCollector . reportForSequence ( sequenceStatistics . sequenceName , ! sequenceStatistics . isInFlow , sequenceStatistics . initTime , System . currentTimeMillis ( ) , sequenceStatistics . isFault ) ; } tobeRemoved . add ( sequenceStatistics ) ; } } sequenceStatisticsList . removeAll ( tobeRemoved ) ; } } public void reportAllToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { int i = sequenceStatisticsList . size ( ) - 1 ; for ( ; i >= 0 ; i -- ) { popSequenceStatistics ( i , statisticsCollector ) ; } } private void popSequenceStatistics ( int index , StatisticsCollector statisticsCollector ) { if ( index >= 0 ) { SequenceStatistics sequenceStatistics = ( SequenceStatistics ) sequenceStatisticsList . get ( index ) ; if ( sequenceStatistics != null ) { if ( sequenceStatistics . isStatisticsEnable && sequenceStatistics . sequenceName != null ) { statisticsCollector . reportForSequence ( sequenceStatistics . sequenceName , ! sequenceStatistics . isInFlow , sequenceStatistics . initTime , System . currentTimeMillis ( ) , sequenceStatistics . isFault ) ; } sequenceStatisticsList . remove ( index ) ; } } } class SequenceStatistics { String sequenceName ; long initTime ; boolean isInFlow ; boolean isStatisticsEnable ; private boolean isFault ; public SequenceStatistics ( String sequenceName , long initTime , boolean inFlow , boolean statisticsEnable , boolean isFault ) { this . sequenceName = sequenceName ; this . initTime = initTime ; isInFlow = inFlow ; isStatisticsEnable = statisticsEnable ; this . isFault = isFault ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; final SequenceStatistics that = ( SequenceStatistics ) o ; if ( ! sequenceName . equals ( that . sequenceName ) ) return false ; return true ; } public int hashCode ( ) { return sequenceName . hashCode ( ) ; } } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . HandlerDescription ; import org . apache . axis2 . engine . AbstractDispatcher ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class SynapseDispatcher extends AbstractDispatcher { private static final Log log = LogFactory . getLog ( SynapseDispatcher . class ) ; private static final long serialVersionUID = - 6970206989111592645L ; private static final String SYNAPSE_SERVICE_NAME = "synapse" ; private static final QName MEDIATE_OPERATION_NAME = new QName ( "mediate" ) ; public void initDispatcher ( ) { QName qn = new QName ( "http://synapse.apache.org" , "SynapseDispatcher" ) ; HandlerDescription hd = new HandlerDescription ( qn . getLocalPart ( ) ) ; super . init ( hd ) ; } public AxisService findService ( MessageContext mc ) throws AxisFault { AxisConfiguration ac = mc . getConfigurationContext ( ) . getAxisConfiguration ( ) ; AxisService as = ac . getService ( SYNAPSE_SERVICE_NAME ) ; return as ; } public AxisOperation findOperation ( AxisService svc , MessageContext mc ) throws AxisFault { AxisOperation ao = svc . getOperation ( MEDIATE_OPERATION_NAME ) ; return ao ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . FilterMediator ; public class FilterMediatorSerializer extends AbstractListMediatorSerializer { private static final Log log = LogFactory . getLog ( FilterMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof FilterMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } FilterMediator mediator = ( FilterMediator ) m ; OMElement filter = fac . createOMElement ( "filter" , synNS ) ; if ( mediator . getSource ( ) != null && mediator . getRegex ( ) != null ) { filter . addAttribute ( fac . createOMAttribute ( "source" , nullNS , mediator . getSource ( ) . toString ( ) ) ) ; super . serializeNamespaces ( filter , mediator . getSource ( ) ) ; filter . addAttribute ( fac . createOMAttribute ( "regex" , nullNS , mediator . getRegex ( ) . pattern ( ) ) ) ; } else if ( mediator . getXpath ( ) != null ) { filter . addAttribute ( fac . createOMAttribute ( "xpath" , nullNS , mediator . getXpath ( ) . toString ( ) ) ) ; super . serializeNamespaces ( filter , mediator . getXpath ( ) ) ; } else { handleException ( "Invalid filter mediator. " + "Should have either a 'source' and a 'regex' OR an 'xpath' " ) ; } finalizeSerialization ( filter , mediator ) ; serializeChildren ( filter , mediator . getList ( ) ) ; if ( parent != null ) { parent . addChild ( filter ) ; } return filter ; } public String getMediatorClassName ( ) { return FilterMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . endpoints . algorithms ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . Endpoint ; public interface LoadbalanceAlgorithm { public Endpoint getNextEndpoint ( MessageContext synapseMessageContext ) ; public void reset ( ) ; } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . * ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . xml . endpoints . EndpointAbstractSerializer ; import org . apache . synapse . config . xml . endpoints . EndpointSerializer ; import org . apache . synapse . core . axis2 . ProxyService ; import java . util . Iterator ; import java . util . ArrayList ; import java . net . URI ; public class ProxyServiceSerializer { private static final Log log = LogFactory . getLog ( PropertyMediatorSerializer . class ) ; protected static final OMFactory fac = OMAbstractFactory . getOMFactory ( ) ; protected static final OMNamespace synNS = fac . createOMNamespace ( Constants . SYNAPSE_NAMESPACE , "syn" ) ; protected static final OMNamespace nullNS = fac . createOMNamespace ( Constants . NULL_NAMESPACE , "" ) ; public static OMElement serializeProxy ( OMElement parent , ProxyService service ) { OMElement proxy = fac . createOMElement ( "proxy" , synNS ) ; if ( service . getName ( ) != null ) { proxy . addAttribute ( fac . createOMAttribute ( "name" , nullNS , service . getName ( ) ) ) ; } else { handleException ( "Invalid proxy service. Service name is required" ) ; } String descriptionStr = service . getDescription ( ) ; if ( descriptionStr != null ) { OMElement description = fac . createOMElement ( "description" , synNS ) ; description . addChild ( fac . createOMText ( descriptionStr ) ) ; proxy . addChild ( description ) ; } ArrayList transports = service . getTransports ( ) ; if ( transports != null && ! transports . isEmpty ( ) ) { String transportStr = "" + transports . get ( 0 ) ; for ( int i = 1 ; i < transports . size ( ) ; i ++ ) { transportStr = transportStr + " " + transports . get ( i ) ; } proxy . addAttribute ( fac . createOMAttribute ( "transports" , nullNS , transportStr ) ) ; } if ( service . isStartOnLoad ( ) ) { proxy . addAttribute ( fac . createOMAttribute ( "startOnLoad" , nullNS , "true" ) ) ; } else { proxy . addAttribute ( fac . createOMAttribute ( "startOnLoad" , nullNS , "false" ) ) ; } String endpoint = service . getTargetEndpoint ( ) ; OMElement target = fac . createOMElement ( "target" , synNS ) ; Endpoint inLineEndpoint = service . getTargetInLineEndpoint ( ) ; if ( endpoint != null ) { target . addAttribute ( fac . createOMAttribute ( "endpoint" , nullNS , endpoint ) ) ; proxy . addChild ( target ) ; } else if ( inLineEndpoint != null ) { EndpointSerializer serializer = EndpointAbstractSerializer . getEndpointSerializer ( inLineEndpoint ) ; OMElement epElement = serializer . serializeEndpoint ( inLineEndpoint ) ; target . addChild ( epElement ) ; proxy . addChild ( target ) ; } String inSeq = service . getTargetInSequence ( ) ; String outSeq = service . getTargetOutSequence ( ) ; String faultSeq = service . getTargetFaultSequence ( ) ; SequenceMediatorSerializer serializer = new SequenceMediatorSerializer ( ) ; if ( inSeq != null ) { target . addAttribute ( fac . createOMAttribute ( "inSequence" , nullNS , inSeq ) ) ; proxy . addChild ( target ) ; } else { SequenceMediator inLineInSeq = service . getTargetInLineInSequence ( ) ; if ( inLineInSeq != null ) { OMElement inSeqElement = serializer . serializeAnonymousSequence ( null , inLineInSeq ) ; inSeqElement . setLocalName ( "inSequence" ) ; target . addChild ( inSeqElement ) ; proxy . addChild ( target ) ; } } if ( outSeq != null ) { target . addAttribute ( fac . createOMAttribute ( "outSequence" , nullNS , outSeq ) ) ; proxy . addChild ( target ) ; } else { SequenceMediator inLineOutSeq = service . getTargetInLineOutSequence ( ) ; if ( inLineOutSeq != null ) { OMElement outSeqElement = serializer . serializeAnonymousSequence ( null , inLineOutSeq ) ; outSeqElement . setLocalName ( "outSequence" ) ; target . addChild ( outSeqElement ) ; proxy . addChild ( target ) ; } } if ( faultSeq != null ) { target . addAttribute ( fac . createOMAttribute ( "faultSequence" , nullNS , faultSeq ) ) ; proxy . addChild ( target ) ; } else { SequenceMediator inLineFaultSeq = service . getTargetInLineFaultSequence ( ) ; if ( inLineFaultSeq != null ) { OMElement faultSeqElement = serializer . serializeAnonymousSequence ( null , inLineFaultSeq ) ; faultSeqElement . setLocalName ( "faultSequence" ) ; target . addChild ( faultSeqElement ) ; proxy . addChild ( target ) ; } } String wsdlKey = service . getWSDLKey ( ) ; URI wsdlUri = service . getWsdlURI ( ) ; Object inLineWSDL = service . getInLineWSDL ( ) ; OMElement wsdl = fac . createOMElement ( "publishWSDL" , synNS ) ; if ( wsdlKey != null ) { wsdl . addAttribute ( fac . createOMAttribute ( "key" , nullNS , wsdlKey ) ) ; proxy . addChild ( wsdl ) ; } else if ( inLineWSDL != null ) { wsdl . addChild ( ( OMNode ) inLineWSDL ) ; proxy . addChild ( wsdl ) ; } else if ( wsdlUri != null ) { wsdl . addAttribute ( fac . createOMAttribute ( "uri" , nullNS , wsdlUri . toString ( ) ) ) ; proxy . addChild ( wsdl ) ; } Iterator iter = service . getServiceLevelPolicies ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String policyKey = ( String ) iter . next ( ) ; OMElement policy = fac . createOMElement ( "policy" , synNS ) ; policy . addAttribute ( fac . createOMAttribute ( "key" , nullNS , policyKey ) ) ; proxy . addChild ( policy ) ; } iter = service . getParameterMap ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String propertyName = ( String ) iter . next ( ) ; OMElement property = fac . createOMElement ( "parameter" , synNS ) ; property . addAttribute ( fac . createOMAttribute ( "name" , nullNS , propertyName ) ) ; Object value = service . getParameterMap ( ) . get ( propertyName ) ; if ( value != null ) { if ( value instanceof String ) { property . setText ( ( ( String ) value ) . trim ( ) ) ; proxy . addChild ( property ) ; } else if ( value instanceof OMNode ) { property . addChild ( ( OMNode ) value ) ; proxy . addChild ( property ) ; } } } if ( service . isWsRMEnabled ( ) ) { proxy . addChild ( fac . createOMElement ( "enableRM" , synNS ) ) ; } if ( service . isWsSecEnabled ( ) ) { proxy . addChild ( fac . createOMElement ( "enableSec" , synNS ) ) ; } int isEnableStatistics = service . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { proxy . addAttribute ( fac . createOMAttribute ( Constants . STATISTICS_ATTRIB_NAME , nullNS , statisticsValue ) ) ; } int traceState = service . getTraceState ( ) ; String traceValue = null ; if ( traceState == org . apache . synapse . Constants . TRACING_ON ) { traceValue = Constants . TRACE_ENABLE ; } else if ( traceState == org . apache . synapse . Constants . TRACING_OFF ) { traceValue = Constants . TRACE_DISABLE ; } if ( traceValue != null ) { proxy . addAttribute ( fac . createOMAttribute ( Constants . TRACE_ATTRIB_NAME , nullNS , traceValue ) ) ; } if ( parent != null ) { parent . addChild ( proxy ) ; } return proxy ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . SwitchMediator ; import java . util . Iterator ; public class SwitchMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( SwitchMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof SwitchMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } SwitchMediator mediator = ( SwitchMediator ) m ; OMElement switchMed = fac . createOMElement ( "switch" , synNS ) ; finalizeSerialization ( switchMed , mediator ) ; if ( mediator . getSource ( ) != null ) { switchMed . addAttribute ( fac . createOMAttribute ( "source" , nullNS , mediator . getSource ( ) . toString ( ) ) ) ; super . serializeNamespaces ( switchMed , mediator . getSource ( ) ) ; } else { handleException ( "Invalid switch mediator. Source required" ) ; } Iterator iter = mediator . getCases ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { OMElement caseElem = fac . createOMElement ( "case" , synNS ) ; SwitchCase aCase = ( ( SwitchCase ) iter . next ( ) ) ; if ( aCase . getRegex ( ) != null ) { caseElem . addAttribute ( fac . createOMAttribute ( "regex" , nullNS , aCase . getRegex ( ) . pattern ( ) ) ) ; } else { handleException ( "Invalid switch case. Regex required" ) ; } AnonymousListMediator caseMediator = aCase . getCaseMediator ( ) ; if ( caseMediator != null ) { AnonymousListMediatorSerializer . serializeAnonymousListMediator ( caseElem , caseMediator ) ; switchMed . addChild ( caseElem ) ; } } SwitchCase defaultCase = mediator . getDefaultCase ( ) ; if ( defaultCase != null ) { OMElement caseDefaultElem = fac . createOMElement ( "default" , synNS ) ; AnonymousListMediator caseDefaultMediator = defaultCase . getCaseMediator ( ) ; if ( caseDefaultMediator != null ) { AnonymousListMediatorSerializer . serializeAnonymousListMediator ( caseDefaultElem , caseDefaultMediator ) ; switchMed . addChild ( caseDefaultElem ) ; } } if ( parent != null ) { parent . addChild ( switchMed ) ; } return switchMed ; } public String getMediatorClassName ( ) { return SwitchMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . * ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . xml . endpoints . EndpointAbstractFactory ; import org . apache . synapse . core . axis2 . ProxyService ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . mediators . builtin . SendMediator ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . mediators . builtin . LogMediator ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import java . io . IOException ; import java . io . InputStream ; import java . util . Iterator ; public class XMLConfigurationBuilder { private static Log log = LogFactory . getLog ( XMLConfigurationBuilder . class ) ; public static SynapseConfiguration getConfiguration ( InputStream is ) { log . info ( "Generating the Synapse configuration model by parsing the XML configuration" ) ; SynapseConfiguration config = new SynapseConfiguration ( ) ; SequenceMediator rootSequence = new SequenceMediator ( ) ; rootSequence . setName ( org . apache . synapse . Constants . MAIN_SEQUENCE_KEY ) ; OMElement definitions = null ; try { definitions = new StAXOMBuilder ( is ) . getDocumentElement ( ) ; definitions . build ( ) ; OMNamespace namespace = definitions . getNamespace ( ) ; if ( namespace == null ) { handleException ( "No namespace is defined for definitions element" ) ; } if ( Constants . SYNAPSE_NAMESPACE . equals ( namespace . getNamespaceURI ( ) ) && Constants . DEFINITIONS_ELT . getLocalPart ( ) . equals ( definitions . getQName ( ) . getLocalPart ( ) ) ) { Iterator iter = definitions . getChildren ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof OMElement ) { OMElement elt = ( OMElement ) o ; if ( Constants . SEQUENCE_ELT . equals ( elt . getQName ( ) ) ) { String key = elt . getAttributeValue ( new QName ( Constants . NULL_NAMESPACE , "key" ) ) ; if ( key != null ) { Mediator m = MediatorFactoryFinder . getInstance ( ) . getMediator ( elt ) ; rootSequence . addChild ( m ) ; } else { defineSequence ( config , elt ) ; } } else if ( Constants . ENDPOINT_ELT . equals ( elt . getQName ( ) ) ) { defineEndpoint ( config , elt ) ; } else if ( Constants . ENTRY_ELT . equals ( elt . getQName ( ) ) ) { defineEntry ( config , elt ) ; } else if ( Constants . PROXY_ELT . equals ( elt . getQName ( ) ) ) { defineProxy ( config , elt ) ; } else if ( Constants . REGISTRY_ELT . equals ( elt . getQName ( ) ) ) { defineRegistry ( config , elt ) ; } else { Mediator m = MediatorFactoryFinder . getInstance ( ) . getMediator ( elt ) ; rootSequence . addChild ( m ) ; } } } } else { handleException ( "Invalid Synapse Configuration : No definition element found" ) ; } } catch ( XMLStreamException e ) { handleException ( "Error parsing Synapse configuration : " + e . getMessage ( ) , e ) ; } if ( is != null ) { try { is . close ( ) ; } catch ( IOException ignore ) { } } if ( config . getLocalRegistry ( ) . isEmpty ( ) && config . getProxyServices ( ) . isEmpty ( ) && rootSequence . getList ( ) . isEmpty ( ) && config . getRegistry ( ) != null ) { OMNode remoteConfigNode = config . getRegistry ( ) . lookup ( "synapse.xml" ) ; config = getConfiguration ( Util . getStreamSource ( remoteConfigNode ) . getInputStream ( ) ) ; } if ( config . getMainSequence ( ) == null ) { if ( rootSequence . getList ( ) . isEmpty ( ) ) { setDefaultMainSequence ( config ) ; } else { config . addSequence ( rootSequence . getName ( ) , rootSequence ) ; } } else if ( ! rootSequence . getList ( ) . isEmpty ( ) ) { handleException ( "Invalid Synapse Configuration : Conflict in resolving the \"main\" " + "mediator\n\tSynapse Configuration cannot have sequence named \"main\" and " + "toplevel mediators simultaniously" ) ; } if ( config . getFaultSequence ( ) == null ) { setDefaultFaultSequence ( config ) ; } return config ; } private static void defineRegistry ( SynapseConfiguration config , OMElement elem ) { if ( config . getRegistry ( ) != null ) { handleException ( "Only one remote registry can be defined within a configuration" ) ; } config . setRegistry ( RegistryFactory . createRegistry ( elem ) ) ; } private static void defineProxy ( SynapseConfiguration config , OMElement elem ) { ProxyService proxy = ProxyServiceFactory . createProxy ( elem ) ; if ( config . getProxyService ( proxy . getName ( ) ) != null ) { handleException ( "Duplicate proxy service with name : " + proxy . getName ( ) ) ; } config . addProxyService ( proxy . getName ( ) , proxy ) ; } private static void defineEntry ( SynapseConfiguration config , OMElement elem ) { Entry entry = EntryFactory . createEntry ( elem ) ; if ( config . getLocalRegistry ( ) . get ( entry . getKey ( ) ) != null ) { handleException ( "Duplicate registry entry definition for key : " + entry . getKey ( ) ) ; } config . addEntry ( entry . getKey ( ) , entry ) ; } public static void defineSequence ( SynapseConfiguration config , OMElement ele ) { String name = ele . getAttributeValue ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { if ( config . getLocalRegistry ( ) . get ( name ) != null ) { handleException ( "Duplicate sequence definition : " + name ) ; } config . addSequence ( name , MediatorFactoryFinder . getInstance ( ) . getMediator ( ele ) ) ; } else { handleException ( "Invalid sequence definition without a name" ) ; } } public static void defineEndpoint ( SynapseConfiguration config , OMElement ele ) { String name = ele . getAttributeValue ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { if ( config . getLocalRegistry ( ) . get ( name . trim ( ) ) != null ) { handleException ( "Duplicate endpoint definition : " + name ) ; } Endpoint endpoint = EndpointAbstractFactory . getEndpointFactroy ( ele ) . createEndpoint ( ele , false ) ; config . addEndpoint ( name . trim ( ) , endpoint ) ; } else { handleException ( "Invalid endpoint definition without a name" ) ; } } private static void setDefaultMainSequence ( SynapseConfiguration config ) { SequenceMediator main = new SequenceMediator ( ) ; main . setName ( org . apache . synapse . Constants . MAIN_SEQUENCE_KEY ) ; main . addChild ( new SendMediator ( ) ) ; config . addSequence ( org . apache . synapse . Constants . MAIN_SEQUENCE_KEY , main ) ; } private static void setDefaultFaultSequence ( SynapseConfiguration config ) { SequenceMediator fault = new SequenceMediator ( ) ; fault . setName ( org . apache . synapse . Constants . FAULT_SEQUENCE_KEY ) ; LogMediator log = new LogMediator ( ) ; log . setLogLevel ( LogMediator . FULL ) ; fault . addChild ( log ) ; config . addSequence ( org . apache . synapse . Constants . FAULT_SEQUENCE_KEY , fault ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . builtin . LogMediator ; public class LogMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( LogMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof LogMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } LogMediator mediator = ( LogMediator ) m ; OMElement log = fac . createOMElement ( "log" , synNS ) ; finalizeSerialization ( log , mediator ) ; if ( mediator . getLogLevel ( ) != LogMediator . SIMPLE ) { log . addAttribute ( fac . createOMAttribute ( "level" , nullNS , mediator . getLogLevel ( ) == LogMediator . HEADERS ? "headers" : mediator . getLogLevel ( ) == LogMediator . FULL ? "full" : mediator . getLogLevel ( ) == LogMediator . CUSTOM ? "custom" : "simple" ) ) ; } if ( mediator . getSeparator ( ) != LogMediator . DEFAULT_SEP ) { log . addAttribute ( fac . createOMAttribute ( "separator" , nullNS , mediator . getSeparator ( ) ) ) ; } super . serializeProperties ( log , mediator . getProperties ( ) ) ; if ( parent != null ) { parent . addChild ( log ) ; } return log ; } public String getMediatorClassName ( ) { return LogMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import javax . xml . namespace . QName ; public class EndpointAbstractFactory { public static EndpointFactory getEndpointFactroy ( OMElement configElement ) { if ( configElement . getAttribute ( new QName ( "key" ) ) != null ) { IndirectEndpointFactory endpointFactory = IndirectEndpointFactory . getInstance ( ) ; return endpointFactory ; } OMElement addressElement = configElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointFactory endpointFactory = AddressEndpointFactory . getInstance ( ) ; return endpointFactory ; } OMElement wsdlElement = configElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "wsdl" ) ) ; if ( wsdlElement != null ) { EndpointFactory endpointFactory = WSDLEndpointFactory . getInstance ( ) ; return endpointFactory ; } OMElement lbElement = configElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "loadbalance" ) ) ; if ( lbElement != null ) { OMElement sessionElement = configElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "session" ) ) ; if ( sessionElement != null ) { EndpointFactory endpointFactory = SALoadbalanceEndpointFactory . getInstance ( ) ; return endpointFactory ; } else { EndpointFactory endpointFactory = LoadbalanceEndpointFactory . getInstance ( ) ; return endpointFactory ; } } OMElement foElement = configElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "failover" ) ) ; if ( foElement != null ) { EndpointFactory endpointFactory = FailoverEndpointFactory . getInstance ( ) ; return endpointFactory ; } throw new SynapseException ( "Invalid endpoint configuration." ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . net . URI ; import java . net . URISyntaxException ; public class FaultMediatorFactory extends AbstractMediatorFactory { private static final QName FAULT_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "makefault" ) ; private static final QName ATT_VERSION_Q = new QName ( Constants . NULL_NAMESPACE , "version" ) ; private static final QName CODE_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "code" ) ; private static final QName REASON_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "reason" ) ; private static final QName NODE_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "node" ) ; private static final QName ROLE_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "role" ) ; private static final QName DETAIL_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "detail" ) ; private static final QName ATT_VALUE_Q = new QName ( Constants . NULL_NAMESPACE , "value" ) ; private static final QName ATT_EXPR_Q = new QName ( Constants . NULL_NAMESPACE , "expression" ) ; private static final String SOAP11 = "soap11" ; private static final String SOAP12 = "soap12" ; private static final Log log = LogFactory . getLog ( FaultMediatorFactory . class ) ; public Mediator createMediator ( OMElement elem ) { FaultMediator faultMediator = new FaultMediator ( ) ; OMAttribute version = elem . getAttribute ( ATT_VERSION_Q ) ; if ( version != null ) { if ( SOAP11 . equals ( version . getAttributeValue ( ) ) ) { faultMediator . setSoapVersion ( FaultMediator . SOAP11 ) ; } else if ( SOAP12 . equals ( version . getAttributeValue ( ) ) ) { faultMediator . setSoapVersion ( FaultMediator . SOAP12 ) ; } else { String msg = "Invalid SOAP version" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMElement code = elem . getFirstChildWithName ( CODE_Q ) ; if ( code != null ) { OMAttribute value = code . getAttribute ( ATT_VALUE_Q ) ; OMAttribute expression = code . getAttribute ( ATT_EXPR_Q ) ; if ( value != null ) { String strValue = value . getAttributeValue ( ) ; String prefix , name ; if ( strValue . indexOf ( ":" ) != - 1 ) { prefix = strValue . substring ( 0 , strValue . indexOf ( ":" ) ) ; name = strValue . substring ( strValue . indexOf ( ":" ) + 1 ) ; } else { String msg = "A QName is expected for fault code as prefix:name" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } faultMediator . setFaultCodeValue ( new QName ( OMElementUtils . getNameSpaceWithPrefix ( prefix , code ) , name , prefix ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , code , log ) ; faultMediator . setFaultCodeExpr ( xp ) ; } catch ( JaxenException je ) { String msg = "Invalid fault code expression : " + je . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( msg , je ) ; } } else { String msg = "A 'value' or 'expression' attribute must specify the fault code" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } else { String msg = "The fault code is a required attribute for the makefault mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } OMElement reason = elem . getFirstChildWithName ( REASON_Q ) ; if ( reason != null ) { OMAttribute value = reason . getAttribute ( ATT_VALUE_Q ) ; OMAttribute expression = reason . getAttribute ( ATT_EXPR_Q ) ; if ( value != null ) { faultMediator . setFaultReasonValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , reason , log ) ; faultMediator . setFaultReasonExpr ( xp ) ; } catch ( JaxenException je ) { String msg = "Invalid fault reason expression : " + je . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( msg , je ) ; } } else { String msg = "A 'value' or 'expression' attribute must specify the fault code" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } else { String msg = "The fault reason is a required attribute for the makefault mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } initMediator ( faultMediator , elem ) ; OMElement node = elem . getFirstChildWithName ( NODE_Q ) ; if ( node != null && node . getText ( ) != null ) { try { faultMediator . setFaultNode ( new URI ( node . getText ( ) ) ) ; } catch ( URISyntaxException e ) { String msg = "Invalid URI specified for fault node : " + node . getText ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMElement role = elem . getFirstChildWithName ( ROLE_Q ) ; if ( role != null && role . getText ( ) != null ) { try { faultMediator . setFaultRole ( new URI ( role . getText ( ) ) ) ; } catch ( URISyntaxException e ) { String msg = "Invalid URI specified for fault role : " + role . getText ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMElement detail = elem . getFirstChildWithName ( DETAIL_Q ) ; if ( detail != null && detail . getText ( ) != null ) { faultMediator . setFaultDetail ( detail . getText ( ) ) ; } return faultMediator ; } public QName getTagQName ( ) { return FAULT_Q ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . SALoadbalanceEndpoint ; import org . apache . synapse . endpoints . dispatch . Dispatcher ; import org . apache . synapse . endpoints . dispatch . SoapSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . SimpleClientSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . HttpSessionDispatcher ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . algorithms . RoundRobin ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . util . ArrayList ; import java . util . List ; public class SALoadbalanceEndpointSerializer implements EndpointSerializer { private static final Log log = LogFactory . getLog ( SALoadbalanceEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof SALoadbalanceEndpoint ) ) { handleException ( "Invalid endpoint type for serializing. " + "Expected: SALoadbalanceEndpoint Found: " + endpoint . getClass ( ) . getName ( ) ) ; } SALoadbalanceEndpoint loadbalanceEndpoint = ( SALoadbalanceEndpoint ) endpoint ; fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; String name = loadbalanceEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } Dispatcher dispatcher = loadbalanceEndpoint . getDispatcher ( ) ; if ( dispatcher instanceof SoapSessionDispatcher ) { OMElement sessionElement = fac . createOMElement ( "session" , Constants . SYNAPSE_OMNAMESPACE ) ; sessionElement . addAttribute ( "type" , "soap" , null ) ; endpointElement . addChild ( sessionElement ) ; } else if ( dispatcher instanceof HttpSessionDispatcher ) { OMElement sessionElement = fac . createOMElement ( "session" , Constants . SYNAPSE_OMNAMESPACE ) ; sessionElement . addAttribute ( "type" , "http" , null ) ; endpointElement . addChild ( sessionElement ) ; } else if ( dispatcher instanceof SimpleClientSessionDispatcher ) { OMElement sessionElement = fac . createOMElement ( "session" , Constants . SYNAPSE_OMNAMESPACE ) ; sessionElement . addAttribute ( "type" , "simpleClientSession" , null ) ; endpointElement . addChild ( sessionElement ) ; } OMElement loadbalanceElement = fac . createOMElement ( "loadbalance" , Constants . SYNAPSE_OMNAMESPACE ) ; endpointElement . addChild ( loadbalanceElement ) ; LoadbalanceAlgorithm algorithm = loadbalanceEndpoint . getAlgorithm ( ) ; String algorithmName = "roundRobin" ; if ( algorithm instanceof RoundRobin ) { algorithmName = "roundRobin" ; } loadbalanceElement . addAttribute ( "algorithm" , algorithmName , null ) ; List endpoints = loadbalanceEndpoint . getEndpoints ( ) ; for ( int i = 0 ; i < endpoints . size ( ) ; i ++ ) { Endpoint childEndpoint = ( Endpoint ) endpoints . get ( i ) ; EndpointSerializer serializer = EndpointAbstractSerializer . getEndpointSerializer ( childEndpoint ) ; OMElement aeElement = serializer . serializeEndpoint ( childEndpoint ) ; loadbalanceElement . addChild ( aeElement ) ; } return endpointElement ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class LogMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( LogMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int CUSTOM = 0 ; public static final int SIMPLE = 1 ; public static final int HEADERS = 2 ; public static final int FULL = 3 ; public static final String DEFAULT_SEP = ", " ; private int logLevel = SIMPLE ; private String separator = DEFAULT_SEP ; private List properties = new ArrayList ( ) ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Log mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Log mediator" ) ; } String logMessage = getLogMessage ( synCtx ) ; log . info ( logMessage ) ; if ( shouldTrace ) { trace . trace ( logMessage ) ; trace . trace ( "End : Log mediator" ) ; } return true ; } private String getLogMessage ( MessageContext synCtx ) { switch ( logLevel ) { case CUSTOM : return getCustomLogMessage ( synCtx ) ; case SIMPLE : return getSimpleLogMessage ( synCtx ) ; case HEADERS : return getHeadersLogMessage ( synCtx ) ; case FULL : return getFullLogMessage ( synCtx ) ; default : return "Invalid log level specified" ; } } private String getCustomLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; setCustomProperties ( sb , synCtx ) ; return trimLeadingSeparator ( sb ) ; } private String getSimpleLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; if ( synCtx . getTo ( ) != null ) sb . append ( "To: " + synCtx . getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( synCtx . getFrom ( ) != null ) sb . append ( separator + "From: " + synCtx . getFrom ( ) . getAddress ( ) ) ; if ( synCtx . getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + synCtx . getWSAAction ( ) ) ; if ( synCtx . getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + synCtx . getSoapAction ( ) ) ; if ( synCtx . getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + synCtx . getReplyTo ( ) . getAddress ( ) ) ; if ( synCtx . getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + synCtx . getMessageID ( ) ) ; setCustomProperties ( sb , synCtx ) ; return trimLeadingSeparator ( sb ) ; } private String getHeadersLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { Iterator iter = header . examineAllHeaderBlocks ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlk = ( SOAPHeaderBlock ) o ; sb . append ( separator + headerBlk . getLocalName ( ) + " : " + headerBlk . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } setCustomProperties ( sb , synCtx ) ; return trimLeadingSeparator ( sb ) ; } private String getFullLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( getSimpleLogMessage ( synCtx ) ) ; if ( synCtx . getEnvelope ( ) != null ) sb . append ( separator + "Envelope: " + synCtx . getEnvelope ( ) ) ; return trimLeadingSeparator ( sb ) ; } private void setCustomProperties ( StringBuffer sb , MessageContext synCtx ) { if ( properties != null && ! properties . isEmpty ( ) ) { Iterator iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; sb . append ( separator + prop . getName ( ) + " = " + ( prop . getValue ( ) != null ? prop . getValue ( ) : prop . getEvaluatedExpression ( synCtx ) ) ) ; } } } public int getLogLevel ( ) { return logLevel ; } public void setLogLevel ( int logLevel ) { this . logLevel = logLevel ; } public String getSeparator ( ) { return separator ; } public void setSeparator ( String separator ) { this . separator = separator ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } private String trimLeadingSeparator ( StringBuffer sb ) { String retStr = sb . toString ( ) ; if ( retStr . startsWith ( separator ) ) { return retStr . substring ( separator . length ( ) ) ; } else { return retStr ; } } } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . helpers . XMLReaderFactory ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import javax . xml . validation . Schema ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . * ; public class ValidateMediator extends AbstractListMediator { private static final Log log = LogFactory . getLog ( ValidateMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private static final String DEFAULT_SCHEMA_LANGUAGE = "http://www.w3.org/2001/XMLSchema" ; private List schemaKeys = new ArrayList ( ) ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Validator validator = null ; private final Object validatorLock = new Object ( ) ; private final MyErrorHandler errorHandler = new MyErrorHandler ( ) ; private static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public ValidateMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } private OMNode getValidateSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } public boolean mediate ( MessageContext synCtx ) { log . debug ( "ValidateMediator - Validate mediator mediate()" ) ; ByteArrayInputStream baisFromSource = null ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Validate mediator" ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; OMNode validateSource = getValidateSource ( synCtx ) ; if ( shouldTrace ) { trace . trace ( "Validate Source : " + validateSource . toString ( ) ) ; } validateSource . serialize ( xsWriterForSource ) ; baisFromSource = new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ; } catch ( Exception e ) { handleException ( "Error accessing source element for validation : " + source , e ) ; } try { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; SAXSource saxSrc = new SAXSource ( reader , new InputSource ( baisFromSource ) ) ; synchronized ( validatorLock ) { initialize ( synCtx ) ; validator . validate ( saxSrc ) ; if ( errorHandler . isValidationError ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Validation of element returned by XPath : " + source + " failed against the given schemas with Message : " + errorHandler . getSaxParseException ( ) . getMessage ( ) + " Executing 'on-fail' sequence" ) ; log . debug ( "Failed message envelope : " + synCtx . getEnvelope ( ) ) ; } if ( shouldTrace ) { trace . trace ( "Validation failed. Invoking the \"on-fail\" " + "sequence of mediators" ) ; } return super . mediate ( synCtx ) ; } } } catch ( SAXException e ) { handleException ( "Error validating " + source + " element" + e . getMessage ( ) , e ) ; } catch ( IOException e ) { handleException ( "Error validating " + source + " element" + e . getMessage ( ) , e ) ; } log . debug ( "validation of element returned by the XPath expression : " + source + " succeeded against the given schemas and the current message" ) ; if ( shouldTrace ) { trace . trace ( "End : Validate mediator" ) ; } return true ; } private void initialize ( MessageContext msgCtx ) { boolean reCreate = false ; Iterator iter = schemaKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { String propKey = ( String ) iter . next ( ) ; Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( propKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { reCreate = true ; } } } if ( ! reCreate && validator != null ) { return ; } try { SchemaFactory factory = SchemaFactory . newInstance ( DEFAULT_SCHEMA_LANGUAGE ) ; errorHandler . setValidationError ( false ) ; factory . setErrorHandler ( errorHandler ) ; iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; factory . setFeature ( prop . getName ( ) , prop . getValue ( ) != null && "true" . equals ( prop . getValue ( ) ) ) ; } Schema schema = null ; StreamSource [ ] sources = new StreamSource [ schemaKeys . size ( ) ] ; iter = schemaKeys . iterator ( ) ; int i = 0 ; while ( iter . hasNext ( ) ) { String propName = ( String ) iter . next ( ) ; sources [ i ++ ] = Util . getStreamSource ( msgCtx . getEntry ( propName ) ) ; } schema = factory . newSchema ( sources ) ; validator = schema . newValidator ( ) ; validator . setErrorHandler ( errorHandler ) ; } catch ( SAXException e ) { handleException ( "Error creating Validator" , e ) ; } } private class MyErrorHandler extends DefaultHandler { private boolean validationError = false ; private SAXParseException saxParseException = null ; public void error ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void warning ( SAXParseException exception ) throws SAXException { } public boolean isValidationError ( ) { return validationError ; } public SAXParseException getSaxParseException ( ) { return saxParseException ; } public void setValidationError ( boolean validationError ) { this . validationError = validationError ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } public Object getProperty ( String key ) { Iterator iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; if ( key . equals ( prop . getName ( ) ) ) { return prop . getValue ( ) ; } } return null ; } public void setProperty ( String key , Object value ) { MediatorProperty prop = new MediatorProperty ( ) ; prop . setName ( key ) ; prop . setValue ( value . toString ( ) ) ; properties . add ( prop ) ; } public void addAllProperties ( List list ) { Iterator iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof MediatorProperty ) { MediatorProperty prop = ( MediatorProperty ) o ; setProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } else { handleException ( "Attempt to set invalid property type. " + "Expected MediatorProperty type got " + o . getClass ( ) . getName ( ) ) ; } } } public void setSchemaKeys ( List schemaKeys ) { this . schemaKeys = schemaKeys ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public AXIOMXPath getSource ( ) { return source ; } public List getSchemaKeys ( ) { return schemaKeys ; } public List getProperties ( ) { return properties ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . metrics ; public final class Constants { public static String GLOBAL_REQUEST_COUNTER = "__GLOBAL_REQUEST_COUNTER__" ; public static String REQUEST_RECEIVED_TIME = "__REQUEST_RECEIVED_TIME__" ; } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . ext . ClassMediator ; import javax . xml . namespace . QName ; public class ClassMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName CLASS_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "class" ) ; public Mediator createMediator ( OMElement elem ) { ClassMediator classMediator = new ClassMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; if ( name == null ) { String msg = "The name of the actual mediator class is a required attribute" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } try { Class clazz = getClass ( ) . getClassLoader ( ) . loadClass ( name . getAttributeValue ( ) ) ; classMediator . setClazz ( clazz ) ; } catch ( ClassNotFoundException e ) { String msg = "Cannot find class : " + name . getAttributeValue ( ) ; log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } initMediator ( classMediator , elem ) ; classMediator . addAllProperties ( MediatorPropertyFactory . getMediatorProperties ( elem ) ) ; return classMediator ; } public QName getTagQName ( ) { return CLASS_Q ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . base . SequenceMediator ; import javax . xml . namespace . QName ; public class SequenceMediatorFactory extends AbstractListMediatorFactory { private static final Log log = LogFactory . getLog ( SequenceMediatorFactory . class ) ; private static final QName SEQUENCE_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "sequence" ) ; public QName getTagQName ( ) { return SEQUENCE_Q ; } public SequenceMediator createAnonymousSequence ( OMElement elem ) { SequenceMediator seqMediator = new SequenceMediator ( ) ; OMAttribute e = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "onError" ) ) ; if ( e != null ) { seqMediator . setErrorHandler ( e . getAttributeValue ( ) ) ; } initMediator ( seqMediator , elem ) ; addChildren ( elem , seqMediator ) ; OMAttribute statistics = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { seqMediator . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { seqMediator . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } return seqMediator ; } public Mediator createMediator ( OMElement elem ) { SequenceMediator seqMediator = new SequenceMediator ( ) ; OMAttribute n = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute e = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "onError" ) ) ; if ( n != null ) { seqMediator . setName ( n . getAttributeValue ( ) ) ; if ( e != null ) { seqMediator . setErrorHandler ( e . getAttributeValue ( ) ) ; } initMediator ( seqMediator , elem ) ; addChildren ( elem , seqMediator ) ; } else { n = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "key" ) ) ; if ( n != null ) { seqMediator . setKey ( n . getAttributeValue ( ) ) ; if ( e != null ) { String msg = "A sequence mediator swhich a reference to another sequence can not have 'ErrorHandler'" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } else { String msg = "A sequence mediator should be a named sequence or a reference to another sequence " + "(i.e. a name attribute or key attribute is required." ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMAttribute statistics = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { seqMediator . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { seqMediator . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } return seqMediator ; } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . endpoints . Endpoint ; import java . util . Set ; import java . util . Stack ; public interface MessageContext { public SynapseConfiguration getConfiguration ( ) ; public void setConfiguration ( SynapseConfiguration cfg ) ; public SynapseEnvironment getEnvironment ( ) ; public void setEnvironment ( SynapseEnvironment se ) ; public Mediator getMainSequence ( ) ; public Mediator getFaultSequence ( ) ; public Mediator getSequence ( String key ) ; public Endpoint getEndpoint ( String key ) ; public Object getProperty ( String key ) ; public Object getEntry ( String key ) ; public void setProperty ( String key , Object value ) ; public Set getPropertyKeySet ( ) ; public SOAPEnvelope getEnvelope ( ) ; public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault ; public EndpointReference getFaultTo ( ) ; public void setFaultTo ( EndpointReference reference ) ; public EndpointReference getFrom ( ) ; public void setFrom ( EndpointReference reference ) ; public String getMessageID ( ) ; public void setMessageID ( String string ) ; public RelatesTo getRelatesTo ( ) ; public void setRelatesTo ( RelatesTo [ ] reference ) ; public EndpointReference getReplyTo ( ) ; public void setReplyTo ( EndpointReference reference ) ; public EndpointReference getTo ( ) ; public void setTo ( EndpointReference reference ) ; public void setWSAAction ( String actionURI ) ; public String getWSAAction ( ) ; public String getSoapAction ( ) ; public void setSoapAction ( String string ) ; public void setWSAMessageID ( String messageID ) ; public String getWSAMessageID ( ) ; public boolean isDoingMTOM ( ) ; public boolean isDoingSWA ( ) ; public void setDoingMTOM ( boolean b ) ; public void setDoingSWA ( boolean b ) ; public boolean isDoingPOX ( ) ; public void setDoingPOX ( boolean b ) ; public boolean isSOAP11 ( ) ; public void setResponse ( boolean b ) ; public boolean isResponse ( ) ; public void setFaultResponse ( boolean b ) ; public boolean isFaultResponse ( ) ; public int getTracingState ( ) ; public void setTracingState ( int tracingState ) ; public Stack getFaultStack ( ) ; public void pushFaultHandler ( FaultHandler fault ) ; } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . RMSequenceMediator ; public class RMSequenceMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( RMSequenceMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof RMSequenceMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } RMSequenceMediator mediator = ( RMSequenceMediator ) m ; OMElement sequence = fac . createOMElement ( "RMSequence" , synNS ) ; finalizeSerialization ( sequence , mediator ) ; if ( mediator . isSingle ( ) && mediator . getCorrelation ( ) != null ) { handleException ( "Invalid RMSequence mediator. A RMSequence can't have both a " + "single attribute value of true and a correlation attribute specified." ) ; } if ( mediator . isSingle ( ) && mediator . getLastMessage ( ) != null ) { handleException ( "Invalid RMSequence mediator. A RMSequence can't have both a " + "single attribute value of true and a last-message attribute specified." ) ; } if ( mediator . isSingle ( ) ) { sequence . addAttribute ( fac . createOMAttribute ( "single" , nullNS , String . valueOf ( mediator . isSingle ( ) ) ) ) ; } else if ( mediator . getCorrelation ( ) != null ) { sequence . addAttribute ( fac . createOMAttribute ( "correlation" , nullNS , mediator . getCorrelation ( ) . toString ( ) ) ) ; super . serializeNamespaces ( sequence , mediator . getCorrelation ( ) ) ; } else { handleException ( "Invalid RMSequence mediator. Specify a single message sequence " + "or a correlation attribute." ) ; } if ( mediator . getLastMessage ( ) != null ) { sequence . addAttribute ( fac . createOMAttribute ( "last-message" , nullNS , mediator . getLastMessage ( ) . toString ( ) ) ) ; super . serializeNamespaces ( sequence , mediator . getLastMessage ( ) ) ; } if ( mediator . getVersion ( ) != null ) { sequence . addAttribute ( fac . createOMAttribute ( "version" , nullNS , mediator . getVersion ( ) ) ) ; } if ( parent != null ) { parent . addChild ( sequence ) ; } return sequence ; } public String getMediatorClassName ( ) { return RMSequenceMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . statistics ; import org . apache . synapse . Constants ; public class StatisticsHolder { private int statisticsCategory ; private String key ; private Statistics inFlowStatistics ; private Statistics outFlowStatistics ; public synchronized void update ( boolean isResponse , long inTime , long outTime , boolean isFault ) { if ( isResponse ) { if ( outFlowStatistics == null ) { outFlowStatistics = new Statistics ( ) ; } outFlowStatistics . update ( inTime , outTime , isFault ) ; } else { if ( inFlowStatistics == null ) { inFlowStatistics = new Statistics ( ) ; } inFlowStatistics . update ( inTime , outTime , isFault ) ; } } public synchronized Statistics getInFlowStatistics ( ) { return inFlowStatistics ; } public synchronized Statistics getOutFlowStatistics ( ) { return outFlowStatistics ; } public int getStatisticsCategory ( ) { return statisticsCategory ; } public void setStatisticsCategory ( int statisticsCategory ) { this . statisticsCategory = statisticsCategory ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public synchronized void clearStatistics ( ) { this . inFlowStatistics = null ; this . outFlowStatistics = null ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . builtin . PropertyMediator ; public class PropertyMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( PropertyMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof PropertyMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } PropertyMediator mediator = ( PropertyMediator ) m ; OMElement property = fac . createOMElement ( "property" , synNS ) ; finalizeSerialization ( property , mediator ) ; if ( mediator . getName ( ) != null ) { property . addAttribute ( fac . createOMAttribute ( "name" , nullNS , mediator . getName ( ) ) ) ; } else { handleException ( "Invalid property mediator. Name is required" ) ; } if ( mediator . getValue ( ) != null ) { property . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mediator . getValue ( ) ) ) ; } else if ( mediator . getExpression ( ) != null ) { property . addAttribute ( fac . createOMAttribute ( "expression" , nullNS , mediator . getExpression ( ) . toString ( ) ) ) ; super . serializeNamespaces ( property , mediator . getExpression ( ) ) ; } else if ( mediator . getAction ( ) == PropertyMediator . ACTION_SET ) { handleException ( "Invalid property mediator. Value or expression is required if action is SET" ) ; } if ( mediator . getScope ( ) != null ) { property . addAttribute ( fac . createOMAttribute ( "scope" , nullNS , mediator . getScope ( ) ) ) ; } if ( mediator . getAction ( ) == PropertyMediator . ACTION_REMOVE ) { property . addAttribute ( fac . createOMAttribute ( "action" , nullNS , "remove" ) ) ; } if ( parent != null ) { parent . addChild ( property ) ; } return property ; } public String getMediatorClassName ( ) { return PropertyMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . config . xml . endpoints . EndpointSerializer ; import org . apache . synapse . config . xml . endpoints . EndpointAbstractSerializer ; import org . apache . synapse . mediators . builtin . SendMediator ; import org . apache . synapse . endpoints . Endpoint ; public class SendMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( SendMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof SendMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } SendMediator mediator = ( SendMediator ) m ; OMElement send = fac . createOMElement ( "send" , synNS ) ; finalizeSerialization ( send , mediator ) ; Endpoint activeEndpoint = mediator . getEndpoint ( ) ; if ( activeEndpoint != null ) { EndpointSerializer serializer = EndpointAbstractSerializer . getEndpointSerializer ( activeEndpoint ) ; OMElement endpointElement = serializer . serializeEndpoint ( activeEndpoint ) ; send . addChild ( endpointElement ) ; } if ( parent != null ) { parent . addChild ( send ) ; } return send ; } public String getMediatorClassName ( ) { return SendMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . endpoints ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . dispatch . Dispatcher ; import org . apache . synapse . MessageContext ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . axis2 . context . OperationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . ArrayList ; import java . util . List ; public class SALoadbalanceEndpoint implements Endpoint { private static final Log log = LogFactory . getLog ( SALoadbalanceEndpoint . class ) ; private static final String FIRST_MESSAGE_IN_SESSION = "first_message_in_session" ; private String name = null ; private List endpoints = null ; private LoadbalanceAlgorithm algorithm = null ; private volatile boolean active = true ; private Endpoint parentEndpoint = null ; private Dispatcher dispatcher = null ; public void send ( MessageContext synMessageContext ) { Endpoint endpoint = null ; endpoint = dispatcher . getEndpoint ( synMessageContext ) ; if ( endpoint == null ) { endpoint = algorithm . getNextEndpoint ( synMessageContext ) ; if ( dispatcher . isServerInitiatedSession ( ) ) { Axis2MessageContext axis2MsgCtx = ( Axis2MessageContext ) synMessageContext ; OperationContext opCtx = axis2MsgCtx . getAxis2MessageContext ( ) . getOperationContext ( ) ; Object o = opCtx . getProperty ( "endpointList" ) ; if ( o != null ) { List endpointList = ( List ) o ; endpointList . add ( this ) ; if ( ! ( endpoint instanceof SALoadbalanceEndpoint ) ) { endpointList . add ( endpoint ) ; } } else { List endpointList = new ArrayList ( ) ; endpointList . add ( this ) ; if ( ! ( endpoint instanceof SALoadbalanceEndpoint ) ) { endpointList . add ( endpoint ) ; } opCtx . setProperty ( "endpointList" , endpointList ) ; } } else { dispatcher . updateSession ( synMessageContext , endpoint ) ; } synMessageContext . getEnvelope ( ) . build ( ) ; synMessageContext . setProperty ( FIRST_MESSAGE_IN_SESSION , Boolean . TRUE ) ; } if ( endpoint != null ) { if ( endpoint . isActive ( synMessageContext ) ) { endpoint . send ( synMessageContext ) ; } else { informFailure ( synMessageContext ) ; } } else { setActive ( false , synMessageContext ) ; informFailure ( synMessageContext ) ; } } public void updateSession ( MessageContext responseMsgCtx , List endpointList ) { Endpoint endpoint = ( Endpoint ) endpointList . remove ( 0 ) ; dispatcher . updateSession ( responseMsgCtx , endpoint ) ; if ( endpoint instanceof SALoadbalanceEndpoint ) { ( ( SALoadbalanceEndpoint ) endpoint ) . updateSession ( responseMsgCtx , endpointList ) ; } } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public LoadbalanceAlgorithm getAlgorithm ( ) { return algorithm ; } public void setAlgorithm ( LoadbalanceAlgorithm algorithm ) { this . algorithm = algorithm ; } public boolean isActive ( MessageContext synMessageContext ) { return active ; } public void setActive ( boolean active , MessageContext synMessageContext ) { this . active = active ; } public List getEndpoints ( ) { return endpoints ; } public void setEndpoints ( List endpoints ) { this . endpoints = endpoints ; } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public Dispatcher getDispatcher ( ) { return dispatcher ; } public void setDispatcher ( Dispatcher dispatcher ) { this . dispatcher = dispatcher ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { Object o = synMessageContext . getProperty ( FIRST_MESSAGE_IN_SESSION ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { dispatcher . unbind ( synMessageContext ) ; send ( synMessageContext ) ; } else { informFailure ( synMessageContext ) ; } } private void informFailure ( MessageContext synMessageContext ) { if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . LoadbalanceEndpoint ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . xml . endpoints . utils . LoadbalanceAlgorithmFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . OMAttribute ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . util . Iterator ; import java . util . ArrayList ; public class LoadbalanceEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( LoadbalanceEndpointFactory . class ) ; private static LoadbalanceEndpointFactory instance = new LoadbalanceEndpointFactory ( ) ; private LoadbalanceEndpointFactory ( ) { } public static LoadbalanceEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { OMElement loadbalanceElement = null ; loadbalanceElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "loadbalance" ) ) ; if ( loadbalanceElement != null ) { LoadbalanceEndpoint loadbalanceEndpoint = new LoadbalanceEndpoint ( ) ; OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { loadbalanceEndpoint . setName ( name . getAttributeValue ( ) ) ; } ArrayList endpoints = getEndpoints ( loadbalanceElement , loadbalanceEndpoint ) ; loadbalanceEndpoint . setEndpoints ( endpoints ) ; LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory . createLoadbalanceAlgorithm ( loadbalanceElement , endpoints ) ; loadbalanceEndpoint . setAlgorithm ( algorithm ) ; String failover = loadbalanceElement . getAttributeValue ( new QName ( "failover" ) ) ; if ( failover != null && failover . equalsIgnoreCase ( "false" ) ) { loadbalanceEndpoint . setFailover ( false ) ; } return loadbalanceEndpoint ; } return null ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } private ArrayList getEndpoints ( OMElement loadbalanceElement , Endpoint parent ) { ArrayList endpoints = new ArrayList ( ) ; Iterator iter = loadbalanceElement . getChildrenWithName ( org . apache . synapse . config . xml . Constants . ENDPOINT_ELT ) ; while ( iter . hasNext ( ) ) { OMElement endptElem = ( OMElement ) iter . next ( ) ; EndpointFactory epFac = EndpointAbstractFactory . getEndpointFactroy ( endptElem ) ; Endpoint endpoint = epFac . createEndpoint ( endptElem , true ) ; endpoint . setParentEndpoint ( parent ) ; endpoints . add ( endpoint ) ; } return endpoints ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . config . Entry ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import javax . xml . stream . XMLStreamConstants ; import java . net . URL ; public class EntrySerializer { private static Log log = LogFactory . getLog ( EntrySerializer . class ) ; protected static final OMFactory fac = OMAbstractFactory . getOMFactory ( ) ; protected static final OMNamespace synNS = fac . createOMNamespace ( Constants . SYNAPSE_NAMESPACE , "syn" ) ; protected static final OMNamespace nullNS = fac . createOMNamespace ( Constants . NULL_NAMESPACE , "" ) ; public static OMElement serializeEntry ( Entry entry , OMElement parent ) { OMElement propertyElement = fac . createOMElement ( "localEntry" , synNS ) ; propertyElement . addAttribute ( fac . createOMAttribute ( "key" , nullNS , entry . getKey ( ) . trim ( ) ) ) ; int type = entry . getType ( ) ; if ( type == Entry . URL_SRC ) { URL srcUrl = entry . getSrc ( ) ; if ( srcUrl != null ) { propertyElement . addAttribute ( fac . createOMAttribute ( "src" , nullNS , srcUrl . toString ( ) . trim ( ) ) ) ; } } else if ( type == Entry . INLINE_XML ) { Object value = entry . getValue ( ) ; if ( value != null && value instanceof OMElement ) { propertyElement . addChild ( ( OMElement ) value ) ; } } else if ( type == Entry . INLINE_TEXT ) { Object value = entry . getValue ( ) ; if ( value != null && value instanceof String ) { OMTextImpl textData = ( OMTextImpl ) fac . createOMText ( ( ( String ) value ) . trim ( ) ) ; textData . setType ( XMLStreamConstants . CDATA ) ; propertyElement . addChild ( textData ) ; } } else if ( type == Entry . REMOTE_ENTRY ) { return null ; } else { handleException ( "Entry type undefined" ) ; } if ( parent != null ) { parent . addChild ( propertyElement ) ; } return propertyElement ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . endpoints ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . MessageContext ; import java . util . List ; public class FailoverEndpoint implements Endpoint { private String name = null ; private volatile boolean active = true ; private List endpoints = null ; private Endpoint currentEndpoint = null ; private Endpoint parentEndpoint = null ; public void send ( MessageContext synMessageContext ) { synMessageContext . getEnvelope ( ) . build ( ) ; if ( currentEndpoint . isActive ( synMessageContext ) ) { currentEndpoint . send ( synMessageContext ) ; } else { Endpoint liveEndpoint = null ; boolean foundEndpoint = false ; for ( int i = 0 ; i < endpoints . size ( ) ; i ++ ) { liveEndpoint = ( Endpoint ) endpoints . get ( i ) ; if ( liveEndpoint . isActive ( synMessageContext ) ) { foundEndpoint = true ; currentEndpoint = liveEndpoint ; currentEndpoint . send ( synMessageContext ) ; break ; } } if ( ! foundEndpoint ) { setActive ( false , synMessageContext ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } } } public String getName ( ) { return this . name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { for ( int i = 0 ; i < endpoints . size ( ) ; i ++ ) { Endpoint endpoint = ( Endpoint ) endpoints . get ( i ) ; if ( endpoint . isActive ( synMessageContext ) ) { active = true ; } } } return active ; } public void setActive ( boolean active , MessageContext synMessageContext ) { this . active = active ; } public List getEndpoints ( ) { return endpoints ; } public void setEndpoints ( List endpoints ) { this . endpoints = endpoints ; if ( endpoints . size ( ) > 0 ) { currentEndpoint = ( Endpoint ) endpoints . get ( 0 ) ; } } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { send ( synMessageContext ) ; } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . util . CallbackReceiver ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisMessage ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import javax . xml . namespace . QName ; public class AnonymousServiceFactory { private static final Log log = LogFactory . getLog ( AnonymousServiceFactory . class ) ; private static final String NONE = "__NONE__" ; private static final String ADDR_ONLY = "__ADDR_ONLY__" ; private static final String RM_AND_ADDR = "__RM_AND_ADDR__" ; private static final String SEC_AND_ADDR = "__SEC_AND_ADDR__" ; private static final String RM_SEC_AND_ADDR = "__RM_SEC_AND_ADDR__" ; public static final String DYNAMIC_OPERATION = "__DYNAMIC_OPERATION__" ; private static final SynapseCallbackReceiver synapseCallback = new SynapseCallbackReceiver ( ) ; public static AxisService getAnonymousService ( AxisConfiguration axisCfg , boolean wsAddrOn , boolean wsRMOn , boolean wsSecOn ) { String servicekey = null ; if ( ! wsAddrOn ) { servicekey = NONE ; } else { if ( ! wsSecOn && ! wsRMOn ) { servicekey = ADDR_ONLY ; } else if ( wsRMOn && ! wsSecOn ) { servicekey = RM_AND_ADDR ; } else if ( wsSecOn && ! wsRMOn ) { servicekey = SEC_AND_ADDR ; } else { servicekey = RM_SEC_AND_ADDR ; } } try { AxisService service = axisCfg . getService ( servicekey ) ; if ( service == null ) { synchronized ( AnonymousServiceFactory . class ) { service = axisCfg . getService ( servicekey ) ; if ( service != null ) { return service ; } service = createAnonymousService ( axisCfg , servicekey ) ; if ( wsAddrOn ) { service . engageModule ( axisCfg . getModule ( Constants . ADDRESSING_MODULE_NAME ) , axisCfg ) ; if ( wsRMOn ) { service . engageModule ( axisCfg . getModule ( Constants . SANDESHA2_MODULE_NAME ) , axisCfg ) ; } if ( wsSecOn ) { service . engageModule ( axisCfg . getModule ( Constants . RAMPART_MODULE_NAME ) , axisCfg ) ; } } } } return service ; } catch ( AxisFault e ) { handleException ( "Error retrieving anonymous service for QoS : " + servicekey , e ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static AxisService createAnonymousService ( AxisConfiguration axisCfg , String serviceKey ) { try { DynamicAxisOperation dynamicOperation = new DynamicAxisOperation ( new QName ( DYNAMIC_OPERATION ) ) ; dynamicOperation . setMessageReceiver ( synapseCallback ) ; AxisMessage inMsg = new AxisMessage ( ) ; inMsg . setName ( "in-message" ) ; inMsg . setParent ( dynamicOperation ) ; AxisMessage outMsg = new AxisMessage ( ) ; outMsg . setName ( "out-message" ) ; outMsg . setParent ( dynamicOperation ) ; dynamicOperation . addMessage ( inMsg , WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ; dynamicOperation . addMessage ( outMsg , WSDLConstants . MESSAGE_LABEL_IN_VALUE ) ; AxisService axisAnonymousService = new AxisService ( serviceKey ) ; axisAnonymousService . addOperation ( dynamicOperation ) ; axisCfg . addService ( axisAnonymousService ) ; axisCfg . getPhasesInfo ( ) . setOperationPhases ( dynamicOperation ) ; return axisAnonymousService ; } catch ( AxisFault e ) { handleException ( "Error occured while creating an anonymous service for QoS : " + serviceKey , e ) ; } return null ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . mediators ; import org . apache . synapse . Mediator ; import java . util . List ; public interface ListMediator extends Mediator { public boolean addChild ( Mediator m ) ; public boolean addAll ( List c ) ; public Mediator getChild ( int pos ) ; public boolean removeChild ( Mediator m ) ; public Mediator removeChild ( int pos ) ; public List getList ( ) ; } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import javax . xml . namespace . QName ; public interface MediatorFactory { public Mediator createMediator ( OMElement elem ) ; public QName getTagQName ( ) ; } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . FaultHandler ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class IndirectEndpoint implements Endpoint { private static final Log log = LogFactory . getLog ( IndirectEndpoint . class ) ; private String name = null ; private String key = null ; private boolean active = true ; private Endpoint parentEndpoint = null ; private MessageContext currentMsgCtx = null ; public void send ( MessageContext synMessageContext ) { Endpoint endpoint = synMessageContext . getEndpoint ( key ) ; if ( endpoint == null ) { handleException ( "Reference to non-existent endpoint for key : " + key ) ; } if ( endpoint . isActive ( synMessageContext ) ) { endpoint . send ( synMessageContext ) ; } else { if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public boolean isActive ( MessageContext synMessageContext ) { Endpoint endpoint = synMessageContext . getEndpoint ( key ) ; if ( endpoint == null ) { handleException ( "Reference to non-existent endpoint for key : " + key ) ; } return endpoint . isActive ( synMessageContext ) ; } public void setActive ( boolean active , MessageContext synMessageContext ) { Endpoint endpoint = synMessageContext . getEndpoint ( key ) ; if ( endpoint == null ) { handleException ( "Reference to non-existent endpoint for key : " + key ) ; } endpoint . setActive ( active , synMessageContext ) ; } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . mediators ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . config . xml . Constants ; import javax . xml . namespace . QName ; public class MediatorProperty { public static final QName PROPERTY_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public static final QName ATT_NAME_Q = new QName ( Constants . NULL_NAMESPACE , "name" ) ; public static final QName ATT_VALUE_Q = new QName ( Constants . NULL_NAMESPACE , "value" ) ; public static final QName ATT_EXPR_Q = new QName ( Constants . NULL_NAMESPACE , "expression" ) ; private String name ; private String value ; private AXIOMXPath expression ; public MediatorProperty ( ) { } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getEvaluatedExpression ( MessageContext synCtx ) { return Axis2MessageContext . getStringValue ( expression , synCtx ) ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . registry ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . config . XMLToObjectMapper ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . endpoints . Endpoint ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; public abstract class AbstractRegistry implements Registry { private static final Log log = LogFactory . getLog ( AbstractRegistry . class ) ; protected Map properties = new HashMap ( ) ; public Object getResource ( Entry entry ) { OMNode omNode = null ; RegistryEntry re = null ; if ( entry . isCached ( ) && ! entry . isExpired ( ) ) { return entry . getValue ( ) ; } else if ( ! entry . isCached ( ) ) { omNode = lookup ( entry . getKey ( ) ) ; if ( omNode == null ) { return null ; } else { re = getRegistryEntry ( entry . getKey ( ) ) ; } } else if ( entry . isExpired ( ) ) { log . debug ( "Cached object has expired for key : " + entry . getKey ( ) ) ; re = getRegistryEntry ( entry . getKey ( ) ) ; if ( re . getVersion ( ) != Long . MIN_VALUE && re . getVersion ( ) == entry . getVersion ( ) ) { log . debug ( "Expired version number is same as current version in registry" ) ; entry . setExpiryTime ( System . currentTimeMillis ( ) + re . getCachableDuration ( ) ) ; log . debug ( "Renew cache lease for another " + re . getCachableDuration ( ) / 1000 + "s" ) ; return entry . getValue ( ) ; } else { omNode = lookup ( entry . getKey ( ) ) ; } } if ( entry . getMapper ( ) != null ) { entry . setValue ( entry . getMapper ( ) . getObjectFromOMNode ( omNode ) ) ; if ( entry . getValue ( ) instanceof SequenceMediator ) { SequenceMediator seq = ( SequenceMediator ) entry . getValue ( ) ; seq . setDynamic ( true ) ; seq . setRegistryKey ( entry . getKey ( ) ) ; } else if ( entry . getValue ( ) instanceof Endpoint ) { Endpoint ep = ( Endpoint ) entry . getValue ( ) ; } } else { if ( re != null && re . getType ( ) != null ) { XMLToObjectMapper mapper = getMapper ( re . getType ( ) ) ; if ( mapper != null ) { entry . setMapper ( mapper ) ; entry . setValue ( mapper . getObjectFromOMNode ( omNode ) ) ; } else { entry . setValue ( omNode ) ; } } } entry . setExpiryTime ( System . currentTimeMillis ( ) + re . getCachableDuration ( ) ) ; entry . setVersion ( re . getVersion ( ) ) ; return entry . getValue ( ) ; } private XMLToObjectMapper getMapper ( URI type ) { return null ; } public String getProviderClass ( ) { return this . getClass ( ) . getName ( ) ; } public Map getConfigProperties ( ) { return properties ; } public void addConfigProperty ( String name , String value ) { properties . put ( name , value ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . registry ; import java . net . URI ; public interface RegistryEntry { public String getKey ( ) ; public String getName ( ) ; public long getVersion ( ) ; public URI getType ( ) ; public String getDescription ( ) ; public long getCreated ( ) ; public long getLastModified ( ) ; public long getCachableDuration ( ) ; } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . engine . AxisEngine ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . rampart . handler . WSSHandlerConstants ; public class Axis2Sender { private static final Log log = LogFactory . getLog ( Axis2Sender . class ) ; public static void sendOn ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseInMessageContext ) { try { Axis2FlexibleMEPClient . send ( endpoint , synapseInMessageContext ) ; } catch ( Exception e ) { handleException ( "Unexpected error during Sending message onwards" , e ) ; } } public static void sendBack ( org . apache . synapse . MessageContext smc ) { MessageContext messageContext = ( ( Axis2MessageContext ) smc ) . getAxis2MessageContext ( ) ; if ( Utils . isExplicitlyTrue ( messageContext , NhttpConstants . SC_ACCEPTED ) && messageContext . getTransportOut ( ) != null && ! messageContext . getTransportOut ( ) . getName ( ) . startsWith ( "http" ) ) { return ; } AxisEngine ae = new AxisEngine ( messageContext . getConfigurationContext ( ) ) ; try { messageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; if ( smc . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( smc ) ; StatisticsUtils . processProxyServiceStatistics ( smc ) ; StatisticsUtils . processAllSequenceStatistics ( smc ) ; } Axis2FlexibleMEPClient . removeAddressingHeaders ( messageContext ) ; messageContext . setMessageID ( UUIDGenerator . getUUID ( ) ) ; if ( messageContext . isEngaged ( WSSHandlerConstants . SECURITY_MODULE_NAME ) && messageContext . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = messageContext . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( messageContext . getEnvelope ( ) ) ; } ae . send ( messageContext ) ; } catch ( AxisFault e ) { handleException ( "Unexpected error during Sending message back" , e ) ; } } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . endpoints . dispatch ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . context . OperationContext ; import org . apache . axis2 . AxisFault ; import javax . xml . namespace . QName ; import java . util . HashMap ; import java . util . Map ; import java . util . Collections ; public class SoapSessionDispatcher implements Dispatcher { private Map sessionMap = Collections . synchronizedMap ( new HashMap ( ) ) ; public Endpoint getEndpoint ( MessageContext synCtx ) { Endpoint endpoint = null ; SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { OMElement sgcID = header . getFirstChildWithName ( new QName ( "http://ws.apache.org/namespaces/axis2" , "ServiceGroupId" , "axis2" ) ) ; if ( sgcID != null && sgcID . getText ( ) != null ) { Object e = sessionMap . get ( sgcID . getText ( ) ) ; if ( e != null ) { endpoint = ( Endpoint ) e ; } } } return endpoint ; } public void updateSession ( MessageContext synCtx , Endpoint endpoint ) { SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { OMElement replyTo = header . getFirstChildWithName ( new QName ( "http://www.w3.org/2005/08/addressing" , "ReplyTo" , "wsa" ) ) ; if ( replyTo != null ) { OMElement referenceParameters = replyTo . getFirstChildWithName ( new QName ( "http://www.w3.org/2005/08/addressing" , "ReferenceParameters" , "wsa" ) ) ; if ( referenceParameters != null ) { OMElement sgcID = referenceParameters . getFirstChildWithName ( new QName ( "http://ws.apache.org/namespaces/axis2" , "ServiceGroupId" , "axis2" ) ) ; synchronized ( sessionMap ) { if ( ! sessionMap . containsKey ( sgcID . getText ( ) ) ) { sessionMap . put ( sgcID . getText ( ) , endpoint ) ; } } } } } } public void unbind ( MessageContext synCtx ) { SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { OMElement sgcID = header . getFirstChildWithName ( new QName ( "http://ws.apache.org/namespaces/axis2" , "ServiceGroupId" , "axis2" ) ) ; if ( sgcID != null && sgcID . getText ( ) != null ) { sessionMap . remove ( sgcID . getText ( ) ) ; } } } public boolean isServerInitiatedSession ( ) { return true ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . MediatorProperty ; import java . util . Collection ; import java . util . Iterator ; public abstract class AbstractMediatorSerializer implements MediatorSerializer { protected static final OMFactory fac = OMAbstractFactory . getOMFactory ( ) ; protected static final OMNamespace synNS = fac . createOMNamespace ( Constants . SYNAPSE_NAMESPACE , "syn" ) ; protected static final OMNamespace nullNS = fac . createOMNamespace ( Constants . NULL_NAMESPACE , "" ) ; private static final Log log = LogFactory . getLog ( AbstractMediatorSerializer . class ) ; protected static void finalizeSerialization ( OMElement mediatorOmElement , Mediator mediator ) { int traceState = mediator . getTraceState ( ) ; String traceValue = null ; if ( traceState == org . apache . synapse . Constants . TRACING_ON ) { traceValue = Constants . TRACE_ENABLE ; } else if ( traceState == org . apache . synapse . Constants . TRACING_OFF ) { traceValue = Constants . TRACE_DISABLE ; } if ( traceValue != null ) { mediatorOmElement . addAttribute ( fac . createOMAttribute ( Constants . TRACE_ATTRIB_NAME , nullNS , traceValue ) ) ; } } public void serializeMediatorProperties ( OMElement parent , Collection props ) { Iterator iter = props . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty mp = ( MediatorProperty ) iter . next ( ) ; OMElement prop = fac . createOMElement ( "property" , synNS , parent ) ; if ( mp . getName ( ) != null ) { prop . addAttribute ( fac . createOMAttribute ( "name" , nullNS , mp . getName ( ) ) ) ; } else { handleException ( "Mediator property name missing" ) ; } if ( mp . getValue ( ) != null ) { prop . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mp . getValue ( ) ) ) ; } else if ( mp . getExpression ( ) != null ) { prop . addAttribute ( fac . createOMAttribute ( "expression" , nullNS , mp . getExpression ( ) . toString ( ) ) ) ; serializeNamespaces ( prop , mp . getExpression ( ) ) ; } else { handleException ( "Mediator property must have a literal value or be an expression" ) ; } } } public void serializeProperties ( OMElement parent , Collection props ) { serializeMediatorProperties ( parent , props ) ; } public void serializeNamespaces ( OMElement elem , AXIOMXPath xpath ) { Iterator iter = xpath . getNamespaces ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String prefix = ( String ) iter . next ( ) ; String uri = xpath . getNamespaceContext ( ) . translateNamespacePrefixToUri ( prefix ) ; if ( ! Constants . SYNAPSE_NAMESPACE . equals ( uri ) ) { elem . declareNamespace ( uri , prefix ) ; } } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . endpoints . EndpointFactory ; import org . apache . synapse . config . xml . endpoints . EndpointAbstractFactory ; import org . apache . synapse . mediators . builtin . SendMediator ; import org . apache . synapse . endpoints . Endpoint ; import javax . xml . namespace . QName ; public class SendMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( SendMediatorFactory . class ) ; private static final QName SEND_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "send" ) ; public Mediator createMediator ( OMElement elem ) { SendMediator sm = new SendMediator ( ) ; initMediator ( sm , elem ) ; OMElement epElement = elem . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "endpoint" ) ) ; if ( epElement != null ) { EndpointFactory fac = EndpointAbstractFactory . getEndpointFactroy ( epElement ) ; if ( fac != null ) { Endpoint endpoint = fac . createEndpoint ( epElement , true ) ; if ( endpoint != null ) { sm . setEndpoint ( endpoint ) ; } } else { throw new SynapseException ( "Invalid endpoint fromat." ) ; } } return sm ; } public QName getTagQName ( ) { return SEND_Q ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . config . xml . endpoints . utils ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . woden . WSDLFactory ; import org . apache . woden . WSDLReader ; import org . apache . woden . WSDLException ; import org . apache . woden . types . NCName ; import org . apache . woden . wsdl20 . xml . DescriptionElement ; import org . apache . woden . wsdl20 . Description ; import org . apache . woden . wsdl20 . Service ; import org . apache . woden . wsdl20 . Endpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class WSDL20EndpointBuilder { } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . description . * ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axis2 . modules . Module ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . log4j . MDC ; import org . apache . neethi . Assertion ; import org . apache . neethi . Policy ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . SynapseConfigurationBuilder ; import javax . xml . namespace . QName ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . Iterator ; import java . util . List ; import java . util . ArrayList ; public class SynapseModule implements Module { private static final Log log = LogFactory . getLog ( SynapseModule . class ) ; private static final String SYNAPSE_SERVICE_NAME = "synapse" ; private static final QName MEDIATE_OPERATION_Q_NAME = new QName ( "mediate" ) ; public void init ( ConfigurationContext configurationContext , AxisModule axisModule ) throws AxisFault { try { InetAddress addr = InetAddress . getLocalHost ( ) ; if ( addr != null ) { String ipAddr = addr . getHostAddress ( ) ; if ( ipAddr != null ) { MDC . put ( "ip" , ipAddr ) ; } String hostname = addr . getHostName ( ) ; if ( hostname == null ) { hostname = ipAddr ; } MDC . put ( "host" , hostname ) ; } } catch ( UnknownHostException e ) { log . warn ( "Unable to report hostname or IP address for tracing" , e ) ; } log . info ( "Initializing the Synapse configuration ..." ) ; SynapseConfiguration synCfg = initializeSynapse ( configurationContext ) ; log . info ( "Deploying the Synapse service.." ) ; AxisConfiguration axisCfg = configurationContext . getAxisConfiguration ( ) ; AxisService synapseService = new AxisService ( SYNAPSE_SERVICE_NAME ) ; AxisOperation mediateOperation = new InOutAxisOperation ( MEDIATE_OPERATION_Q_NAME ) ; mediateOperation . setMessageReceiver ( new SynapseMessageReceiver ( ) ) ; synapseService . addOperation ( mediateOperation ) ; List transports = new ArrayList ( ) ; transports . add ( org . apache . axis2 . Constants . TRANSPORT_HTTP ) ; transports . add ( "https" ) ; synapseService . setExposedTransports ( transports ) ; axisCfg . addService ( synapseService ) ; log . info ( "Initializing Sandesha 2..." ) ; AxisModule sandeshaAxisModule = configurationContext . getAxisConfiguration ( ) . getModule ( Constants . SANDESHA2_MODULE_NAME ) ; if ( sandeshaAxisModule != null ) { Module sandesha2 = sandeshaAxisModule . getModule ( ) ; sandesha2 . init ( configurationContext , sandeshaAxisModule ) ; } log . info ( "Deploying Proxy services..." ) ; Iterator iter = synCfg . getProxyServices ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ProxyService proxy = ( ProxyService ) iter . next ( ) ; proxy . buildAxisService ( synCfg , axisCfg ) ; log . debug ( "Deployed Proxy service : " + proxy . getName ( ) ) ; if ( ! proxy . isStartOnLoad ( ) ) { proxy . stop ( synCfg ) ; } } log . info ( "Synapse initialized successfully...!" ) ; } private static SynapseConfiguration initializeSynapse ( ConfigurationContext cfgCtx ) { cfgCtx . setProperty ( "addressing.validateAction" , Boolean . FALSE ) ; AxisConfiguration axisConfiguration = cfgCtx . getAxisConfiguration ( ) ; SynapseConfiguration synapseConfiguration ; String config = System . getProperty ( Constants . SYNAPSE_XML ) ; if ( config != null ) { log . debug ( "System property '" + Constants . SYNAPSE_XML + "' specifies synapse configuration as " + config ) ; synapseConfiguration = SynapseConfigurationBuilder . getConfiguration ( config ) ; } else { log . warn ( "System property '" + Constants . SYNAPSE_XML + "' is not specified. Using default configuration.." ) ; synapseConfiguration = SynapseConfigurationBuilder . getDefaultConfiguration ( ) ; } synapseConfiguration . setAxisConfiguration ( cfgCtx . getAxisConfiguration ( ) ) ; Parameter synapseCtxParam = new Parameter ( Constants . SYNAPSE_CONFIG , null ) ; synapseCtxParam . setValue ( synapseConfiguration ) ; MessageContextCreatorForAxis2 . setSynConfig ( synapseConfiguration ) ; Parameter synapseEnvParam = new Parameter ( Constants . SYNAPSE_ENV , null ) ; Axis2SynapseEnvironment synEnv = new Axis2SynapseEnvironment ( cfgCtx , synapseConfiguration ) ; synapseEnvParam . setValue ( synEnv ) ; MessageContextCreatorForAxis2 . setSynEnv ( synEnv ) ; try { axisConfiguration . addParameter ( synapseCtxParam ) ; axisConfiguration . addParameter ( synapseEnvParam ) ; } catch ( AxisFault e ) { String msg = "Could not set parameters '" + Constants . SYNAPSE_CONFIG + "' and/or '" + Constants . SYNAPSE_ENV + "'to the Axis2 configuration : " + e . getMessage ( ) ; log . fatal ( msg , e ) ; throw new SynapseException ( msg , e ) ; } return synapseConfiguration ; } public void engageNotify ( AxisDescription axisDescription ) throws AxisFault { } public boolean canSupportAssertion ( Assertion assertion ) { return false ; } public void applyPolicy ( Policy policy , AxisDescription axisDescription ) throws AxisFault { } public void shutdown ( ConfigurationContext configurationContext ) throws AxisFault { } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . statistics ; public class Statistics { private long maxProcessingTime = 0 ; private long minProcessingTime = - 1 ; private double avgProcessingTime = 0 ; private double totalProcessingTime ; private int count = 0 ; private int faultCount = 0 ; public void update ( long inTime , long outTime , boolean isFault ) { count ++ ; if ( isFault ) { faultCount ++ ; } long responseTime = outTime - inTime ; if ( maxProcessingTime < responseTime ) { maxProcessingTime = responseTime ; } if ( minProcessingTime > responseTime ) { minProcessingTime = responseTime ; } if ( minProcessingTime == - 1 ) { minProcessingTime = responseTime ; } totalProcessingTime = totalProcessingTime + responseTime ; avgProcessingTime = totalProcessingTime / count ; } public long getMaxProcessingTime ( ) { return maxProcessingTime ; } public double getAvgProcessingTime ( ) { return avgProcessingTime ; } public long getMinProcessingTime ( ) { return minProcessingTime ; } public int getFaultCount ( ) { return faultCount ; } public int getCount ( ) { return count ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . ListMediator ; import org . apache . synapse . Mediator ; import java . util . Iterator ; public abstract class AbstractListMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( AbstractListMediatorFactory . class ) ; protected static void addChildren ( OMElement el , ListMediator m ) { Iterator it = el . getChildElements ( ) ; while ( it . hasNext ( ) ) { OMElement child = ( OMElement ) it . next ( ) ; Mediator med = MediatorFactoryFinder . getInstance ( ) . getMediator ( child ) ; if ( med != null ) { m . addChild ( med ) ; } else { String msg = "Unknown mediator : " + child . getLocalName ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . MessageContext ; public class AnonymousListMediator extends AbstractListMediator { public boolean mediate ( MessageContext synCtx ) { return super . mediate ( synCtx ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . mediators . base ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . statistics . impl . SequenceStatisticsStack ; import org . apache . synapse . mediators . AbstractListMediator ; public class SynapseMediator extends AbstractListMediator { private static final Log log = LogFactory . getLog ( SynapseMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Synapse main mediator :: mediate()" ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processAllSequenceStatistics ( synCtx ) ; } StatisticsStack sequenceStack = ( StatisticsStack ) synCtx . getProperty ( Constants . SEQUENCE_STATISTICS_STACK ) ; if ( sequenceStack == null ) { sequenceStack = new SequenceStatisticsStack ( ) ; synCtx . setProperty ( Constants . SEQUENCE_STATISTICS_STACK , sequenceStack ) ; } String seqName = "MainSequence" ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; sequenceStack . put ( seqName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , true , isFault ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; try { if ( shouldTrace ) { trace . trace ( "Start : Synapse main mediator" ) ; } return super . mediate ( synCtx ) ; } finally { if ( shouldTrace ) { trace . trace ( "End : Synapse main mediator" ) ; } } } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . metrics ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . handlers . AbstractHandler ; public class GlobalRequestCountHandler extends AbstractHandler { public InvocationResponse invoke ( MessageContext msgContext ) throws AxisFault { msgContext . setProperty ( Constants . REQUEST_RECEIVED_TIME , new Long ( System . currentTimeMillis ( ) ) ) ; ( ( Counter ) msgContext . getParameter ( Constants . GLOBAL_REQUEST_COUNTER ) . getValue ( ) ) . increment ( ) ; return InvocationResponse . CONTINUE ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . InMediator ; public class InMediatorSerializer extends AbstractListMediatorSerializer { private static final Log log = LogFactory . getLog ( InMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof InMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } InMediator mediator = ( InMediator ) m ; OMElement in = fac . createOMElement ( "in" , synNS ) ; finalizeSerialization ( in , mediator ) ; serializeChildren ( in , mediator . getList ( ) ) ; if ( parent != null ) { parent . addChild ( in ) ; } return in ; } public String getMediatorClassName ( ) { return InMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; public interface Constants { public static final QName DEFINITIONS_ELT = new QName ( Constants . SYNAPSE_NAMESPACE , "definitions" ) ; public static final QName SEQUENCE_ELT = new QName ( Constants . SYNAPSE_NAMESPACE , "sequence" ) ; public static final QName ENDPOINT_ELT = new QName ( Constants . SYNAPSE_NAMESPACE , "endpoint" ) ; public static final QName ENTRY_ELT = new QName ( Constants . SYNAPSE_NAMESPACE , "localEntry" ) ; public static final QName REGISTRY_ELT = new QName ( Constants . SYNAPSE_NAMESPACE , "registry" ) ; public static final QName PROXY_ELT = new QName ( Constants . SYNAPSE_NAMESPACE , "proxy" ) ; public static final String SYNAPSE_NAMESPACE = org . apache . synapse . Constants . SYNAPSE_NAMESPACE ; public static final String NULL_NAMESPACE = "" ; public static final String RAMPART_POLICY = "rampartPolicy" ; public static final String SANDESHA_POLICY = "sandeshaPolicy" ; public static final String TRACE_ATTRIB_NAME = "trace" ; public static final String TRACE_ENABLE = "enable" ; public static final String TRACE_DISABLE = "disable" ; public static final String STATISTICS_ATTRIB_NAME = "statistics" ; public static final String STATISTICS_ENABLE = "enable" ; public static final String STATISTICS_DISABLE = "disable" ; public static final String SCOPE_AXIS2 = org . apache . synapse . Constants . SCOPE_AXIS2 ; String SCOPE_TRANSPORT = org . apache . synapse . Constants . SCOPE_TRANSPORT ; String SCOPE_DEFAULT = org . apache . synapse . Constants . SCOPE_DEFAULT ; public static final String SEQUENCE_VERSION_1_0 = org . apache . synapse . Constants . SEQUENCE_VERSION_1_0 ; public static final String SEQUENCE_VERSION_1_1 = org . apache . synapse . Constants . SEQUENCE_VERSION_1_1 ; String SEND_ELEMENT = "send" ; String LOADBALANCE_ELEMENT = "loadbalance" ; String FAILOVER_ELEMENT = "failover" ; String SUSPEND_DURATION_ON_FAILURE = "suspendDurationOnFailure" ; String MAXIMUM_RETRIES = "maximumRetries" ; String RETRY_INTERVAL = "retryInterval" ; String FAILOVER = "failover" ; String SESSION_AFFINITY = "sessionAffinity" ; String ALGORITHM_NAME = "policy" ; String FAILOVER_GROUP_ELEMENT = "failover" ; String DISPATCH_MANAGER = "DISPATCH_MANAGER" ; String DISPATCHERS_ELEMENT = "dispatchers" ; String DISPATCHER_ELEMENT = "dispatcher" ; QName ATT_KEY_Q = new QName ( NULL_NAMESPACE , "key" ) ; QName ATT_ADDRESS_Q = new QName ( NULL_NAMESPACE , "address" ) ; String ONREJECT = "onReject" ; String ONACCEPT = "onAccept" ; } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . statistics ; public interface StatisticsStack { public void put ( String key , long initTime , boolean isInFlow , boolean isStatisticsEnable , boolean isFault ) ; public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) ; public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault , String name ) ; public void reportAllToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) ; } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . helpers . XMLReaderFactory ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import javax . xml . validation . Schema ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . * ; public class ValidateMediator extends AbstractListMediator { private static final Log log = LogFactory . getLog ( ValidateMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private static final String DEFAULT_SCHEMA_LANGUAGE = "http://www.w3.org/2001/XMLSchema" ; private List schemaKeys = new ArrayList ( ) ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Validator validator = null ; private final Object validatorLock = new Object ( ) ; private final MyErrorHandler errorHandler = new MyErrorHandler ( ) ; private static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public ValidateMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } private OMNode getValidateSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } public boolean mediate ( MessageContext synCtx ) { log . debug ( "ValidateMediator - Validate mediator mediate()" ) ; ByteArrayInputStream baisFromSource = null ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Validate mediator" ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; OMNode validateSource = getValidateSource ( synCtx ) ; if ( shouldTrace ) { trace . trace ( "Validate Source : " + validateSource . toString ( ) ) ; } validateSource . serialize ( xsWriterForSource ) ; baisFromSource = new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ; } catch ( Exception e ) { handleException ( "Error accessing source element for validation : " + source , e ) ; } try { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; SAXSource saxSrc = new SAXSource ( reader , new InputSource ( baisFromSource ) ) ; synchronized ( validatorLock ) { initialize ( synCtx ) ; validator . validate ( saxSrc ) ; if ( errorHandler . isValidationError ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Validation of element returned by XPath : " + source + " failed against the given schemas with Message : " + errorHandler . getSaxParseException ( ) . getMessage ( ) + " Executing 'on-fail' sequence" ) ; log . debug ( "Failed message envelope : " + synCtx . getEnvelope ( ) ) ; } if ( shouldTrace ) { trace . trace ( "Validation failed. Invoking the \"on-fail\" " + "sequence of mediators" ) ; } return super . mediate ( synCtx ) ; } } } catch ( SAXException e ) { handleException ( "Error validating " + source + " element" + e . getMessage ( ) , e ) ; } catch ( IOException e ) { handleException ( "Error validating " + source + " element" + e . getMessage ( ) , e ) ; } log . debug ( "validation of element returned by the XPath expression : " + source + " succeeded against the given schemas and the current message" ) ; if ( shouldTrace ) { trace . trace ( "End : Validate mediator" ) ; } return true ; } private void initialize ( MessageContext msgCtx ) { boolean reCreate = false ; Iterator iter = schemaKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { String propKey = ( String ) iter . next ( ) ; Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( propKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { reCreate = true ; } } } if ( ! reCreate && validator != null ) { return ; } try { SchemaFactory factory = SchemaFactory . newInstance ( DEFAULT_SCHEMA_LANGUAGE ) ; errorHandler . setValidationError ( false ) ; factory . setErrorHandler ( errorHandler ) ; iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; factory . setFeature ( prop . getName ( ) , prop . getValue ( ) != null && "true" . equals ( prop . getValue ( ) ) ) ; } Schema schema = null ; StreamSource [ ] sources = new StreamSource [ schemaKeys . size ( ) ] ; iter = schemaKeys . iterator ( ) ; int i = 0 ; while ( iter . hasNext ( ) ) { String propName = ( String ) iter . next ( ) ; sources [ i ++ ] = Util . getStreamSource ( msgCtx . getEntry ( propName ) ) ; } schema = factory . newSchema ( sources ) ; validator = schema . newValidator ( ) ; validator . setErrorHandler ( errorHandler ) ; } catch ( SAXException e ) { handleException ( "Error creating Validator" , e ) ; } } private class MyErrorHandler extends DefaultHandler { private boolean validationError = false ; private SAXParseException saxParseException = null ; public void error ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void warning ( SAXParseException exception ) throws SAXException { } public boolean isValidationError ( ) { return validationError ; } public SAXParseException getSaxParseException ( ) { return saxParseException ; } public void setValidationError ( boolean validationError ) { this . validationError = validationError ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } public Object getProperty ( String key ) { Iterator iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; if ( key . equals ( prop . getName ( ) ) ) { return prop . getValue ( ) ; } } return null ; } public void setProperty ( String key , Object value ) { MediatorProperty prop = new MediatorProperty ( ) ; prop . setName ( key ) ; prop . setValue ( value . toString ( ) ) ; properties . add ( prop ) ; } public void addAllProperties ( List list ) { Iterator iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof MediatorProperty ) { MediatorProperty prop = ( MediatorProperty ) o ; setProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } else { handleException ( "Attempt to set invalid property type. " + "Expected MediatorProperty type got " + o . getClass ( ) . getName ( ) ) ; } } } public void setSchemaKeys ( List schemaKeys ) { this . schemaKeys = schemaKeys ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public AXIOMXPath getSource ( ) { return source ; } public List getSchemaKeys ( ) { return schemaKeys ; } public List getProperties ( ) { return properties ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . builtin . DropMediator ; public class DropMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( DropMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof DropMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } DropMediator mediator = ( DropMediator ) m ; OMElement drop = fac . createOMElement ( "drop" , synNS ) ; finalizeSerialization ( drop , mediator ) ; if ( parent != null ) { parent . addChild ( drop ) ; } return drop ; } public String getMediatorClassName ( ) { return DropMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse . mediators . filters ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractListMediator ; public class InMediator extends AbstractListMediator implements org . apache . synapse . mediators . FilterMediator { private static final Log log = LogFactory . getLog ( InMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "In mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; try { if ( shouldTrace ) { trace . trace ( "Start : In mediator" ) ; } if ( test ( synCtx ) ) { log . debug ( "Current message is incoming.. executing child mediators" ) ; return super . mediate ( synCtx ) ; } else { log . debug ( "Current message is not incoming.. skipping child mediators" ) ; return true ; } } finally { if ( shouldTrace ) { trace . trace ( "End : In mediator" ) ; } } } public boolean test ( MessageContext synCtx ) { return ! synCtx . isResponse ( ) ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . OutMediator ; public class OutMediatorSerializer extends AbstractListMediatorSerializer { private static final Log log = LogFactory . getLog ( OutMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof OutMediator ) ) { handleException ( "Unsupported mediator passed out for serialization : " + m . getType ( ) ) ; } OutMediator mediator = ( OutMediator ) m ; OMElement out = fac . createOMElement ( "out" , synNS ) ; finalizeSerialization ( out , mediator ) ; serializeChildren ( out , mediator . getList ( ) ) ; if ( parent != null ) { parent . addChild ( out ) ; } return out ; } public String getMediatorClassName ( ) { return OutMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . mediators ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; public abstract class AbstractMediator implements Mediator { protected int parentTraceState = Constants . TRACING_UNSET ; protected int traceState = Constants . TRACING_UNSET ; public String getType ( ) { String cls = getClass ( ) . getName ( ) ; int p = cls . lastIndexOf ( "." ) ; if ( p == - 1 ) return cls ; else return cls . substring ( p + 1 ) ; } public int getTraceState ( ) { return traceState ; } public void setTraceState ( int traceState ) { this . traceState = traceState ; } public void saveAndSetTraceState ( MessageContext synCtx ) { parentTraceState = synCtx . getTracingState ( ) ; synCtx . setTracingState ( traceState ) ; } public void restoreTracingState ( MessageContext synCtx ) { synCtx . setTracingState ( parentTraceState ) ; } public boolean shouldTrace ( int parentTraceState ) { return ( traceState == Constants . TRACING_ON ) || ( traceState == Constants . TRACING_UNSET && parentTraceState == Constants . TRACING_ON ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import javax . xml . stream . XMLInputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . net . URLConnection ; import java . net . URI ; import java . net . MalformedURLException ; public class Util { private static final Log log = LogFactory . getLog ( Util . class ) ; public static StreamSource getStreamSource ( Object o ) { if ( o == null ) { handleException ( "Cannot convert null to a StreamSource" ) ; } else if ( o instanceof OMNode ) { OMNode omNode = ( OMNode ) o ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { omNode . serialize ( baos ) ; return new StreamSource ( new ByteArrayInputStream ( baos . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error converting to a StreamSource" , e ) ; } } else { handleException ( "Cannot convert object to a StreamSource" ) ; } return null ; } public static InputStream getInputStream ( Object o ) { if ( o == null ) { handleException ( "Cannot convert null to a StreamSource" ) ; } else if ( o instanceof OMElement ) { OMElement omElement = ( OMElement ) o ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { omElement . serialize ( baos ) ; return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error converting to a StreamSource" , e ) ; } } else if ( o instanceof URI ) { try { return ( ( URI ) ( o ) ) . toURL ( ) . openStream ( ) ; } catch ( IOException e ) { handleException ( "Error opening stream form URI" , e ) ; } } else { handleException ( "Cannot convert object to a StreamSource" ) ; } return null ; } public static Object getObject ( URL url ) { try { URLConnection urlc = url . openConnection ( ) ; XMLToObjectMapper xmlToObject = getXmlToObjectMapper ( urlc . getContentType ( ) ) ; try { XMLStreamReader parser = XMLInputFactory . newInstance ( ) . createXMLStreamReader ( urlc . getInputStream ( ) ) ; StAXOMBuilder builder = new StAXOMBuilder ( parser ) ; OMElement omElem = builder . getDocumentElement ( ) ; omElem . build ( ) ; if ( xmlToObject != null ) { return xmlToObject . getObjectFromOMNode ( omElem ) ; } else { return omElem ; } } catch ( XMLStreamException e ) { log . warn ( "Content at URL : " + url + " is non XML.." ) ; return urlc . getContent ( ) ; } } catch ( IOException e ) { handleException ( "Error connecting to URL : " + url , e ) ; } return null ; } public static OMElement getOMElementFromURL ( String url ) throws IOException { URLConnection conn = new URL ( url ) . openConnection ( ) ; conn . setReadTimeout ( 10000 ) ; conn . setConnectTimeout ( 2000 ) ; conn . setRequestProperty ( "Connection" , "close" ) ; InputStream urlInStream = conn . getInputStream ( ) ; if ( urlInStream != null ) { try { StAXOMBuilder builder = new StAXOMBuilder ( urlInStream ) ; OMElement doc = builder . getDocumentElement ( ) ; doc . build ( ) ; return doc ; } catch ( Exception e ) { handleException ( "Error parsing resource at URL : " + url + " as XML" , e ) ; } finally { try { urlInStream . close ( ) ; } catch ( IOException ignore ) { } } } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static XMLToObjectMapper getXmlToObjectMapper ( String contentType ) { return null ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . statistics . impl ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . SynapseException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ProxyServiceStatisticsStack implements StatisticsStack { private static final Log log = LogFactory . getLog ( ProxyServiceStatisticsStack . class ) ; private String proxyServiceName ; private boolean isStatisticsEnable = false ; private long inTimeForInFlow = - 1 ; private long inTimeForOutFlow = - 1 ; private boolean isINFault ; private boolean isOUTFault ; public void put ( String key , long initTime , boolean isInFlow , boolean isStatisticsEnable , boolean isFault ) { if ( isInFlow ) { this . proxyServiceName = key ; this . isStatisticsEnable = isStatisticsEnable ; this . inTimeForInFlow = initTime ; this . isINFault = isFault ; } } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { if ( proxyServiceName != null && isStatisticsEnable && inTimeForInFlow != - 1 ) { inTimeForOutFlow = System . currentTimeMillis ( ) ; isOUTFault = isFault ; statisticsCollector . reportForProxyService ( proxyServiceName , false , inTimeForInFlow , inTimeForOutFlow , isINFault ) ; inTimeForInFlow = - 1 ; } else if ( inTimeForOutFlow != - 1 ) { statisticsCollector . reportForProxyService ( proxyServiceName , true , inTimeForOutFlow , System . currentTimeMillis ( ) , isFault ) ; inTimeForOutFlow = - 1 ; } } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault , String name ) { if ( name != null && proxyServiceName != null && proxyServiceName . equals ( name ) ) { reportToStatisticsCollector ( statisticsCollector , isFault ) ; } else { handleException ( "Invalid ProxyService Name " + name + " expected " + proxyServiceName ) ; } } public void reportAllToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { reportToStatisticsCollector ( statisticsCollector , isFault ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . statistics . impl ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . StatisticsCollector ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class SequenceStatisticsStack implements StatisticsStack { private List sequenceStatisticsList = new ArrayList ( ) ; public void put ( String sequenceName , long initTime , boolean isInFlow , boolean isStatisticsEnable , boolean isFault ) { sequenceStatisticsList . add ( new SequenceStatistics ( sequenceName , initTime , isInFlow , isStatisticsEnable , isFault ) ) ; } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { int top = sequenceStatisticsList . size ( ) ; if ( top > 0 ) { popSequenceStatistics ( sequenceStatisticsList . size ( ) - 1 , statisticsCollector ) ; } } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault , String name ) { if ( ! sequenceStatisticsList . isEmpty ( ) ) { List tobeRemoved = new ArrayList ( ) ; for ( Iterator seqIterator = sequenceStatisticsList . iterator ( ) ; seqIterator . hasNext ( ) ; ) { SequenceStatistics sequenceStatistics = ( SequenceStatistics ) seqIterator . next ( ) ; if ( sequenceStatistics != null ) { if ( sequenceStatistics . isStatisticsEnable && sequenceStatistics . sequenceName != null && sequenceStatistics . sequenceName . equals ( name ) ) { statisticsCollector . reportForSequence ( sequenceStatistics . sequenceName , ! sequenceStatistics . isInFlow , sequenceStatistics . initTime , System . currentTimeMillis ( ) , sequenceStatistics . isFault ) ; } tobeRemoved . add ( sequenceStatistics ) ; } } sequenceStatisticsList . removeAll ( tobeRemoved ) ; } } public void reportAllToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { int i = sequenceStatisticsList . size ( ) - 1 ; for ( ; i >= 0 ; i -- ) { popSequenceStatistics ( i , statisticsCollector ) ; } } private void popSequenceStatistics ( int index , StatisticsCollector statisticsCollector ) { if ( index >= 0 ) { SequenceStatistics sequenceStatistics = ( SequenceStatistics ) sequenceStatisticsList . get ( index ) ; if ( sequenceStatistics != null ) { if ( sequenceStatistics . isStatisticsEnable && sequenceStatistics . sequenceName != null ) { statisticsCollector . reportForSequence ( sequenceStatistics . sequenceName , ! sequenceStatistics . isInFlow , sequenceStatistics . initTime , System . currentTimeMillis ( ) , sequenceStatistics . isFault ) ; } sequenceStatisticsList . remove ( index ) ; } } } class SequenceStatistics { String sequenceName ; long initTime ; boolean isInFlow ; boolean isStatisticsEnable ; private boolean isFault ; public SequenceStatistics ( String sequenceName , long initTime , boolean inFlow , boolean statisticsEnable , boolean isFault ) { this . sequenceName = sequenceName ; this . initTime = initTime ; isInFlow = inFlow ; isStatisticsEnable = statisticsEnable ; this . isFault = isFault ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; final SequenceStatistics that = ( SequenceStatistics ) o ; if ( ! sequenceName . equals ( that . sequenceName ) ) return false ; return true ; } public int hashCode ( ) { return sequenceName . hashCode ( ) ; } } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . base . SynapseMediator ; public class SynapseMediatorSerializer extends AbstractListMediatorSerializer { private static final Log log = LogFactory . getLog ( SynapseMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof SynapseMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } SynapseMediator mediator = ( SynapseMediator ) m ; OMElement rules = fac . createOMElement ( "rules" , synNS ) ; finalizeSerialization ( rules , mediator ) ; serializeChildren ( rules , mediator . getList ( ) ) ; if ( parent != null ) { parent . addChild ( rules ) ; } return rules ; } public String getMediatorClassName ( ) { return SynapseMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . description . * ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Util ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLInputFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . ByteArrayOutputStream ; import java . io . ByteArrayInputStream ; import java . util . * ; import java . net . URI ; import java . net . URLConnection ; import java . net . MalformedURLException ; import java . net . URL ; public class ProxyService { private static final Log log = LogFactory . getLog ( ProxyService . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String name ; private String description ; private ArrayList transports ; private String targetEndpoint = null ; private String targetInSequence = null ; private String targetOutSequence = null ; private String targetFaultSequence = null ; private Endpoint targetInLineEndpoint = null ; private SequenceMediator targetInLineInSequence = null ; private SequenceMediator targetInLineOutSequence = null ; private SequenceMediator targetInLineFaultSequence = null ; private Map parameters = new HashMap ( ) ; private String wsdlKey ; private URI wsdlURI ; private Object inLineWSDL ; private List schemaKeys = new ArrayList ( ) ; private List serviceLevelPolicies = new ArrayList ( ) ; private boolean wsRMEnabled = false ; private boolean wsSecEnabled = false ; private boolean startOnLoad = true ; private boolean running = false ; public static final String ALL_TRANSPORTS = "all" ; private int statisticsEnable = Constants . STATISTICS_UNSET ; protected int traceState = Constants . TRACING_UNSET ; public ProxyService ( ) { } public AxisService buildAxisService ( SynapseConfiguration synCfg , AxisConfiguration axisCfg ) { AxisService proxyService = null ; InputStream wsdlInputStream = null ; OMElement wsdlElement = null ; if ( wsdlKey != null ) { synCfg . getEntryDefinition ( wsdlKey ) ; Object keyObject = synCfg . getEntry ( wsdlKey ) ; if ( keyObject instanceof OMElement ) { wsdlElement = ( OMElement ) keyObject ; } } else if ( inLineWSDL != null ) { wsdlElement = ( OMElement ) inLineWSDL ; } else if ( wsdlURI != null ) { try { URL url = wsdlURI . toURL ( ) ; wsdlElement = Util . getOMElementFromURL ( url . toString ( ) ) ; } catch ( MalformedURLException e ) { handleException ( "Malformed URI for wsdl" , e ) ; } catch ( IOException e ) { handleException ( "Error reading from wsdl URI" , e ) ; } } if ( wsdlElement != null ) { OMNamespace wsdlNamespace = wsdlElement . getNamespace ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { wsdlElement . serialize ( baos ) ; wsdlInputStream = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error converting to a StreamSource" , e ) ; } if ( wsdlInputStream != null ) { try { if ( wsdlNamespace != null ) { boolean isWSDL11 = false ; WSDLToAxisServiceBuilder wsdlToAxisServiceBuilder = null ; if ( WSDL2Constants . WSDL_NAMESPACE . equals ( wsdlNamespace . getNamespaceURI ( ) ) ) { wsdlToAxisServiceBuilder = new WSDL20ToAxisServiceBuilder ( wsdlInputStream , null , null ) ; wsdlToAxisServiceBuilder . setBaseUri ( wsdlURI != null ? wsdlURI . toString ( ) : "" ) ; } else if ( org . apache . axis2 . namespace . Constants . NS_URI_WSDL11 . equals ( wsdlNamespace . getNamespaceURI ( ) ) ) { wsdlToAxisServiceBuilder = new WSDL11ToAxisServiceBuilder ( wsdlInputStream , null , null ) ; isWSDL11 = true ; } else { handleException ( "Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0" ) ; } if ( wsdlToAxisServiceBuilder == null ) { throw new SynapseException ( "Could not get the WSDL to Axis Service Builder" ) ; } proxyService = wsdlToAxisServiceBuilder . populateService ( ) ; proxyService . setWsdlFound ( true ) ; if ( isWSDL11 ) { Collection endpoints = proxyService . getEndpoints ( ) . values ( ) ; Iterator iter = endpoints . iterator ( ) ; while ( iter . hasNext ( ) ) { AxisEndpoint endpoint = ( AxisEndpoint ) iter . next ( ) ; Iterator children = endpoint . getBinding ( ) . getChildren ( ) ; while ( children . hasNext ( ) ) { AxisBindingOperation axisBindingOperation = ( AxisBindingOperation ) children . next ( ) ; axisBindingOperation . setProperty ( WSDL2Constants . ATTR_WHTTP_IGNORE_UNCITED , new Boolean ( false ) ) ; } } } } else { handleException ( "Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0" ) ; } } catch ( AxisFault af ) { handleException ( "Error building service from WSDL" , af ) ; } catch ( IOException ioe ) { handleException ( "Error reading WSDL" , ioe ) ; } } } else { proxyService = new AxisService ( ) ; AxisOperation mediateOperation = new InOutAxisOperation ( new QName ( "mediate" ) ) ; proxyService . addOperation ( mediateOperation ) ; } if ( proxyService == null ) { throw new SynapseException ( "Could not create a proxy service" ) ; } proxyService . setName ( name ) ; if ( description != null ) { proxyService . setServiceDescription ( description ) ; } if ( transports == null || transports . size ( ) == 0 ) { } else { proxyService . setExposedTransports ( transports ) ; } Iterator iter = parameters . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String name = ( String ) iter . next ( ) ; Object value = parameters . get ( name ) ; Parameter p = new Parameter ( ) ; p . setName ( name ) ; p . setValue ( value ) ; try { proxyService . addParameter ( p ) ; } catch ( AxisFault af ) { handleException ( "Error setting parameter : " + name + "" + "to proxy service as a Parameter" , af ) ; } } if ( ! serviceLevelPolicies . isEmpty ( ) ) { Policy svcEffectivePolicy = null ; iter = serviceLevelPolicies . iterator ( ) ; while ( iter . hasNext ( ) ) { String policyKey = ( String ) iter . next ( ) ; synCfg . getEntryDefinition ( policyKey ) ; Object policyProp = synCfg . getEntry ( policyKey ) ; if ( policyProp != null ) { if ( svcEffectivePolicy == null ) { svcEffectivePolicy = PolicyEngine . getPolicy ( Util . getStreamSource ( policyProp ) . getInputStream ( ) ) ; } else { svcEffectivePolicy = ( Policy ) svcEffectivePolicy . merge ( PolicyEngine . getPolicy ( Util . getStreamSource ( policyProp ) . getInputStream ( ) ) ) ; } } } PolicyInclude pi = proxyService . getPolicyInclude ( ) ; if ( pi != null && svcEffectivePolicy != null ) { pi . addPolicyElement ( PolicyInclude . AXIS_SERVICE_POLICY , svcEffectivePolicy ) ; } } ProxyServiceMessageReceiver msgRcvr = new ProxyServiceMessageReceiver ( ) ; msgRcvr . setName ( name ) ; iter = proxyService . getOperations ( ) ; while ( iter . hasNext ( ) ) { AxisOperation op = ( AxisOperation ) iter . next ( ) ; op . setMessageReceiver ( msgRcvr ) ; } try { axisCfg . addService ( proxyService ) ; this . setRunning ( true ) ; } catch ( AxisFault axisFault ) { try { if ( axisCfg . getService ( proxyService . getName ( ) ) != null ) { axisCfg . removeService ( proxyService . getName ( ) ) ; } } catch ( AxisFault ignore ) { } handleException ( "Error adding Proxy service to the Axis2 engine" , axisFault ) ; } if ( wsRMEnabled ) { try { proxyService . engageModule ( axisCfg . getModule ( Constants . SANDESHA2_MODULE_NAME ) , axisCfg ) ; } catch ( AxisFault axisFault ) { handleException ( "Error loading WS RM module on proxy service : " + name , axisFault ) ; } } if ( wsSecEnabled ) { try { proxyService . engageModule ( axisCfg . getModule ( Constants . RAMPART_MODULE_NAME ) , axisCfg ) ; } catch ( AxisFault axisFault ) { handleException ( "Error loading WS Sec module on proxy service : " + name , axisFault ) ; } } return proxyService ; } public void start ( SynapseConfiguration synCfg ) { AxisConfiguration axisConfig = synCfg . getAxisConfiguration ( ) ; axisConfig . getServiceForActivation ( this . getName ( ) ) . setActive ( true ) ; this . setRunning ( true ) ; } public void stop ( SynapseConfiguration synCfg ) { AxisConfiguration axisConfig = synCfg . getAxisConfiguration ( ) . getAxisConfiguration ( ) ; try { axisConfig . getService ( this . getName ( ) ) . setActive ( false ) ; this . setRunning ( false ) ; } catch ( AxisFault axisFault ) { handleException ( axisFault . getMessage ( ) ) ; } } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public ArrayList getTransports ( ) { return transports ; } public void addParameter ( String name , Object value ) { parameters . put ( name , value ) ; } public Map getParameterMap ( ) { return this . parameters ; } public void setTransports ( ArrayList transports ) { this . transports = transports ; } public String getTargetEndpoint ( ) { return targetEndpoint ; } public void setTargetEndpoint ( String targetEndpoint ) { this . targetEndpoint = targetEndpoint ; } public String getTargetInSequence ( ) { return targetInSequence ; } public void setTargetInSequence ( String targetInSequence ) { this . targetInSequence = targetInSequence ; } public String getTargetOutSequence ( ) { return targetOutSequence ; } public void setTargetOutSequence ( String targetOutSequence ) { this . targetOutSequence = targetOutSequence ; } public String getWSDLKey ( ) { return wsdlKey ; } public void setWSDLKey ( String wsdlKey ) { this . wsdlKey = wsdlKey ; } public List getSchemas ( ) { return schemaKeys ; } public void setSchemas ( List schemas ) { this . schemaKeys = schemas ; } public List getServiceLevelPolicies ( ) { return serviceLevelPolicies ; } public void addServiceLevelPolicy ( String serviceLevelPolicy ) { this . serviceLevelPolicies . add ( serviceLevelPolicy ) ; } public boolean isWsRMEnabled ( ) { return wsRMEnabled ; } public void setWsRMEnabled ( boolean wsRMEnabled ) { this . wsRMEnabled = wsRMEnabled ; } public boolean isWsSecEnabled ( ) { return wsSecEnabled ; } public void setWsSecEnabled ( boolean wsSecEnabled ) { this . wsSecEnabled = wsSecEnabled ; } public boolean isStartOnLoad ( ) { return startOnLoad ; } public void setStartOnLoad ( boolean startOnLoad ) { this . startOnLoad = startOnLoad ; } public boolean isRunning ( ) { return running ; } public void setRunning ( boolean running ) { this . running = running ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } public int getStatisticsEnable ( ) { return statisticsEnable ; } public void setStatisticsEnable ( int statisticsEnable ) { this . statisticsEnable = statisticsEnable ; } public int getTraceState ( ) { return traceState ; } public void setTraceState ( int traceState ) { this . traceState = traceState ; } public String getTargetFaultSequence ( ) { return targetFaultSequence ; } public void setTargetFaultSequence ( String targetFaultSequence ) { this . targetFaultSequence = targetFaultSequence ; } public Object getInLineWSDL ( ) { return inLineWSDL ; } public void setInLineWSDL ( Object inLineWSDL ) { this . inLineWSDL = inLineWSDL ; } public URI getWsdlURI ( ) { return wsdlURI ; } public void setWsdlURI ( URI wsdlURI ) { this . wsdlURI = wsdlURI ; } public Endpoint getTargetInLineEndpoint ( ) { return targetInLineEndpoint ; } public void setTargetInLineEndpoint ( Endpoint targetInLineEndpoint ) { this . targetInLineEndpoint = targetInLineEndpoint ; } public SequenceMediator getTargetInLineInSequence ( ) { return targetInLineInSequence ; } public void setTargetInLineInSequence ( SequenceMediator targetInLineInSequence ) { this . targetInLineInSequence = targetInLineInSequence ; } public SequenceMediator getTargetInLineOutSequence ( ) { return targetInLineOutSequence ; } public void setTargetInLineOutSequence ( SequenceMediator targetInLineOutSequence ) { this . targetInLineOutSequence = targetInLineOutSequence ; } public SequenceMediator getTargetInLineFaultSequence ( ) { return targetInLineFaultSequence ; } public void setTargetInLineFaultSequence ( SequenceMediator targetInLineFaultSequence ) { this . targetInLineFaultSequence = targetInLineFaultSequence ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . WSDLEndpoint ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . config . xml . endpoints . utils . WSDL11EndpointBuilder ; import org . apache . synapse . config . xml . endpoints . utils . WSDL20EndpointBuilder ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . description . WSDL2Constants ; import org . apache . synapse . config . Util ; import javax . xml . namespace . QName ; import java . net . URL ; import java . net . URLConnection ; import java . io . InputStream ; import java . io . IOException ; public class WSDLEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( WSDLEndpointFactory . class ) ; private static WSDLEndpointFactory instance = new WSDLEndpointFactory ( ) ; private WSDLEndpointFactory ( ) { } public static WSDLEndpointFactory getInstance ( ) { return instance ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { WSDLEndpoint wsdlEndpoint = new WSDLEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { wsdlEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement wsdlElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "wsdl" ) ) ; if ( wsdlElement != null ) { OMElement suspendElement = wsdlElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; wsdlEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "suspendDurationOnFailure should be valid number." ) ; } } EndpointDefinition endpoint = null ; String serviceName = wsdlElement . getAttributeValue ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "service" ) ) ; String portName = wsdlElement . getAttributeValue ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "port" ) ) ; String wsdlURI = wsdlElement . getAttributeValue ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; wsdlEndpoint . setServiceName ( serviceName ) ; wsdlEndpoint . setPortName ( portName ) ; if ( wsdlURI != null ) { wsdlEndpoint . setWsdlURI ( wsdlURI . trim ( ) ) ; try { String ns = Util . getOMElementFromURL ( new URL ( wsdlURI ) . toString ( ) ) . getNamespace ( ) . getNamespaceURI ( ) ; if ( org . apache . axis2 . namespace . Constants . NS_URI_WSDL11 . equals ( ns ) ) { endpoint = new WSDL11EndpointBuilder ( ) . createEndpointDefinitionFromWSDL ( wsdlURI , serviceName , portName ) ; } else if ( WSDL2Constants . WSDL_NAMESPACE . equals ( ns ) ) { handleException ( "WSDL 2.0 Endpoints are currently not supported" ) ; } } catch ( Exception e ) { handleException ( "Couldn't create endpoint from the given WSDL URI : " + e . getMessage ( ) , e ) ; } } OMElement definitionElement = wsdlElement . getFirstChildWithName ( new QName ( org . apache . axis2 . namespace . Constants . NS_URI_WSDL11 , "definitions" ) ) ; if ( endpoint == null && definitionElement != null ) { wsdlEndpoint . setWsdlDoc ( definitionElement ) ; endpoint = new WSDL11EndpointBuilder ( ) . createEndpointDefinitionFromWSDL ( definitionElement , serviceName , portName ) ; } OMElement descriptionElement = wsdlElement . getFirstChildWithName ( new QName ( org . apache . axis2 . namespace . Constants . NS_URI_WSDL11 , "description" ) ) ; if ( endpoint == null && descriptionElement != null ) { wsdlEndpoint . setWsdlDoc ( descriptionElement ) ; handleException ( "WSDL 2.0 Endpoints are currently not supported." ) ; } if ( endpoint != null ) { extractQOSInformation ( endpoint , wsdlElement ) ; OMAttribute statistics = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } wsdlEndpoint . setEndpointDefinition ( endpoint ) ; } else { handleException ( "WSDL is not specified for WSDL endpoint." ) ; } } return wsdlEndpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void extractQOSInformation ( EndpointDefinition endpointDefinition , OMElement wsdlElement ) { OMAttribute format = wsdlElement . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = wsdlElement . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpointDefinition . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpointDefinition . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpointDefinition . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpointDefinition . setUseSwa ( true ) ; } } OMElement wsAddr = wsdlElement . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpointDefinition . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpointDefinition . setUseSeparateListener ( true ) ; } } } OMElement wsSec = wsdlElement . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpointDefinition . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpointDefinition . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = wsdlElement . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpointDefinition . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpointDefinition . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = wsdlElement . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpointDefinition . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpointDefinition . setTimeoutAction ( Constants . DISCARD ) ; if ( endpointDefinition . getTimeoutDuration ( ) == 0 ) { endpointDefinition . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpointDefinition . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpointDefinition . getTimeoutDuration ( ) == 0 ) { endpointDefinition . setTimeoutDuration ( 30000 ) ; } } } } } } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . RMSequenceMediator ; import org . jaxen . JaxenException ; public class RMSequenceMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName SEQUENCE_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "RMSequence" ) ; public Mediator createMediator ( OMElement elem ) { RMSequenceMediator sequenceMediator = new RMSequenceMediator ( ) ; OMAttribute correlation = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "correlation" ) ) ; OMAttribute lastMessage = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "last-message" ) ) ; OMAttribute single = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "single" ) ) ; OMAttribute version = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "version" ) ) ; if ( single == null && correlation == null ) { String msg = "The 'single' attribute value of true or a 'correlation' attribute is " + "required for the configuration of a RMSequence mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } if ( correlation != null ) { if ( correlation . getAttributeValue ( ) != null && correlation . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) { String msg = "Invalid attribute value specified for correlation" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { try { sequenceMediator . setCorrelation ( new AXIOMXPath ( correlation . getAttributeValue ( ) ) ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute correlation : " + correlation . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMElementUtils . addNameSpaces ( sequenceMediator . getCorrelation ( ) , elem , log ) ; } if ( single != null ) { sequenceMediator . setSingle ( Boolean . valueOf ( single . getAttributeValue ( ) ) ) ; } if ( sequenceMediator . isSingle ( ) && sequenceMediator . getCorrelation ( ) != null ) { String msg = "Invalid RMSequence mediator. A RMSequence can't have both a " + "single attribute value of true and a correlation attribute specified." ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ! sequenceMediator . isSingle ( ) && sequenceMediator . getCorrelation ( ) == null ) { String msg = "Invalid RMSequence mediator. A RMSequence must have a " + "single attribute value of true or a correlation attribute specified." ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } if ( lastMessage != null ) { if ( lastMessage . getAttributeValue ( ) != null && lastMessage . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) { String msg = "Invalid attribute value specified for last-message" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { try { sequenceMediator . setLastMessage ( new AXIOMXPath ( lastMessage . getAttributeValue ( ) ) ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute last-message : " + lastMessage . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMElementUtils . addNameSpaces ( sequenceMediator . getLastMessage ( ) , elem , log ) ; } if ( sequenceMediator . isSingle ( ) && sequenceMediator . getLastMessage ( ) != null ) { String msg = "Invalid RMSequence mediator. A RMSequence can't have both a " + "single attribute value of true and a last-message attribute specified." ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } if ( version != null ) { if ( ! Constants . SEQUENCE_VERSION_1_0 . equals ( version . getAttributeValue ( ) ) && ! Constants . SEQUENCE_VERSION_1_1 . equals ( version . getAttributeValue ( ) ) ) { String msg = "Only '" + Constants . SEQUENCE_VERSION_1_0 + "' or '" + Constants . SEQUENCE_VERSION_1_1 + "' values are allowed for attribute version for a RMSequence mediator" + ", Unsupported version " + version . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } sequenceMediator . setVersion ( version . getAttributeValue ( ) ) ; } initMediator ( sequenceMediator , elem ) ; return sequenceMediator ; } public QName getTagQName ( ) { return SEQUENCE_Q ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . statistics . impl ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . StatisticsCollector ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . List ; public class EndPointStatisticsStack implements StatisticsStack { private List endpointStatistics ; private boolean isCompleteInFlowStatisicsReport = false ; public void put ( String key , long initTime , boolean isInFlow , boolean isStatisticsEnable , boolean isFault ) { if ( endpointStatistics == null ) { endpointStatistics = new ArrayList ( ) ; } endpointStatistics . add ( new EndPointStatistics ( key , initTime , isInFlow , isStatisticsEnable , isFault ) ) ; } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { if ( endpointStatistics != null && ! endpointStatistics . isEmpty ( ) ) { EndPointStatistics statistics = ( EndPointStatistics ) endpointStatistics . get ( endpointStatistics . size ( ) - 1 ) ; if ( statistics != null && statistics . isStatisticsEnable && statistics . endPointName != null ) { if ( statistics . inTimeForInFlow != - 1 ) { long initTimeForOutFlow = System . currentTimeMillis ( ) ; statisticsCollector . reportForEndPoint ( statistics . endPointName , false , statistics . inTimeForInFlow , initTimeForOutFlow , isFault ) ; statistics . inTimeForInFlow = - 1 ; statistics . inTimeForOutFlow = initTimeForOutFlow ; } else if ( statistics . inTimeForOutFlow != - 1 && isCompleteInFlowStatisicsReport ) { statisticsCollector . reportForEndPoint ( statistics . endPointName , true , statistics . inTimeForOutFlow , System . currentTimeMillis ( ) , isFault ) ; endpointStatistics . remove ( statistics ) ; } } } } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault , String name ) { if ( endpointStatistics != null && ! endpointStatistics . isEmpty ( ) ) { List tobeRemoved = new ArrayList ( ) ; for ( Iterator epIterator = endpointStatistics . iterator ( ) ; epIterator . hasNext ( ) ; ) { Object statisticsObj = epIterator . next ( ) ; if ( statisticsObj instanceof EndPointStatistics ) { EndPointStatistics statistics = ( EndPointStatistics ) statisticsObj ; if ( statistics . isStatisticsEnable && statistics . endPointName != null && statistics . endPointName . equals ( name ) ) { if ( statistics . inTimeForInFlow != - 1 ) { long initTimeForOutFlow = System . currentTimeMillis ( ) ; statisticsCollector . reportForEndPoint ( statistics . endPointName , false , statistics . inTimeForInFlow , initTimeForOutFlow , isFault ) ; statistics . inTimeForInFlow = - 1 ; statistics . inTimeForOutFlow = initTimeForOutFlow ; } else if ( statistics . inTimeForOutFlow != - 1 && isCompleteInFlowStatisicsReport ) { statisticsCollector . reportForEndPoint ( statistics . endPointName , true , statistics . inTimeForOutFlow , System . currentTimeMillis ( ) , isFault ) ; tobeRemoved . add ( statistics ) ; } } } } endpointStatistics . removeAll ( tobeRemoved ) ; } } public void reportAllToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { if ( endpointStatistics != null && ! endpointStatistics . isEmpty ( ) ) { List tobeRemoved = new ArrayList ( ) ; for ( Iterator epIterator = endpointStatistics . iterator ( ) ; epIterator . hasNext ( ) ; ) { Object statisticsObj = epIterator . next ( ) ; if ( statisticsObj instanceof EndPointStatistics ) { EndPointStatistics statistics = ( EndPointStatistics ) statisticsObj ; if ( statistics . isStatisticsEnable && statistics . endPointName != null ) { if ( statistics . inTimeForInFlow != - 1 ) { long initTimeForOutFlow = System . currentTimeMillis ( ) ; statisticsCollector . reportForEndPoint ( statistics . endPointName , false , statistics . inTimeForInFlow , initTimeForOutFlow , isFault ) ; statistics . inTimeForInFlow = - 1 ; statistics . inTimeForOutFlow = initTimeForOutFlow ; } else if ( statistics . inTimeForOutFlow != - 1 && isCompleteInFlowStatisicsReport ) { statisticsCollector . reportForEndPoint ( statistics . endPointName , true , statistics . inTimeForOutFlow , System . currentTimeMillis ( ) , isFault ) ; tobeRemoved . add ( statistics ) ; } } } } endpointStatistics . removeAll ( tobeRemoved ) ; } isCompleteInFlowStatisicsReport = true ; } class EndPointStatistics { private String endPointName ; private boolean isStatisticsEnable ; private boolean isFault ; private long inTimeForInFlow = - 1 ; private long inTimeForOutFlow = - 1 ; public EndPointStatistics ( String endPointName , long initTime , boolean inFlow , boolean statisticsEnable , boolean fault ) { if ( inFlow ) { this . endPointName = endPointName ; this . inTimeForInFlow = initTime ; isStatisticsEnable = statisticsEnable ; isFault = fault ; } } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; EndPointStatistics that = ( EndPointStatistics ) o ; if ( endPointName != null ? ! endPointName . equals ( that . endPointName ) : that . endPointName != null ) return false ; return true ; } public int hashCode ( ) { return ( endPointName != null ? endPointName . hashCode ( ) : 0 ) ; } } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . endpoints ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import java . util . ArrayList ; import java . util . List ; public class LoadbalanceEndpoint implements Endpoint { private String name = null ; private List endpoints = null ; private LoadbalanceAlgorithm algorithm = null ; private volatile boolean active = true ; private boolean failover = true ; private Endpoint parentEndpoint = null ; public void send ( MessageContext synMessageContext ) { Endpoint endpoint = algorithm . getNextEndpoint ( synMessageContext ) ; if ( endpoint != null ) { if ( failover ) { synMessageContext . getEnvelope ( ) . build ( ) ; } endpoint . send ( synMessageContext ) ; } else { setActive ( false , synMessageContext ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public LoadbalanceAlgorithm getAlgorithm ( ) { return algorithm ; } public void setAlgorithm ( LoadbalanceAlgorithm algorithm ) { this . algorithm = algorithm ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { for ( int i = 0 ; i < endpoints . size ( ) ; i ++ ) { Endpoint endpoint = ( Endpoint ) endpoints . get ( i ) ; if ( endpoint . isActive ( synMessageContext ) ) { active = true ; } } } return active ; } public void setActive ( boolean active , MessageContext synMessageContext ) { this . active = active ; } public boolean isFailover ( ) { return failover ; } public void setFailover ( boolean failover ) { this . failover = failover ; } public List getEndpoints ( ) { return endpoints ; } public void setEndpoints ( List endpoints ) { this . endpoints = endpoints ; } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { if ( failover ) { send ( synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . config . xml . XSLTMediatorFactory ; import org . apache . synapse . config . xml . ValidateMediatorFactory ; import org . apache . synapse . config . XMLToObjectMapper ; import sun . misc . Service ; import javax . xml . namespace . QName ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class MediatorFactoryFinder implements XMLToObjectMapper { private static final Log log = LogFactory . getLog ( MediatorFactoryFinder . class ) ; private static final Class [ ] mediatorFactories = { SequenceMediatorFactory . class , LogMediatorFactory . class , SendMediatorFactory . class , FilterMediatorFactory . class , SynapseMediatorFactory . class , DropMediatorFactory . class , HeaderMediatorFactory . class , FaultMediatorFactory . class , PropertyMediatorFactory . class , SwitchMediatorFactory . class , InMediatorFactory . class , OutMediatorFactory . class , RMSequenceMediatorFactory . class , ClassMediatorFactory . class , ValidateMediatorFactory . class , XSLTMediatorFactory . class } ; private static MediatorFactoryFinder instance = null ; private static Map factoryMap = new HashMap ( ) ; public static synchronized MediatorFactoryFinder getInstance ( ) { if ( instance == null ) { instance = new MediatorFactoryFinder ( ) ; } return instance ; } public synchronized void reset ( ) { factoryMap . clear ( ) ; instance = null ; } private MediatorFactoryFinder ( ) { factoryMap = new HashMap ( ) ; for ( int i = 0 ; i < mediatorFactories . length ; i ++ ) { Class c = mediatorFactories [ i ] ; try { MediatorFactory fac = ( MediatorFactory ) c . newInstance ( ) ; factoryMap . put ( fac . getTagQName ( ) , c ) ; } catch ( Exception e ) { throw new SynapseException ( "Error instantiating " + c . getName ( ) , e ) ; } } registerExtensions ( ) ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private void registerExtensions ( ) { Iterator it = Service . providers ( MediatorFactory . class ) ; while ( it . hasNext ( ) ) { MediatorFactory mf = ( MediatorFactory ) it . next ( ) ; QName tag = mf . getTagQName ( ) ; factoryMap . put ( tag , mf . getClass ( ) ) ; log . debug ( "Added MediatorFactory " + mf . getClass ( ) + " to handle " + tag ) ; } } public Mediator getMediator ( OMElement element ) { String localName = element . getLocalName ( ) ; QName qName = null ; if ( element . getNamespace ( ) != null ) { qName = new QName ( element . getNamespace ( ) . getNamespaceURI ( ) , localName ) ; } else { qName = new QName ( localName ) ; } log . debug ( "getMediator(" + qName + ")" ) ; Class cls = ( Class ) factoryMap . get ( qName ) ; if ( cls == null && localName . indexOf ( '.' ) > - 1 ) { String newLocalName = localName . substring ( 0 , localName . indexOf ( '.' ) ) ; qName = new QName ( element . getNamespace ( ) . getNamespaceURI ( ) , newLocalName ) ; log . debug ( "getMediator.2(" + qName + ")" ) ; cls = ( Class ) factoryMap . get ( qName ) ; } if ( cls == null ) { String msg = "Unknown mediator referenced by configuration element : " + qName ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } try { MediatorFactory mf = ( MediatorFactory ) cls . newInstance ( ) ; return mf . createMediator ( element ) ; } catch ( InstantiationException e ) { String msg = "Error initializing mediator factory : " + cls ; log . error ( msg ) ; throw new SynapseException ( msg , e ) ; } catch ( IllegalAccessException e ) { String msg = "Error initializing mediator factory : " + cls ; log . error ( msg ) ; throw new SynapseException ( msg , e ) ; } } public Map getFactoryMap ( ) { return factoryMap ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return getMediator ( ( OMElement ) om ) ; } else { handleException ( "Invalid mediator configuration XML : " + om ) ; } return null ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . mediators . ext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class ClassMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( ClassMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private Class clazz = null ; private List properties = new ArrayList ( ) ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Class mediator <" + clazz . getName ( ) + ">:: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Class mediator" ) ; } Mediator m ; try { try { m = ( Mediator ) clazz . newInstance ( ) ; } catch ( Exception e ) { String msg = "Error while creating an instance of the specified mediator class : " + clazz . getName ( ) ; if ( shouldTrace ) trace . trace ( msg ) ; log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } setProperties ( m , synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Executing an instance of the specified class : " + clazz . getName ( ) ) ; } return m . mediate ( synCtx ) ; } finally { if ( shouldTrace ) { trace . trace ( "End : Class mediator" ) ; } } } private void setProperties ( Mediator m , MessageContext synCtx , boolean shouldTrace ) { Iterator iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty mProp = ( MediatorProperty ) iter . next ( ) ; String mName = "set" + Character . toUpperCase ( mProp . getName ( ) . charAt ( 0 ) ) + mProp . getName ( ) . substring ( 1 ) ; String value = ( mProp . getValue ( ) != null ? mProp . getValue ( ) : Axis2MessageContext . getStringValue ( mProp . getExpression ( ) , synCtx ) ) ; try { if ( value != null ) { Method method = m . getClass ( ) . getMethod ( mName , new Class [ ] { String . class } ) ; log . debug ( "Setting property :: invoking method " + mName + "(" + value + ")" ) ; if ( shouldTrace ) { trace . trace ( "Setting property :: invoking method " + mName + "(" + value + ")" ) ; } method . invoke ( m , new Object [ ] { value } ) ; } } catch ( Exception e ) { String msg = "Error setting property : " + mProp . getName ( ) + " as a String property into class" + " mediator : " + m . getClass ( ) + " : " + e . getMessage ( ) ; log . error ( msg ) ; if ( shouldTrace ) { trace . trace ( msg ) ; } throw new SynapseException ( msg , e ) ; } } } public void setClazz ( Class clazz ) { this . clazz = clazz ; } public Class getClazz ( ) { return clazz ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . OMElementUtils ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . XSLTMediator ; import org . apache . synapse . config . xml . Constants ; import org . apache . synapse . config . xml . AbstractMediatorFactory ; import org . apache . synapse . config . xml . MediatorPropertyFactory ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; public class XSLTMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( XSLTMediatorFactory . class ) ; private static final QName TAG_NAME = new QName ( Constants . SYNAPSE_NAMESPACE , "xslt" ) ; public QName getTagQName ( ) { return TAG_NAME ; } public Mediator createMediator ( OMElement elem ) { XSLTMediator transformMediator = new XSLTMediator ( ) ; OMAttribute attXslt = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "key" ) ) ; OMAttribute attSource = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "source" ) ) ; if ( attXslt != null ) { transformMediator . setXsltKey ( attXslt . getAttributeValue ( ) ) ; } else { handleException ( "The 'key' attribute is required for the XSLT mediator" ) ; } if ( attSource != null ) { try { AXIOMXPath xp = new AXIOMXPath ( attSource . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; transformMediator . setSource ( xp ) ; } catch ( JaxenException e ) { handleException ( "Invalid XPath specified for the source attribute : " + attSource . getAttributeValue ( ) ) ; } } initMediator ( transformMediator , elem ) ; transformMediator . addAllProperties ( MediatorPropertyFactory . getMediatorProperties ( elem ) ) ; return transformMediator ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . mediators . builtin ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . SALoadbalanceEndpoint ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . context . OperationContext ; import java . util . List ; public class SendMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( SendMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private Endpoint endpoint = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Send mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; try { if ( shouldTrace ) { trace . trace ( "Start : Send mediator" ) ; trace . trace ( "Sending Message :: " + synCtx . getEnvelope ( ) ) ; } if ( endpoint == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message using implicit message properties.." ) ; log . debug ( "Sending To: " + ( synCtx . getTo ( ) != null ? synCtx . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } if ( synCtx . isResponse ( ) ) { Axis2MessageContext axis2MsgCtx = ( Axis2MessageContext ) synCtx ; OperationContext opCtx = axis2MsgCtx . getAxis2MessageContext ( ) . getOperationContext ( ) ; Object o = opCtx . getProperty ( "endpointList" ) ; if ( o != null ) { List endpointList = ( List ) o ; Object e = endpointList . remove ( 0 ) ; if ( e != null && e instanceof SALoadbalanceEndpoint ) { SALoadbalanceEndpoint saLoadbalanceEndpoint = ( SALoadbalanceEndpoint ) e ; saLoadbalanceEndpoint . updateSession ( synCtx , endpointList ) ; } } } synCtx . getEnvironment ( ) . send ( null , synCtx ) ; } else { endpoint . send ( synCtx ) ; } } finally { if ( shouldTrace ) { trace . trace ( "End : Send mediator" ) ; } } return true ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . synapse . config . XMLToObjectMapper ; import org . apache . synapse . config . Entry ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMText ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . net . URL ; import java . net . MalformedURLException ; public class EntryFactory implements XMLToObjectMapper { private static Log log = LogFactory . getLog ( EntryFactory . class ) ; public static Entry createEntry ( OMElement elem ) { OMAttribute key = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "key" ) ) ; if ( key == null ) { handleException ( "The 'key' attribute is required for a local registry entry" ) ; return null ; } else { Entry entry = new Entry ( key . getAttributeValue ( ) ) ; String src = elem . getAttributeValue ( new QName ( Constants . NULL_NAMESPACE , "src" ) ) ; if ( src != null ) { try { entry . setSrc ( new URL ( src . trim ( ) ) ) ; entry . setType ( Entry . URL_SRC ) ; entry . setValue ( org . apache . synapse . config . Util . getObject ( entry . getSrc ( ) ) ) ; } catch ( MalformedURLException e ) { handleException ( "The entry with key : " + key + " refers to an invalid URL" ) ; } } else { OMNode nodeValue = elem . getFirstOMChild ( ) ; OMElement elemValue = elem . getFirstElement ( ) ; if ( elemValue != null ) { entry . setType ( Entry . INLINE_XML ) ; entry . setValue ( elemValue ) ; } else if ( nodeValue != null && nodeValue instanceof OMText ) { entry . setType ( Entry . INLINE_TEXT ) ; entry . setValue ( ( ( OMText ) nodeValue ) . getText ( ) . trim ( ) ) ; } } return entry ; } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEntry ( ( OMElement ) om ) ; } else { handleException ( "Invalid XML configuration for an Entry. OMElement expected" ) ; } return null ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config ; import org . apache . axiom . om . OMNode ; public interface XMLToObjectMapper { public Object getObjectFromOMNode ( OMNode om ) ; } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Iterator ; public abstract class AnonymousListMediatorFactory extends AbstractListMediatorFactory { private static final Log log = LogFactory . getLog ( AnonymousListMediator . class ) ; public static AnonymousListMediator createAnonymousListMediator ( OMElement el ) { AnonymousListMediator mediator = new AnonymousListMediator ( ) ; { addChildren ( el , mediator ) ; } return mediator ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . mediators . builtin ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Collections ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import org . jaxen . JaxenException ; public class RMSequenceMediator extends AbstractMediator { private static Log log = LogFactory . getLog ( RMSequenceMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private AXIOMXPath correlation = null ; private AXIOMXPath lastMessage = null ; private Boolean single = null ; private String version = null ; private static final String WSRM_SpecVersion_1_0 = "Spec_2005_02" ; private static final String WSRM_SpecVersion_1_1 = "Spec_2007_02" ; private static final long SEQUENCE_EXPIRY_TIME = 300000 ; private static Map sequenceMap = Collections . synchronizedMap ( new HashMap ( ) ) ; public boolean mediate ( MessageContext smc ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "RMSequence Mediator  ::  mediate() " ) ; } boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : RMSequence mediator" ) ; } if ( ! ( smc instanceof Axis2MessageContext ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "RMSequence Mediator  ::  only axis2 message context is supported " ) ; } return true ; } Axis2MessageContext axis2MessageCtx = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext orgMessageCtx = axis2MessageCtx . getAxis2MessageContext ( ) ; cleanupSequenceMap ( ) ; String version = getVersionValue ( ) ; orgMessageCtx . getOptions ( ) . setProperty ( Constants . SANDESHA_SPEC_VERSION , version ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "using WS-RM version " + version ) ; } if ( isSingle ( ) ) { String sequenceID = UUIDGenerator . getUUID ( ) ; orgMessageCtx . getOptions ( ) . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , sequenceID ) ; orgMessageCtx . getOptions ( ) . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , UUIDGenerator . getUUID ( ) ) ; orgMessageCtx . getOptions ( ) . setProperty ( Constants . SANDESHA_LAST_MESSAGE , "true" ) ; return true ; } String correlationValue = getCorrelationValue ( smc ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "correlation value is " + correlationValue ) ; } boolean lastMessage = isLastMessage ( smc ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Is this message the last message in sequence: " + lastMessage ) ; } if ( ! sequenceMap . containsKey ( correlationValue ) ) { orgMessageCtx . getOptions ( ) . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , UUIDGenerator . getUUID ( ) ) ; } String sequenceID = retrieveSequenceID ( correlationValue ) ; orgMessageCtx . getOptions ( ) . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , sequenceID ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "RMSequence Mediator  ::  using sequence " + sequenceID ) ; } if ( lastMessage ) { orgMessageCtx . getOptions ( ) . setProperty ( Constants . SANDESHA_LAST_MESSAGE , "true" ) ; sequenceMap . remove ( correlationValue ) ; } if ( shouldTrace ) { trace . trace ( "End : RMSequence mediator" ) ; } return true ; } private String retrieveSequenceID ( String correlationValue ) { String sequenceID = null ; if ( ! sequenceMap . containsKey ( correlationValue ) ) { sequenceID = UUIDGenerator . getUUID ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "setting sequenceID " + sequenceID + " for correlation " + correlationValue ) ; } Entry sequenceEntry = new Entry ( ) ; sequenceEntry . setValue ( sequenceID ) ; sequenceEntry . setExpiryTime ( System . currentTimeMillis ( ) + SEQUENCE_EXPIRY_TIME ) ; sequenceMap . put ( correlationValue , sequenceEntry ) ; } else { sequenceID = ( String ) ( ( Entry ) sequenceMap . get ( correlationValue ) ) . getValue ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "got sequenceID " + sequenceID + " for correlation " + correlationValue ) ; } } return sequenceID ; } private String getCorrelationValue ( MessageContext smc ) { OMElement node = null ; try { node = ( OMElement ) getCorrelation ( ) . selectSingleNode ( smc . getEnvelope ( ) ) ; } catch ( JaxenException e ) { log . error ( "XPath error : " + e . getMessage ( ) ) ; throw new SynapseException ( "XPath error : " + e . getMessage ( ) ) ; } if ( node == null ) { log . debug ( "XPath expression did not return any node" ) ; throw new SynapseException ( "XPath expression did not return any node" ) ; } return node . getText ( ) ; } private String getVersionValue ( ) { if ( Constants . SEQUENCE_VERSION_1_1 . equals ( getVersion ( ) ) ) { return WSRM_SpecVersion_1_1 ; } else { return WSRM_SpecVersion_1_0 ; } } private boolean isLastMessage ( MessageContext smc ) { if ( getLastMessage ( ) == null ) { return false ; } try { return getLastMessage ( ) . booleanValueOf ( smc . getEnvelope ( ) ) ; } catch ( JaxenException e ) { log . error ( "XPath error : " + e . getMessage ( ) ) ; throw new SynapseException ( "XPath error : " + e . getMessage ( ) ) ; } } private synchronized void cleanupSequenceMap ( ) { Iterator itKey = sequenceMap . keySet ( ) . iterator ( ) ; while ( itKey . hasNext ( ) ) { Object key = itKey . next ( ) ; Entry sequenceEntry = ( Entry ) sequenceMap . get ( key ) ; if ( sequenceEntry . isExpired ( ) ) { sequenceMap . remove ( key ) ; } } } public boolean isSingle ( ) { if ( getSingle ( ) != null && getSingle ( ) . booleanValue ( ) ) { return true ; } else { return false ; } } public AXIOMXPath getCorrelation ( ) { return correlation ; } public void setCorrelation ( AXIOMXPath correlation ) { this . correlation = correlation ; } public AXIOMXPath getLastMessage ( ) { return lastMessage ; } public void setLastMessage ( AXIOMXPath lastMessage ) { this . lastMessage = lastMessage ; } public Boolean getSingle ( ) { return single ; } public void setSingle ( Boolean single ) { this . single = single ; } public String getVersion ( ) { return version ; } public void setVersion ( String version ) { this . version = version ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . statistics ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . impl . SequenceStatisticsStack ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . statistics . impl . ProxyServiceStatisticsStack ; public class StatisticsUtils { public static void processProxyServiceStatistics ( MessageContext synCtx ) { StatisticsCollector statisticsCollector = getStatisticsCollector ( synCtx ) ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; ProxyServiceStatisticsStack proxyServiceStatisticsStack = ( ProxyServiceStatisticsStack ) synCtx . getProperty ( Constants . PROXYSERVICE_STATISTICS_STACK ) ; if ( proxyServiceStatisticsStack != null ) { proxyServiceStatisticsStack . reportToStatisticsCollector ( statisticsCollector , isFault ) ; } ProxyServiceStatisticsStack synapseServiceStatisticsStack = ( ProxyServiceStatisticsStack ) synCtx . getProperty ( Constants . SYNAPSESERVICE_STATISTICS_STACK ) ; if ( synapseServiceStatisticsStack != null ) { synapseServiceStatisticsStack . reportToStatisticsCollector ( statisticsCollector , isFault ) ; } } public static void processEndPointStatistics ( MessageContext synCtx ) { StatisticsCollector statisticsCollector = getStatisticsCollector ( synCtx ) ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; EndPointStatisticsStack endPointStatisticsStack = ( EndPointStatisticsStack ) synCtx . getProperty ( Constants . ENDPOINT_STATISTICS_STACK ) ; if ( endPointStatisticsStack != null ) { Object endpointObj = synCtx . getProperty ( Constants . PROCESSED_ENDPOINT ) ; if ( endpointObj instanceof Endpoint ) { Endpoint endpoint = ( Endpoint ) endpointObj ; String name = endpoint . getName ( ) ; if ( name == null ) { endPointStatisticsStack . reportToStatisticsCollector ( statisticsCollector , isFault ) ; } else { endPointStatisticsStack . reportToStatisticsCollector ( statisticsCollector , isFault , name ) ; } endPointStatisticsStack . reportAllToStatisticsCollector ( statisticsCollector , true ) ; } } } public static void processSequenceStatistics ( MessageContext synCtx ) { StatisticsCollector statisticsCollector = getStatisticsCollector ( synCtx ) ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; SequenceStatisticsStack sequenceStatisticsStack = ( SequenceStatisticsStack ) synCtx . getProperty ( Constants . SEQUENCE_STATISTICS_STACK ) ; if ( sequenceStatisticsStack != null ) { sequenceStatisticsStack . reportToStatisticsCollector ( statisticsCollector , isFault ) ; } } public static void processAllSequenceStatistics ( MessageContext synCtx ) { StatisticsCollector statisticsCollector = getStatisticsCollector ( synCtx ) ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; SequenceStatisticsStack sequenceStatisticsStack = ( SequenceStatisticsStack ) synCtx . getProperty ( Constants . SEQUENCE_STATISTICS_STACK ) ; if ( sequenceStatisticsStack != null ) { sequenceStatisticsStack . reportAllToStatisticsCollector ( statisticsCollector , isFault ) ; } } private static StatisticsCollector getStatisticsCollector ( MessageContext synCtx ) { SynapseEnvironment synEnv = synCtx . getEnvironment ( ) ; StatisticsCollector statisticsCollector = null ; if ( synEnv != null ) { statisticsCollector = synEnv . getStatisticsCollector ( ) ; if ( statisticsCollector == null ) { statisticsCollector = new StatisticsCollector ( ) ; synEnv . setStatisticsCollector ( statisticsCollector ) ; } } return statisticsCollector ; } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . transport . TransportUtils ; import org . apache . axis2 . i18n . Messages ; import org . apache . axis2 . util . TargetResolver ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . description . * ; import org . apache . axis2 . engine . AxisEngine ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . synapse . Constants ; import javax . xml . namespace . QName ; public class DynamicAxisOperation extends OutInAxisOperation { public DynamicAxisOperation ( ) { super ( ) ; } public DynamicAxisOperation ( QName name ) { super ( name ) ; } public OperationClient createClient ( ServiceContext sc , Options options ) { return new DynamicOperationClient ( this , sc , options ) ; } class DynamicOperationClient extends OperationClient { DynamicOperationClient ( OutInAxisOperation axisOp , ServiceContext sc , Options options ) { super ( axisOp , sc , options ) ; } public void addMessageContext ( MessageContext mc ) throws AxisFault { mc . setServiceContext ( sc ) ; if ( mc . getMessageID ( ) == null ) { setMessageID ( mc ) ; } axisOp . registerOperationContext ( mc , oc ) ; } public MessageContext getMessageContext ( String messageLabel ) throws AxisFault { return oc . getMessageContext ( messageLabel ) ; } public void setCallback ( Callback callback ) { this . callback = callback ; } public void execute ( boolean block ) throws AxisFault { if ( completed ) { throw new AxisFault ( Messages . getMessage ( "mepiscomplted" ) ) ; } MessageContext outMsgCtx = oc . getMessageContext ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ; if ( outMsgCtx == null ) { throw new AxisFault ( Messages . getMessage ( "outmsgctxnull" ) ) ; } ConfigurationContext cfgCtx = sc . getConfigurationContext ( ) ; outMsgCtx . setOptions ( options ) ; TargetResolver tr = cfgCtx . getAxisConfiguration ( ) . getTargetResolverChain ( ) ; if ( tr != null ) { tr . resolveTarget ( outMsgCtx ) ; } TransportOutDescription transportOut = options . getTransportOut ( ) ; if ( transportOut == null ) { EndpointReference toEPR = ( options . getTo ( ) != null ) ? options . getTo ( ) : outMsgCtx . getTo ( ) ; transportOut = ClientUtils . inferOutTransport ( cfgCtx . getAxisConfiguration ( ) , toEPR , outMsgCtx ) ; } outMsgCtx . setTransportOut ( transportOut ) ; if ( options . getTransportIn ( ) == null && outMsgCtx . getTransportIn ( ) == null ) { outMsgCtx . setTransportIn ( ClientUtils . inferInTransport ( cfgCtx . getAxisConfiguration ( ) , options , outMsgCtx ) ) ; } else if ( outMsgCtx . getTransportIn ( ) == null ) { outMsgCtx . setTransportIn ( options . getTransportIn ( ) ) ; } addReferenceParameters ( outMsgCtx ) ; if ( options . isUseSeparateListener ( ) ) { } else { SynapseCallbackReceiver callbackReceiver = ( SynapseCallbackReceiver ) axisOp . getMessageReceiver ( ) ; callbackReceiver . addCallback ( outMsgCtx . getMessageID ( ) , callback ) ; send ( outMsgCtx ) ; } } private void send ( MessageContext msgctx ) throws AxisFault { MessageContext responseMessageContext = new MessageContext ( ) ; responseMessageContext . setMessageID ( msgctx . getMessageID ( ) ) ; responseMessageContext . setProperty ( Constants . RELATES_TO_FOR_POX , msgctx . getMessageID ( ) ) ; responseMessageContext . setOptions ( options ) ; addMessageContext ( responseMessageContext ) ; AxisEngine engine = new AxisEngine ( msgctx . getConfigurationContext ( ) ) ; engine . send ( msgctx ) ; if ( msgctx . getProperty ( MessageContext . TRANSPORT_IN ) != null ) { responseMessageContext . setOperationContext ( msgctx . getOperationContext ( ) ) ; responseMessageContext . setAxisMessage ( msgctx . getOperationContext ( ) . getAxisOperation ( ) . getMessage ( WSDLConstants . MESSAGE_LABEL_IN_VALUE ) ) ; responseMessageContext . setAxisService ( msgctx . getAxisService ( ) ) ; responseMessageContext . setServerSide ( true ) ; responseMessageContext . setProperty ( MessageContext . TRANSPORT_OUT , msgctx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; responseMessageContext . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , msgctx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; responseMessageContext . setProperty ( org . apache . synapse . Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; responseMessageContext . setTransportIn ( msgctx . getTransportIn ( ) ) ; responseMessageContext . setTransportOut ( msgctx . getTransportOut ( ) ) ; responseMessageContext . setDoingREST ( msgctx . isDoingREST ( ) ) ; responseMessageContext . setProperty ( MessageContext . TRANSPORT_IN , msgctx . getProperty ( MessageContext . TRANSPORT_IN ) ) ; responseMessageContext . setTransportIn ( msgctx . getTransportIn ( ) ) ; responseMessageContext . setTransportOut ( msgctx . getTransportOut ( ) ) ; responseMessageContext . setSoapAction ( "" ) ; if ( responseMessageContext . getEnvelope ( ) == null ) { SOAPEnvelope resenvelope = TransportUtils . createSOAPMessage ( responseMessageContext ) ; if ( resenvelope != null ) { responseMessageContext . setEnvelope ( resenvelope ) ; engine = new AxisEngine ( msgctx . getConfigurationContext ( ) ) ; engine . receive ( responseMessageContext ) ; if ( responseMessageContext . getReplyTo ( ) != null ) { sc . setTargetEPR ( responseMessageContext . getReplyTo ( ) ) ; } } else { throw new AxisFault ( Messages . getMessage ( "blockingInvocationExpectsResponse" ) ) ; } } } } } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . FilterMediator ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; public class FilterMediatorFactory extends AbstractListMediatorFactory { private static final Log log = LogFactory . getLog ( FaultMediatorFactory . class ) ; private static final QName FILTER_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "filter" ) ; public Mediator createMediator ( OMElement elem ) { FilterMediator filter = new FilterMediator ( ) ; OMAttribute attXpath = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "xpath" ) ) ; OMAttribute attSource = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "source" ) ) ; OMAttribute attRegex = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "regex" ) ) ; if ( attXpath != null ) { if ( attXpath . getAttributeValue ( ) != null && attXpath . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) { String msg = "Invalid attribute value specified for xpath" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { try { filter . setXpath ( new AXIOMXPath ( attXpath . getAttributeValue ( ) ) ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute xpath : " + attXpath . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMElementUtils . addNameSpaces ( filter . getXpath ( ) , elem , log ) ; } else if ( attSource != null && attRegex != null ) { if ( ( attSource . getAttributeValue ( ) != null && attSource . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) || ( attRegex . getAttributeValue ( ) != null && attRegex . getAttributeValue ( ) . trim ( ) . length ( ) == 0 ) ) { String msg = "Invalid attribute values for source and/or regex specified" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { try { filter . setSource ( new AXIOMXPath ( attSource . getAttributeValue ( ) ) ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute source : " + attSource . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } try { filter . setRegex ( Pattern . compile ( attRegex . getAttributeValue ( ) ) ) ; } catch ( PatternSyntaxException pse ) { String msg = "Invalid Regular Expression for attribute regex : " + attRegex . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } OMElementUtils . addNameSpaces ( filter . getSource ( ) , elem , log ) ; } else { String msg = "An xpath or (source, regex) attributes are required for a filter" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } initMediator ( filter , elem ) ; addChildren ( elem , filter ) ; return filter ; } public QName getTagQName ( ) { return FILTER_Q ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse ; import org . apache . synapse . MessageContext ; public interface Mediator { public boolean mediate ( MessageContext synCtx ) ; public String getType ( ) ; public int getTraceState ( ) ; public void setTraceState ( int traceState ) ; } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . metrics ; public class Counter { private long count = 0 ; public synchronized void increment ( ) { count ++ ; } public long getCount ( ) { return count ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . MessageContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . regex . Pattern ; import java . util . regex . Matcher ; public class SwitchCase { private static final Log log = LogFactory . getLog ( SwitchCase . class ) ; private Pattern regex = null ; private AnonymousListMediator caseMediator ; public SwitchCase ( ) { } public boolean mediate ( MessageContext synCtx ) { if ( caseMediator != null ) { return caseMediator . mediate ( synCtx ) ; } return true ; } public AnonymousListMediator getCaseMediator ( ) { return caseMediator ; } public void setCaseMediator ( AnonymousListMediator caseMediator ) { this . caseMediator = caseMediator ; } public Pattern getRegex ( ) { return regex ; } public void setRegex ( Pattern regex ) { this . regex = regex ; } public boolean matches ( String value ) { Matcher matcher = regex . matcher ( value ) ; if ( matcher == null ) { return false ; } boolean retVal = matcher . matches ( ) ; log . debug ( "Case : " + regex . pattern ( ) + " evaluated to : " + retVal ) ; return retVal ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . mediators . builtin ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . mediators . AbstractMediator ; public class DropMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( DropMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Drop mediator :: mediate()" ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processAllSequenceStatistics ( synCtx ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Drop mediator" ) ; } if ( synCtx . getTo ( ) == null ) { if ( shouldTrace ) { trace . trace ( "End : Drop mediator" ) ; } return false ; } else { synCtx . setTo ( null ) ; if ( shouldTrace ) { trace . trace ( "End : Drop mediator" ) ; } return false ; } } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class AnonymousListMediatorSerializer extends AbstractListMediatorSerializer { private static final Log log = LogFactory . getLog ( AnonymousListMediatorSerializer . class ) ; public static OMElement serializeAnonymousListMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof AnonymousListMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } AnonymousListMediator mediator = ( AnonymousListMediator ) m ; serializeChildren ( parent , mediator . getList ( ) ) ; return parent ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . builtin . DropMediator ; import javax . xml . namespace . QName ; public class DropMediatorFactory extends AbstractMediatorFactory { private static final QName DROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "drop" ) ; public Mediator createMediator ( OMElement el ) { Mediator dropMediator = new DropMediator ( ) ; initMediator ( dropMediator , el ) ; return dropMediator ; } public QName getTagQName ( ) { return DROP_Q ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . metrics ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . description . AxisDescription ; import org . apache . axis2 . description . AxisModule ; import org . apache . axis2 . description . Parameter ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axis2 . modules . Module ; import org . apache . neethi . Assertion ; import org . apache . neethi . Policy ; public class MetricsAggregatorModule implements Module { public void init ( ConfigurationContext configContext , AxisModule module ) throws AxisFault { AxisConfiguration axiConfiguration = configContext . getAxisConfiguration ( ) ; Counter globalRequestCounter = new Counter ( ) ; Parameter globalRequestCounterParameter = new Parameter ( ) ; globalRequestCounterParameter . setName ( Constants . GLOBAL_REQUEST_COUNTER ) ; globalRequestCounterParameter . setValue ( globalRequestCounter ) ; axiConfiguration . addParameter ( globalRequestCounterParameter ) ; } public void engageNotify ( AxisDescription axisDescription ) throws AxisFault { } public boolean canSupportAssertion ( Assertion assertion ) { return false ; } public void applyPolicy ( Policy policy , AxisDescription axisDescription ) throws AxisFault { } public void shutdown ( ConfigurationContext configurationContext ) throws AxisFault { } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . helpers . XMLReaderFactory ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import javax . xml . validation . Schema ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . * ; public class ValidateMediator extends AbstractListMediator { private static final Log log = LogFactory . getLog ( ValidateMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private static final String DEFAULT_SCHEMA_LANGUAGE = "http://www.w3.org/2001/XMLSchema" ; private List schemaKeys = new ArrayList ( ) ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Validator validator = null ; private final Object validatorLock = new Object ( ) ; private final MyErrorHandler errorHandler = new MyErrorHandler ( ) ; private static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public ValidateMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } private OMNode getValidateSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } public boolean mediate ( MessageContext synCtx ) { log . debug ( "ValidateMediator - Validate mediator mediate()" ) ; ByteArrayInputStream baisFromSource = null ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Validate mediator" ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; OMNode validateSource = getValidateSource ( synCtx ) ; if ( shouldTrace ) { trace . trace ( "Validate Source : " + validateSource . toString ( ) ) ; } validateSource . serialize ( xsWriterForSource ) ; baisFromSource = new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ; } catch ( Exception e ) { handleException ( "Error accessing source element for validation : " + source , e ) ; } try { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; SAXSource saxSrc = new SAXSource ( reader , new InputSource ( baisFromSource ) ) ; synchronized ( validatorLock ) { initialize ( synCtx ) ; validator . validate ( saxSrc ) ; if ( errorHandler . isValidationError ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Validation of element returned by XPath : " + source + " failed against the given schemas with Message : " + errorHandler . getSaxParseException ( ) . getMessage ( ) + " Executing 'on-fail' sequence" ) ; log . debug ( "Failed message envelope : " + synCtx . getEnvelope ( ) ) ; } if ( shouldTrace ) { trace . trace ( "Validation failed. Invoking the \"on-fail\" " + "sequence of mediators" ) ; } return super . mediate ( synCtx ) ; } } } catch ( SAXException e ) { handleException ( "Error validating " + source + " element" + e . getMessage ( ) , e ) ; } catch ( IOException e ) { handleException ( "Error validating " + source + " element" + e . getMessage ( ) , e ) ; } log . debug ( "validation of element returned by the XPath expression : " + source + " succeeded against the given schemas and the current message" ) ; if ( shouldTrace ) { trace . trace ( "End : Validate mediator" ) ; } return true ; } private void initialize ( MessageContext msgCtx ) { boolean reCreate = false ; Iterator iter = schemaKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { String propKey = ( String ) iter . next ( ) ; Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( propKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { reCreate = true ; } } } if ( ! reCreate && validator != null ) { return ; } try { SchemaFactory factory = SchemaFactory . newInstance ( DEFAULT_SCHEMA_LANGUAGE ) ; errorHandler . setValidationError ( false ) ; factory . setErrorHandler ( errorHandler ) ; iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; factory . setFeature ( prop . getName ( ) , prop . getValue ( ) != null && "true" . equals ( prop . getValue ( ) ) ) ; } Schema schema = null ; StreamSource [ ] sources = new StreamSource [ schemaKeys . size ( ) ] ; iter = schemaKeys . iterator ( ) ; int i = 0 ; while ( iter . hasNext ( ) ) { String propName = ( String ) iter . next ( ) ; sources [ i ++ ] = Util . getStreamSource ( msgCtx . getEntry ( propName ) ) ; } schema = factory . newSchema ( sources ) ; validator = schema . newValidator ( ) ; validator . setErrorHandler ( errorHandler ) ; } catch ( SAXException e ) { handleException ( "Error creating Validator" , e ) ; } } private class MyErrorHandler extends DefaultHandler { private boolean validationError = false ; private SAXParseException saxParseException = null ; public void error ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void warning ( SAXParseException exception ) throws SAXException { } public boolean isValidationError ( ) { return validationError ; } public SAXParseException getSaxParseException ( ) { return saxParseException ; } public void setValidationError ( boolean validationError ) { this . validationError = validationError ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } public Object getProperty ( String key ) { Iterator iter = properties . iterator ( ) ; while ( iter . hasNext ( ) ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; if ( key . equals ( prop . getName ( ) ) ) { return prop . getValue ( ) ; } } return null ; } public void setProperty ( String key , Object value ) { MediatorProperty prop = new MediatorProperty ( ) ; prop . setName ( key ) ; prop . setValue ( value . toString ( ) ) ; properties . add ( prop ) ; } public void addAllProperties ( List list ) { Iterator iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof MediatorProperty ) { MediatorProperty prop = ( MediatorProperty ) o ; setProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } else { handleException ( "Attempt to set invalid property type. " + "Expected MediatorProperty type got " + o . getClass ( ) . getName ( ) ) ; } } } public void setSchemaKeys ( List schemaKeys ) { this . schemaKeys = schemaKeys ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public AXIOMXPath getSource ( ) { return source ; } public List getSchemaKeys ( ) { return schemaKeys ; } public List getProperties ( ) { return properties ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . * ; import org . apache . synapse . SynapseException ; public class EndpointAbstractSerializer { public static EndpointSerializer getEndpointSerializer ( Endpoint endpoint ) { if ( endpoint instanceof AddressEndpoint ) { return new AddressEndpointSerializer ( ) ; } else if ( endpoint instanceof WSDLEndpoint ) { return new WSDLEndpointSerializer ( ) ; } else if ( endpoint instanceof IndirectEndpoint ) { return new IndirectEndpointSerializer ( ) ; } else if ( endpoint instanceof LoadbalanceEndpoint ) { return new LoadbalanceEndpointSerializer ( ) ; } else if ( endpoint instanceof SALoadbalanceEndpoint ) { return new SALoadbalanceEndpointSerializer ( ) ; } else if ( endpoint instanceof FailoverEndpoint ) { return new FailoverEndpointSerializer ( ) ; } throw new SynapseException ( "Serializer for endpoint " + endpoint . getClass ( ) . toString ( ) + " is not defined." ) ; } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMNamespace ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . registry . Registry ; import java . util . Iterator ; public class RegistrySerializer { private static final Log log = LogFactory . getLog ( RegistrySerializer . class ) ; protected static final OMFactory fac = OMAbstractFactory . getOMFactory ( ) ; protected static final OMNamespace synNS = fac . createOMNamespace ( Constants . SYNAPSE_NAMESPACE , "syn" ) ; protected static final OMNamespace nullNS = fac . createOMNamespace ( Constants . NULL_NAMESPACE , "" ) ; public static OMElement serializeRegistry ( OMElement parent , Registry registry ) { OMElement reg = fac . createOMElement ( "registry" , synNS ) ; if ( registry . getProviderClass ( ) != null ) { reg . addAttribute ( fac . createOMAttribute ( "provider" , nullNS , registry . getProviderClass ( ) ) ) ; } else { handleException ( "Invalid registry. Provider is required" ) ; } Iterator iter = registry . getConfigProperties ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String name = ( String ) iter . next ( ) ; String value = ( String ) registry . getConfigProperties ( ) . get ( name ) ; OMElement property = fac . createOMElement ( "parameter" , synNS ) ; property . addAttribute ( fac . createOMAttribute ( "name" , nullNS , name ) ) ; property . setText ( value . trim ( ) ) ; reg . addChild ( property ) ; } if ( parent != null ) { parent . addChild ( reg ) ; } return reg ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . axiom . om . OMElement ; import java . util . Stack ; public class WSDLEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private String wsdlURI ; private OMElement wsdlDoc ; private String serviceName ; private String portName ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; private boolean active = true ; private Endpoint parentEndpoint = null ; private EndpointDefinition endpointDefinition = null ; public void send ( MessageContext synCtx ) { String eprAddress = null ; if ( endpointDefinition . getAddress ( ) != null ) { eprAddress = endpointDefinition . getAddress ( ) . toString ( ) ; String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpointDefinition . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + eprAddress ) ; log . debug ( "Sending To: " + ( synCtx . getTo ( ) != null ? synCtx . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpointDefinition , synCtx ) ; } } public void onFault ( MessageContext synCtx ) { if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public String getWsdlURI ( ) { return wsdlURI ; } public void setWsdlURI ( String wsdlURI ) { this . wsdlURI = wsdlURI ; } public OMElement getWsdlDoc ( ) { return wsdlDoc ; } public void setWsdlDoc ( OMElement wsdlDoc ) { this . wsdlDoc = wsdlDoc ; } public String getServiceName ( ) { return serviceName ; } public void setServiceName ( String serviceName ) { this . serviceName = serviceName ; } public String getPortName ( ) { return portName ; } public void setPortName ( String portName ) { this . portName = portName ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; } } return active ; } public void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public EndpointDefinition getEndpointDefinition ( ) { return endpointDefinition ; } public void setEndpointDefinition ( EndpointDefinition endpointDefinition ) { this . endpointDefinition = endpointDefinition ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . endpoints . utils ; import org . apache . synapse . Constants ; public class EndpointDefinition { private String address = null ; private boolean reliableMessagingOn = false ; private boolean addressingOn = false ; private boolean securityOn = false ; private String wsRMPolicyKey = null ; private String wsSecPolicyKey = null ; private boolean useSeparateListener = false ; private boolean forcePOX = false ; private boolean forceSOAP = false ; private boolean useMTOM = false ; private boolean useSwa = false ; private long timeoutDuration = 0 ; private int timeoutAction = Constants . NONE ; private int statisticsEnable = Constants . STATISTICS_UNSET ; public String getAddress ( ) { return address ; } public void setAddress ( String address ) { this . address = address ; } public boolean isReliableMessagingOn ( ) { return reliableMessagingOn ; } public void setReliableMessagingOn ( boolean reliableMessagingOn ) { this . reliableMessagingOn = reliableMessagingOn ; } public boolean isAddressingOn ( ) { return addressingOn ; } public void setAddressingOn ( boolean addressingOn ) { this . addressingOn = addressingOn ; } public boolean isSecurityOn ( ) { return securityOn ; } public void setSecurityOn ( boolean securityOn ) { this . securityOn = securityOn ; } public String getWsSecPolicyKey ( ) { return wsSecPolicyKey ; } public void setWsSecPolicyKey ( String wsSecPolicyKey ) { this . wsSecPolicyKey = wsSecPolicyKey ; } public String getWsRMPolicyKey ( ) { return wsRMPolicyKey ; } public void setWsRMPolicyKey ( String wsRMPolicyKey ) { this . wsRMPolicyKey = wsRMPolicyKey ; } public void setUseSeparateListener ( boolean b ) { this . useSeparateListener = b ; } public boolean isUseSeparateListener ( ) { return useSeparateListener ; } public void setForcePOX ( boolean forcePOX ) { this . forcePOX = forcePOX ; } public boolean isForcePOX ( ) { return forcePOX ; } public void setForceSOAP ( boolean forceSOAP ) { this . forceSOAP = forceSOAP ; } public boolean isForceSOAP ( ) { return forceSOAP ; } public boolean isUseMTOM ( ) { return useMTOM ; } public void setUseMTOM ( boolean useMTOM ) { this . useMTOM = useMTOM ; } public boolean isUseSwa ( ) { return useSwa ; } public void setUseSwa ( boolean useSwa ) { this . useSwa = useSwa ; } public long getTimeoutDuration ( ) { return timeoutDuration ; } public void setTimeoutDuration ( long timeoutDuration ) { this . timeoutDuration = timeoutDuration ; } public int getTimeoutAction ( ) { return timeoutAction ; } public void setTimeoutAction ( int timeoutAction ) { this . timeoutAction = timeoutAction ; } public int getStatisticsEnable ( ) { return statisticsEnable ; } public void setStatisticsEnable ( int statisticsEnable ) { this . statisticsEnable = statisticsEnable ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import java . util . Iterator ; import java . util . List ; public abstract class AbstractListMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( AbstractListMediatorSerializer . class ) ; protected static void serializeChildren ( OMElement parent , List list ) { Iterator iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { Mediator child = ( Mediator ) iter . next ( ) ; MediatorSerializer medSer = MediatorSerializerFinder . getInstance ( ) . getSerializer ( child ) ; if ( medSer != null ) { medSer . serializeMediator ( parent , child ) ; } else { handleException ( "Unable to find a serializer for mediator : " + child . getType ( ) ) ; } } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . IndirectEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class IndirectEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( IndirectEndpointFactory . class ) ; private static IndirectEndpointFactory instance = new IndirectEndpointFactory ( ) ; private IndirectEndpointFactory ( ) { } public static IndirectEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { IndirectEndpoint indirectEndpoint = new IndirectEndpoint ( ) ; String ref = epConfig . getAttributeValue ( new QName ( "key" ) ) ; indirectEndpoint . setKey ( ref ) ; return indirectEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . registry . Registry ; import javax . xml . namespace . QName ; import java . util . Iterator ; public class RegistryFactory { private static final Log log = LogFactory . getLog ( RegistryFactory . class ) ; public static final QName PROVIDER_Q = new QName ( Constants . NULL_NAMESPACE , "provider" ) ; public static final QName PARAMETER_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "parameter" ) ; public static final QName NAME_Q = new QName ( Constants . NULL_NAMESPACE , "name" ) ; public static Registry createRegistry ( OMElement elem ) { OMAttribute prov = elem . getAttribute ( PROVIDER_Q ) ; if ( prov != null ) { try { Class provider = Class . forName ( prov . getAttributeValue ( ) ) ; Registry registry = ( Registry ) provider . newInstance ( ) ; setProperties ( registry , elem ) ; return registry ; } catch ( ClassNotFoundException e ) { handleException ( "Cannot locate registry provider class : " + prov . getAttributeValue ( ) , e ) ; } catch ( IllegalAccessException e ) { handleException ( "Error instantiating registry provider : " + prov . getAttributeValue ( ) , e ) ; } catch ( InstantiationException e ) { handleException ( "Error instantiating registry provider : " + prov . getAttributeValue ( ) , e ) ; } } else { handleException ( "The registry 'provider' attribute is required for a registry definition" ) ; } return null ; } private static void setProperties ( Registry reg , OMElement elem ) { Iterator params = elem . getChildrenWithName ( PARAMETER_Q ) ; while ( params . hasNext ( ) ) { Object o = params . next ( ) ; if ( o instanceof OMElement ) { OMElement prop = ( OMElement ) o ; OMAttribute pname = prop . getAttribute ( NAME_Q ) ; String propertyValue = prop . getText ( ) ; if ( pname != null ) { if ( propertyValue != null ) { reg . addConfigProperty ( pname . getAttributeValue ( ) , propertyValue . trim ( ) ) ; } } else { handleException ( "Invalid registry property - property should have a name " ) ; } } else { handleException ( "Invalid registry property" ) ; } } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . base . SequenceMediator ; public class SequenceMediatorSerializer extends AbstractListMediatorSerializer { private static final Log log = LogFactory . getLog ( SequenceMediatorSerializer . class ) ; public OMElement serializeAnonymousSequence ( OMElement parent , SequenceMediator mediator ) { OMElement sequence = fac . createOMElement ( "sequence" , synNS ) ; int isEnableStatistics = mediator . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { sequence . addAttribute ( fac . createOMAttribute ( Constants . STATISTICS_ATTRIB_NAME , nullNS , statisticsValue ) ) ; } if ( mediator . getErrorHandler ( ) != null ) { sequence . addAttribute ( fac . createOMAttribute ( "onError" , nullNS , mediator . getErrorHandler ( ) ) ) ; } finalizeSerialization ( sequence , mediator ) ; serializeChildren ( sequence , mediator . getList ( ) ) ; if ( parent != null ) { parent . addChild ( sequence ) ; } return sequence ; } public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof SequenceMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } SequenceMediator mediator = ( SequenceMediator ) m ; OMElement sequence = fac . createOMElement ( "sequence" , synNS ) ; if ( mediator . isDynamic ( ) ) { sequence . addAttribute ( fac . createOMAttribute ( "name" , nullNS , mediator . getName ( ) ) ) ; sequence . addAttribute ( fac . createOMAttribute ( "key" , nullNS , mediator . getRegistryKey ( ) ) ) ; } else { int isEnableStatistics = mediator . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { sequence . addAttribute ( fac . createOMAttribute ( Constants . STATISTICS_ATTRIB_NAME , nullNS , statisticsValue ) ) ; } if ( mediator . getKey ( ) != null ) { sequence . addAttribute ( fac . createOMAttribute ( "key" , nullNS , mediator . getKey ( ) ) ) ; } else if ( mediator . getName ( ) != null ) { sequence . addAttribute ( fac . createOMAttribute ( "name" , nullNS , mediator . getName ( ) ) ) ; if ( mediator . getErrorHandler ( ) != null ) { sequence . addAttribute ( fac . createOMAttribute ( "onError" , nullNS , mediator . getErrorHandler ( ) ) ) ; } finalizeSerialization ( sequence , mediator ) ; serializeChildren ( sequence , mediator . getList ( ) ) ; } } if ( parent != null ) { parent . addChild ( sequence ) ; } return sequence ; } public String getMediatorClassName ( ) { return SequenceMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . config ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . config . xml . MediatorFactoryFinder ; import org . apache . synapse . config . xml . endpoints . XMLToEndpointMapper ; import org . apache . synapse . core . axis2 . ProxyService ; import org . apache . synapse . registry . Registry ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLInputFactory ; import javax . xml . stream . XMLStreamException ; import java . util . * ; import java . net . URLConnection ; import java . io . IOException ; public class SynapseConfiguration { private static final Log log = LogFactory . getLog ( SynapseConfiguration . class ) ; Registry registry = null ; private Map proxyServices = new HashMap ( ) ; private Map localRegistry = new HashMap ( ) ; private AxisConfiguration axisConfiguration = null ; private String pathToConfigFile = null ; public void addSequence ( String key , Mediator mediator ) { localRegistry . put ( key , mediator ) ; } public void addSequence ( String key , Entry entry ) { localRegistry . put ( key , entry ) ; } public Map getDefinedSequences ( ) { Map definedSequences = new HashMap ( ) ; Iterator itr = localRegistry . values ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Object o = itr . next ( ) ; if ( o instanceof SequenceMediator ) { definedSequences . put ( ( ( SequenceMediator ) o ) . getName ( ) , o ) ; } } return definedSequences ; } public Mediator getSequence ( String key ) { Object o = localRegistry . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } Entry entry = null ; if ( o != null && o instanceof Entry ) { entry = ( Entry ) o ; } else { entry = new Entry ( key ) ; entry . setType ( Entry . REMOTE_ENTRY ) ; entry . setMapper ( MediatorFactoryFinder . getInstance ( ) ) ; } if ( registry != null ) { o = registry . getResource ( entry ) ; if ( o != null && o instanceof Mediator ) { localRegistry . put ( key , entry ) ; return ( Mediator ) o ; } } return null ; } public void removeSequence ( String key ) { localRegistry . remove ( key ) ; } public Mediator getMainSequence ( ) { return getSequence ( Constants . MAIN_SEQUENCE_KEY ) ; } public Mediator getFaultSequence ( ) { return getSequence ( Constants . FAULT_SEQUENCE_KEY ) ; } public void addEntry ( String key , Entry entry ) { if ( entry . getType ( ) == Entry . URL_SRC ) { try { entry . setValue ( Util . getOMElementFromURL ( entry . getSrc ( ) . toString ( ) ) ) ; localRegistry . put ( key , entry ) ; } catch ( IOException e ) { handleException ( "Can not read from source URL : " + entry . getSrc ( ) ) ; } } else { localRegistry . put ( key , entry ) ; } } public Map getDefinedEntries ( ) { Map definedEntries = new HashMap ( ) ; Iterator itr = localRegistry . values ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Object o = itr . next ( ) ; if ( o instanceof Entry && ( ( Entry ) o ) . getType ( ) != Entry . REMOTE_ENTRY ) { definedEntries . put ( ( ( Entry ) o ) . getKey ( ) , o ) ; } } return definedEntries ; } public Object getEntry ( String key ) { Object o = localRegistry . get ( key ) ; if ( o != null && o instanceof Entry ) { Entry entry = ( Entry ) o ; if ( entry . isDynamic ( ) ) { if ( entry . isCached ( ) && ! entry . isExpired ( ) ) { return entry . getValue ( ) ; } else if ( registry != null ) { o = registry . getResource ( entry ) ; } } else { return entry . getValue ( ) ; } } return o ; } public Entry getEntryDefinition ( String key ) { Object o = localRegistry . get ( key ) ; if ( o == null || o instanceof Entry ) { if ( o == null ) { Entry entry = new Entry ( key ) ; entry . setType ( Entry . REMOTE_ENTRY ) ; addEntry ( key , entry ) ; return entry ; } return ( Entry ) o ; } else { handleException ( "Invalid local registry entry : " + key ) ; return null ; } } public void removeEntry ( String key ) { localRegistry . remove ( key ) ; } public void addEndpoint ( String key , Endpoint endpoint ) { localRegistry . put ( key , endpoint ) ; } public void addEndpoint ( String key , Entry entry ) { localRegistry . put ( key , entry ) ; } public Map getDefinedEndpoints ( ) { Map definedEndpoints = new HashMap ( ) ; Iterator itr = localRegistry . values ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Object o = itr . next ( ) ; if ( o instanceof Endpoint ) { definedEndpoints . put ( ( ( Endpoint ) o ) . getName ( ) , o ) ; } } return definedEndpoints ; } public Endpoint getEndpoint ( String key ) { Object o = localRegistry . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } Entry entry = null ; if ( o != null && o instanceof Entry ) { entry = ( Entry ) o ; } else { entry = new Entry ( key ) ; entry . setType ( Entry . REMOTE_ENTRY ) ; entry . setMapper ( XMLToEndpointMapper . getInstance ( ) ) ; } if ( registry != null ) { o = registry . getResource ( entry ) ; if ( o != null && o instanceof Endpoint ) { localRegistry . put ( key , entry ) ; return ( Endpoint ) o ; } } return null ; } public void removeEndpoint ( String key ) { localRegistry . remove ( key ) ; } public void addProxyService ( String name , ProxyService proxy ) { proxyServices . put ( name , proxy ) ; } public ProxyService getProxyService ( String name ) { return ( ProxyService ) proxyServices . get ( name ) ; } public void removeProxyService ( String name ) { Object o = proxyServices . get ( name ) ; if ( o == null ) { handleException ( "Unknown proxy service for name : " + name ) ; } else { try { if ( getAxisConfiguration ( ) . getServiceForActivation ( name ) != null ) { if ( getAxisConfiguration ( ) . getServiceForActivation ( name ) . isActive ( ) ) { getAxisConfiguration ( ) . getService ( name ) . setActive ( false ) ; } getAxisConfiguration ( ) . removeService ( name ) ; } proxyServices . remove ( name ) ; } catch ( AxisFault axisFault ) { handleException ( axisFault . getMessage ( ) ) ; } } } public Collection getProxyServices ( ) { return proxyServices . values ( ) ; } public Map getLocalRegistry ( ) { return Collections . unmodifiableMap ( localRegistry ) ; } public Registry getRegistry ( ) { return registry ; } public void setRegistry ( Registry registry ) { this . registry = registry ; } public void setAxisConfiguration ( AxisConfiguration axisConfig ) { this . axisConfiguration = axisConfig ; } public AxisConfiguration getAxisConfiguration ( ) { return axisConfiguration ; } public String getPathToConfigFile ( ) { return pathToConfigFile ; } public void setPathToConfigFile ( String pathToConfigFile ) { this . pathToConfigFile = pathToConfigFile ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . config . xml . endpoints . utils ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . algorithms . RoundRobin ; import org . apache . synapse . config . xml . Constants ; import javax . xml . namespace . QName ; import java . util . ArrayList ; public class LoadbalanceAlgorithmFactory { public static LoadbalanceAlgorithm createLoadbalanceAlgorithm ( OMElement loadbalanceElement , ArrayList endpoints ) { LoadbalanceAlgorithm algorithm = null ; String algorithmName = "roundRobin" ; OMAttribute algoAttribute = loadbalanceElement . getAttribute ( new QName ( null , Constants . ALGORITHM_NAME ) ) ; if ( algoAttribute != null ) { algorithmName = algoAttribute . getAttributeValue ( ) ; } if ( algorithmName . equalsIgnoreCase ( "roundRobin" ) ) { algorithm = new RoundRobin ( endpoints ) ; } return algorithm ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse ; import java . util . Stack ; import java . io . StringWriter ; import java . io . Writer ; import java . io . PrintWriter ; public abstract class FaultHandler { public void handleFault ( MessageContext synCtx ) { try { onFault ( synCtx ) ; } catch ( SynapseException e ) { Stack faultStack = synCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } public void handleFault ( MessageContext synCtx , Exception e ) { if ( synCtx . getProperty ( Constants . ERROR_CODE ) == null ) { synCtx . setProperty ( Constants . ERROR_CODE , "00000" ) ; } if ( synCtx . getProperty ( Constants . ERROR_MESSAGE ) == null ) { synCtx . setProperty ( Constants . ERROR_MESSAGE , e . getMessage ( ) . split ( "\n" ) [ 0 ] ) ; } synCtx . setProperty ( Constants . ERROR_DETAIL , getStackTrace ( e ) ) ; try { onFault ( synCtx ) ; } catch ( SynapseException se ) { Stack faultStack = synCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx , se ) ; } } } public abstract void onFault ( MessageContext synCtx ) ; private static String getStackTrace ( Throwable aThrowable ) { final Writer result = new StringWriter ( ) ; final PrintWriter printWriter = new PrintWriter ( result ) ; aThrowable . printStackTrace ( printWriter ) ; return result . toString ( ) ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . builtin . LogMediator ; import javax . xml . namespace . QName ; public class LogMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName LOG_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "log" ) ; private static final String SIMPLE = "simple" ; private static final String HEADERS = "headers" ; private static final String FULL = "full" ; private static final String CUSTOM = "custom" ; public QName getTagQName ( ) { return LOG_Q ; } public Mediator createMediator ( OMElement elem ) { LogMediator logMediator = new LogMediator ( ) ; initMediator ( logMediator , elem ) ; OMAttribute level = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "level" ) ) ; if ( level != null ) { String levelstr = level . getAttributeValue ( ) ; if ( SIMPLE . equals ( levelstr ) ) { logMediator . setLogLevel ( LogMediator . SIMPLE ) ; } else if ( HEADERS . equals ( levelstr ) ) { logMediator . setLogLevel ( LogMediator . HEADERS ) ; } else if ( FULL . equals ( levelstr ) ) { logMediator . setLogLevel ( LogMediator . FULL ) ; } else if ( CUSTOM . equals ( levelstr ) ) { logMediator . setLogLevel ( LogMediator . CUSTOM ) ; } } OMAttribute separator = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "separator" ) ) ; if ( separator != null ) { logMediator . setSeparator ( separator . getAttributeValue ( ) ) ; } logMediator . addAllProperties ( MediatorPropertyFactory . getMediatorProperties ( elem ) ) ; return logMediator ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . XMLToObjectMapper ; import org . apache . axiom . om . OMElement ; public interface EndpointFactory extends XMLToObjectMapper { public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) ; } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse ; public class SynapseException extends RuntimeException { private static final long serialVersionUID = - 7244032125641596311L ; public SynapseException ( String string ) { super ( string ) ; } public SynapseException ( String msg , Throwable e ) { super ( msg , e ) ; } public SynapseException ( Throwable t ) { super ( t ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; public interface Endpoint { public void send ( MessageContext synMessageContext ) ; public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) ; public void setParentEndpoint ( Endpoint parentEndpoint ) ; public String getName ( ) ; public void setName ( String name ) ; public boolean isActive ( MessageContext synMessageContext ) ; public void setActive ( boolean active , MessageContext synMessageContext ) ; } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . statistics . impl ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . StatisticsCollector ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . List ; public class EndPointStatisticsStack implements StatisticsStack { private List endpointStatistics ; private boolean isCompleteInFlowStatisicsReport = false ; public void put ( String key , long initTime , boolean isInFlow , boolean isStatisticsEnable , boolean isFault ) { if ( endpointStatistics == null ) { endpointStatistics = new ArrayList ( ) ; } endpointStatistics . add ( new EndPointStatistics ( key , initTime , isInFlow , isStatisticsEnable , isFault ) ) ; } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { if ( endpointStatistics != null && ! endpointStatistics . isEmpty ( ) ) { EndPointStatistics statistics = ( EndPointStatistics ) endpointStatistics . get ( endpointStatistics . size ( ) - 1 ) ; if ( statistics != null && statistics . isStatisticsEnable && statistics . endPointName != null ) { if ( statistics . inTimeForInFlow != - 1 ) { long initTimeForOutFlow = System . currentTimeMillis ( ) ; statisticsCollector . reportForEndPoint ( statistics . endPointName , false , statistics . inTimeForInFlow , initTimeForOutFlow , isFault ) ; statistics . inTimeForInFlow = - 1 ; statistics . inTimeForOutFlow = initTimeForOutFlow ; } else if ( statistics . inTimeForOutFlow != - 1 && isCompleteInFlowStatisicsReport ) { statisticsCollector . reportForEndPoint ( statistics . endPointName , true , statistics . inTimeForOutFlow , System . currentTimeMillis ( ) , isFault ) ; endpointStatistics . remove ( statistics ) ; } } } } public void reportToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault , String name ) { if ( endpointStatistics != null && ! endpointStatistics . isEmpty ( ) ) { List tobeRemoved = new ArrayList ( ) ; for ( Iterator epIterator = endpointStatistics . iterator ( ) ; epIterator . hasNext ( ) ; ) { Object statisticsObj = epIterator . next ( ) ; if ( statisticsObj instanceof EndPointStatistics ) { EndPointStatistics statistics = ( EndPointStatistics ) statisticsObj ; if ( statistics . isStatisticsEnable && statistics . endPointName != null && statistics . endPointName . equals ( name ) ) { if ( statistics . inTimeForInFlow != - 1 ) { long initTimeForOutFlow = System . currentTimeMillis ( ) ; statisticsCollector . reportForEndPoint ( statistics . endPointName , false , statistics . inTimeForInFlow , initTimeForOutFlow , isFault ) ; statistics . inTimeForInFlow = - 1 ; statistics . inTimeForOutFlow = initTimeForOutFlow ; } else if ( statistics . inTimeForOutFlow != - 1 && isCompleteInFlowStatisicsReport ) { statisticsCollector . reportForEndPoint ( statistics . endPointName , true , statistics . inTimeForOutFlow , System . currentTimeMillis ( ) , isFault ) ; tobeRemoved . add ( statistics ) ; } } } } endpointStatistics . removeAll ( tobeRemoved ) ; } } public void reportAllToStatisticsCollector ( StatisticsCollector statisticsCollector , boolean isFault ) { if ( endpointStatistics != null && ! endpointStatistics . isEmpty ( ) ) { List tobeRemoved = new ArrayList ( ) ; for ( Iterator epIterator = endpointStatistics . iterator ( ) ; epIterator . hasNext ( ) ; ) { Object statisticsObj = epIterator . next ( ) ; if ( statisticsObj instanceof EndPointStatistics ) { EndPointStatistics statistics = ( EndPointStatistics ) statisticsObj ; if ( statistics . isStatisticsEnable && statistics . endPointName != null ) { if ( statistics . inTimeForInFlow != - 1 ) { long initTimeForOutFlow = System . currentTimeMillis ( ) ; statisticsCollector . reportForEndPoint ( statistics . endPointName , false , statistics . inTimeForInFlow , initTimeForOutFlow , isFault ) ; statistics . inTimeForInFlow = - 1 ; statistics . inTimeForOutFlow = initTimeForOutFlow ; } else if ( statistics . inTimeForOutFlow != - 1 && isCompleteInFlowStatisicsReport ) { statisticsCollector . reportForEndPoint ( statistics . endPointName , true , statistics . inTimeForOutFlow , System . currentTimeMillis ( ) , isFault ) ; tobeRemoved . add ( statistics ) ; } } } } endpointStatistics . removeAll ( tobeRemoved ) ; } isCompleteInFlowStatisicsReport = true ; } class EndPointStatistics { private String endPointName ; private boolean isStatisticsEnable ; private boolean isFault ; private long inTimeForInFlow = - 1 ; private long inTimeForOutFlow = - 1 ; public EndPointStatistics ( String endPointName , long initTime , boolean inFlow , boolean statisticsEnable , boolean fault ) { if ( inFlow ) { this . endPointName = endPointName ; this . inTimeForInFlow = initTime ; isStatisticsEnable = statisticsEnable ; isFault = fault ; } } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; EndPointStatistics that = ( EndPointStatistics ) o ; if ( endPointName != null ? ! endPointName . equals ( that . endPointName ) : that . endPointName != null ) return false ; return true ; } public int hashCode ( ) { return ( endPointName != null ? endPointName . hashCode ( ) : 0 ) ; } } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . SwitchMediator ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . util . Iterator ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; public class SwitchMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( SwitchMediatorFactory . class ) ; private static final QName SWITCH_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "switch" ) ; private static final QName CASE_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "case" ) ; private static final QName DEFAULT_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "default" ) ; public Mediator createMediator ( OMElement elem ) { SwitchMediator switchMediator = new SwitchMediator ( ) ; OMAttribute source = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "source" ) ) ; if ( source == null ) { String msg = "A 'source' XPath attribute is required for a switch mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else { try { AXIOMXPath sourceXPath = new AXIOMXPath ( source . getAttributeValue ( ) ) ; org . apache . synapse . config . xml . OMElementUtils . addNameSpaces ( sourceXPath , elem , log ) ; switchMediator . setSource ( sourceXPath ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath for attribute 'source' : " + source . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } initMediator ( switchMediator , elem ) ; Iterator iter = elem . getChildrenWithName ( CASE_Q ) ; while ( iter . hasNext ( ) ) { OMElement caseElem = ( OMElement ) iter . next ( ) ; SwitchCase aCase = new SwitchCase ( ) ; OMAttribute regex = caseElem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "regex" ) ) ; if ( regex == null ) { String msg = "The 'regex' attribute is required for a switch case definition" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } try { aCase . setRegex ( Pattern . compile ( regex . getAttributeValue ( ) ) ) ; } catch ( PatternSyntaxException pse ) { String msg = "Invalid Regular Expression for attribute 'regex' : " + regex . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } aCase . setCaseMediator ( AnonymousListMediatorFactory . createAnonymousListMediator ( caseElem ) ) ; switchMediator . addCase ( aCase ) ; } iter = elem . getChildrenWithName ( DEFAULT_Q ) ; while ( iter . hasNext ( ) ) { SwitchCase aCase = new SwitchCase ( ) ; aCase . setCaseMediator ( AnonymousListMediatorFactory . createAnonymousListMediator ( ( OMElement ) iter . next ( ) ) ) ; switchMediator . setDefaultCase ( aCase ) ; break ; } return switchMediator ; } public QName getTagQName ( ) { return SWITCH_Q ; } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import javax . xml . namespace . QName ; public interface Constants { public static final String SYNAPSE_NAMESPACE = "http://ws.apache.org/ns/synapse" ; public static final String MAIN_SEQUENCE_KEY = "main" ; public static final String FAULT_SEQUENCE_KEY = "fault" ; public static final OMNamespace SYNAPSE_OMNAMESPACE = OMAbstractFactory . getOMFactory ( ) . createOMNamespace ( SYNAPSE_NAMESPACE , "syn" ) ; String SYNAPSE_CONFIG = "synapse.config" ; String SYNAPSE_ENV = "synapse.env" ; String SYNAPSE_XML = "synapse.xml" ; String RELATES_TO_FOR_POX = "RelatesToForPox" ; String OUTFLOW_ADDRESSING_ON = "OUTFLOW_ADDRESSING_ON" ; String OUTFLOW_RM_ON = "OUTFLOW_RM_ON" ; String OUTFLOW_RM_POLICY = "OUTFLOW_RM_POLICY" ; String OUTFLOW_SECURITY_ON = "OUTFLOW_SECURITY_ON" ; String OUTFLOW_SEC_POLICY = "OUTFLOW_SEC_POLICY" ; String SCOPE_DEFAULT = "default" ; String SCOPE_AXIS2 = "axis2" ; String SCOPE_TRANSPORT = "transport" ; String PROXY_SERVICE = "proxy.name" ; String ISRESPONSE_PROPERTY = "synapse.isresponse" ; public static final String OUTFLOW_USE_SEPARATE_LISTENER = "OUTFLOW_USE_SEPARATE_LISTENER" ; String ERROR_CODE = "ERROR_CODE" ; String ERROR_MESSAGE = "ERROR_MESSAGE" ; String ERROR_DETAIL = "ERROR_DETAIL" ; String SANDESHA2_MODULE_NAME = "sandesha2" ; String ADDRESSING_MODULE_NAME = "addressing" ; String RAMPART_MODULE_NAME = "rampart" ; String HEADER_TO = "To" ; String HEADER_FROM = "From" ; String HEADER_FAULT = "FaultTo" ; String HEADER_ACTION = "Action" ; String HEADER_REPLY_TO = "ReplyTo" ; String HEADER_MESSAGE_ID = "MessageID" ; String RESPONSE = "RESPONSE" ; int TRACING_OFF = 0 ; int TRACING_ON = 1 ; int TRACING_UNSET = 2 ; String TRACE_LOGGER = "TRACE_LOGGER" ; String SEQUENCE_VERSION_1_0 = "1.0" ; String SEQUENCE_VERSION_1_1 = "1.1" ; String SANDESHA_LAST_MESSAGE = "Sandesha2LastMessage" ; String SANDESHA_SEQUENCE_KEY = "Sandesha2SequenceKey" ; String SANDESHA_SPEC_VERSION = "Sandesha2RMSpecVersion" ; int STATISTICS_OFF = 0 ; int STATISTICS_ON = 1 ; int STATISTICS_UNSET = 2 ; String SYNAPSE_ERROR = "syapse_error" ; String SEQUENCE_STATISTICS_STACK = "sequence_statistics_stack" ; String PROXYSERVICE_STATISTICS_STACK = "proxyservice_statistics_stack" ; String SYNAPSESERVICE_STATISTICS_STACK = "synapseservice_statistics_stack" ; String ENDPOINT_STATISTICS_STACK = "endpoint_statistics_stack" ; int SEQUENCE_STATISTICS = 0 ; int PROXYSERVICE_STATISTICS = 1 ; int ENDPOINT_STATISTICS = 2 ; long TIMEOUT_HANDLER_INTERVAL = 1000 ; int NONE = 100 ; int DISCARD = 101 ; int DISCARD_AND_FAULT = 102 ; String TIME_OUT = "504" ; String SENDING_FAULT = "503" ; String PROCESSED_ENDPOINT = "processed_endpoint" ; String ANONYMOUS_ENDPOINTS = "AnonymousEndpoints" ; String ANONYMOUS_SEQUENCES = "AnonymousSequences" ; String ANONYMOUS_PROXYSERVICES = "AnonymousProxyServices" ; } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . FaultMediator ; import javax . xml . namespace . QName ; public class FaultMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( FaultMediatorSerializer . class ) ; private static final String SOAP11 = "soap11" ; private static final String SOAP12 = "soap12" ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof FaultMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } FaultMediator mediator = ( FaultMediator ) m ; OMElement fault = fac . createOMElement ( "makefault" , synNS ) ; finalizeSerialization ( fault , mediator ) ; if ( mediator . getSoapVersion ( ) == FaultMediator . SOAP11 ) { fault . addAttribute ( fac . createOMAttribute ( "version" , nullNS , SOAP11 ) ) ; } else if ( mediator . getSoapVersion ( ) == FaultMediator . SOAP12 ) { fault . addAttribute ( fac . createOMAttribute ( "version" , nullNS , SOAP12 ) ) ; } OMElement code = fac . createOMElement ( "code" , synNS , fault ) ; if ( mediator . getFaultCodeValue ( ) != null ) { code . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mediator . getFaultCodeValue ( ) . getPrefix ( ) + ":" + mediator . getFaultCodeValue ( ) . getLocalPart ( ) ) ) ; code . declareNamespace ( mediator . getFaultCodeValue ( ) . getNamespaceURI ( ) , mediator . getFaultCodeValue ( ) . getPrefix ( ) ) ; } else if ( mediator . getFaultCodeExpr ( ) != null ) { code . addAttribute ( fac . createOMAttribute ( "expression" , nullNS , mediator . getFaultCodeExpr ( ) . toString ( ) ) ) ; super . serializeNamespaces ( code , mediator . getFaultCodeExpr ( ) ) ; } else { handleException ( "Fault code is required for a fault mediator" ) ; } OMElement reason = fac . createOMElement ( "reason" , synNS , fault ) ; if ( mediator . getFaultReasonValue ( ) != null ) { reason . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mediator . getFaultReasonValue ( ) ) ) ; } else if ( mediator . getFaultReasonExpr ( ) != null ) { reason . addAttribute ( fac . createOMAttribute ( "expression" , nullNS , mediator . getFaultReasonExpr ( ) . toString ( ) ) ) ; super . serializeNamespaces ( code , mediator . getFaultReasonExpr ( ) ) ; } else { handleException ( "Fault reason is required for a fault mediator" ) ; } if ( mediator . getFaultNode ( ) != null ) { OMElement node = fac . createOMElement ( "node" , synNS , fault ) ; node . setText ( mediator . getFaultNode ( ) . toString ( ) ) ; } if ( mediator . getFaultRole ( ) != null ) { OMElement role = fac . createOMElement ( "role" , synNS , fault ) ; role . setText ( mediator . getFaultRole ( ) . toString ( ) ) ; } if ( mediator . getFaultDetail ( ) != null ) { OMElement detail = fac . createOMElement ( "detail" , synNS , fault ) ; detail . setText ( mediator . getFaultDetail ( ) ) ; } if ( parent != null ) { parent . addChild ( fault ) ; } return fault ; } public String getMediatorClassName ( ) { return FaultMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . endpoints . Endpoint ; public interface EndpointSerializer { public OMElement serializeEndpoint ( Endpoint endpoint ) ; } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . config . xml . ValidateMediatorSerializer ; import org . apache . synapse . config . xml . XSLTMediatorSerializer ; import sun . misc . Service ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class MediatorSerializerFinder { private static final Log log = LogFactory . getLog ( MediatorSerializerFinder . class ) ; private static final Class [ ] mediatorSerializers = { SequenceMediatorSerializer . class , LogMediatorSerializer . class , SendMediatorSerializer . class , FilterMediatorSerializer . class , SynapseMediatorSerializer . class , DropMediatorSerializer . class , HeaderMediatorSerializer . class , FaultMediatorSerializer . class , PropertyMediatorSerializer . class , SwitchMediatorSerializer . class , InMediatorSerializer . class , OutMediatorSerializer . class , RMSequenceMediatorSerializer . class , ClassMediatorSerializer . class , ValidateMediatorSerializer . class , XSLTMediatorSerializer . class } ; private static MediatorSerializerFinder instance = null ; private static Map serializerMap = new HashMap ( ) ; public static synchronized MediatorSerializerFinder getInstance ( ) { if ( instance == null ) { instance = new MediatorSerializerFinder ( ) ; } return instance ; } public MediatorSerializer getSerializer ( Mediator mediator ) { return ( MediatorSerializer ) serializerMap . get ( mediator . getClass ( ) . getName ( ) ) ; } private MediatorSerializerFinder ( ) { serializerMap = new HashMap ( ) ; for ( int i = 0 ; i < mediatorSerializers . length ; i ++ ) { Class c = mediatorSerializers [ i ] ; try { MediatorSerializer ser = ( MediatorSerializer ) c . newInstance ( ) ; serializerMap . put ( ser . getMediatorClassName ( ) , ser ) ; } catch ( Exception e ) { throw new SynapseException ( "Error instantiating " + c . getName ( ) , e ) ; } } registerExtensions ( ) ; } private void registerExtensions ( ) { log . debug ( "Registering mediator extensions found in the classpath : " + System . getProperty ( "java.class.path" ) ) ; Iterator it = Service . providers ( MediatorSerializer . class ) ; while ( it . hasNext ( ) ) { MediatorSerializer ms = ( MediatorSerializer ) it . next ( ) ; String name = ms . getMediatorClassName ( ) ; try { serializerMap . put ( name , ms . getClass ( ) . newInstance ( ) ) ; } catch ( InstantiationException e ) { handleException ( "Error instantiating mediator serializer : " + ms ) ; } catch ( IllegalAccessException e ) { handleException ( "Error instantiating mediator serializer : " + ms ) ; } log . debug ( "Added MediatorSerializer " + ms . getClass ( ) . getName ( ) + " to handle " + name ) ; } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . client . async . AsyncResult ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; public class AsyncCallback extends Callback { MessageContext synapseOutMsgCtx = null ; private long timeOutOn ; private int timeOutAction = Constants . NONE ; public AsyncCallback ( org . apache . synapse . MessageContext synapseOutMsgCtx ) { this . synapseOutMsgCtx = synapseOutMsgCtx ; } public void onComplete ( AsyncResult result ) { } public void onError ( Exception e ) { } public void setSynapseOutMshCtx ( MessageContext synapseOutMsgCtx ) { this . synapseOutMsgCtx = synapseOutMsgCtx ; } public MessageContext getSynapseOutMsgCtx ( ) { return synapseOutMsgCtx ; } public long getTimeOutOn ( ) { return timeOutOn ; } public void setTimeOutOn ( long timeOutOn ) { this . timeOutOn = timeOutOn ; } public int getTimeOutAction ( ) { return timeOutAction ; } public void setTimeOutAction ( int timeOutAction ) { this . timeOutAction = timeOutAction ; } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . statistics . impl . ProxyServiceStatisticsStack ; public class ProxyServiceMessageReceiver extends SynapseMessageReceiver { private static final Log log = LogFactory . getLog ( ProxyServiceMessageReceiver . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String name = null ; public void receive ( org . apache . axis2 . context . MessageContext mc ) throws AxisFault { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy Service " + name + " received a new message..." ) ; log . debug ( "Message To: " + ( mc . getTo ( ) != null ? mc . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( mc . getSoapAction ( ) != null ? mc . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( mc . getWSAAction ( ) != null ? mc . getWSAAction ( ) : "null" ) ) ; String [ ] cids = mc . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + mc . getEnvelope ( ) ) ; } MessageContext synCtx = MessageContextCreatorForAxis2 . getSynapseMessageContext ( mc ) ; try { synCtx . setProperty ( org . apache . synapse . Constants . PROXY_SERVICE , name ) ; ProxyService proxy = synCtx . getConfiguration ( ) . getProxyService ( name ) ; boolean statisticsEnable ; if ( proxy != null ) { statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == proxy . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { ProxyServiceStatisticsStack proxyServiceStatisticsStack = new ProxyServiceStatisticsStack ( ) ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; proxyServiceStatisticsStack . put ( name , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; synCtx . setProperty ( org . apache . synapse . Constants . PROXYSERVICE_STATISTICS_STACK , proxyServiceStatisticsStack ) ; } boolean shouldTrace = ( proxy . getTraceState ( ) == Constants . TRACING_ON ) ; if ( shouldTrace ) { trace . trace ( "Proxy Service " + name + " received a new message..." ) ; trace . trace ( "Received Message :: " + mc . getEnvelope ( ) ) ; } if ( proxy . getTargetFaultSequence ( ) != null ) { Mediator faultSequence = synCtx . getSequence ( proxy . getTargetFaultSequence ( ) ) ; if ( faultSequence != null ) { log . debug ( "Setting the fault-sequence of the " + "proxy service to MessageContext" ) ; synCtx . pushFaultHandler ( new MediatorFaultHandler ( synCtx . getSequence ( proxy . getTargetFaultSequence ( ) ) ) ) ; } else { log . warn ( "Unable to find the fault-sequence for the proxy service " + "specified by the name " + proxy . getTargetFaultSequence ( ) ) ; } } else if ( proxy . getTargetInLineFaultSequence ( ) != null ) { log . debug ( "Setting the anonymous fault-sequence of the proxy to context" ) ; synCtx . pushFaultHandler ( new MediatorFaultHandler ( proxy . getTargetInLineFaultSequence ( ) ) ) ; } if ( proxy . getTargetInSequence ( ) != null ) { Mediator inSequence = synCtx . getSequence ( proxy . getTargetInSequence ( ) ) ; if ( inSequence != null ) { String msg = "Using the sequence named " + proxy . getTargetInSequence ( ) + " for message mediation" ; if ( shouldTrace ) { trace . trace ( msg ) ; } log . debug ( msg ) ; inSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the in-sequence for the proxy service " + "specified by the name " + proxy . getTargetInSequence ( ) ) ; throw new SynapseException ( "Unable to find the in-sequence for the proxy " + "service specified by the name " + proxy . getTargetInSequence ( ) ) ; } } else if ( proxy . getTargetInLineInSequence ( ) != null ) { String msg = "Using the anonymous " + "in-sequence of the proxy service for message mediation" ; if ( shouldTrace ) { trace . trace ( msg ) ; } log . debug ( msg ) ; proxy . getTargetInLineInSequence ( ) . mediate ( synCtx ) ; } if ( proxy . getTargetEndpoint ( ) != null ) { Endpoint endpoint = synCtx . getEndpoint ( proxy . getTargetEndpoint ( ) ) ; if ( endpoint != null ) { String msg = "Forwarding message to the endpoint named " + proxy . getTargetEndpoint ( ) + " after message mediation" ; if ( shouldTrace ) { trace . trace ( msg ) ; } log . debug ( msg ) ; endpoint . send ( synCtx ) ; } else { log . error ( "Unable to find the endpoint for the proxy service " + "specified by the name " + proxy . getTargetEndpoint ( ) ) ; throw new SynapseException ( "Unable to find the endpoint for the " + "proxy service specified by the name " + proxy . getTargetEndpoint ( ) ) ; } } else if ( proxy . getTargetInLineEndpoint ( ) != null ) { String msg = "Forwarding the message to the anonymous " + "endpoint of the proxy service after message mediation" ; if ( shouldTrace ) { trace . trace ( msg ) ; } log . debug ( msg ) ; proxy . getTargetInLineEndpoint ( ) . send ( synCtx ) ; } } else { log . error ( "Proxy Service with the name " + name + " does not exists" ) ; throw new SynapseException ( "Proxy Service with the name " + name + " does not exists" ) ; } } catch ( SynapseException syne ) { if ( ! synCtx . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synCtx . getFaultStack ( ) . pop ( ) ) . handleFault ( synCtx , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } public void setName ( String name ) { this . name = name ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . registry . url ; import org . apache . synapse . registry . RegistryEntry ; import java . net . URI ; import java . util . Date ; public class URLRegistryEntry implements RegistryEntry { private String key = null ; private String name = null ; private long version = Long . MIN_VALUE ; private URI type = null ; private String description ; private long created ; private long lastModified ; private long cachableDuration ; public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public long getVersion ( ) { return version ; } public void setVersion ( long version ) { this . version = version ; } public URI getType ( ) { return type ; } public void setType ( URI type ) { this . type = type ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public long getCreated ( ) { return created ; } public void setCreated ( long created ) { this . created = created ; } public long getLastModified ( ) { return lastModified ; } public void setLastModified ( long lastModified ) { this . lastModified = lastModified ; } public long getCachableDuration ( ) { return cachableDuration ; } public void setCachableDuration ( long cachableDuration ) { this . cachableDuration = cachableDuration ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "RegistryEntry {" ) . append ( " Key : " + key ) . append ( " Name : " + name ) . append ( " Ver : " + version ) . append ( " Type : " + type ) . append ( " Desc : " + description ) . append ( " Created : " + new Date ( created ) ) . append ( " Modified : " + new Date ( lastModified ) ) . append ( " Cacheable for : " + ( cachableDuration / 1000 ) + "sec" ) . append ( "}" ) ; return sb . toString ( ) ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . filters . OutMediator ; import javax . xml . namespace . QName ; public class OutMediatorFactory extends AbstractListMediatorFactory { private static final QName OUT_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "out" ) ; public Mediator createMediator ( OMElement elem ) { OutMediator filter = new OutMediator ( ) ; initMediator ( filter , elem ) ; addChildren ( elem , filter ) ; return filter ; } public QName getTagQName ( ) { return OUT_Q ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public abstract class AbstractListMediator extends AbstractMediator implements ListMediator { private static final Log log = LogFactory . getLog ( AbstractListMediator . class ) ; protected List mediators = new ArrayList ( ) ; public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "Implicit Sequence <" + getType ( ) + "> :: mediate()" ) ; saveAndSetTraceState ( synCtx ) ; Iterator it = mediators . iterator ( ) ; while ( it . hasNext ( ) ) { Mediator m = ( Mediator ) it . next ( ) ; if ( ! m . mediate ( synCtx ) ) { return false ; } } } finally { restoreTracingState ( synCtx ) ; } return true ; } public List getList ( ) { return mediators ; } public boolean addChild ( Mediator m ) { return mediators . add ( m ) ; } public boolean addAll ( List c ) { return mediators . addAll ( c ) ; } public Mediator getChild ( int pos ) { return ( Mediator ) mediators . get ( pos ) ; } public boolean removeChild ( Mediator m ) { return mediators . remove ( m ) ; } public Mediator removeChild ( int pos ) { return ( Mediator ) mediators . remove ( pos ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . util ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Random ; public class UUIDGenerator { private static String baseUUID = null ; private static long incrementingValue = 0 ; private static Random myRand = null ; private static boolean useNano = false ; public static String getUUID ( ) { if ( baseUUID == null ) { baseUUID = getInitialUUID ( ) ; baseUUID = "urn:uuid:" + baseUUID ; } if ( ++ incrementingValue >= Long . MAX_VALUE ) { incrementingValue = 0 ; } if ( useNano ) { return baseUUID + ( System . nanoTime ( ) + incrementingValue ) + Integer . toString ( myRand . nextInt ( ) ) ; } else { return baseUUID + ( System . currentTimeMillis ( ) + incrementingValue + Integer . toString ( myRand . nextInt ( ) ) ) ; } } protected static String getInitialUUID ( ) { try { if ( System . class . getMethod ( "nanoTime" , new Class [ 0 ] ) != null ) { useNano = true ; } } catch ( NoSuchMethodException ignore ) { } if ( myRand == null ) { myRand = new Random ( ) ; } long rand = myRand . nextLong ( ) ; String sid ; try { sid = InetAddress . getLocalHost ( ) . toString ( ) ; } catch ( UnknownHostException e ) { sid = Thread . currentThread ( ) . getName ( ) ; } StringBuffer sb = new StringBuffer ( ) ; sb . append ( sid ) ; sb . append ( ":" ) ; sb . append ( Long . toString ( rand ) ) ; MessageDigest md5 = null ; try { md5 = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { } md5 . update ( sb . toString ( ) . getBytes ( ) ) ; byte [ ] array = md5 . digest ( ) ; StringBuffer sb2 = new StringBuffer ( ) ; for ( int j = 0 ; j < array . length ; ++ j ) { int b = array [ j ] & 0xFF ; sb2 . append ( Integer . toHexString ( b ) ) ; } int begin = myRand . nextInt ( ) ; if ( begin < 0 ) begin = begin * - 1 ; begin = begin % 8 ; return sb2 . toString ( ) . substring ( begin , begin + 18 ) . toUpperCase ( ) ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . transport . TransportUtils ; import org . apache . axis2 . i18n . Messages ; import org . apache . axis2 . util . TargetResolver ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . description . * ; import org . apache . axis2 . engine . AxisEngine ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . synapse . Constants ; import javax . xml . namespace . QName ; public class DynamicAxisOperation extends OutInAxisOperation { public DynamicAxisOperation ( ) { super ( ) ; } public DynamicAxisOperation ( QName name ) { super ( name ) ; } public OperationClient createClient ( ServiceContext sc , Options options ) { return new DynamicOperationClient ( this , sc , options ) ; } class DynamicOperationClient extends OperationClient { DynamicOperationClient ( OutInAxisOperation axisOp , ServiceContext sc , Options options ) { super ( axisOp , sc , options ) ; } public void addMessageContext ( MessageContext mc ) throws AxisFault { mc . setServiceContext ( sc ) ; if ( mc . getMessageID ( ) == null ) { setMessageID ( mc ) ; } axisOp . registerOperationContext ( mc , oc ) ; } public MessageContext getMessageContext ( String messageLabel ) throws AxisFault { return oc . getMessageContext ( messageLabel ) ; } public void setCallback ( Callback callback ) { this . callback = callback ; } public void execute ( boolean block ) throws AxisFault { if ( completed ) { throw new AxisFault ( Messages . getMessage ( "mepiscomplted" ) ) ; } MessageContext outMsgCtx = oc . getMessageContext ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ; if ( outMsgCtx == null ) { throw new AxisFault ( Messages . getMessage ( "outmsgctxnull" ) ) ; } ConfigurationContext cfgCtx = sc . getConfigurationContext ( ) ; outMsgCtx . setOptions ( options ) ; TargetResolver tr = cfgCtx . getAxisConfiguration ( ) . getTargetResolverChain ( ) ; if ( tr != null ) { tr . resolveTarget ( outMsgCtx ) ; } TransportOutDescription transportOut = options . getTransportOut ( ) ; if ( transportOut == null ) { EndpointReference toEPR = ( options . getTo ( ) != null ) ? options . getTo ( ) : outMsgCtx . getTo ( ) ; transportOut = ClientUtils . inferOutTransport ( cfgCtx . getAxisConfiguration ( ) , toEPR , outMsgCtx ) ; } outMsgCtx . setTransportOut ( transportOut ) ; if ( options . getTransportIn ( ) == null && outMsgCtx . getTransportIn ( ) == null ) { outMsgCtx . setTransportIn ( ClientUtils . inferInTransport ( cfgCtx . getAxisConfiguration ( ) , options , outMsgCtx ) ) ; } else if ( outMsgCtx . getTransportIn ( ) == null ) { outMsgCtx . setTransportIn ( options . getTransportIn ( ) ) ; } addReferenceParameters ( outMsgCtx ) ; if ( options . isUseSeparateListener ( ) ) { } else { SynapseCallbackReceiver callbackReceiver = ( SynapseCallbackReceiver ) axisOp . getMessageReceiver ( ) ; callbackReceiver . addCallback ( outMsgCtx . getMessageID ( ) , callback ) ; send ( outMsgCtx ) ; } } private void send ( MessageContext msgctx ) throws AxisFault { MessageContext responseMessageContext = new MessageContext ( ) ; responseMessageContext . setMessageID ( msgctx . getMessageID ( ) ) ; responseMessageContext . setProperty ( Constants . RELATES_TO_FOR_POX , msgctx . getMessageID ( ) ) ; responseMessageContext . setOptions ( options ) ; addMessageContext ( responseMessageContext ) ; AxisEngine engine = new AxisEngine ( msgctx . getConfigurationContext ( ) ) ; engine . send ( msgctx ) ; if ( msgctx . getProperty ( MessageContext . TRANSPORT_IN ) != null ) { responseMessageContext . setOperationContext ( msgctx . getOperationContext ( ) ) ; responseMessageContext . setAxisMessage ( msgctx . getOperationContext ( ) . getAxisOperation ( ) . getMessage ( WSDLConstants . MESSAGE_LABEL_IN_VALUE ) ) ; responseMessageContext . setAxisService ( msgctx . getAxisService ( ) ) ; responseMessageContext . setServerSide ( true ) ; responseMessageContext . setProperty ( MessageContext . TRANSPORT_OUT , msgctx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; responseMessageContext . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , msgctx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; responseMessageContext . setProperty ( org . apache . synapse . Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; responseMessageContext . setTransportIn ( msgctx . getTransportIn ( ) ) ; responseMessageContext . setTransportOut ( msgctx . getTransportOut ( ) ) ; responseMessageContext . setDoingREST ( msgctx . isDoingREST ( ) ) ; responseMessageContext . setProperty ( MessageContext . TRANSPORT_IN , msgctx . getProperty ( MessageContext . TRANSPORT_IN ) ) ; responseMessageContext . setTransportIn ( msgctx . getTransportIn ( ) ) ; responseMessageContext . setTransportOut ( msgctx . getTransportOut ( ) ) ; responseMessageContext . setSoapAction ( "" ) ; if ( responseMessageContext . getEnvelope ( ) == null ) { SOAPEnvelope resenvelope = TransportUtils . createSOAPMessage ( responseMessageContext ) ; if ( resenvelope != null ) { responseMessageContext . setEnvelope ( resenvelope ) ; engine = new AxisEngine ( msgctx . getConfigurationContext ( ) ) ; engine . receive ( responseMessageContext ) ; if ( responseMessageContext . getReplyTo ( ) != null ) { sc . setTargetEPR ( responseMessageContext . getReplyTo ( ) ) ; } } else { throw new AxisFault ( Messages . getMessage ( "blockingInvocationExpectsResponse" ) ) ; } } } } } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . config ; import org . apache . synapse . SynapseException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . net . URL ; public class Entry { private static final Log log = LogFactory . getLog ( Entry . class ) ; private String key ; private int type ; private URL src ; private Object value ; private XMLToObjectMapper mapper ; private long version ; private long expiryTime ; public Entry ( ) { } public Entry ( String key ) { this . key = key ; } public int getType ( ) { return type ; } public boolean isRemote ( ) { return type == REMOTE_ENTRY ; } public boolean isURLSource ( ) { return type == URL_SRC ; } public boolean isInlineXML ( ) { return type == INLINE_XML ; } public boolean isInlineText ( ) { return type == INLINE_TEXT ; } public void setType ( int type ) { if ( type <= 4 && type >= 0 ) this . type = type ; else handleException ( "Invalid entry type for the static entry" ) ; } public URL getSrc ( ) { return src ; } public void setSrc ( URL src ) { this . src = src ; } public String getKey ( ) { return this . key ; } public void setKey ( String key ) { this . key = key ; } public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } public XMLToObjectMapper getMapper ( ) { return mapper ; } public void setMapper ( XMLToObjectMapper mapper ) { this . mapper = mapper ; } public long getVersion ( ) { return version ; } public void setVersion ( long version ) { this . version = version ; } public long getExpiryTime ( ) { return expiryTime ; } public void setExpiryTime ( long expiryTime ) { this . expiryTime = expiryTime ; } public boolean isExpired ( ) { if ( getType ( ) == REMOTE_ENTRY ) { return System . currentTimeMillis ( ) > expiryTime ; } else { return false ; } } public boolean isCached ( ) { return value != null ; } public boolean isDynamic ( ) { return type == REMOTE_ENTRY ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static final int INLINE_TEXT = 0 ; public static final int INLINE_XML = 1 ; public static final int URL_SRC = 2 ; public static final int REMOTE_ENTRY = 3 ; } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . IndirectEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; public class IndirectEndpointSerializer implements EndpointSerializer { private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof IndirectEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; IndirectEndpoint indirectEndpoint = ( IndirectEndpoint ) endpoint ; String ref = indirectEndpoint . getKey ( ) ; if ( ref != null ) { endpointElement . addAttribute ( "key" , ref , null ) ; } return endpointElement ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . config . xml . endpoints . utils ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . xml . sax . InputSource ; import javax . wsdl . factory . WSDLFactory ; import javax . wsdl . WSDLException ; import javax . wsdl . Definition ; import javax . wsdl . Service ; import javax . wsdl . Port ; import javax . wsdl . extensions . soap . SOAPAddress ; import javax . wsdl . extensions . soap12 . SOAP12Address ; import javax . wsdl . xml . WSDLReader ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import java . util . List ; import java . io . ByteArrayOutputStream ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; public class WSDL11EndpointBuilder { private static Log log = LogFactory . getLog ( WSDL11EndpointBuilder . class ) ; public EndpointDefinition createEndpointDefinitionFromWSDL ( OMElement wsdl , String service , String port ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { wsdl . serialize ( baos ) ; InputStream in = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; InputSource inputSource = new InputSource ( in ) ; WSDLFactory fac = WSDLFactory . newInstance ( ) ; WSDLReader reader = fac . newWSDLReader ( ) ; Definition definition = reader . readWSDL ( null , inputSource ) ; return createEndpointDefinitionFromWSDL ( definition , service , port ) ; } catch ( XMLStreamException e ) { handleException ( "Error retrieving the WSDL definition from the inline WSDL." ) ; } catch ( WSDLException e ) { handleException ( "Error retrieving the WSDL definition from the inline WSDL." ) ; } return null ; } public EndpointDefinition createEndpointDefinitionFromWSDL ( String wsdlURI , String service , String port ) { try { WSDLFactory fac = WSDLFactory . newInstance ( ) ; WSDLReader reader = fac . newWSDLReader ( ) ; Definition definition = reader . readWSDL ( wsdlURI ) ; return createEndpointDefinitionFromWSDL ( definition , service , port ) ; } catch ( WSDLException e ) { handleException ( "Error retrieving the WSDL definition from the WSDL URI." ) ; } return null ; } private EndpointDefinition createEndpointDefinitionFromWSDL ( Definition definition , String serviceName , String portName ) { if ( definition == null ) { handleException ( "WSDL is not specified." ) ; } if ( serviceName == null ) { handleException ( "Service of the WSDL document is not specified." ) ; } if ( portName == null ) { handleException ( "Port of the WSDL document is not specified." ) ; } String serviceURL = null ; String tns = definition . getTargetNamespace ( ) ; Service service = definition . getService ( new QName ( tns , serviceName ) ) ; if ( service != null ) { Port port = service . getPort ( portName ) ; if ( port != null ) { List ext = port . getExtensibilityElements ( ) ; for ( int i = 0 ; i < ext . size ( ) ; i ++ ) { Object o = ext . get ( i ) ; if ( o instanceof SOAPAddress ) { SOAPAddress address = ( SOAPAddress ) o ; serviceURL = address . getLocationURI ( ) ; break ; } else if ( o instanceof SOAP12Address ) { SOAP12Address address = ( SOAP12Address ) o ; serviceURL = address . getLocationURI ( ) ; break ; } } } } if ( serviceURL != null ) { EndpointDefinition endpointDefinition = new EndpointDefinition ( ) ; endpointDefinition . setAddress ( serviceURL ) ; return endpointDefinition ; } else { handleException ( "Couldn't retrieve endpoint information from the WSDL." ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . description . Parameter ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . core . SynapseEnvironment ; public class MessageContextCreatorForAxis2 implements Constants { private static Log log = LogFactory . getLog ( MessageContextCreatorForAxis2 . class ) ; private static SynapseConfiguration synCfg = null ; private static SynapseEnvironment synEnv = null ; public static MessageContext getSynapseMessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) throws AxisFault { if ( synCfg == null || synEnv == null ) { String msg = "Synapse environment has not initialized properly.." ; log . fatal ( msg ) ; throw new SynapseException ( msg ) ; } return new Axis2MessageContext ( axisMsgCtx , synCfg , synEnv ) ; } public static void setSynConfig ( SynapseConfiguration synCfg ) { MessageContextCreatorForAxis2 . synCfg = synCfg ; } public static void setSynEnv ( SynapseEnvironment synEnv ) { MessageContextCreatorForAxis2 . synEnv = synEnv ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . * ; import org . apache . synapse . mediators . GetPropertyFunction ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . Entry ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jaxen . SimpleFunctionContext ; import org . jaxen . XPathFunctionContext ; import org . jaxen . JaxenException ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private static final Log log = LogFactory . getLog ( Axis2MessageContext . class ) ; private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map properties = new HashMap ( ) ; private Map localEntries = new HashMap ( ) ; private Stack faultStack = new Stack ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = Constants . TRACING_UNSET ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( Constants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( Constants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( Constants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( Constants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( Constants . RESPONSE . equals ( key ) ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . valueOf ( b ) ) ; } public boolean isResponse ( ) { Object o = properties . get ( Constants . RESPONSE ) ; if ( o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) { return true ; } return response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( Constants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) response = resp . booleanValue ( ) ; } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public static String getStringValue ( AXIOMXPath xpath , MessageContext synCtx ) { if ( xpath != null ) { try { GetPropertyFunction getPropertyFunc = new GetPropertyFunction ( ) ; getPropertyFunc . setSynCtx ( synCtx ) ; SimpleFunctionContext fc = new XPathFunctionContext ( ) ; fc . registerFunction ( Constants . SYNAPSE_NAMESPACE , "get-property" , getPropertyFunc ) ; fc . registerFunction ( null , "get-property" , getPropertyFunc ) ; xpath . setFunctionContext ( fc ) ; xpath . addNamespace ( "synapse" , Constants . SYNAPSE_NAMESPACE ) ; xpath . addNamespace ( "syn" , Constants . SYNAPSE_NAMESPACE ) ; } catch ( JaxenException je ) { handleException ( "Error setting up the Synapse XPath " + "extension function for XPath : " + xpath , je ) ; } try { Object result = xpath . evaluate ( synCtx . getEnvelope ( ) ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { Iterator iter = ( ( List ) result ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o == null ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { textValue . append ( ( ( OMElementImpl ) o ) . getText ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + xpath . toString ( ) + " resulted in an error" , je ) ; } } else { handleException ( "Invalid (null) XPath expression" ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) sb . append ( "To: " + getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( getFrom ( ) != null ) sb . append ( separator + "From: " + getFrom ( ) . getAddress ( ) ) ; if ( getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + getWSAAction ( ) ) ; if ( getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + getSoapAction ( ) ) ; if ( getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + getReplyTo ( ) . getAddress ( ) ) ; if ( getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + getMessageID ( ) ) ; Iterator iter = getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { sb . append ( separator + "Headers : " ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; sb . append ( separator + header . getLocalName ( ) + " : " + header . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } return sb . toString ( ) ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . LoadbalanceEndpoint ; import org . apache . synapse . endpoints . SALoadbalanceEndpoint ; import org . apache . synapse . endpoints . dispatch . Dispatcher ; import org . apache . synapse . endpoints . dispatch . SoapSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . SimpleClientSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . HttpSessionDispatcher ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . endpoints . utils . LoadbalanceAlgorithmFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import javax . xml . namespace . QName ; import java . util . ArrayList ; import java . util . Iterator ; public class SALoadbalanceEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( LoadbalanceEndpointFactory . class ) ; private static SALoadbalanceEndpointFactory instance = new SALoadbalanceEndpointFactory ( ) ; private SALoadbalanceEndpointFactory ( ) { } public static SALoadbalanceEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { SALoadbalanceEndpoint loadbalanceEndpoint = new SALoadbalanceEndpoint ( ) ; OMElement sessionElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "session" ) ) ; if ( sessionElement != null ) { String type = sessionElement . getAttributeValue ( new QName ( "type" ) ) ; if ( type . equalsIgnoreCase ( "soap" ) ) { Dispatcher soapDispatcher = new SoapSessionDispatcher ( ) ; loadbalanceEndpoint . setDispatcher ( soapDispatcher ) ; } else if ( type . equalsIgnoreCase ( "http" ) ) { Dispatcher httpDispatcher = new HttpSessionDispatcher ( ) ; loadbalanceEndpoint . setDispatcher ( httpDispatcher ) ; } else if ( type . equalsIgnoreCase ( "simpleClientSession" ) ) { Dispatcher csDispatcher = new SimpleClientSessionDispatcher ( ) ; loadbalanceEndpoint . setDispatcher ( csDispatcher ) ; } } else { handleException ( "Session affinity endpoints should have a session element in the configuration." ) ; } OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { loadbalanceEndpoint . setName ( name . getAttributeValue ( ) ) ; } OMElement loadbalanceElement = null ; loadbalanceElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "loadbalance" ) ) ; if ( loadbalanceElement != null ) { ArrayList endpoints = getEndpoints ( loadbalanceElement , loadbalanceEndpoint ) ; loadbalanceEndpoint . setEndpoints ( endpoints ) ; LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory . createLoadbalanceAlgorithm ( loadbalanceElement , endpoints ) ; loadbalanceEndpoint . setAlgorithm ( algorithm ) ; return loadbalanceEndpoint ; } return null ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } private ArrayList getEndpoints ( OMElement loadbalanceElement , Endpoint parent ) { ArrayList endpoints = new ArrayList ( ) ; Iterator iter = loadbalanceElement . getChildrenWithName ( org . apache . synapse . config . xml . Constants . ENDPOINT_ELT ) ; while ( iter . hasNext ( ) ) { OMElement endptElem = ( OMElement ) iter . next ( ) ; EndpointFactory epFac = EndpointAbstractFactory . getEndpointFactroy ( endptElem ) ; Endpoint endpoint = epFac . createEndpoint ( endptElem , true ) ; endpoint . setParentEndpoint ( parent ) ; endpoints . add ( endpoint ) ; } return endpoints ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse ; import org . apache . axis2 . util . OptionsParser ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import java . io . File ; import java . util . Iterator ; import java . net . ServerSocket ; import java . net . Socket ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; public static void printUsage ( ) { System . out . println ( "Usage: SynapseServer <repository>" ) ; System . out . println ( " Opts: -? this message" ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 || ! new File ( args [ 0 ] ) . exists ( ) ) { printUsage ( ) ; } System . out . println ( "[SynapseServer] Using the Axis2 Repository " + new File ( args [ 0 ] ) . getAbsolutePath ( ) ) ; try { ConfigurationContext configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( args [ 0 ] , null ) ; ListenerManager listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } selectPort ( configctx ) ; Iterator iter = configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String trp = ( String ) iter . next ( ) ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; listenerManager . addListener ( trsIn , false ) ; String msg = "[SynapseServer] Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } System . out . println ( msg ) ; } System . out . println ( "[SynapseServer] Ready" ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; System . out . println ( "[SynapseServer] Startup failed..." ) ; } } private static void selectPort ( ConfigurationContext configCtx ) { TransportInDescription trsIn = ( TransportInDescription ) configCtx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( "http" ) ; if ( trsIn != null ) { int port = 8080 ; String strPort = System . getProperty ( "port" ) ; if ( strPort != null ) { try { port = new Integer ( strPort ) . intValue ( ) ; } catch ( NumberFormatException e ) { log . error ( "Given port is not a valid integer. Port specified in the configuration is used for the server." ) ; port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } } else { port = Integer . parseInt ( trsIn . getParameter ( "port" ) . getValue ( ) . toString ( ) ) ; } while ( true ) { ServerSocket sock = null ; try { sock = new ServerSocket ( port ) ; trsIn . getParameter ( "port" ) . setValue ( Integer . toString ( port ) ) ; break ; } catch ( Exception e ) { System . out . println ( "[SynapseServer] Port " + port + " already in use. Trying alternate" ) ; if ( port == 8080 ) { port = 8008 ; } else { port ++ ; } } finally { if ( sock != null ) { try { sock . close ( ) ; } catch ( Exception e ) { } } } } } } } 	1
package org . apache . synapse . endpoints . dispatch ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . MessageContext ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . om . OMElement ; import javax . xml . namespace . QName ; import java . util . Map ; import java . util . HashMap ; import java . util . Collections ; public class SimpleClientSessionDispatcher implements Dispatcher { private Map sessionMap = Collections . synchronizedMap ( new HashMap ( ) ) ; public Endpoint getEndpoint ( MessageContext synCtx ) { SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { OMElement csID = header . getFirstChildWithName ( new QName ( "http://ws.apache.org/namespaces/synapse" , "ClientID" , "syn" ) ) ; if ( csID != null && csID . getText ( ) != null ) { Object o = sessionMap . get ( csID . getText ( ) ) ; if ( o != null ) { return ( Endpoint ) o ; } } } return null ; } public void updateSession ( MessageContext synCtx , Endpoint endpoint ) { SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { OMElement csID = header . getFirstChildWithName ( new QName ( "http://ws.apache.org/namespaces/synapse" , "ClientID" , "syn" ) ) ; if ( csID != null && csID . getText ( ) != null ) { synchronized ( sessionMap ) { if ( ! sessionMap . containsKey ( csID . getText ( ) ) ) { sessionMap . put ( csID . getText ( ) , endpoint ) ; } } } } } public void unbind ( MessageContext synCtx ) { SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { OMElement csID = header . getFirstChildWithName ( new QName ( "http://ws.apache.org/namespaces/synapse" , "ClientID" , "syn" ) ) ; if ( csID != null && csID . getText ( ) != null ) { sessionMap . remove ( csID . getText ( ) ) ; } } } public boolean isServerInitiatedSession ( ) { return false ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AddressEndpointSerializer implements EndpointSerializer { private static Log log = LogFactory . getLog ( AddressEndpointSerializer . class ) ; private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof AddressEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; AddressEndpoint addressEndpoint = ( AddressEndpoint ) endpoint ; String name = addressEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } EndpointDefinition epAddress = addressEndpoint . getEndpoint ( ) ; OMElement addressElement = serializeEndpointDefinition ( epAddress ) ; endpointElement . addChild ( addressElement ) ; long suspendDuration = addressEndpoint . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE , Constants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; addressElement . addChild ( suspendElement ) ; } return endpointElement ; } public OMElement serializeEndpointDefinition ( EndpointDefinition endpt ) { OMElement address = fac . createOMElement ( "address" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isForcePOX ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "pox" ) ) ; } else if ( endpt . isForceSOAP ( ) ) { address . addAttribute ( fac . createOMAttribute ( "format" , null , "soap" ) ) ; } if ( endpt . isUseSwa ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpt . isUseMTOM ( ) ) { address . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpt . getAddress ( ) != null ) { address . addAttribute ( fac . createOMAttribute ( "uri" , null , endpt . getAddress ( ) ) ) ; } else { handleException ( "Invalid Endpoint. Address is required" ) ; } int isEnableStatistics = endpt . getStatisticsEnable ( ) ; String statisticsValue = null ; if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_ON ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE ; } else if ( isEnableStatistics == org . apache . synapse . Constants . STATISTICS_OFF ) { statisticsValue = org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE ; } if ( statisticsValue != null ) { address . addAttribute ( fac . createOMAttribute ( org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME , null , statisticsValue ) ) ; } if ( endpt . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } address . addChild ( addressing ) ; } if ( endpt . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsRMPolicyKey ( ) ) ) ; } address . addChild ( rm ) ; } if ( endpt . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpt . getWsSecPolicyKey ( ) ) ) ; } address . addChild ( sec ) ; } if ( endpt . getTimeoutAction ( ) != Constants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , Constants . SYNAPSE_OMNAMESPACE ) ; address . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , Constants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpt . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , Constants . SYNAPSE_OMNAMESPACE ) ; if ( endpt . getTimeoutAction ( ) == Constants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpt . getTimeoutAction ( ) == Constants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } return address ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . mediators . filters ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . config . xml . SwitchCase ; import org . apache . synapse . config . xml . AnonymousListMediator ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class SwitchMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( SwitchMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private AXIOMXPath source = null ; private List cases = new ArrayList ( ) ; private SwitchCase defaultCase = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Switch mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Switch mediator" ) ; } String sourceText = Axis2MessageContext . getStringValue ( source , synCtx ) ; log . debug ( "Applying switch case regex patterns against evaluated source value : " + sourceText ) ; try { saveAndSetTraceState ( synCtx ) ; if ( shouldTrace ) { trace . trace ( "Source Value : " + sourceText ) ; trace . trace ( "Start Case mediator list" ) ; } if ( sourceText != null ) { Iterator iter = cases . iterator ( ) ; while ( iter . hasNext ( ) ) { SwitchCase swCase = ( SwitchCase ) iter . next ( ) ; if ( swCase != null ) { if ( swCase . matches ( sourceText ) ) { if ( shouldTrace ) { trace . trace ( "Executing case for : " + swCase . getRegex ( ) ) ; } return swCase . mediate ( synCtx ) ; } } } if ( shouldTrace ) { trace . trace ( "End Case mediator list" ) ; } } else { log . warn ( "Source has been evaluated to Null...Default Case will be run" ) ; } if ( defaultCase != null ) { log . debug ( "Executing default case" ) ; if ( shouldTrace ) { trace . trace ( "Executing default case" ) ; } return defaultCase . mediate ( synCtx ) ; } } finally { restoreTracingState ( synCtx ) ; if ( shouldTrace ) { trace . trace ( "End : Switch mediator" ) ; } } return true ; } public void addCase ( SwitchCase m ) { cases . add ( m ) ; } public List getCases ( ) { return cases ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public SwitchCase getDefaultCase ( ) { return defaultCase ; } public void setDefaultCase ( SwitchCase defaultCase ) { this . defaultCase = defaultCase ; } } 	0
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private AXIOMXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; private static final Log log = LogFactory . getLog ( PropertyMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext smc ) { log . debug ( "Property mediator :: mediate()" ) ; boolean shouldTrace = shouldTrace ( smc . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Property mediator" ) ; } if ( action == ACTION_SET ) { String resultValue = ( this . value != null ? this . value : Axis2MessageContext . getStringValue ( expression , smc ) ) ; log . debug ( "Setting : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") = " + resultValue ) ; if ( shouldTrace ) { trace . trace ( "Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ") set to " + ( value != null ? " resultValue = " + value : " result of expression " + expression + " = " + resultValue ) ) ; } if ( scope == null ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { smc . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } else { log . debug ( "Removing : " + name + " property (scope:" + ( scope == null ? "default" : scope ) + ") " ) ; trace . trace ( "Remove - Property Name : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; if ( scope == null ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = smc . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Map pros = axis2MessageCtx . getProperties ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && smc instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) smc ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } if ( headers == null ) { log . info ( "No Headers found " ) ; } } else { String msg = "Unsupported scope : " + scope + " for property mediator" ; handleException ( msg ) ; } } if ( shouldTrace ) { trace . trace ( "End : Property mediator" ) ; } return true ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1
package org . apache . synapse . mediators ; import org . apache . synapse . MessageContext ; public interface FilterMediator extends ListMediator { public boolean test ( MessageContext synCtx ) ; } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . addressing . EndpointReference ; import javax . xml . namespace . QName ; import java . util . List ; import java . util . Iterator ; public class HeaderMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( HeaderMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private AXIOMXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Header mediator <" + ( action == ACTION_SET ? "Set" : "Remove" ) + "> :: mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : Header mediator, action = " + ( action == ACTION_SET ? "set" : "remove" ) ) ; } if ( action == ACTION_SET ) { String value = ( getValue ( ) != null ? getValue ( ) : Axis2MessageContext . getStringValue ( getExpression ( ) , synCtx ) ) ; log . debug ( "Setting header : " + qName + " to : " + value ) ; if ( shouldTrace ) { trace . trace ( "Set Header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else { addCustomHeader ( synCtx ) ; } } else { addCustomHeader ( synCtx ) ; } } else { log . debug ( "Removing header : " + qName + " from current message" ) ; if ( shouldTrace ) { trace . trace ( "Remove Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( Constants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( Constants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( Constants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( Constants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( "" ) ) ; } } else { removeFromHeaderList ( synCtx . getEnvelope ( ) . getHeader ( ) . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } if ( shouldTrace ) { trace . trace ( "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } Iterator iter = headersList . iterator ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public AXIOMXPath getExpression ( ) { return expression ; } public void setExpression ( AXIOMXPath expression ) { this . expression = expression ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . XSLTMediator ; import org . apache . synapse . config . xml . AbstractMediatorSerializer ; public class XSLTMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( XSLTMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof XSLTMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } XSLTMediator mediator = ( XSLTMediator ) m ; OMElement xslt = fac . createOMElement ( "xslt" , synNS ) ; if ( mediator . getXsltKey ( ) != null ) { xslt . addAttribute ( fac . createOMAttribute ( "key" , nullNS , mediator . getXsltKey ( ) ) ) ; } else { handleException ( "Invalid XSLT mediator. XSLT registry key is required" ) ; } finalizeSerialization ( xslt , mediator ) ; if ( mediator . getSource ( ) != null && ! XSLTMediator . DEFAULT_XPATH . toString ( ) . equals ( mediator . getSource ( ) . toString ( ) ) ) { xslt . addAttribute ( fac . createOMAttribute ( "source" , nullNS , mediator . getSource ( ) . toString ( ) ) ) ; serializeNamespaces ( xslt , mediator . getSource ( ) ) ; } serializeProperties ( xslt , mediator . getProperties ( ) ) ; if ( parent != null ) { parent . addChild ( xslt ) ; } return xslt ; } public String getMediatorClassName ( ) { return XSLTMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import java . util . ArrayList ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . axiom . attachments . Attachments ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . sandesha2 . client . SandeshaClientConstants ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [ mtom = " + endpoint . isUseMTOM ( ) + "] [ swa = " + endpoint . isUseSwa ( ) + "] [ force soap=" + endpoint . isForceSOAP ( ) + "; pox=" + endpoint . isForcePOX ( ) : "" ) + "] [ to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; String eprAddress = null ; if ( endpoint != null && endpoint . getAddress ( ) != null ) { eprAddress = endpoint . getAddress ( ) . toString ( ) ; if ( endpoint . isForcePOX ( ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( endpoint . isForceSOAP ( ) ) { axisOutMsgCtx . setDoingREST ( false ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . setProperty ( Constants . OUTFLOW_USE_SEPARATE_LISTENER , Boolean . TRUE ) ; } axisOutMsgCtx . setTo ( new EndpointReference ( eprAddress ) ) ; } if ( wsAddressingEnabled ) { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( new QName ( AnonymousServiceFactory . DYNAMIC_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( org . apache . synapse . config . xml . Constants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } mepClient . setCallback ( callback ) ; mepClient . execute ( false ) ; originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = new MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( int i = 0 ; i < cIDs . length ; i ++ ) { if ( ! cIDs [ i ] . equals ( soapPart ) ) { newMC . addAttachment ( cIDs [ i ] , attachments . getDataHandler ( cIDs [ i ] ) ) ; } } } newMC . setServerSide ( false ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( MessageContext . TRANSPORT_HEADERS , ori . getProperty ( MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_LAST_MESSAGE , oriOptions . getProperty ( Constants . SANDESHA_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SPEC_VERSION , oriOptions . getProperty ( Constants . SANDESHA_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( Constants . SANDESHA_SEQUENCE_KEY , oriOptions . getProperty ( Constants . SANDESHA_SEQUENCE_KEY ) ) ; } if ( oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) != null ) { targetOptions . setProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID , oriOptions . getProperty ( SandeshaClientConstants . OFFERED_SEQUENCE_ID ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate Policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { Iterator iterator = headerInformation . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . impl . ProxyServiceStatisticsStack ; public class SynapseMessageReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseMessageReceiver . class ) ; public void receive ( org . apache . axis2 . context . MessageContext mc ) throws AxisFault { if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received a new message for message mediation..." ) ; log . debug ( "Received To: " + ( mc . getTo ( ) != null ? mc . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( mc . getSoapAction ( ) != null ? mc . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( mc . getWSAAction ( ) != null ? mc . getWSAAction ( ) : "null" ) ) ; String [ ] cids = mc . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + mc . getEnvelope ( ) ) ; } MessageContext synCtx = MessageContextCreatorForAxis2 . getSynapseMessageContext ( mc ) ; try { StatisticsStack synapseServiceStack = ( StatisticsStack ) synCtx . getProperty ( org . apache . synapse . Constants . SYNAPSESERVICE_STATISTICS_STACK ) ; if ( synapseServiceStack == null ) { synapseServiceStack = new ProxyServiceStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . SYNAPSESERVICE_STATISTICS_STACK , synapseServiceStack ) ; } String name = "SynapseService" ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; synapseServiceStack . put ( name , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , true , isFault ) ; synCtx . getEnvironment ( ) . injectMessage ( synCtx ) ; } catch ( SynapseException syne ) { if ( ! synCtx . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synCtx . getFaultStack ( ) . pop ( ) ) . handleFault ( synCtx , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } 	0
package org . apache . synapse . mediators ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { int size = args . size ( ) ; if ( size == 0 ) { log . warn ( "Property key value for lookup was not specified" ) ; return null ; } else if ( size == 1 ) { return evaluate ( Constants . SCOPE_DEFAULT , args . get ( 0 ) , context . getNavigator ( ) ) ; } else if ( size == 2 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope,prop-name) XPath function " ; log . warn ( msg ) ; throw new FunctionCallException ( msg ) ; } } public Object evaluate ( Object scopeObject , Object keyObject , Navigator navigator ) { if ( synCtx == null ) { log . warn ( "Synapse context has not been set for the XPath extension function" + "'synapse:get-property(prop-name)'" ) ; return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { log . warn ( "property-name should be provided when executing " + "synapse:get-property(scope,prop-name)" + " or synapse:get-property(prop-name) Xpath function" ) ; return null ; } if ( Constants . SCOPE_DEFAULT . equals ( scope ) ) { if ( Constants . HEADER_TO . equals ( key ) && synCtx . getTo ( ) != null ) { return synCtx . getTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_FROM . equals ( key ) && synCtx . getFrom ( ) != null ) { return synCtx . getFrom ( ) . getAddress ( ) ; } else if ( Constants . HEADER_ACTION . equals ( key ) && synCtx . getWSAAction ( ) != null ) { return synCtx . getWSAAction ( ) ; } else if ( Constants . HEADER_FAULT . equals ( key ) && synCtx . getFaultTo ( ) != null ) { return synCtx . getFaultTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_REPLY_TO . equals ( key ) && synCtx . getReplyTo ( ) != null ) { return synCtx . getReplyTo ( ) . getAddress ( ) ; } else if ( Constants . HEADER_MESSAGE_ID . equals ( key ) && synCtx . getMessageID ( ) != null ) { return synCtx . getMessageID ( ) ; } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( Constants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getConfigurationContext ( ) . getProperty ( key ) ; } else if ( Constants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; return headersMap . get ( key ) ; } } else { log . warn ( "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } return null ; } } 	1
package org . apache . synapse . mediators . filters ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractListMediator ; public class OutMediator extends AbstractListMediator implements org . apache . synapse . mediators . FilterMediator { private static final Log log = LogFactory . getLog ( OutMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Out mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; try { if ( shouldTrace ) { trace . trace ( "Start : Out mediator" ) ; } if ( test ( synCtx ) ) { log . debug ( "Current message is outgoing.. executing child mediators" ) ; return super . mediate ( synCtx ) ; } else { log . debug ( "Current message is not outgoing.. skipping child mediators" ) ; return true ; } } finally { if ( shouldTrace ) { trace . trace ( "End : Out mediator" ) ; } } } public boolean test ( MessageContext synCtx ) { return synCtx . isResponse ( ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . client . async . Callback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . util . Utils ; import org . apache . axis2 . transport . nhttp . NhttpConstants ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . axiom . soap . SOAPFault ; import org . apache . sandesha2 . client . SandeshaClientConstants ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map callbackStore ; private Timer timeOutTimer = null ; public SynapseCallbackReceiver ( ) { callbackStore = Collections . synchronizedMap ( new HashMap ( ) ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; timeOutTimer = new Timer ( true ) ; timeOutTimer . schedule ( timeoutHandler , 0 , Constants . TIMEOUT_HANDLER_INTERVAL ) ; } public void addCallback ( String MsgID , Callback callback ) { callbackStore . put ( MsgID , callback ) ; } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { messageID = messageCtx . getOptions ( ) . getRelatesTo ( ) . getValue ( ) ; } else if ( messageCtx . getProperty ( SandeshaClientConstants . SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( Constants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { Callback callback = ( Callback ) callbackStore . remove ( messageID ) ; RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback has not been registered to process this response" ) ; } } else if ( ! Utils . isExplicitlyTrue ( messageCtx , NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPFault fault = response . getEnvelope ( ) . getBody ( ) . getFault ( ) ; Exception e = fault . getException ( ) ; if ( e == null ) { e = new Exception ( fault . toString ( ) ) ; } synapseOutMsgCtx . setProperty ( Constants . ERROR_CODE , Constants . SENDING_FAULT ) ; if ( fault != null && fault . getReason ( ) != null ) { synapseOutMsgCtx . setProperty ( Constants . ERROR_MESSAGE , fault . getReason ( ) . getText ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( int i = 0 ; i < cids . length ; i ++ ) { log . debug ( "Attachment : " + cids [ i ] ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . getAxisMessage ( ) . setParent ( axisOutMsgCtx . getOperationContext ( ) . getAxisOperation ( ) ) ; response . setAxisService ( axisOutMsgCtx . getAxisService ( ) ) ; response . setServerSide ( true ) ; response . setProperty ( Constants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; Iterator iter = synapseOutMsgCtx . getPropertyKeySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { if ( ! synapseInMessageContext . getFaultStack ( ) . isEmpty ( ) ) { ( ( FaultHandler ) synapseInMessageContext . getFaultStack ( ) . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( int i = 0 ; i < relates . length ; i ++ ) { RelatesTo current = relates [ i ] ; boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . FailoverEndpoint ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import java . util . ArrayList ; import java . util . List ; public class FailoverEndpointSerializer implements EndpointSerializer { private OMFactory fac = null ; public OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof FailoverEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } FailoverEndpoint failoverEndpoint = ( FailoverEndpoint ) endpoint ; fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , Constants . SYNAPSE_OMNAMESPACE ) ; OMElement failoverElement = fac . createOMElement ( "failover" , Constants . SYNAPSE_OMNAMESPACE ) ; endpointElement . addChild ( failoverElement ) ; String name = failoverEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } List endpoints = failoverEndpoint . getEndpoints ( ) ; for ( int i = 0 ; i < endpoints . size ( ) ; i ++ ) { Endpoint childEndpoint = ( Endpoint ) endpoints . get ( i ) ; EndpointSerializer serializer = EndpointAbstractSerializer . getEndpointSerializer ( childEndpoint ) ; OMElement aeElement = serializer . serializeEndpoint ( childEndpoint ) ; failoverElement . addChild ( aeElement ) ; } return endpointElement ; } } 	0
package org . apache . synapse . config . xml ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . builtin . PropertyMediator ; import org . jaxen . JaxenException ; public class PropertyMediatorFactory extends AbstractMediatorFactory { private static final Log log = LogFactory . getLog ( LogMediatorFactory . class ) ; private static final QName PROP_Q = new QName ( Constants . SYNAPSE_NAMESPACE , "property" ) ; public Mediator createMediator ( OMElement elem ) { PropertyMediator propMediator = new PropertyMediator ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMAttribute value = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "value" ) ) ; OMAttribute expression = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "expression" ) ) ; OMAttribute scope = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "scope" ) ) ; OMAttribute action = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "action" ) ) ; if ( name == null ) { String msg = "The 'name' attribute is required for the configuration of a property mediator" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } else if ( ( value == null && expression == null ) && ! ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) ) { String msg = "Either an 'value' or 'expression' attribute is required for a property mediator when action is SET" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setName ( name . getAttributeValue ( ) ) ; if ( value != null ) { propMediator . setValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { AXIOMXPath xp = new AXIOMXPath ( expression . getAttributeValue ( ) ) ; OMElementUtils . addNameSpaces ( xp , elem , log ) ; propMediator . setExpression ( xp ) ; } catch ( JaxenException e ) { String msg = "Invalid XPath expression for attribute 'expression' : " + expression . getAttributeValue ( ) ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } if ( scope != null ) { String valueStr = scope . getAttributeValue ( ) ; if ( ! Constants . SCOPE_AXIS2 . equals ( valueStr ) && ! Constants . SCOPE_TRANSPORT . equals ( valueStr ) && ! Constants . SCOPE_DEFAULT . equals ( valueStr ) ) { String msg = "Only '" + Constants . SCOPE_AXIS2 + "' or '" + Constants . SCOPE_TRANSPORT + "' values are allowed for attribute scope for a property mediator" + ", Unsupported scope " + valueStr ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } propMediator . setScope ( valueStr ) ; } initMediator ( propMediator , elem ) ; if ( action != null && "remove" . equals ( action . getAttributeValue ( ) ) ) { propMediator . setAction ( PropertyMediator . ACTION_REMOVE ) ; } return propMediator ; } public QName getTagQName ( ) { return PROP_Q ; } } 	1
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . config . XMLToObjectMapper ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . OMElement ; public class XMLToEndpointMapper implements XMLToObjectMapper { private static XMLToEndpointMapper instance = new XMLToEndpointMapper ( ) ; private XMLToEndpointMapper ( ) { } public static XMLToEndpointMapper getInstance ( ) { return instance ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { OMElement epElement = ( OMElement ) om ; return EndpointAbstractFactory . getEndpointFactroy ( epElement ) . createEndpoint ( epElement , false ) ; } else { throw new SynapseException ( "Configuration is not in proper format." ) ; } } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . config . Util ; import org . apache . synapse . config . Entry ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . jaxen . JaxenException ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . * ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; public class XSLTMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( XSLTMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private String xsltKey = null ; private AXIOMXPath source = null ; private List properties = new ArrayList ( ) ; private Transformer transformer = null ; private final Object transformerLock = new Object ( ) ; public static final String DEFAULT_XPATH = "//s11:Envelope/s11:Body/child::*[position()=1] | " + "//s12:Envelope/s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new AXIOMXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { handleException ( "Error creating source XPath expression" , e ) ; } } public boolean mediate ( MessageContext synCtx ) { try { log . debug ( "XSLT mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } log . debug ( "Performing XSLT transformation against resource with key : " + xsltKey ) ; performXLST ( synCtx , shouldTrace ) ; if ( shouldTrace ) { trace . trace ( "Start : XSLT mediator" ) ; } return true ; } catch ( Exception e ) { handleException ( "Unable to do the transformation" ) ; } return false ; } private void performXLST ( MessageContext msgCtx , boolean shouldTrace ) { Source transformSrc = null ; ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream ( ) ; StreamResult transformTgt = new StreamResult ( baosForTarget ) ; OMNode sourceNode = getTransformSource ( msgCtx ) ; if ( shouldTrace ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation source : " + sourceNode ) ; } try { ByteArrayOutputStream baosForSource = new ByteArrayOutputStream ( ) ; XMLStreamWriter xsWriterForSource = XMLOutputFactory . newInstance ( ) . createXMLStreamWriter ( baosForSource ) ; sourceNode . serialize ( xsWriterForSource ) ; transformSrc = new StreamSource ( new ByteArrayInputStream ( baosForSource . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error gettting transform source " + e . getMessage ( ) , e ) ; } Entry dp = msgCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } else { if ( transformer == null ) { synchronized ( transformerLock ) { try { transformer = TransformerFactory . newInstance ( ) . newTransformer ( Util . getStreamSource ( msgCtx . getEntry ( xsltKey ) ) ) ; } catch ( TransformerConfigurationException e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e ) ; } } } } try { transformer . transform ( transformSrc , transformTgt ) ; StAXOMBuilder builder = new StAXOMBuilder ( new ByteArrayInputStream ( baosForTarget . toByteArray ( ) ) ) ; OMElement result = builder . getDocumentElement ( ) ; if ( shouldTrace ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Transformation result : " + result ) ; } sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation " + xsltKey , e ) ; } catch ( XMLStreamException e ) { handleException ( "Error building result from XSLT transformation" , e ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx . getEnvelope ( ) ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " must result in an OMNode" ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath " + source + " on message" ) ; } return null ; } private void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . ext . ClassMediator ; import org . apache . synapse . mediators . filters . FilterMediator ; public class ClassMediatorSerializer extends AbstractMediatorSerializer { private static final Log log = LogFactory . getLog ( ClassMediatorSerializer . class ) ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof ClassMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } ClassMediator mediator = ( ClassMediator ) m ; OMElement clazz = fac . createOMElement ( "class" , synNS ) ; finalizeSerialization ( clazz , mediator ) ; if ( mediator . getClazz ( ) != null ) { clazz . addAttribute ( fac . createOMAttribute ( "name" , nullNS , mediator . getClazz ( ) . getName ( ) ) ) ; } else { handleException ( "Invalid class mediator. " + "The class name is required" ) ; } serializeProperties ( clazz , mediator . getProperties ( ) ) ; if ( parent != null ) { parent . addChild ( clazz ) ; } return clazz ; } public String getMediatorClassName ( ) { return ClassMediator . class . getName ( ) ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( ) { } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this . synapseConfig = synapseConfig ; } public void injectMessage ( final MessageContext synCtx ) { synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } if ( synCtx . getProperty ( Constants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) ) ; outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( Constants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { log . debug ( "Proxy service " + synCtx . getProperty ( Constants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; Axis2Sender . sendBack ( synCtx ) ; } } else { synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) Axis2Sender . sendBack ( synCtx ) ; else Axis2Sender . sendOn ( endpoint , synCtx ) ; } public MessageContext createMessageContext ( ) { org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; return mc ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } } 	1
package org . apache . synapse . mediators . filters ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Constants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractListMediator ; import org . jaxen . JaxenException ; import java . util . regex . Pattern ; import java . util . regex . Matcher ; public class FilterMediator extends AbstractListMediator implements org . apache . synapse . mediators . FilterMediator { private static final Log log = LogFactory . getLog ( FilterMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; private AXIOMXPath source = null ; private Pattern regex = null ; private AXIOMXPath xpath = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Filter mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; try { if ( shouldTrace ) { trace . trace ( "Start : Filter mediator " ) ; } if ( test ( synCtx ) ) { log . debug ( "Filter condition satisfied.. executing child mediators" ) ; return super . mediate ( synCtx ) ; } else { log . debug ( "Filter condition failed.. will skip executing child mediators" ) ; return true ; } } finally { if ( shouldTrace ) { trace . trace ( "End : Filter mediator " ) ; } } } public boolean test ( MessageContext synCtx ) { try { if ( xpath != null ) { log . debug ( "Evaluating XPath expression : " + xpath ) ; if ( shouldTrace ( synCtx . getTracingState ( ) ) ) { trace . trace ( "XPath expression : " + xpath + " evaluates to : " + xpath . booleanValueOf ( synCtx . getEnvelope ( ) ) ) ; } return xpath . booleanValueOf ( synCtx . getEnvelope ( ) ) ; } else if ( source != null && regex != null ) { log . debug ( "Evaluating regular expression : " + regex . pattern ( ) + " against source : " + source ) ; String sourceString = Axis2MessageContext . getStringValue ( source , synCtx ) ; if ( sourceString == null ) { log . debug ( "Source String has been evaluated to Null" ) ; return false ; } if ( shouldTrace ( synCtx . getTracingState ( ) ) ) { trace . trace ( "Regular expression : " + regex . pattern ( ) + " and Source " + sourceString + " matches : " + regex . matcher ( sourceString ) . matches ( ) ) ; } Matcher matcher = regex . matcher ( sourceString ) ; if ( matcher == null ) { log . warn ( "Can not find a Regex Pattren Matcher" ) ; return false ; } return matcher . matches ( ) ; } else { log . error ( "Invalid configuration specified" ) ; return false ; } } catch ( JaxenException e ) { log . error ( "XPath error : " + e . getMessage ( ) ) ; return false ; } } public AXIOMXPath getSource ( ) { return source ; } public void setSource ( AXIOMXPath source ) { this . source = source ; } public Pattern getRegex ( ) { return regex ; } public void setRegex ( Pattern regex ) { this . regex = regex ; } public AXIOMXPath getXpath ( ) { return xpath ; } public void setXpath ( AXIOMXPath xpath ) { this . xpath = xpath ; } } 	0
package org . apache . synapse . core ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsCollector ; public interface SynapseEnvironment { public void injectMessage ( MessageContext smc ) ; public void send ( EndpointDefinition endpoint , MessageContext smc ) ; public MessageContext createMessageContext ( ) ; public StatisticsCollector getStatisticsCollector ( ) ; public void setStatisticsCollector ( StatisticsCollector statisticsCollector ) ; } 	1
package org . apache . synapse . mediators ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MediatorFaultHandler extends FaultHandler { private static final Log log = LogFactory . getLog ( MediatorFaultHandler . class ) ; private Mediator faultMediator = null ; public MediatorFaultHandler ( Mediator faultMediator ) { this . faultMediator = faultMediator ; } public void onFault ( MessageContext synCtx ) throws SynapseException { log . debug ( "MediatorFaultHandler :: handleFault" ) ; this . faultMediator . mediate ( synCtx ) ; } public Mediator getFaultMediator ( ) { return faultMediator ; } public void setFaultMediator ( Mediator faultMediator ) { this . faultMediator = faultMediator ; } } 	0
package org . apache . synapse . core . axis2 ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . TimerTask ; import java . util . Map ; import java . util . Iterator ; import java . util . Stack ; public class TimeoutHandler extends TimerTask { private Map callbackStore = null ; private Object lock = new Object ( ) ; private boolean alreadyExecuting = false ; public TimeoutHandler ( Map callbacks ) { this . callbackStore = callbacks ; } public void run ( ) { if ( alreadyExecuting ) return ; synchronized ( lock ) { alreadyExecuting = true ; try { processCallbacks ( ) ; } catch ( Exception ignore ) { } alreadyExecuting = false ; } } private void processCallbacks ( ) { synchronized ( callbackStore ) { if ( callbackStore . size ( ) > 0 ) { long currentTime = currentTime ( ) ; Iterator i = callbackStore . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Object key = i . next ( ) ; AsyncCallback callback = ( AsyncCallback ) callbackStore . get ( key ) ; if ( callback . getTimeOutAction ( ) != Constants . NONE ) { if ( callback . getTimeOutOn ( ) <= currentTime ) { callbackStore . remove ( key ) ; if ( callback . getTimeOutAction ( ) == Constants . DISCARD_AND_FAULT ) { MessageContext msgContext = callback . getSynapseOutMsgCtx ( ) ; msgContext . setProperty ( Constants . ERROR_CODE , Constants . TIME_OUT ) ; Stack faultStack = msgContext . getFaultStack ( ) ; for ( int j = 0 ; j < faultStack . size ( ) ; j ++ ) { Object o = faultStack . pop ( ) ; if ( o instanceof MediatorFaultHandler ) { ( ( MediatorFaultHandler ) o ) . handleFault ( msgContext ) ; } } } } } } } } } private long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	1
package org . apache . synapse . statistics ; import org . apache . synapse . Constants ; import java . util . * ; public class StatisticsCollector { private Map sequenceStatistics = Collections . synchronizedMap ( new HashMap ( ) ) ; private Map endpointStatistics = Collections . synchronizedMap ( new HashMap ( ) ) ; private Map proxyServicesStatistics = Collections . synchronizedMap ( new HashMap ( ) ) ; public void reportForEndPoint ( String keyOfStatistic , boolean isResponse , long inTime , long outTime , boolean isFault ) { StatisticsHolder statisticsHolder = ( StatisticsHolder ) endpointStatistics . get ( keyOfStatistic ) ; if ( statisticsHolder == null ) { statisticsHolder = new StatisticsHolder ( ) ; statisticsHolder . setKey ( keyOfStatistic ) ; statisticsHolder . setStatisticsCategory ( Constants . ENDPOINT_STATISTICS ) ; endpointStatistics . put ( keyOfStatistic , statisticsHolder ) ; } statisticsHolder . update ( isResponse , inTime , outTime , isFault ) ; } public void reportForProxyService ( String keyOfStatistic , boolean isResponse , long inTime , long outTime , boolean isFault ) { StatisticsHolder statisticsHolder = ( StatisticsHolder ) proxyServicesStatistics . get ( keyOfStatistic ) ; if ( statisticsHolder == null ) { statisticsHolder = new StatisticsHolder ( ) ; statisticsHolder . setKey ( keyOfStatistic ) ; statisticsHolder . setStatisticsCategory ( Constants . PROXYSERVICE_STATISTICS ) ; proxyServicesStatistics . put ( keyOfStatistic , statisticsHolder ) ; } statisticsHolder . update ( isResponse , inTime , outTime , isFault ) ; } public void reportForSequence ( String keyOfStatistic , boolean isResponse , long inTime , long outTime , boolean isFault ) { StatisticsHolder statisticsHolder = ( StatisticsHolder ) sequenceStatistics . get ( keyOfStatistic ) ; if ( statisticsHolder == null ) { statisticsHolder = new StatisticsHolder ( ) ; statisticsHolder . setKey ( keyOfStatistic ) ; statisticsHolder . setStatisticsCategory ( Constants . SEQUENCE_STATISTICS ) ; sequenceStatistics . put ( keyOfStatistic , statisticsHolder ) ; } statisticsHolder . update ( isResponse , inTime , outTime , isFault ) ; } public Map getSequenceStatistics ( ) { return sequenceStatistics ; } public Map getProxyServiceStatistics ( ) { return proxyServicesStatistics ; } public Map getEndPointStatistics ( ) { return endpointStatistics ; } public void resetSequenceStatistics ( ) { this . sequenceStatistics = Collections . synchronizedMap ( new HashMap ( ) ) ; } public void resetProxyServiceStatistics ( ) { this . proxyServicesStatistics = Collections . synchronizedMap ( new HashMap ( ) ) ; } public void resetEndPointStatistics ( ) { this . endpointStatistics = Collections . synchronizedMap ( new HashMap ( ) ) ; } } 	0
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; import org . apache . synapse . Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Stack ; public class AddressEndpoint extends FaultHandler implements Endpoint { private static final Log log = LogFactory . getLog ( AddressEndpoint . class ) ; private String name = null ; private volatile boolean active = true ; private EndpointDefinition endpoint = null ; private Endpoint parentEndpoint = null ; private long suspendOnFailDuration = - 1 ; private long recoverOn = Long . MAX_VALUE ; public EndpointDefinition getEndpoint ( ) { return endpoint ; } public void setEndpoint ( EndpointDefinition endpoint ) { this . endpoint = endpoint ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public boolean isActive ( MessageContext synMessageContext ) { if ( ! active ) { if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; recoverOn = 0 ; } } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { if ( suspendOnFailDuration != - 1 ) { recoverOn = System . currentTimeMillis ( ) + suspendOnFailDuration ; } else { recoverOn = Long . MAX_VALUE ; } } this . active = active ; } public void send ( MessageContext synCtx ) { String endPointName = this . getName ( ) ; if ( endPointName == null ) { endPointName = Constants . ANONYMOUS_ENDPOINTS ; } boolean statisticsEnable = ( org . apache . synapse . Constants . STATISTICS_ON == endpoint . getStatisticsEnable ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . Constants . ENDPOINT_STATISTICS_STACK , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending message to endpoint :: name = " + endPointName + " resolved address = " + endpoint . getAddress ( ) ) ; log . debug ( "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; log . debug ( "Body : \n" + synCtx . getEnvelope ( ) ) ; } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( Constants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public long getSuspendOnFailDuration ( ) { return suspendOnFailDuration ; } public void setSuspendOnFailDuration ( long suspendOnFailDuration ) { this . suspendOnFailDuration = suspendOnFailDuration ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synCtx ) ; } else { Stack faultStack = synCtx . getFaultStack ( ) ; if ( ! faultStack . isEmpty ( ) ) { ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synCtx ) ; } } } } 	1
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . endpoints . EndpointAbstractFactory ; import org . apache . synapse . config . xml . endpoints . EndpointFactory ; import org . apache . synapse . core . axis2 . ProxyService ; import org . apache . axis2 . wsdl . WSDLConstants ; import javax . xml . namespace . QName ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . util . ArrayList ; import java . net . URI ; import java . net . URISyntaxException ; public class ProxyServiceFactory { private static final Log log = LogFactory . getLog ( ProxyServiceFactory . class ) ; public static ProxyService createProxy ( OMElement elem ) { ProxyService proxy = new ProxyService ( ) ; OMAttribute name = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; if ( name == null ) { handleException ( "The 'name' attribute is required for a Proxy service definition" ) ; } else { proxy . setName ( name . getAttributeValue ( ) ) ; } OMAttribute statistics = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { proxy . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { proxy . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } OMAttribute trans = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "transports" ) ) ; if ( trans != null ) { String transports = trans . getAttributeValue ( ) ; if ( transports == null || ProxyService . ALL_TRANSPORTS . equals ( transports ) ) { } else { StringTokenizer st = new StringTokenizer ( transports , " ," ) ; ArrayList transportList = new ArrayList ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . length ( ) != 0 ) { transportList . add ( token ) ; } } proxy . setTransports ( transportList ) ; } } OMAttribute trace = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , Constants . TRACE_ATTRIB_NAME ) ) ; if ( trace != null ) { String traceValue = trace . getAttributeValue ( ) ; if ( traceValue != null ) { if ( traceValue . equals ( Constants . TRACE_ENABLE ) ) { proxy . setTraceState ( org . apache . synapse . Constants . TRACING_ON ) ; } else if ( traceValue . equals ( Constants . TRACE_DISABLE ) ) { proxy . setTraceState ( org . apache . synapse . Constants . TRACING_OFF ) ; } } } OMAttribute startOnLoad = elem . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "startOnLoad" ) ) ; if ( startOnLoad != null ) { proxy . setStartOnLoad ( Boolean . valueOf ( startOnLoad . getAttributeValue ( ) ) . booleanValue ( ) ) ; } else { proxy . setStartOnLoad ( true ) ; } OMElement descriptionElement = elem . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "description" ) ) ; if ( descriptionElement != null ) { proxy . setDescription ( descriptionElement . getText ( ) . trim ( ) ) ; } OMElement target = elem . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "target" ) ) ; if ( target != null ) { boolean isTargetOk = false ; SequenceMediatorFactory mediatorFactory = new SequenceMediatorFactory ( ) ; OMAttribute inSequence = target . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "inSequence" ) ) ; if ( inSequence != null ) { proxy . setTargetInSequence ( inSequence . getAttributeValue ( ) ) ; isTargetOk = true ; } else { OMElement inSequenceElement = target . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "inSequence" ) ) ; if ( inSequenceElement != null ) { proxy . setTargetInLineInSequence ( mediatorFactory . createAnonymousSequence ( inSequenceElement ) ) ; isTargetOk = true ; } } OMAttribute outSequence = target . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "outSequence" ) ) ; if ( outSequence != null ) { proxy . setTargetOutSequence ( outSequence . getAttributeValue ( ) ) ; } else { OMElement outSequenceElement = target . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "outSequence" ) ) ; if ( outSequenceElement != null ) { proxy . setTargetInLineOutSequence ( mediatorFactory . createAnonymousSequence ( outSequenceElement ) ) ; } else { handleException ( "Target for the proxy service must declare an out sequence" ) ; } } OMAttribute faultSequence = target . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "faultSequence" ) ) ; if ( faultSequence != null ) { proxy . setTargetFaultSequence ( faultSequence . getAttributeValue ( ) ) ; } else { OMElement faultSequenceElement = target . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "faultSequence" ) ) ; if ( faultSequenceElement != null ) { proxy . setTargetInLineFaultSequence ( mediatorFactory . createAnonymousSequence ( faultSequenceElement ) ) ; } } OMAttribute tgtEndpt = target . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "endpoint" ) ) ; if ( tgtEndpt != null ) { proxy . setTargetEndpoint ( tgtEndpt . getAttributeValue ( ) ) ; isTargetOk = true ; } else { OMElement endpointElement = target . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "endpoint" ) ) ; if ( endpointElement != null ) { EndpointFactory fac = EndpointAbstractFactory . getEndpointFactroy ( endpointElement ) ; proxy . setTargetInLineEndpoint ( fac . createEndpoint ( endpointElement , true ) ) ; isTargetOk = true ; } } if ( ! isTargetOk ) { handleException ( "Target of the proxy service must declare either an inSequence or endpoint or both" ) ; } } else { handleException ( "Target is required for a Proxy service definition" ) ; } OMElement wsdl = elem . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "publishWSDL" ) ) ; if ( wsdl != null ) { OMAttribute wsdlkey = wsdl . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "key" ) ) ; if ( wsdlkey != null ) { proxy . setWSDLKey ( wsdlkey . getAttributeValue ( ) ) ; } else { OMAttribute wsdlURI = wsdl . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "uri" ) ) ; if ( wsdlURI != null ) { try { proxy . setWsdlURI ( new URI ( wsdlURI . getAttributeValue ( ) ) ) ; } catch ( URISyntaxException e ) { String msg = "Error creating uri for proxy service wsdl" ; log . error ( msg ) ; handleException ( msg , e ) ; } } else { OMElement wsdl11 = wsdl . getFirstChildWithName ( new QName ( WSDLConstants . WSDL1_1_NAMESPACE , "definitions" ) ) ; if ( wsdl11 != null ) { proxy . setInLineWSDL ( wsdl11 ) ; } else { OMElement wsdl20 = wsdl . getFirstChildWithName ( new QName ( WSDLConstants . WSDL2_0_NAMESPACE , "descriptions" ) ) ; if ( wsdl20 != null ) { proxy . setInLineWSDL ( wsdl20 ) ; } } } } } Iterator policies = elem . getChildrenWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "policy" ) ) ; while ( policies . hasNext ( ) ) { Object o = policies . next ( ) ; if ( o instanceof OMElement ) { OMElement policy = ( OMElement ) o ; OMAttribute key = policy . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "key" ) ) ; if ( key != null ) { proxy . addServiceLevelPolicy ( key . getAttributeValue ( ) ) ; } else { handleException ( "Policy element does not specify the policy key" ) ; } } else { handleException ( "Invalid 'policy' element found under element 'policies'" ) ; } } Iterator props = elem . getChildrenWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "parameter" ) ) ; while ( props . hasNext ( ) ) { Object o = props . next ( ) ; if ( o instanceof OMElement ) { OMElement prop = ( OMElement ) o ; OMAttribute pname = prop . getAttribute ( new QName ( Constants . NULL_NAMESPACE , "name" ) ) ; OMElement propertyValue = prop . getFirstElement ( ) ; if ( pname != null ) { if ( propertyValue != null ) { proxy . addParameter ( pname . getAttributeValue ( ) , propertyValue ) ; } else { proxy . addParameter ( pname . getAttributeValue ( ) , prop . getText ( ) . trim ( ) ) ; } } else { handleException ( "Invalid property specified for proxy service : " + name ) ; } } else { handleException ( "Invalid property specified for proxy service : " + name ) ; } } if ( elem . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) != null ) { proxy . setWsRMEnabled ( true ) ; } if ( elem . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) != null ) { proxy . setWsSecEnabled ( true ) ; } return proxy ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	0
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Constants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( FaultMediator . class ) ; private static final Log trace = LogFactory . getLog ( Constants . TRACE_LOGGER ) ; public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; private int soapVersion ; private QName faultCodeValue = null ; private AXIOMXPath faultCodeExpr = null ; private String faultReasonValue = null ; private AXIOMXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; public boolean mediate ( MessageContext synCtx ) { log . debug ( "Fault mediator mediate()" ) ; boolean shouldTrace = shouldTrace ( synCtx . getTracingState ( ) ) ; SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( shouldTrace ) { trace . trace ( "Start : Fault mediator" ) ; } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; default : { if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , shouldTrace ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , shouldTrace ) ; } } } } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean shouldTrace ) { log . debug ( "Creating a SOAP fault using SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) ) ; SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( factory , fault ) ; Iterator iter = synCtx . getEnvelope ( ) . getHeader ( ) . examineAllHeaderBlocks ( ) ; if ( iter . hasNext ( ) ) { while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } log . debug ( "The fault message as : " + fault ) ; try { if ( shouldTrace ) { trace . trace ( "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) ) ; trace . trace ( "Fault Message created : " + faultEnvelope . toString ( ) ) ; } synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { String msg = "Error replacing SOAP envelope with a fault envelope " + af . getMessage ( ) ; log . error ( msg ) ; throw new SynapseException ( af ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( shouldTrace ) { trace . trace ( "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( Axis2MessageContext . getStringValue ( faultCodeExpr , synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = Axis2MessageContext . getStringValue ( faultReasonExpr , synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { String msg = "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } public AXIOMXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( AXIOMXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public AXIOMXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( AXIOMXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } } 	1
package org . apache . synapse . endpoints . dispatch ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import java . util . HashMap ; import java . util . Map ; import java . util . Collections ; public class HttpSessionDispatcher implements Dispatcher { Map sessionMap = Collections . synchronizedMap ( new HashMap ( ) ) ; public Endpoint getEndpoint ( MessageContext synCtx ) { Endpoint endpoint = null ; org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object o = axis2MessageContext . getProperty ( "TRANSPORT_HEADERS" ) ; if ( o != null && o instanceof Map ) { Map headerMap = ( Map ) o ; Object cookie = headerMap . get ( "Cookie" ) ; if ( cookie != null ) { Object e = sessionMap . get ( cookie ) ; if ( e != null ) { endpoint = ( Endpoint ) e ; } } } return endpoint ; } public void updateSession ( MessageContext synCtx , Endpoint endpoint ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object o = axis2MessageContext . getProperty ( "TRANSPORT_HEADERS" ) ; if ( o != null && o instanceof Map ) { Map headerMap = ( Map ) o ; Object cookie = headerMap . get ( "Set-Cookie" ) ; if ( cookie != null ) { synchronized ( sessionMap ) { if ( ! sessionMap . containsKey ( cookie ) ) { sessionMap . put ( cookie , endpoint ) ; } } } } } public void unbind ( MessageContext synCtx ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object o = axis2MessageContext . getProperty ( "TRANSPORT_HEADERS" ) ; if ( o != null && o instanceof Map ) { Map headerMap = ( Map ) o ; Object cookie = headerMap . get ( "Cookie" ) ; if ( cookie != null ) { sessionMap . remove ( cookie ) ; } } } public boolean isServerInitiatedSession ( ) { return true ; } } 	0
package org . apache . synapse . config . xml . endpoints ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . Constants ; import org . apache . synapse . SynapseException ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; public class AddressEndpointFactory implements EndpointFactory { private static Log log = LogFactory . getLog ( AddressEndpointFactory . class ) ; private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } public Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; if ( ! anonymousEndpoint ) { OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; OMElement suspendElement = addressElement . getFirstChildWithName ( new QName ( Constants . SYNAPSE_NAMESPACE , org . apache . synapse . config . xml . Constants . SUSPEND_DURATION_ON_FAILURE ) ) ; if ( suspendElement != null ) { String suspend = suspendElement . getText ( ) ; try { if ( suspend != null ) { long suspendDuration = Long . parseLong ( suspend . trim ( ) ) ; addressEndpoint . setSuspendOnFailDuration ( suspendDuration * 1000 ) ; } } catch ( NumberFormatException e ) { handleException ( "The suspend duration should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } return addressEndpoint ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return createEndpoint ( ( OMElement ) om , false ) ; } else { handleException ( "Invalid XML configuration for an Endpoint. OMElement expected" ) ; } return null ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "uri" ) ) ; OMAttribute format = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "format" ) ) ; OMAttribute optimize = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "optimize" ) ) ; EndpointDefinition endpoint = new EndpointDefinition ( ) ; OMAttribute statistics = elem . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , org . apache . synapse . config . xml . Constants . STATISTICS_ATTRIB_NAME ) ) ; if ( statistics != null ) { String statisticsValue = statistics . getAttributeValue ( ) ; if ( statisticsValue != null ) { if ( org . apache . synapse . config . xml . Constants . STATISTICS_ENABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_ON ) ; } else if ( org . apache . synapse . config . xml . Constants . STATISTICS_DISABLE . equals ( statisticsValue ) ) { endpoint . setStatisticsEnable ( org . apache . synapse . Constants . STATISTICS_OFF ) ; } } } if ( address != null ) { endpoint . setAddress ( address . getAttributeValue ( ) ) ; } else { handleException ( "One of the 'address' or 'ref' attributes are required in an " + "anonymous endpoint" ) ; } if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( forceValue . equals ( "pox" ) ) { endpoint . setForcePOX ( true ) ; } else if ( forceValue . equals ( "soap" ) ) { endpoint . setForceSOAP ( true ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } if ( optimize != null && optimize . getAttributeValue ( ) . length ( ) > 0 ) { String method = optimize . getAttributeValue ( ) . trim ( ) ; if ( "mtom" . equalsIgnoreCase ( method ) ) { endpoint . setUseMTOM ( true ) ; } else if ( "swa" . equalsIgnoreCase ( method ) ) { endpoint . setUseSwa ( true ) ; } } OMElement wsAddr = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableAddressing" ) ) ; if ( wsAddr != null ) { endpoint . setAddressingOn ( true ) ; String useSepList = wsAddr . getAttributeValue ( new QName ( "separateListener" ) ) ; if ( useSepList != null ) { if ( useSepList . trim ( ) . toLowerCase ( ) . startsWith ( "tr" ) || useSepList . trim ( ) . startsWith ( "1" ) ) { endpoint . setUseSeparateListener ( true ) ; } } } OMElement wsSec = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableSec" ) ) ; if ( wsSec != null ) { endpoint . setSecurityOn ( true ) ; OMAttribute policy = wsSec . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsSecPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement wsRm = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "enableRM" ) ) ; if ( wsRm != null ) { endpoint . setReliableMessagingOn ( true ) ; OMAttribute policy = wsRm . getAttribute ( new QName ( org . apache . synapse . config . xml . Constants . NULL_NAMESPACE , "policy" ) ) ; if ( policy != null ) { endpoint . setWsRMPolicyKey ( policy . getAttributeValue ( ) ) ; } } OMElement timeout = elem . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "timeout" ) ) ; if ( timeout != null ) { OMElement duration = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "duration" ) ) ; if ( duration != null ) { String d = duration . getText ( ) ; if ( d != null ) { try { long timeoutSeconds = new Long ( d . trim ( ) ) . longValue ( ) ; endpoint . setTimeoutDuration ( timeoutSeconds * 1000 ) ; } catch ( NumberFormatException e ) { handleException ( "The timeout seconds should be specified as a valid number :: " + e . getMessage ( ) , e ) ; } } } OMElement action = timeout . getFirstChildWithName ( new QName ( org . apache . synapse . config . xml . Constants . SYNAPSE_NAMESPACE , "action" ) ) ; if ( action != null ) { String a = action . getText ( ) ; if ( a != null ) { if ( ( a . trim ( ) ) . equalsIgnoreCase ( "discard" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } else if ( ( a . trim ( ) ) . equalsIgnoreCase ( "fault" ) ) { endpoint . setTimeoutAction ( Constants . DISCARD_AND_FAULT ) ; if ( endpoint . getTimeoutDuration ( ) == 0 ) { endpoint . setTimeoutDuration ( 30000 ) ; } } } } } return endpoint ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1
