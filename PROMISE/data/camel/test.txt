package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultExchange ; import org . quartz . JobExecutionContext ; public class QuartzExchange extends DefaultExchange { public QuartzExchange ( CamelContext context , JobExecutionContext jobExecutionContext ) { super ( context ) ; setIn ( new QuartzMessage ( this , jobExecutionContext ) ) ; } @ Override public QuartzMessage getIn ( ) { return ( QuartzMessage ) super . getIn ( ) ; } public JobExecutionContext getJobExecutionContext ( ) { return getIn ( ) . getJobExecutionContext ( ) ; } } 	0
package org . apache . camel . component . mina ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoConnector ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . serialization . ObjectSerializationCodecFactory ; import org . apache . mina . transport . socket . nio . DatagramAcceptor ; import org . apache . mina . transport . socket . nio . DatagramConnector ; import org . apache . mina . transport . socket . nio . DatagramConnectorConfig ; import org . apache . mina . transport . socket . nio . SocketAcceptor ; import org . apache . mina . transport . socket . nio . SocketConnector ; import org . apache . mina . transport . socket . nio . SocketConnectorConfig ; import org . apache . mina . transport . vmpipe . VmPipeAcceptor ; import org . apache . mina . transport . vmpipe . VmPipeAddress ; import org . apache . mina . transport . vmpipe . VmPipeConnector ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; public class MinaComponent extends DefaultComponent < MinaExchange > { public MinaComponent ( ) { } public MinaComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < MinaExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI u = new URI ( remaining ) ; String protocol = u . getScheme ( ) ; if ( protocol . equals ( "tcp" ) ) { return createSocketEndpoint ( uri , u ) ; } else if ( protocol . equals ( "udp" ) || protocol . equals ( "mcast" ) || protocol . equals ( "multicast" ) ) { return createDatagramEndpoint ( uri , u ) ; } else if ( protocol . equals ( "vm" ) ) { return createVmEndpoint ( uri , u ) ; } else { throw new IOException ( "Unrecognised MINA protocol: " + protocol + " for uri: " + uri ) ; } } protected MinaEndpoint createVmEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new VmPipeAcceptor ( ) ; SocketAddress address = new VmPipeAddress ( connectUri . getPort ( ) ) ; IoConnector connector = new VmPipeConnector ( ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , null ) ; } protected MinaEndpoint createSocketEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new SocketAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new SocketConnector ( ) ; SocketConnectorConfig config = new SocketConnectorConfig ( ) ; config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new ObjectSerializationCodecFactory ( ) ) ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } protected MinaEndpoint createDatagramEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new DatagramAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new DatagramConnector ( ) ; DatagramConnectorConfig config = new DatagramConnectorConfig ( ) ; config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new ObjectSerializationCodecFactory ( ) ) ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public class RandomLoadBalancer extends QueueLoadBalancer { protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; while ( true ) { int index = ( int ) Math . round ( Math . random ( ) * size ) ; if ( index < size ) { return processors . get ( index ) ; } } } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class ValueBuilder < E extends Exchange > implements Expression < E > { private Expression < E > expression ; public ValueBuilder ( Expression < E > expression ) { this . expression = expression ; } public Object evaluate ( E exchange ) { return expression . evaluate ( exchange ) ; } public Expression < E > getExpression ( ) { return expression ; } @ Override public String toString ( ) { return expression . toString ( ) ; } @ Fluent public Predicate < E > isNotEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isNotEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isLessThan ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThan ( expression , right ) ) ; } @ Fluent public Predicate < E > isLessThanOrEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThanOrEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isGreaterThan ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThan ( expression , right ) ) ; } @ Fluent public Predicate < E > isGreaterThanOrEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThanOrEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isInstanceOf ( @ FluentArg ( "class" ) Class type ) { return onNewPredicate ( PredicateBuilder . isInstanceOf ( expression , type ) ) ; } @ Fluent public Predicate < E > matchesRegex ( @ FluentArg ( "regex" ) String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } @ Fluent public Predicate < E > isNull ( ) { return onNewPredicate ( PredicateBuilder . isNull ( expression ) ) ; } @ Fluent public Predicate < E > isNotNull ( ) { return onNewPredicate ( PredicateBuilder . isNotNull ( expression ) ) ; } @ Fluent public Predicate < E > contains ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . contains ( expression , right ) ) ; } @ Fluent public Predicate < E > regex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } @ Fluent public ValueBuilder < E > tokenize ( ) { return tokenize ( "\n" ) ; } @ Fluent public ValueBuilder < E > tokenize ( @ FluentArg ( "token" ) String token ) { Expression < E > newExp = ExpressionBuilder . tokenizeExpression ( expression , token ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexTokenize ( @ FluentArg ( "regex" ) String regex ) { Expression < E > newExp = ExpressionBuilder . regexTokenize ( expression , regex ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexReplaceAll ( @ FluentArg ( "regex" ) String regex , @ FluentArg ( "replacement" ) String replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexReplaceAll ( @ FluentArg ( "regex" ) String regex , @ FluentArg ( "replacement" ) Expression < E > replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > convertTo ( @ FluentArg ( "type" ) Class type ) { Expression < E > newExp = ExpressionBuilder . convertTo ( expression , type ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > convertToString ( ) { return convertTo ( String . class ) ; } @ Fluent public ValueBuilder < E > append ( @ FluentArg ( "value" ) Object value ) { return new ValueBuilder < E > ( ExpressionBuilder . append ( expression , asExpression ( value ) ) ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { return predicate ; } protected Expression < E > asExpression ( Object value ) { if ( value instanceof Expression ) { return ( Expression < E > ) value ; } else { return ExpressionBuilder . constantExpression ( value ) ; } } } 	0
package org . apache . camel . component . xmpp ; import com . sun . jndi . toolkit . url . Uri ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; public class XmppComponent extends DefaultComponent < XmppExchange > { public static XmppComponent xmppComponent ( ) { return new XmppComponent ( ) ; } public XmppComponent ( ) { } public XmppComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < XmppExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { XmppEndpoint endpoint = new XmppEndpoint ( uri , this ) ; URI u = new URI ( uri ) ; endpoint . setHost ( u . getHost ( ) ) ; endpoint . setPort ( u . getPort ( ) ) ; if ( u . getUserInfo ( ) != null ) { endpoint . setUser ( u . getUserInfo ( ) ) ; } String remainingPath = u . getPath ( ) ; if ( remainingPath != null ) { if ( remainingPath . startsWith ( "/" ) ) { remainingPath = remainingPath . substring ( 1 ) ; } if ( remainingPath . length ( ) > 0 ) { endpoint . setParticipant ( remainingPath ) ; } } return endpoint ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . processor . Resequencer ; import java . util . List ; public class ResequencerBuilder extends FromBuilder { private final List < Expression < Exchange > > expressions ; private long batchTimeout = 1000L ; private int batchSize = 100 ; public ResequencerBuilder ( FromBuilder builder , List < Expression < Exchange > > expressions ) { super ( builder ) ; this . expressions = expressions ; } @ Override public Route createRoute ( ) throws Exception { final Processor processor = super . createProcessor ( ) ; final Resequencer resequencer = new Resequencer ( getFrom ( ) , processor , expressions ) ; return new Route < Exchange > ( getFrom ( ) ) { protected void addServices ( List < Service > list ) throws Exception { list . add ( resequencer ) ; } @ Override public String toString ( ) { return "ResequencerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } } ; } public ResequencerBuilder batchSize ( int batchSize ) { setBatchSize ( batchSize ) ; return this ; } public ResequencerBuilder batchTimeout ( int batchTimeout ) { setBatchTimeout ( batchTimeout ) ; return this ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } } 	0
package org . apache . camel . spring . xml ; import java . lang . annotation . Annotation ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Set ; import java . util . Map ; import org . apache . camel . Expression ; import org . apache . camel . builder . Fluent ; import org . apache . camel . builder . FluentArg ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . builder . ValueBuilder ; import org . springframework . beans . SimpleTypeConverter ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . ChildBeanDefinition ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . StringUtils ; import org . springframework . util . xml . DomUtils ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class CamelBeanDefinitionParser extends AbstractBeanDefinitionParser { private final CamelNamespaceHandler namespaceHandler ; private int counter ; public CamelBeanDefinitionParser ( CamelNamespaceHandler namespaceHandler ) { this . namespaceHandler = namespaceHandler ; } protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionBuilder factory = BeanDefinitionBuilder . rootBeanDefinition ( RouteBuilderFactoryBean . class ) ; List childElements = DomUtils . getChildElementsByTagName ( element , "route" ) ; ArrayList < BuilderStatement > routes = new ArrayList < BuilderStatement > ( childElements . size ( ) ) ; if ( childElements != null && childElements . size ( ) > 0 ) { for ( int i = 0 ; i < childElements . size ( ) ; ++ i ) { Element routeElement = ( Element ) childElements . get ( i ) ; ArrayList < BuilderAction > actions = new ArrayList < BuilderAction > ( ) ; Class type = parseBuilderElement ( parserContext , routeElement , RouteBuilder . class , actions ) ; BuilderStatement statement = new BuilderStatement ( ) ; statement . setReturnType ( type ) ; statement . setActions ( actions ) ; routes . add ( statement ) ; } } factory . addPropertyValue ( "routes" , routes ) ; return factory . getBeanDefinition ( ) ; } private Class parseBuilderElement ( ParserContext parserContext , Element element , Class < RouteBuilder > builder , ArrayList < BuilderAction > actions ) { Class currentBuilder = builder ; NodeList childElements = element . getChildNodes ( ) ; Element previousElement = null ; for ( int i = 0 ; i < childElements . getLength ( ) ; ++ i ) { Node node = childElements . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { currentBuilder = parseAction ( parserContext , currentBuilder , actions , ( Element ) node , previousElement ) ; previousElement = ( Element ) node ; BuilderAction action = actions . get ( actions . size ( ) - 1 ) ; if ( action . getMethodInfo ( ) . methodAnnotation . nestedActions ( ) ) { currentBuilder = parseBuilderElement ( parserContext , ( Element ) node , currentBuilder , actions ) ; } else { if ( hasChildElements ( node ) ) { throw new IllegalArgumentException ( "The element " + node . getLocalName ( ) + " should not have any child elements." ) ; } } } } if ( currentBuilder != null ) { Method [ ] methods = currentBuilder . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; Fluent annotation = method . getAnnotation ( Fluent . class ) ; if ( annotation != null && annotation . callOnElementEnd ( ) ) { if ( method . getParameterTypes ( ) . length > 0 ) { throw new RuntimeException ( "Only methods with no parameters can annotated with @Fluent(callOnElementEnd=true): " + method ) ; } MethodInfo methodInfo = new MethodInfo ( method , annotation , new LinkedHashMap < String , Class > ( ) , new LinkedHashMap < String , FluentArg > ( ) ) ; actions . add ( new BuilderAction ( methodInfo , new HashMap < String , Object > ( ) ) ) ; currentBuilder = method . getReturnType ( ) ; } } } return currentBuilder ; } private boolean hasChildElements ( Node node ) { NodeList nl = node . getChildNodes ( ) ; for ( int j = 0 ; j < nl . getLength ( ) ; ++ j ) { if ( nl . item ( j ) . getNodeType ( ) == Node . ELEMENT_NODE ) { return true ; } } return false ; } private Class parseAction ( ParserContext parserContext , Class currentBuilder , ArrayList < BuilderAction > actions , Element element , Element previousElement ) { String actionName = element . getLocalName ( ) ; ArrayList < MethodInfo > methods = findFluentMethodsWithName ( currentBuilder , element . getLocalName ( ) ) ; if ( methods . isEmpty ( ) ) { throw new IllegalActionException ( actionName , previousElement == null ? null : previousElement . getLocalName ( ) ) ; } Collections . sort ( methods , new Comparator < MethodInfo > ( ) { public int compare ( MethodInfo m1 , MethodInfo m2 ) { return m1 . method . getParameterTypes ( ) . length - m2 . method . getParameterTypes ( ) . length ; } } ) ; HashMap < String , Object > attributeArguments = getArugmentsFromAttributes ( element ) ; HashMap < String , ArrayList < Element > > elementArguments = getArgumentsFromElements ( element ) ; MethodInfo match = null ; match = findMethodMatch ( methods , attributeArguments . keySet ( ) , elementArguments . keySet ( ) ) ; if ( match == null ) throw new IllegalActionException ( actionName , previousElement == null ? null : previousElement . getLocalName ( ) ) ; Set < Map . Entry < String , Object > > attributeEntries = attributeArguments . entrySet ( ) ; for ( Map . Entry < String , Object > entry : attributeEntries ) { String name = entry . getKey ( ) ; FluentArg arg = match . parameterAnnotations . get ( name ) ; if ( arg != null && ( arg . reference ( ) || name . equals ( "ref" ) ) ) { Object value = entry . getValue ( ) ; if ( value instanceof String ) { entry . setValue ( new RuntimeBeanReference ( value . toString ( ) ) ) ; } } } Set < String > parameterNames = new HashSet < String > ( match . parameters . keySet ( ) ) ; parameterNames . removeAll ( attributeArguments . keySet ( ) ) ; for ( String key : parameterNames ) { ArrayList < Element > elements = elementArguments . get ( key ) ; if ( elements == null ) { elements = getFirstChildElements ( element ) ; } Class clazz = match . parameters . get ( key ) ; Object value = convertTo ( parserContext , elements , clazz ) ; attributeArguments . put ( key , value ) ; for ( Element el : elements ) { el . getParentNode ( ) . removeChild ( el ) ; } } actions . add ( new BuilderAction ( match , attributeArguments ) ) ; return match . method . getReturnType ( ) ; } private ArrayList < Element > getFirstChildElements ( Element element ) { ArrayList < Element > answer = new ArrayList < Element > ( ) ; NodeList list = element . getChildNodes ( ) ; for ( int i = 0 , size = list . getLength ( ) ; i < size ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { answer . add ( ( Element ) node ) ; break ; } } return answer ; } private Object convertTo ( ParserContext parserContext , ArrayList < Element > elements , Class clazz ) { if ( clazz . isArray ( ) || elements . size ( ) > 1 ) { List list = new ArrayList ( ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { ArrayList < Element > e = new ArrayList < Element > ( 1 ) ; e . add ( elements . get ( i ) ) ; Object value = convertTo ( parserContext , e , clazz . getComponentType ( ) ) ; list . add ( value ) ; } return list ; } else { Element element = elements . get ( 0 ) ; String ref = element . getAttribute ( "ref" ) ; if ( StringUtils . hasText ( ref ) ) { return new RuntimeBeanReference ( ref ) ; } if ( hasChildElements ( element ) ) { ArrayList < BuilderAction > actions = new ArrayList < BuilderAction > ( ) ; Class type = parseBuilderElement ( parserContext , element , RouteBuilder . class , actions ) ; if ( type == ValueBuilder . class && clazz == Expression . class ) { Method method ; try { method = ValueBuilder . class . getMethod ( "getExpression" , new Class [ ] { } ) ; } catch ( Throwable e ) { throw new RuntimeException ( ValueBuilder . class . getName ( ) + " does not have the getExpression() method." ) ; } MethodInfo methodInfo = new MethodInfo ( method , null , new LinkedHashMap < String , Class > ( ) , new LinkedHashMap < String , FluentArg > ( ) ) ; actions . add ( new BuilderAction ( methodInfo , new HashMap < String , Object > ( ) ) ) ; type = Expression . class ; } BuilderStatement statement = new BuilderStatement ( ) ; statement . setReturnType ( type ) ; statement . setActions ( actions ) ; if ( ! clazz . isAssignableFrom ( statement . getReturnType ( ) ) ) { throw new IllegalStateException ( "Builder does not produce object of expected type: " + clazz . getName ( ) + ", it produced: " + statement . getReturnType ( ) ) ; } return statement ; } else { String name = element . getLocalName ( ) ; if ( namespaceHandler . getParserElementNames ( ) . contains ( name ) ) { String id = createBeanId ( name ) ; element . setAttribute ( "id" , id ) ; namespaceHandler . parse ( element , parserContext ) ; return new RuntimeBeanReference ( id ) ; } SimpleTypeConverter converter = new SimpleTypeConverter ( ) ; return converter . convertIfNecessary ( element . getTextContent ( ) , clazz ) ; } } } protected synchronized String createBeanId ( String name ) { return "_internal:camel:bean:" + name + ( ++ counter ) ; } private MethodInfo findMethodMatch ( ArrayList < MethodInfo > methods , Set < String > attributeNames , Set < String > elementNames ) { for ( MethodInfo method : methods ) { boolean miss = false ; for ( String key : attributeNames ) { FluentArg arg = method . parameterAnnotations . get ( key ) ; if ( arg == null || ! arg . attribute ( ) ) { miss = true ; break ; } } if ( miss ) continue ; Set < String > parameterNames = new HashSet < String > ( method . parameters . keySet ( ) ) ; parameterNames . removeAll ( attributeNames ) ; if ( parameterNames . isEmpty ( ) ) { return method ; } return method ; } return null ; } private LinkedHashMap < String , ArrayList < Element > > getArgumentsFromElements ( Element element ) { LinkedHashMap < String , ArrayList < Element > > elements = new LinkedHashMap < String , ArrayList < Element > > ( ) ; NodeList childNodes = element . getChildNodes ( ) ; String lastTag = null ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { Element el = ( Element ) node ; String tag = el . getLocalName ( ) ; ArrayList < Element > els = elements . get ( tag ) ; if ( els == null ) { els = new ArrayList < Element > ( ) ; elements . put ( el . getLocalName ( ) , els ) ; els . add ( el ) ; lastTag = tag ; } else { if ( tag . equals ( lastTag ) ) { els . add ( el ) ; lastTag = tag ; } } } } return elements ; } private HashMap < String , Object > getArugmentsFromAttributes ( Element element ) { HashMap < String , Object > attributes = new HashMap < String , Object > ( ) ; NamedNodeMap childNodes = element . getAttributes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; if ( node . getNodeType ( ) == Node . ATTRIBUTE_NODE ) { Attr attr = ( Attr ) node ; String str = attr . getValue ( ) ; Object value = str ; if ( str . startsWith ( "#" ) ) { str = str . substring ( 1 ) ; if ( ! str . startsWith ( "#" ) ) { value = new RuntimeBeanReference ( str ) ; } } attributes . put ( attr . getName ( ) , value ) ; } } return attributes ; } private ArrayList < MethodInfo > findFluentMethodsWithName ( Class clazz , String name ) { ArrayList < MethodInfo > rc = new ArrayList < MethodInfo > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( ! method . isAnnotationPresent ( Fluent . class ) ) { continue ; } Fluent fluentAnnotation = method . getAnnotation ( Fluent . class ) ; if ( StringUtils . hasText ( fluentAnnotation . value ( ) ) ? name . equals ( fluentAnnotation . value ( ) ) : name . equals ( method . getName ( ) ) ) { LinkedHashMap < String , Class > map = new LinkedHashMap < String , Class > ( ) ; LinkedHashMap < String , FluentArg > amap = new LinkedHashMap < String , FluentArg > ( ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( int j = 0 ; j < parameters . length ; j ++ ) { Class < ? > parameter = parameters [ j ] ; FluentArg annotation = getParameterAnnotation ( FluentArg . class , method , j ) ; if ( annotation != null ) { map . put ( annotation . value ( ) , parameter ) ; amap . put ( annotation . value ( ) , annotation ) ; } else { break ; } } if ( parameters . length == map . size ( ) ) { rc . add ( new MethodInfo ( method , fluentAnnotation , map , amap ) ) ; } } } return rc ; } private < T > T getParameterAnnotation ( Class < T > annotationClass , Method method , int index ) { Annotation [ ] annotations = method . getParameterAnnotations ( ) [ index ] ; for ( int i = 0 ; i < annotations . length ; i ++ ) { if ( annotationClass . isAssignableFrom ( annotations [ i ] . getClass ( ) ) ) { return ( T ) annotations [ i ] ; } } return null ; } } 	0
package org . apache . camel ; import java . util . Map ; public interface Message { String getMessageId ( ) ; void setMessageId ( String messageId ) ; Exchange getExchange ( ) ; Object getHeader ( String name ) ; < T > T getHeader ( String name , Class < T > type ) ; void setHeader ( String name , Object value ) ; Map < String , Object > getHeaders ( ) ; void setHeaders ( Map < String , Object > headers ) ; public Object getBody ( ) ; public < T > T getBody ( Class < T > type ) ; public void setBody ( Object body ) ; public < T > void setBody ( Object body , Class < T > type ) ; Message copy ( ) ; } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class ConstantProcessorBuilder implements ProcessorFactory { private Processor processor ; public ConstantProcessorBuilder ( Processor processor ) { this . processor = processor ; } public Processor createProcessor ( ) { return processor ; } } 	0
package org . apache . camel . component . cxf ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . cxf . Bus ; import org . apache . cxf . BusException ; import org . apache . cxf . bus . CXFBusFactory ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . DestinationFactoryManager ; import org . apache . cxf . transport . local . LocalTransportFactory ; import org . xmlsoap . schemas . wsdl . http . AddressType ; public class CxfComponent extends DefaultComponent < CxfExchange > { private LocalTransportFactory localTransportFactory ; public CxfComponent ( ) { } public CxfComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < CxfExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI u = new URI ( remaining ) ; EndpointInfo endpointInfo = new EndpointInfo ( null , "http://schemas.xmlsoap.org/soap/http" ) ; AddressType a = new AddressType ( ) ; a . setLocation ( remaining ) ; endpointInfo . addExtensor ( a ) ; return new CxfEndpoint ( uri , this , endpointInfo ) ; } public LocalTransportFactory getLocalTransportFactory ( ) throws BusException { if ( localTransportFactory == null ) { localTransportFactory = findLocalTransportFactory ( ) ; if ( localTransportFactory == null ) { localTransportFactory = new LocalTransportFactory ( ) ; } } return localTransportFactory ; } public void setLocalTransportFactory ( LocalTransportFactory localTransportFactory ) { this . localTransportFactory = localTransportFactory ; } protected LocalTransportFactory findLocalTransportFactory ( ) throws BusException { Bus bus = CXFBusFactory . getDefaultBus ( ) ; DestinationFactoryManager dfm = bus . getExtension ( DestinationFactoryManager . class ) ; return ( LocalTransportFactory ) dfm . getDestinationFactory ( LocalTransportFactory . TRANSPORT_ID ) ; } } 	0
package org . apache . camel ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ProducerCache ; import java . util . HashMap ; import java . util . Map ; public class CamelTemplate < E extends Exchange > extends ServiceSupport { private CamelContext context ; private ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public CamelTemplate ( CamelContext context ) { this . context = context ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; send ( endpoint , exchange ) ; return exchange ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = endpoint . toExchangeType ( exchange ) ; producerCache . send ( endpoint , convertedExchange ) ; return exchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , final Object body ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body , final String header , final Object headerValue ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body , final Map < String , Object > headers ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected Object extractResultBody ( E result ) { return result != null ? result . getOut ( ) . getBody ( ) : null ; } } 	0
package org . apache . camel . component . mail ; import javax . mail . MessagingException ; public class MessageHeaderAccessException extends RuntimeMailException { private static final long serialVersionUID = - 3996286386119163309L ; private String propertyName ; public MessageHeaderAccessException ( String propertyName , MessagingException e ) { super ( "Error accessing header: " + propertyName , e ) ; this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . util . ServiceHelper ; import org . apache . camel . impl . ServiceSupport ; import java . util . ArrayList ; import java . util . List ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . getProcessor ( ) . process ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . RuntimeCamelException ; public class JbiException extends RuntimeCamelException { public JbiException ( Throwable cause ) { super ( cause ) ; } public JbiException ( String message ) { super ( message ) ; } public JbiException ( String message , Throwable cause ) { super ( message , cause ) ; } } 	0
package org . apache . camel . util ; import java . net . InetAddress ; import java . net . ServerSocket ; import java . util . logging . Level ; import java . util . logging . Logger ; public class UuidGenerator { private static final Logger log = Logger . getLogger ( UuidGenerator . class . getName ( ) ) ; private static final String UNIQUE_STUB ; private static int instanceCount ; private static String hostName ; private String seed ; private long sequence ; static { String stub = "" ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; ServerSocket ss = new ServerSocket ( 0 ) ; stub = "/" + ss . getLocalPort ( ) + "-" + System . currentTimeMillis ( ) + "/" ; Thread . sleep ( 100 ) ; ss . close ( ) ; } catch ( Exception ioe ) { log . log ( Level . WARNING , "could not generate unique stub" , ioe ) ; } } else { hostName = "localhost" ; stub = "-1-" + System . currentTimeMillis ( ) + "-" ; } UNIQUE_STUB = stub ; } public static String getHostName ( ) { return hostName ; } public UuidGenerator ( String prefix ) { synchronized ( UNIQUE_STUB ) { this . seed = prefix + UNIQUE_STUB + ( instanceCount ++ ) + "-" ; } } public UuidGenerator ( ) { this ( "ID-" + hostName ) ; } public synchronized String generateId ( ) { return this . seed + ( this . sequence ++ ) ; } public String generateSanitizedId ( ) { String result = generateId ( ) ; result = result . replace ( ':' , '-' ) ; result = result . replace ( '_' , '-' ) ; result = result . replace ( '.' , '-' ) ; return result ; } } 	0
package org . apache . camel . component . jms ; import javax . jms . Message ; import org . apache . camel . Processor ; import org . apache . camel . PollingConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; public class JmsEndpoint extends DefaultEndpoint < JmsExchange > { private JmsBinding binding ; private String destination ; private final boolean pubSubDomain ; private String selector ; private JmsConfiguration configuration ; public JmsEndpoint ( String uri , JmsComponent component , String destination , boolean pubSubDomain , JmsConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; this . destination = destination ; this . pubSubDomain = pubSubDomain ; } public JmsProducer createProducer ( ) throws Exception { JmsOperations template = createJmsOperations ( ) ; return createProducer ( template ) ; } public JmsProducer createProducer ( JmsOperations template ) throws Exception { if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setPubSubDomain ( pubSubDomain ) ; jmsTemplate . setDefaultDestinationName ( destination ) ; } return new JmsProducer ( this , template ) ; } public JmsConsumer createConsumer ( Processor processor ) throws Exception { AbstractMessageListenerContainer listenerContainer = configuration . createMessageListenerContainer ( ) ; return createConsumer ( processor , listenerContainer ) ; } public JmsConsumer createConsumer ( Processor processor , AbstractMessageListenerContainer listenerContainer ) throws Exception { listenerContainer . setDestinationName ( destination ) ; listenerContainer . setPubSubDomain ( pubSubDomain ) ; if ( selector != null ) { listenerContainer . setMessageSelector ( selector ) ; } return new JmsConsumer ( this , processor , listenerContainer ) ; } @ Override public PollingConsumer < JmsExchange > createPollingConsumer ( ) throws Exception { JmsOperations template = createJmsOperations ( ) ; return new JmsPollingConsumer ( this , template ) ; } public JmsExchange createExchange ( ) { return new JmsExchange ( getContext ( ) , getBinding ( ) ) ; } public JmsExchange createExchange ( Message message ) { return new JmsExchange ( getContext ( ) , getBinding ( ) , message ) ; } public JmsBinding getBinding ( ) { if ( binding == null ) { binding = new JmsBinding ( ) ; } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public String getDestination ( ) { return destination ; } public JmsConfiguration getConfiguration ( ) { return configuration ; } public String getSelector ( ) { return selector ; } public void setSelector ( String selector ) { this . selector = selector ; } public boolean isSingleton ( ) { return false ; } protected JmsOperations createJmsOperations ( ) { return configuration . createJmsOperations ( pubSubDomain , destination ) ; } } 	0
package org . apache . camel . bam . model ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import java . util . List ; @ Entity public class ProcessDefinition extends EntitySupport { private static final transient Log log = LogFactory . getLog ( ProcessDefinition . class ) ; private String name ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public static ProcessDefinition getRefreshedProcessDefinition ( JpaTemplate template , ProcessDefinition definition ) { ObjectHelper . notNull ( definition , "definition" ) ; Long id = definition . getId ( ) ; if ( id == null ) { log . warn ( "No primary key is available!" ) ; return findOrCreateProcessDefinition ( template , definition . getName ( ) ) ; } definition = template . find ( ProcessDefinition . class , id ) ; return definition ; } public static ProcessDefinition findOrCreateProcessDefinition ( JpaTemplate template , String processName ) { List < ProcessDefinition > list = template . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; template . persist ( answer ) ; return answer ; } } } 	0
package org . apache . camel . impl ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingExceptionHandler implements ExceptionHandler { private final Logger logger ; public LoggingExceptionHandler ( Class ownerType ) { this ( new Logger ( LogFactory . getLog ( ownerType ) , LoggingLevel . ERROR ) ) ; } public LoggingExceptionHandler ( Logger logger ) { this . logger = logger ; } public void handleException ( Throwable exception ) { logger . log ( exception . getMessage ( ) , exception ) ; } } 	0
package org . apache . camel ; public interface Consumer < E extends Exchange > extends Service { } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . RecipientList ; public class RecipientListBuilder < E extends Exchange > extends BuilderSupport implements ProcessorFactory { private final Expression expression ; public RecipientListBuilder ( FromBuilder parent , Expression expression ) { super ( parent ) ; this . expression = expression ; } public Processor createProcessor ( ) { return new RecipientList ( expression ) ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . impl . PollingConsumerSupport ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; import javax . jms . Message ; public class JmsPollingConsumer extends PollingConsumerSupport < JmsExchange > { private JmsOperations template ; public JmsPollingConsumer ( JmsEndpoint endpoint , JmsOperations template ) { super ( endpoint ) ; this . template = template ; } @ Override public JmsEndpoint getEndpoint ( ) { return ( JmsEndpoint ) super . getEndpoint ( ) ; } public JmsExchange receiveNoWait ( ) { return receive ( 0 ) ; } public JmsExchange receive ( ) { return receive ( - 1 ) ; } public JmsExchange receive ( long timeout ) { setReceiveTimeout ( timeout ) ; Message message = template . receive ( ) ; if ( message != null ) { return getEndpoint ( ) . createExchange ( message ) ; } return null ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } protected void setReceiveTimeout ( long timeout ) { if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setReceiveTimeout ( timeout ) ; } else if ( template instanceof JmsTemplate102 ) { JmsTemplate102 jmsTemplate102 = ( JmsTemplate102 ) template ; jmsTemplate102 . setReceiveTimeout ( timeout ) ; } else { throw new IllegalArgumentException ( "Cannot set the receiveTimeout property on unknown JmsOperations type: " + template ) ; } } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . RuntimeExpressionException ; import javax . xml . xpath . XPathException ; public class InvalidXPathExpression extends RuntimeExpressionException { private final String xpath ; public InvalidXPathExpression ( String xpath , XPathException e ) { super ( "Invalid xpath: " + xpath + ". Reason: " + e , e ) ; this . xpath = xpath ; } public String getXpath ( ) { return xpath ; } } 	0
package org . apache . camel . component . xmpp ; import org . apache . camel . impl . DefaultMessage ; import org . jivesoftware . smack . packet . Message ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class XmppMessage extends DefaultMessage { private Message xmppMessage ; public XmppMessage ( ) { this ( new Message ( ) ) ; } public XmppMessage ( Message jmsMessage ) { this . xmppMessage = jmsMessage ; } @ Override public String toString ( ) { if ( xmppMessage != null ) { return "XmppMessage: " + xmppMessage ; } else { return "XmppMessage: " + getBody ( ) ; } } @ Override public XmppExchange getExchange ( ) { return ( XmppExchange ) super . getExchange ( ) ; } public Message getXmppMessage ( ) { return xmppMessage ; } public void setXmppMessage ( Message xmppMessage ) { this . xmppMessage = xmppMessage ; } public Object getHeader ( String name ) { return xmppMessage . getProperty ( name ) ; } @ Override public void setHeader ( String name , Object value ) { if ( value == null ) { xmppMessage . deleteProperty ( name ) ; } else { xmppMessage . setProperty ( name , value ) ; } } @ Override public Map < String , Object > getHeaders ( ) { Map < String , Object > answer = new HashMap < String , Object > ( ) ; Iterator iter = xmppMessage . getPropertyNames ( ) ; while ( iter . hasNext ( ) ) { String name = ( String ) iter . next ( ) ; answer . put ( name , xmppMessage . getProperty ( name ) ) ; } return answer ; } @ Override public XmppMessage newInstance ( ) { return new XmppMessage ( ) ; } @ Override protected Object createBody ( ) { if ( xmppMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromXmpp ( getExchange ( ) , xmppMessage ) ; } return null ; } } 	0
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface Converter { } 	0
package org . apache . camel . impl ; import org . apache . camel . Message ; import java . util . HashMap ; import java . util . Map ; public class DefaultMessage extends MessageSupport { private Map < String , Object > headers ; @ Override public String toString ( ) { return "Message: " + getBody ( ) ; } public Object getHeader ( String name ) { return getHeaders ( ) . get ( name ) ; } public < T > T getHeader ( String name , Class < T > type ) { Object value = getHeader ( name ) ; return getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setHeader ( String name , Object value ) { if ( headers == null ) { headers = createHeaders ( ) ; } headers . put ( name , value ) ; } public Map < String , Object > getHeaders ( ) { if ( headers == null ) { headers = createHeaders ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public DefaultMessage newInstance ( ) { return new DefaultMessage ( ) ; } protected Map < String , Object > createHeaders ( ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; populateInitialHeaders ( map ) ; return map ; } protected void populateInitialHeaders ( Map < String , Object > map ) { } } 	0
package org . apache . camel . bam . model ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . OneToMany ; import java . util . Collection ; import java . util . Date ; import java . util . HashSet ; @ Entity public class ProcessInstance extends TemporalEntity { private static final transient Log log = LogFactory . getLog ( ProcessInstance . class ) ; private ProcessDefinition processDefinition ; private Collection < ActivityState > activityStates = new HashSet < ActivityState > ( ) ; private String correlationKey ; public ProcessInstance ( ) { setTimeStarted ( new Date ( ) ) ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[id: " + getId ( ) + ", key: " + getCorrelationKey ( ) + "]" ; } @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } @ OneToMany ( mappedBy = "processInstance" , fetch = FetchType . LAZY , cascade = { CascadeType . ALL } ) public Collection < ActivityState > getActivityStates ( ) { return activityStates ; } public void setActivityStates ( Collection < ActivityState > activityStates ) { this . activityStates = activityStates ; } public String getCorrelationKey ( ) { return correlationKey ; } public void setCorrelationKey ( String correlationKey ) { this . correlationKey = correlationKey ; } public ActivityState getActivityState ( ActivityRules activityRules ) { for ( ActivityState activityState : getActivityStates ( ) ) { if ( activityState . isActivity ( activityRules ) ) { return activityState ; } } return null ; } public ActivityState getOrCreateActivityState ( ActivityRules activityRules ) { ActivityState state = getActivityState ( activityRules ) ; if ( state == null ) { state = createActivityState ( ) ; state . setProcessInstance ( this ) ; state . setActivityDefinition ( activityRules . getActivityDefinition ( ) ) ; } return state ; } protected ActivityState createActivityState ( ) { return new ActivityState ( ) ; } } 	0
package org . apache . camel . component . file ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import java . io . File ; import java . util . Map ; public class FileComponent extends DefaultComponent < FileExchange > { public FileComponent ( ) { } public FileComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < FileExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { File file = new File ( remaining ) ; FileEndpoint result = new FileEndpoint ( file , remaining , this ) ; IntrospectionSupport . setProperties ( result , parameters ) ; return result ; } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . impl . DefaultMessage ; import org . apache . camel . util . CollectionHelper ; import javax . mail . Header ; import javax . mail . Message ; import javax . mail . MessagingException ; import java . util . Enumeration ; import java . util . Map ; public class MailMessage extends DefaultMessage { private Message mailMessage ; public MailMessage ( ) { } public MailMessage ( Message message ) { this . mailMessage = message ; } @ Override public String toString ( ) { if ( mailMessage != null ) { return "MailMessage: " + mailMessage ; } else { return "MailMessage: " + getBody ( ) ; } } @ Override public MailExchange getExchange ( ) { return ( MailExchange ) super . getExchange ( ) ; } public Message getMessage ( ) { return mailMessage ; } public void setMessage ( Message mailMessage ) { this . mailMessage = mailMessage ; } public Object getHeader ( String name ) { String [ ] answer = null ; if ( mailMessage != null ) { try { answer = mailMessage . getHeader ( name ) ; } catch ( MessagingException e ) { throw new MessageHeaderAccessException ( name , e ) ; } } if ( answer == null ) { return super . getHeader ( name ) ; } if ( answer . length == 1 ) { return answer [ 0 ] ; } return answer ; } @ Override public MailMessage newInstance ( ) { return new MailMessage ( ) ; } @ Override protected Object createBody ( ) { if ( mailMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromMail ( getExchange ( ) , mailMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( mailMessage != null ) { Enumeration names ; try { names = mailMessage . getAllHeaders ( ) ; } catch ( MessagingException e ) { throw new MessageHeaderNamesAccessException ( e ) ; } try { while ( names . hasMoreElements ( ) ) { Header header = ( Header ) names . nextElement ( ) ; String value = header . getValue ( ) ; String name = header . getName ( ) ; CollectionHelper . appendValue ( map , name , value ) ; } } catch ( Throwable e ) { throw new MessageHeaderNamesAccessException ( e ) ; } } } } 	0
package org . apache . camel . component . pojo ; import java . lang . reflect . Method ; public class PojoInvocation { private final Object proxy ; private final Method method ; private final Object [ ] args ; public PojoInvocation ( Object proxy , Method method , Object [ ] args ) { this . proxy = proxy ; this . method = method ; this . args = args ; } public Object [ ] getArgs ( ) { return args ; } public Method getMethod ( ) { return method ; } public Object getProxy ( ) { return proxy ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . PollingConsumer ; import org . apache . camel . processor . Logger ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; public class DefaultPollingConsumer < E extends Exchange > extends PollingConsumerSupport < E > implements Processor { private static final transient Log log = LogFactory . getLog ( DefaultPollingConsumer . class ) ; private BlockingQueue < E > queue ; private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler ( new Logger ( log ) ) ; private Consumer < E > consumer ; public DefaultPollingConsumer ( Endpoint < E > endpoint ) { this ( endpoint , new ArrayBlockingQueue < E > ( 1000 ) ) ; } public DefaultPollingConsumer ( Endpoint < E > endpoint , BlockingQueue < E > queue ) { super ( endpoint ) ; this . queue = queue ; } public E receiveNoWait ( ) { return receive ( 0 ) ; } public E receive ( ) { while ( ! isStopping ( ) && ! isStopped ( ) ) { try { return queue . take ( ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; } } return null ; } public E receive ( long timeout ) { try { return queue . poll ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; return null ; } } public void process ( Exchange exchange ) throws Exception { queue . offer ( ( E ) exchange ) ; } public ExceptionHandler getInteruptedExceptionHandler ( ) { return interuptedExceptionHandler ; } public void setInteruptedExceptionHandler ( ExceptionHandler interuptedExceptionHandler ) { this . interuptedExceptionHandler = interuptedExceptionHandler ; } protected void handleInteruptedException ( InterruptedException e ) { getInteruptedExceptionHandler ( ) . handleException ( e ) ; } protected void doStart ( ) throws Exception { consumer = getEndpoint ( ) . createConsumer ( this ) ; consumer . start ( ) ; } protected void doStop ( ) throws Exception { if ( consumer != null ) { try { consumer . stop ( ) ; } finally { consumer = null ; } } } } 	0
package org . apache . camel . impl ; import org . apache . camel . impl . converter . TypeConverterRegistry ; public class CachingInjector < T > { private final TypeConverterRegistry repository ; private final Class < T > type ; private T instance ; public CachingInjector ( TypeConverterRegistry repository , Class < T > type ) { this . repository = repository ; this . type = type ; } public synchronized T newInstance ( ) { if ( instance == null ) { instance = createInstance ( type ) ; } return instance ; } protected T createInstance ( Class < T > type ) { return ( T ) repository . getInjector ( ) . newInstance ( type ) ; } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import javax . mail . Message ; public class MailExchange extends DefaultExchange { private MailBinding binding ; public MailExchange ( CamelContext context , MailBinding binding ) { super ( context ) ; this . binding = binding ; } public MailExchange ( CamelContext context , MailBinding binding , Message message ) { this ( context , binding ) ; setIn ( new MailMessage ( message ) ) ; } @ Override public MailMessage getIn ( ) { return ( MailMessage ) super . getIn ( ) ; } @ Override public MailMessage getOut ( ) { return ( MailMessage ) super . getOut ( ) ; } @ Override public MailMessage getOut ( boolean lazyCreate ) { return ( MailMessage ) super . getOut ( lazyCreate ) ; } @ Override public MailMessage getFault ( ) { return ( MailMessage ) super . getFault ( ) ; } public MailBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new MailExchange ( getContext ( ) , binding ) ; } @ Override protected MailMessage createInMessage ( ) { return new MailMessage ( ) ; } @ Override protected MailMessage createOutMessage ( ) { return new MailMessage ( ) ; } } 	0
package org . apache . camel . bam . model ; import javax . persistence . Transient ; import java . util . Date ; public abstract class TemporalEntity extends EntitySupport { private Date timeStarted ; private Date timeCompleted ; @ Transient public boolean isStarted ( ) { return timeStarted != null ; } @ Transient public boolean isCompleted ( ) { return timeCompleted != null ; } public Date getTimeStarted ( ) { return timeStarted ; } public void setTimeStarted ( Date timeStarted ) { this . timeStarted = timeStarted ; } public Date getTimeCompleted ( ) { return timeCompleted ; } public void setTimeCompleted ( Date timeCompleted ) { this . timeCompleted = timeCompleted ; } } 	0
package org . apache . camel ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public abstract class Route < E extends Exchange > { private final Map < String , Object > properties = new HashMap < String , Object > ( 16 ) ; private Endpoint < E > endpoint ; private List < Service > services = new ArrayList < Service > ( ) ; public Route ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Map < String , Object > getProperties ( ) { return properties ; } public List < Service > getServicesForRoute ( ) throws Exception { List < Service > servicesForRoute = new ArrayList < Service > ( getServices ( ) ) ; addServices ( servicesForRoute ) ; return servicesForRoute ; } public List < Service > getServices ( ) throws Exception { return services ; } public void setServices ( List < Service > services ) { this . services = services ; } protected abstract void addServices ( List < Service > services ) throws Exception ; } 	0
package org . apache . camel . spi ; import org . apache . camel . Processor ; public interface Policy < E > { Processor wrap ( Processor processor ) ; } 	0
package org . apache . camel . util ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionHelper { public static < E extends Exchange > String evaluateAsString ( Expression < E > expression , E exchange ) { return evaluateAsType ( expression , exchange , String . class ) ; } public static < T , E extends Exchange > T evaluateAsType ( Expression < E > expression , E exchange , Class < T > resultType ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( resultType , value ) ; } } 	0
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface MessageDriven { String uri ( ) default "" ; String name ( ) default "" ; } 	0
package org . apache . camel . bam . processor ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; public class NoCorrelationKeyException extends CamelException { private BamProcessorSupport processor ; private Exchange exchange ; public NoCorrelationKeyException ( BamProcessorSupport processor , Exchange exchange ) { super ( "No correlation key could be found for " + processor . getCorrelationKeyExpression ( ) + " on " + exchange ) ; this . processor = processor ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } public BamProcessorSupport getProcessor ( ) { return processor ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . Splitter ; public class SplitterBuilder extends FromBuilder { private final Expression expression ; public SplitterBuilder ( FromBuilder parent , Expression expression ) { super ( parent ) ; this . expression = expression ; } public Processor createProcessor ( ) throws Exception { Processor destination = super . createProcessor ( ) ; return new Splitter ( destination , expression ) ; } } 	0
package org . apache . camel . spring . xml ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . BeanFactory ; import java . util . ArrayList ; public class StatementRouteBuilder extends RouteBuilder { private ArrayList < BuilderStatement > routes ; private BeanFactory beanFactory ; @ Override public void configure ( ) { for ( BuilderStatement routeFactory : routes ) { routeFactory . create ( beanFactory , this ) ; } } public ArrayList < BuilderStatement > getRoutes ( ) { return routes ; } public void setRoutes ( ArrayList < BuilderStatement > routes ) { this . routes = routes ; } public void setBeanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . cxf . endpoint . ServerImpl ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . message . Message ; public class CxfInvokeConsumer extends DefaultConsumer < CxfExchange > { protected CxfInvokeEndpoint cxfEndpoint ; private ServerImpl server ; public CxfInvokeConsumer ( CxfInvokeEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . cxfEndpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( server != null ) { ServerFactoryBean svrBean = new ServerFactoryBean ( ) ; svrBean . setAddress ( getEndpoint ( ) . getEndpointUri ( ) ) ; svrBean . setServiceClass ( Class . forName ( cxfEndpoint . getProperty ( CxfConstants . IMPL ) ) ) ; svrBean . setBus ( cxfEndpoint . getBus ( ) ) ; server = ( ServerImpl ) svrBean . create ( ) ; server . start ( ) ; } } @ Override protected void doStop ( ) throws Exception { if ( server != null ) { server . stop ( ) ; server = null ; } super . doStop ( ) ; } protected void incomingCxfMessage ( Message message ) { try { CxfExchange exchange = cxfEndpoint . createExchange ( message ) ; getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	0
package org . apache . camel . spring . util ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . Expression ; import org . apache . camel . Exchange ; import org . apache . camel . Endpoint ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Message ; import org . apache . camel . builder . ExpressionBuilder ; public class DefaultMethodInvocationStrategy implements MethodInvocationStrategy { private Map < Class , Expression > parameterTypeToExpressionMap = new ConcurrentHashMap < Class , Expression > ( ) ; public DefaultMethodInvocationStrategy ( ) { } public synchronized Expression getDefaultParameterTypeExpression ( Class parameterType ) { return parameterTypeToExpressionMap . get ( parameterType ) ; } public synchronized void addParameterMapping ( Class parameterType , Expression expression ) { parameterTypeToExpressionMap . put ( parameterType , expression ) ; } public void loadDefaultRegistry ( ) { addParameterMapping ( Exchange . class , ExpressionBuilder . exchangeExpression ( ) ) ; addParameterMapping ( Message . class , ExpressionBuilder . inMessageExpression ( ) ) ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . cxf . BusException ; import org . apache . cxf . message . Message ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . local . LocalTransportFactory ; public class CxfEndpoint extends DefaultEndpoint < CxfExchange > { private CxfBinding binding ; private final CxfComponent component ; private final EndpointInfo endpointInfo ; private boolean inOut = true ; public CxfEndpoint ( String uri , CxfComponent component , EndpointInfo endpointInfo ) { super ( uri , component ) ; this . component = component ; this . endpointInfo = endpointInfo ; } public Producer < CxfExchange > createProducer ( ) throws Exception { return new CxfProducer ( this , getLocalTransportFactory ( ) ) ; } public Consumer < CxfExchange > createConsumer ( Processor processor ) throws Exception { return new CxfConsumer ( this , processor , getLocalTransportFactory ( ) ) ; } public CxfExchange createExchange ( ) { return new CxfExchange ( getContext ( ) , getBinding ( ) ) ; } public CxfExchange createExchange ( Message inMessage ) { return new CxfExchange ( getContext ( ) , getBinding ( ) , inMessage ) ; } public CxfBinding getBinding ( ) { if ( binding == null ) { binding = new CxfBinding ( ) ; } return binding ; } public void setBinding ( CxfBinding binding ) { this . binding = binding ; } public boolean isInOut ( ) { return inOut ; } public void setInOut ( boolean inOut ) { this . inOut = inOut ; } public LocalTransportFactory getLocalTransportFactory ( ) throws BusException { return component . getLocalTransportFactory ( ) ; } public EndpointInfo getEndpointInfo ( ) { return endpointInfo ; } public CxfComponent getComponent ( ) { return component ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . Iterator ; public class StickyLoadBalancer extends QueueLoadBalancer { private Expression < Exchange > correlationExpression ; private QueueLoadBalancer loadBalancer ; private int numberOfHashGroups = 64 * 1024 ; private Map < Object , Processor > stickyMap = new HashMap < Object , Processor > ( ) ; public StickyLoadBalancer ( Expression < Exchange > correlationExpression ) { this ( correlationExpression , new RoundRobinLoadBalancer ( ) ) ; } public StickyLoadBalancer ( Expression < Exchange > correlationExpression , QueueLoadBalancer loadBalancer ) { this . correlationExpression = correlationExpression ; this . loadBalancer = loadBalancer ; } protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { Object value = correlationExpression . evaluate ( exchange ) ; Object key = getStickyKey ( value ) ; Processor processor ; synchronized ( stickyMap ) { processor = stickyMap . get ( key ) ; if ( processor == null ) { processor = loadBalancer . chooseProcessor ( processors , exchange ) ; stickyMap . put ( key , processor ) ; } } return processor ; } @ Override public void removeProcessor ( Processor processor ) { synchronized ( stickyMap ) { Iterator < Map . Entry < Object , Processor > > iter = stickyMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Object , Processor > entry = iter . next ( ) ; if ( processor . equals ( entry . getValue ( ) ) ) { iter . remove ( ) ; } } } super . removeProcessor ( processor ) ; } public int getNumberOfHashGroups ( ) { return numberOfHashGroups ; } public void setNumberOfHashGroups ( int numberOfHashGroups ) { this . numberOfHashGroups = numberOfHashGroups ; } protected Object getStickyKey ( Object value ) { int hashCode = 37 ; if ( value != null ) { hashCode = value . hashCode ( ) ; } if ( numberOfHashGroups > 0 ) { hashCode = hashCode % numberOfHashGroups ; } return hashCode ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Expression ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; public class IdempotentConsumerBuilder extends FromBuilder implements ProcessorFactory { private final Expression messageIdExpression ; private final MessageIdRepository messageIdRegistry ; public IdempotentConsumerBuilder ( FromBuilder fromBuilder , Expression messageIdExpression , MessageIdRepository messageIdRegistry ) { super ( fromBuilder ) ; this . messageIdRegistry = messageIdRegistry ; this . messageIdExpression = messageIdExpression ; } public MessageIdRepository getMessageIdRegistry ( ) { return messageIdRegistry ; } @ Override protected Processor wrapInErrorHandler ( Processor processor ) throws Exception { return processor ; } @ Override protected Processor wrapProcessor ( Processor processor ) { return new IdempotentConsumer ( messageIdExpression , messageIdRegistry , processor ) ; } } 	0
package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . JobDetail ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . SchedulerFactory ; import org . quartz . Trigger ; import org . quartz . CronTrigger ; import org . quartz . impl . StdSchedulerFactory ; import java . util . Map ; import java . net . URI ; import com . sun . jndi . toolkit . url . Uri ; public class QuartzComponent extends DefaultComponent < QuartzExchange > { private static final transient Log log = LogFactory . getLog ( QuartzComponent . class ) ; private SchedulerFactory factory ; private Scheduler scheduler ; private Map < Trigger , JobDetail > triggers ; public QuartzComponent ( ) { } public QuartzComponent ( CamelContext context ) { super ( context ) ; } @ Override protected QuartzEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { QuartzEndpoint answer = new QuartzEndpoint ( uri , this , getScheduler ( ) ) ; URI u = new URI ( uri ) ; String name ; String group = "Camel" ; String path = u . getPath ( ) ; CronTrigger cronTrigger = null ; if ( path != null && path . length ( ) > 1 ) { if ( path . startsWith ( "/" ) ) { path = path . substring ( 1 ) ; } int idx = path . indexOf ( '/' ) ; if ( idx > 0 ) { cronTrigger = new CronTrigger ( ) ; name = path . substring ( 0 , idx ) ; String cronExpression = path . substring ( idx + 1 ) ; cronExpression = cronExpression . replace ( '/' , ' ' ) ; cronExpression = cronExpression . replace ( '$' , '?' ) ; log . debug ( "Creating cron trigger: " + cronExpression ) ; cronTrigger . setCronExpression ( cronExpression ) ; answer . setTrigger ( cronTrigger ) ; } else { name = path ; } group = u . getHost ( ) ; } else { name = u . getHost ( ) ; } Trigger trigger = cronTrigger ; if ( trigger == null ) { trigger = answer . getTrigger ( ) ; } trigger . setName ( name ) ; trigger . setGroup ( group ) ; Map triggerParameters = IntrospectionSupport . extractProperties ( parameters , "trigger." ) ; Map jobParameters = IntrospectionSupport . extractProperties ( parameters , "job." ) ; IntrospectionSupport . setProperties ( trigger , triggerParameters ) ; IntrospectionSupport . setProperties ( answer . getJobDetail ( ) , jobParameters ) ; return answer ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getScheduler ( ) . start ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( scheduler != null ) { scheduler . shutdown ( ) ; } super . doStop ( ) ; } public SchedulerFactory getFactory ( ) { if ( factory == null ) { factory = createSchedulerFactory ( ) ; } return factory ; } public void setFactory ( SchedulerFactory factory ) { this . factory = factory ; } public Scheduler getScheduler ( ) throws SchedulerException { if ( scheduler == null ) { scheduler = createScheduler ( ) ; } return scheduler ; } public void setScheduler ( Scheduler scheduler ) { this . scheduler = scheduler ; } public Map getTriggers ( ) { return triggers ; } public void setTriggers ( Map triggers ) { this . triggers = triggers ; } protected SchedulerFactory createSchedulerFactory ( ) { return new StdSchedulerFactory ( ) ; } protected Scheduler createScheduler ( ) throws SchedulerException { return getFactory ( ) . getScheduler ( ) ; } } 	0
package org . apache . camel . impl . converter ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import org . apache . camel . TypeConverter ; public class PropertyEditorTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value == null ) return null ; if ( value . getClass ( ) == String . class ) { if ( toType == String . class ) { return toType . cast ( value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( toType ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return toType . cast ( editor . getValue ( ) ) ; } } else if ( toType == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( value . getClass ( ) ) ; if ( editor != null ) { editor . setValue ( value ) ; return toType . cast ( editor . getAsText ( ) ) ; } } return null ; } } 	0
package org . apache . camel . spi ; import java . io . IOException ; import java . io . OutputStream ; public interface Marshaller { void marshal ( Object graph , OutputStream stream ) throws IOException ; } 	0
package org . apache . camel . component . jms ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import static org . apache . camel . util . ObjectHelper . removeStartingCharacters ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . transaction . PlatformTransactionManager ; import javax . jms . ConnectionFactory ; import javax . jms . ExceptionListener ; import javax . jms . Session ; import java . util . Map ; public class JmsComponent extends DefaultComponent < JmsExchange > { public static final String QUEUE_PREFIX = "queue:" ; public static final String TOPIC_PREFIX = "topic:" ; private JmsConfiguration configuration ; public static JmsComponent jmsComponent ( ) { return new JmsComponent ( ) ; } public static JmsComponent jmsComponent ( JmsConfiguration configuration ) { return new JmsComponent ( configuration ) ; } public static JmsComponent jmsComponent ( ConnectionFactory connectionFactory ) { return jmsComponent ( new JmsConfiguration ( connectionFactory ) ) ; } public static JmsComponent jmsComponentClientAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . CLIENT_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentAutoAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . AUTO_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setTransacted ( true ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory , PlatformTransactionManager transactionManager ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setTransactionManager ( transactionManager ) ; template . setTransacted ( true ) ; return jmsComponent ( template ) ; } public JmsComponent ( ) { } public JmsComponent ( JmsConfiguration configuration ) { this . configuration = configuration ; } public JmsComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < JmsExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { boolean pubSubDomain = false ; if ( remaining . startsWith ( QUEUE_PREFIX ) ) { pubSubDomain = false ; remaining = removeStartingCharacters ( remaining . substring ( QUEUE_PREFIX . length ( ) ) , '/' ) ; } else if ( remaining . startsWith ( TOPIC_PREFIX ) ) { pubSubDomain = true ; remaining = removeStartingCharacters ( remaining . substring ( TOPIC_PREFIX . length ( ) ) , '/' ) ; } final String subject = convertPathToActualDestination ( remaining ) ; JmsEndpoint endpoint = new JmsEndpoint ( uri , this , subject , pubSubDomain , getConfiguration ( ) . copy ( ) ) ; String selector = ( String ) parameters . remove ( "selector" ) ; if ( selector != null ) { endpoint . setSelector ( selector ) ; } IntrospectionSupport . setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public JmsConfiguration getConfiguration ( ) { if ( configuration == null ) { configuration = createConfiguration ( ) ; } return configuration ; } public void setConfiguration ( JmsConfiguration configuration ) { this . configuration = configuration ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { getConfiguration ( ) . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementMode ( consumerAcknowledgementMode ) ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementModeName ( consumerAcknowledgementMode ) ; } public void setAutoStartup ( boolean autoStartup ) { getConfiguration ( ) . setAutoStartup ( autoStartup ) ; } public void setCacheLevel ( int cacheLevel ) { getConfiguration ( ) . setCacheLevel ( cacheLevel ) ; } public void setCacheLevelName ( String cacheName ) { getConfiguration ( ) . setCacheLevelName ( cacheName ) ; } public void setClientId ( String consumerClientId ) { getConfiguration ( ) . setClientId ( consumerClientId ) ; } public void setConcurrentConsumers ( int concurrentConsumers ) { getConfiguration ( ) . setConcurrentConsumers ( concurrentConsumers ) ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { getConfiguration ( ) . setConnectionFactory ( connectionFactory ) ; } public void setConsumerType ( ConsumerType consumerType ) { getConfiguration ( ) . setConsumerType ( consumerType ) ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { getConfiguration ( ) . setDeliveryPersistent ( deliveryPersistent ) ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { getConfiguration ( ) . setDurableSubscriptionName ( durableSubscriptionName ) ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { getConfiguration ( ) . setExceptionListener ( exceptionListener ) ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { getConfiguration ( ) . setExplicitQosEnabled ( explicitQosEnabled ) ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { getConfiguration ( ) . setExposeListenerSession ( exposeListenerSession ) ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { getConfiguration ( ) . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { getConfiguration ( ) . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { getConfiguration ( ) . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } public void setMessageConverter ( MessageConverter messageConverter ) { getConfiguration ( ) . setMessageConverter ( messageConverter ) ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { getConfiguration ( ) . setMessageIdEnabled ( messageIdEnabled ) ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { getConfiguration ( ) . setMessageTimestampEnabled ( messageTimestampEnabled ) ; } public void setPriority ( int priority ) { getConfiguration ( ) . setPriority ( priority ) ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { getConfiguration ( ) . setPubSubNoLocal ( pubSubNoLocal ) ; } public void setReceiveTimeout ( long receiveTimeout ) { getConfiguration ( ) . setReceiveTimeout ( receiveTimeout ) ; } public void setRecoveryInterval ( long recoveryInterval ) { getConfiguration ( ) . setRecoveryInterval ( recoveryInterval ) ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { getConfiguration ( ) . setServerSessionFactory ( serverSessionFactory ) ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { getConfiguration ( ) . setSubscriptionDurable ( subscriptionDurable ) ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { getConfiguration ( ) . setTaskExecutor ( taskExecutor ) ; } public void setTimeToLive ( long timeToLive ) { getConfiguration ( ) . setTimeToLive ( timeToLive ) ; } public void setTransacted ( boolean consumerTransacted ) { getConfiguration ( ) . setTransacted ( consumerTransacted ) ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { getConfiguration ( ) . setTransactionManager ( transactionManager ) ; } public void setTransactionName ( String transactionName ) { getConfiguration ( ) . setTransactionName ( transactionName ) ; } public void setTransactionTimeout ( int transactionTimeout ) { getConfiguration ( ) . setTransactionTimeout ( transactionTimeout ) ; } public void setUseVersion102 ( boolean useVersion102 ) { getConfiguration ( ) . setUseVersion102 ( useVersion102 ) ; } protected String convertPathToActualDestination ( String path ) { return path ; } protected JmsConfiguration createConfiguration ( ) { return new JmsConfiguration ( ) ; } } 	0
package org . apache . camel . spring . remoting ; import org . apache . camel . CamelContext ; import org . apache . camel . component . pojo . PojoComponent ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . remoting . support . RemoteExporter ; public class CamelServiceExporter extends RemoteExporter implements InitializingBean , DisposableBean { CamelContext camelContext ; PojoComponent pojoComponent ; String serviceName ; public void afterPropertiesSet ( ) throws Exception { if ( serviceName == null ) { throw new IllegalArgumentException ( "The serviceName must be configured." ) ; } if ( pojoComponent == null ) { if ( camelContext == null ) { throw new IllegalArgumentException ( "A pojoComponent or camelContext must be configured." ) ; } pojoComponent = ( PojoComponent ) camelContext . getComponent ( "pojo" ) ; if ( pojoComponent == null ) { throw new IllegalArgumentException ( "The pojoComponent could not be found." ) ; } } pojoComponent . addService ( serviceName , getProxyForService ( ) ) ; } public void destroy ( ) throws Exception { if ( serviceName != null ) { pojoComponent . removeService ( serviceName ) ; } } public PojoComponent getPojoComponent ( ) { return pojoComponent ; } public void setPojoComponent ( PojoComponent pojoComponent ) { this . pojoComponent = pojoComponent ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getServiceName ( ) { return serviceName ; } public void setServiceName ( String serviceName ) { this . serviceName = serviceName ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class DefaultConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > { private Endpoint < E > endpoint ; private Processor processor ; private ExceptionHandler exceptionHandler ; public DefaultConsumer ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "Consumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	0
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; public class FileProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( FileProducer . class ) ; private final FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) { process ( endpoint . toExchangeType ( exchange ) ) ; } public void process ( FileExchange exchange ) { String fileName = exchange . getIn ( ) . getMessageId ( ) ; ByteBuffer payload = exchange . getIn ( ) . getBody ( ByteBuffer . class ) ; payload . flip ( ) ; File file = null ; if ( endpoint . getFile ( ) != null && endpoint . getFile ( ) . isDirectory ( ) ) { file = new File ( endpoint . getFile ( ) , fileName ) ; } else { file = new File ( fileName ) ; } buildDirectory ( file ) ; try { FileChannel fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . position ( fc . size ( ) ) ; fc . write ( payload ) ; fc . close ( ) ; } catch ( Throwable e ) { log . error ( "Failed to write to File: " + file , e ) ; } } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	1
package org . apache . camel ; public class FailedToCreateProducerException extends RuntimeCamelException { private final Endpoint endpoint ; public FailedToCreateProducerException ( Endpoint endpoint , Throwable cause ) { super ( "Failed to create Producer for endpoint: " + endpoint + ". Reason: " + cause , cause ) ; this . endpoint = endpoint ; } public Endpoint getEndpoint ( ) { return endpoint ; } } 	0
package org . apache . camel . processor . idempotent ; import org . apache . camel . Expression ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; public class NoMessageIdException extends RuntimeCamelException { private final Exchange exchange ; private final Expression expression ; public NoMessageIdException ( Exchange exchange , Expression expression ) { super ( "No message ID could be found using expression: " + expression + " on message exchange: " + exchange ) ; this . exchange = exchange ; this . expression = expression ; } public Exchange getExchange ( ) { return exchange ; } public Expression getExpression ( ) { return expression ; } } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; public class ArrayTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isArray ( ) ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; Object array = Array . newInstance ( type . getComponentType ( ) , collection . size ( ) ) ; if ( array instanceof Object [ ] ) { collection . toArray ( ( Object [ ] ) array ) ; } else { int index = 0 ; for ( Object element : collection ) { Array . set ( array , index ++ , element ) ; } } return ( T ) array ; } else if ( value != null && value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; Object answer = Array . newInstance ( type . getComponentType ( ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( answer , i , Array . get ( value , i ) ) ; } return ( T ) answer ; } } else if ( Collection . class . isAssignableFrom ( type ) ) { if ( value != null ) { if ( value instanceof Object [ ] ) { return ( T ) Arrays . asList ( ( Object [ ] ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; List answer = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { answer . add ( Array . get ( value , i ) ) ; } return ( T ) answer ; } } } return null ; } } 	0
package org . apache . camel . component . direct ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ProducerCache ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DirectEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private static final Log log = LogFactory . getLog ( DirectEndpoint . class ) ; private final CopyOnWriteArrayList < DefaultConsumer < E > > consumers = new CopyOnWriteArrayList < DefaultConsumer < E > > ( ) ; boolean allowMultipleConsumers = true ; public DirectEndpoint ( String uri , DirectComponent < E > component ) { super ( uri , component ) ; } public Producer createProducer ( ) throws Exception { return new DefaultProducer ( this ) { public void process ( Exchange exchange ) throws Exception { DirectEndpoint . this . process ( exchange ) ; } } ; } protected void process ( Exchange exchange ) throws Exception { if ( consumers . isEmpty ( ) ) { log . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } } public Consumer < E > createConsumer ( Processor processor ) throws Exception { return new DefaultConsumer < E > ( this , processor ) { @ Override public void start ( ) throws Exception { if ( ! allowMultipleConsumers && ! consumers . isEmpty ( ) ) throw new IllegalStateException ( "Endpoint " + getEndpointUri ( ) + " only allows 1 active consumer but you attempted to start a 2nd consumer." ) ; consumers . add ( this ) ; super . start ( ) ; } @ Override public void stop ( ) throws Exception { super . stop ( ) ; consumers . remove ( this ) ; } } ; } public E createExchange ( ) { return ( E ) new DefaultExchange ( getContext ( ) ) ; } public boolean isAllowMultipleConsumers ( ) { return allowMultipleConsumers ; } public void setAllowMultipleConsumers ( boolean allowMutlipleConsumers ) { this . allowMultipleConsumers = allowMutlipleConsumers ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class FilterProcessor extends ServiceSupport implements Processor { private Predicate < Exchange > predicate ; private Processor processor ; public FilterProcessor ( Predicate < Exchange > predicate , Processor processor ) { this . predicate = predicate ; this . processor = processor ; } public void process ( Exchange exchange ) throws Exception { if ( predicate . matches ( exchange ) ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { return "filter (" + predicate + ") " + processor ; } public Predicate < Exchange > getPredicate ( ) { return predicate ; } public Processor getProcessor ( ) { return processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } } 	0
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . IntrospectionSupport ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; import java . util . List ; public class JpaBamProcessorSupport < T > extends BamProcessorSupport < T > { private ActivityRules activityRules ; private JpaTemplate template ; private String findByKeyQuery ; private String keyPropertyName = "correlationKey" ; public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < T > entitytype ) { super ( transactionTemplate , correlationKeyExpression , entitytype ) ; this . activityRules = activityRules ; this . template = template ; } public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , correlationKeyExpression ) ; this . activityRules = activityRules ; this . template = template ; } public String getFindByKeyQuery ( ) { if ( findByKeyQuery == null ) { findByKeyQuery = createFindByKeyQuery ( ) ; } return findByKeyQuery ; } public void setFindByKeyQuery ( String findByKeyQuery ) { this . findByKeyQuery = findByKeyQuery ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public void setActivityRules ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public String getKeyPropertyName ( ) { return keyPropertyName ; } public void setKeyPropertyName ( String keyPropertyName ) { this . keyPropertyName = keyPropertyName ; } public JpaTemplate getTemplate ( ) { return template ; } public void setTemplate ( JpaTemplate template ) { this . template = template ; } protected T loadEntity ( Exchange exchange , Object key ) { List < T > list = template . find ( getFindByKeyQuery ( ) , key ) ; T entity = null ; if ( ! list . isEmpty ( ) ) { entity = list . get ( 0 ) ; } if ( entity == null ) { entity = createEntity ( exchange , key ) ; setKeyProperty ( entity , key ) ; ProcessDefinition definition = ProcessDefinition . getRefreshedProcessDefinition ( template , getActivityRules ( ) . getProcessRules ( ) . getProcessDefinition ( ) ) ; setProcessDefinitionProperty ( entity , definition ) ; template . persist ( entity ) ; } return entity ; } protected void setKeyProperty ( T entity , Object key ) { IntrospectionSupport . setProperty ( entity , getKeyPropertyName ( ) , key ) ; } protected void setProcessDefinitionProperty ( T entity , ProcessDefinition processDefinition ) { IntrospectionSupport . setProperty ( entity , "processDefinition" , processDefinition ) ; } protected T createEntity ( Exchange exchange , Object key ) { return ( T ) exchange . getContext ( ) . getInjector ( ) . newInstance ( getEntityType ( ) ) ; } protected void processEntity ( Exchange exchange , T entity ) throws Exception { if ( entity instanceof Processor ) { Processor processor = ( Processor ) entity ; processor . process ( exchange ) ; } else { throw new IllegalArgumentException ( "No processor defined for this route" ) ; } } protected String createFindByKeyQuery ( ) { return "select x from " + getEntityType ( ) . getName ( ) + " x where x." + getKeyPropertyName ( ) + " = ?1" ; } } 	0
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . cxf . Bus ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractTransportFactory ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . DestinationFactory ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import javax . annotation . Resource ; import java . io . IOException ; import java . util . HashSet ; import java . util . Set ; public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator , DestinationFactory { private static final Set < String > URI_PREFIXES = new HashSet < String > ( ) ; static { URI_PREFIXES . add ( "camel://" ) ; } private Bus bus ; private CamelContext camelContext ; @ Resource public void setBus ( Bus b ) { bus = b ; } public Bus getBus ( ) { return bus ; } public CamelContext getCamelContext ( ) { return camelContext ; } @ Resource public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public Conduit getConduit ( EndpointInfo targetInfo ) throws IOException { return getConduit ( targetInfo , null ) ; } public Conduit getConduit ( EndpointInfo endpointInfo , EndpointReferenceType target ) throws IOException { return new CamelConduit ( camelContext , bus , endpointInfo , target ) ; } public Destination getDestination ( EndpointInfo endpointInfo ) throws IOException { CamelDestination destination = new CamelDestination ( camelContext , bus , this , endpointInfo ) ; Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( destination ) ; } return destination ; } public Set < String > getUriPrefixes ( ) { return URI_PREFIXES ; } } 	0
package org . apache . camel . spring ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . CamelContext ; import org . apache . camel . spring . spi . SpringComponentResolver ; import org . apache . camel . spring . spi . SpringInjector ; import org . apache . camel . spring . component . BeanComponent ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationContext ; import org . springframework . context . support . ClassPathXmlApplicationContext ; import org . springframework . context . support . AbstractRefreshableApplicationContext ; public class SpringCamelContext extends DefaultCamelContext implements InitializingBean , DisposableBean , ApplicationContextAware { private ApplicationContext applicationContext ; public SpringCamelContext ( ) { } public SpringCamelContext ( ApplicationContext applicationContext ) { setApplicationContext ( applicationContext ) ; } public static SpringCamelContext springCamelContext ( ApplicationContext applicationContext ) throws Exception { String [ ] names = applicationContext . getBeanNamesForType ( SpringCamelContext . class ) ; if ( names . length == 1 ) { return ( SpringCamelContext ) applicationContext . getBean ( names [ 0 ] , SpringCamelContext . class ) ; } SpringCamelContext answer = new SpringCamelContext ( ) ; answer . setApplicationContext ( applicationContext ) ; answer . afterPropertiesSet ( ) ; return answer ; } public static SpringCamelContext springCamelContext ( String configLocations ) throws Exception { return springCamelContext ( new ClassPathXmlApplicationContext ( configLocations ) ) ; } public void afterPropertiesSet ( ) throws Exception { getInjector ( ) ; start ( ) ; } public void destroy ( ) throws Exception { stop ( ) ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; addComponent ( "bean" , new BeanComponent ( applicationContext ) ) ; } @ Override protected Injector createInjector ( ) { return new SpringInjector ( ( AbstractRefreshableApplicationContext ) getApplicationContext ( ) ) ; } @ Override protected ComponentResolver createComponentResolver ( ) { ComponentResolver defaultResolver = super . createComponentResolver ( ) ; return new SpringComponentResolver ( getApplicationContext ( ) , defaultResolver ) ; } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public interface LoadBalancer extends Processor { void addProcessor ( Processor processor ) ; void removeProcessor ( Processor processor ) ; List < Processor > getProcessors ( ) ; } 	0
package org . apache . camel . impl ; import org . apache . camel . Predicate ; import org . apache . camel . Exchange ; public abstract class PredicateSupport < E extends Exchange > implements Predicate < E > { public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( assertionFailureMessage ( exchange ) ) ; } } protected String assertionFailureMessage ( E exchange ) { return this + " failed on " + exchange ; } } 	0
package org . apache . camel . spring . spi ; import org . springframework . context . ApplicationContext ; import org . springframework . beans . factory . wiring . BeanConfigurerSupport ; public class BeanInjector extends BeanConfigurerSupport { public BeanInjector ( ApplicationContext applicationContext ) throws Exception { setBeanFactory ( applicationContext ) ; afterPropertiesSet ( ) ; } public void inject ( Object bean ) { configureBean ( bean ) ; } } 	0
package org . apache . camel . component . file ; import java . io . File ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultMessage ; public class FileMessage extends DefaultMessage { private File file ; public FileMessage ( ) { this ( new File ( "." ) ) ; } public FileMessage ( File file ) { this . file = file ; } @ Override public String toString ( ) { return "FileMessage: " + file ; } @ Override public FileExchange getExchange ( ) { return ( FileExchange ) super . getExchange ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } @ Override public FileMessage newInstance ( ) { return new FileMessage ( ) ; } } 	0
package org . apache . camel . component . mail ; public class MessageHeaderNamesAccessException extends RuntimeMailException { private static final long serialVersionUID = - 6744171518099741324L ; public MessageHeaderNamesAccessException ( Throwable e ) { super ( "Failed to acess the Mail message property names" , e ) ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . FailedToCreateProducerException ; import org . apache . servicemix . common . DefaultComponent ; import org . apache . servicemix . jbi . util . IntrospectionSupport ; import org . apache . servicemix . jbi . util . URISupport ; import org . apache . servicemix . jbi . resolver . URIResolver ; import javax . jbi . servicedesc . ServiceEndpoint ; import javax . xml . namespace . QName ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; public class CamelJbiComponent extends DefaultComponent implements Component < Exchange > { private JbiBinding binding ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; @ Override protected List < CamelJbiEndpoint > getConfiguredEndpoints ( ) { List < CamelJbiEndpoint > answer = new ArrayList < CamelJbiEndpoint > ( ) ; return answer ; } @ Override protected Class [ ] getEndpointClasses ( ) { return new Class [ ] { CamelJbiEndpoint . class } ; } public JbiBinding getBinding ( ) { if ( binding == null ) { binding = new JbiBinding ( ) ; } return binding ; } public void setBinding ( JbiBinding binding ) { this . binding = binding ; } @ Override protected String [ ] getEPRProtocols ( ) { return new String [ ] { "camel" } ; } protected org . apache . servicemix . common . Endpoint getResolvedEPR ( ServiceEndpoint ep ) throws Exception { CamelJbiEndpoint endpoint = createEndpoint ( ep ) ; endpoint . activate ( ) ; return endpoint ; } public CamelJbiEndpoint createEndpoint ( ServiceEndpoint ep ) throws URISyntaxException { URI uri = new URI ( ep . getEndpointName ( ) ) ; Map map = URISupport . parseQuery ( uri . getQuery ( ) ) ; String camelUri = uri . getSchemeSpecificPart ( ) ; Endpoint camelEndpoint = getCamelContext ( ) . getEndpoint ( camelUri ) ; Processor processor = null ; try { processor = camelEndpoint . createProducer ( ) ; } catch ( Exception e ) { throw new FailedToCreateProducerException ( camelEndpoint , e ) ; } CamelJbiEndpoint endpoint = new CamelJbiEndpoint ( getServiceUnit ( ) , camelEndpoint , getBinding ( ) , processor ) ; IntrospectionSupport . setProperties ( endpoint , map ) ; return endpoint ; } public Endpoint < Exchange > createEndpoint ( String uri ) { if ( uri . startsWith ( "jbi:" ) ) { uri = uri . substring ( "jbi:" . length ( ) ) ; return new JbiEndpoint ( this , uri ) ; } return null ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = new ScheduledThreadPoolExecutor ( 5 ) ; } return executorService ; } public CamelJbiEndpoint activateJbiEndpoint ( JbiEndpoint camelEndpoint , Processor processor ) throws Exception { CamelJbiEndpoint jbiEndpoint ; String endpointUri = camelEndpoint . getEndpointUri ( ) ; if ( endpointUri . startsWith ( "endpoint:" ) ) { String uri = endpointUri . substring ( "endpoint:" . length ( ) ) ; String [ ] parts = new String [ 0 ] ; try { parts = URIResolver . split3 ( uri ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( "Expected syntax endpoint:[serviceNamespace]:[serviceName]:[endpointName] but was given: " + endpointUri + ". Cause: " + e , e ) ; } QName service = new QName ( parts [ 0 ] , parts [ 1 ] ) ; String endpoint = parts [ 2 ] ; jbiEndpoint = new CamelJbiEndpoint ( getServiceUnit ( ) , service , endpoint , camelEndpoint , getBinding ( ) , processor ) ; } else { jbiEndpoint = new CamelJbiEndpoint ( getServiceUnit ( ) , camelEndpoint , getBinding ( ) , processor ) ; } addEndpoint ( jbiEndpoint ) ; return jbiEndpoint ; } } 	0
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . springframework . beans . factory . FactoryBean ; public class EndpointFactoryBean implements FactoryBean { private CamelContext context ; private String uri ; private Endpoint endpoint ; private boolean singleton ; public Object getObject ( ) throws Exception { if ( endpoint == null ) { endpoint = createEndpoint ( ) ; } return endpoint ; } public Class getObjectType ( ) { return Endpoint . class ; } public boolean isSingleton ( ) { return singleton ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public void setSingleton ( boolean singleton ) { this . singleton = singleton ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } protected Endpoint createEndpoint ( ) { notNull ( context , "context" ) ; notNull ( uri , "uri" ) ; return context . getEndpoint ( uri ) ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class Builder { public static < E extends Exchange > ValueBuilder < E > constant ( Object value ) { Expression < E > expression = ExpressionBuilder . constantExpression ( value ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > header ( @ FluentArg ( "name" ) String name ) { Expression < E > expression = ExpressionBuilder . headerExpression ( name ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > body ( ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > bodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > bodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > outBody ( ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > outBody ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > bodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name , final String defaultValue ) { return new ValueBuilder < E > ( ExpressionBuilder . < E > systemProperty ( name , defaultValue ) ) ; } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class LoadBalancerSupport implements LoadBalancer { private List < Processor > processors = new CopyOnWriteArrayList < Processor > ( ) ; public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public void removeProcessor ( Processor processor ) { processors . remove ( processor ) ; } public List < Processor > getProcessors ( ) { return processors ; } } 	0
package org . apache . camel ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; public interface CamelContext extends Service { void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < Route > getRoutes ( ) ; void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( RouteBuilder builder ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Injector getInjector ( ) ; } 	1
package org . apache . camel . component . cxf . transport ; public class CamelConstants { public static final String TEXT_MESSAGE_TYPE = "text" ; public static final String BINARY_MESSAGE_TYPE = "binary" ; public static final String CAMEL_SERVER_REQUEST_HEADERS = "org.apache.cxf.camel.server.request.headers" ; public static final String CAMEL_SERVER_RESPONSE_HEADERS = "org.apache.cxf.camel.server.response.headers" ; public static final String CAMEL_REQUEST_MESSAGE = "org.apache.cxf.camel.request.message" ; public static final String CAMEL_RESPONSE_MESSAGE = "org.apache.cxf.camel.reponse.message" ; public static final String CAMEL_CLIENT_REQUEST_HEADERS = "org.apache.cxf.camel.template.request.headers" ; public static final String CAMEL_CLIENT_RESPONSE_HEADERS = "org.apache.cxf.camel.template.response.headers" ; public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = "org.apache.cxf.camel.template.timeout" ; public static final String CAMEL_SERVER_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-server" ; public static final String CAMEL_CLIENT_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-template" ; public static final String ENDPOINT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/endpoint-config" ; public static final String SERVICE_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/service-config" ; public static final String PORT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/port-config" ; public static final String CAMEL_CLIENT_CONFIG_ID = "camel-template" ; public static final String CAMEL_SERVER_CONFIG_ID = "camel-server" ; public static final String CAMEL_REBASED_REPLY_TO = "org.apache.cxf.camel.server.replyto" ; public static final String CAMEL_CORRELATION_ID = "org.apache.cxf.camel.correlationId" ; } 	0
package org . apache . camel . component . file ; import java . io . File ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; public class FileExchange extends DefaultExchange { private File file ; public FileExchange ( CamelContext camelContext , File file ) { super ( camelContext ) ; setIn ( new FileMessage ( file ) ) ; this . file = file ; } public File getFile ( ) { return this . file ; } public void setFile ( File file ) { this . file = file ; } } 	0
package org . apache . camel . spring . util ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . Body ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Header ; import org . apache . camel . Property ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . Collection ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; public class BeanInfo { private static final transient Log log = LogFactory . getLog ( BeanInfo . class ) ; private Class type ; private MethodInvocationStrategy strategy ; private Map < String , MethodInfo > operations = new ConcurrentHashMap < String , MethodInfo > ( ) ; private MethodInfo defaultExpression ; public BeanInfo ( Class type , MethodInvocationStrategy strategy ) { this . type = type ; this . strategy = strategy ; } public Class getType ( ) { return type ; } public void introspect ( ) { introspect ( getType ( ) ) ; if ( operations . size ( ) == 1 ) { Collection < MethodInfo > methodInfos = operations . values ( ) ; for ( MethodInfo methodInfo : methodInfos ) { defaultExpression = methodInfo ; } } } public MethodInvocation createInvocation ( Method method , Object pojo , Exchange messageExchange ) throws RuntimeCamelException { MethodInfo methodInfo = introspect ( type , method ) ; return methodInfo . createMethodInvocation ( pojo , messageExchange ) ; } public MethodInvocation createInvocation ( Object pojo , Exchange messageExchange ) throws RuntimeCamelException { MethodInfo methodInfo = null ; String name = messageExchange . getIn ( ) . getHeader ( "org.apache.camel.MethodName" , String . class ) ; if ( name != null ) { methodInfo = operations . get ( name ) ; } if ( methodInfo == null ) { methodInfo = defaultExpression ; } if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , messageExchange ) ; } return null ; } protected void introspect ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method method : methods ) { introspect ( clazz , method ) ; } Class superclass = clazz . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { introspect ( superclass ) ; } } protected MethodInfo introspect ( Class clazz , Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; final Expression [ ] parameterExpressions = new Expression [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { Class parameterType = parameterTypes [ i ] ; Expression expression = createParameterUnmarshalExpression ( clazz , method , parameterType , parameterAnnotations [ i ] ) ; if ( expression == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "No expression available for method: " + method . toString ( ) + " parameter: " + i + " so ignoring method" ) ; } if ( parameterTypes . length == 1 ) { expression = ExpressionBuilder . bodyExpression ( parameterType ) ; } else { return null ; } } parameterExpressions [ i ] = expression ; } String opName = method . getName ( ) ; Expression parametersExpression = createMethodParametersExpression ( parameterExpressions ) ; MethodInfo methodInfo = new MethodInfo ( clazz , method , parametersExpression ) ; operations . put ( opName , methodInfo ) ; return methodInfo ; } protected Expression createMethodParametersExpression ( final Expression [ ] parameterExpressions ) { return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object [ ] answer = new Object [ parameterExpressions . length ] ; for ( int i = 0 ; i < parameterExpressions . length ; i ++ ) { Expression parameterExpression = parameterExpressions [ i ] ; answer [ i ] = parameterExpression . evaluate ( exchange ) ; } return answer ; } @ Override public String toString ( ) { return "parametersExpression" + Arrays . asList ( parameterExpressions ) ; } } ; } protected Expression createParameterUnmarshalExpression ( Class clazz , Method method , Class parameterType , Annotation [ ] parameterAnnotation ) { for ( Annotation annotation : parameterAnnotation ) { Expression answer = createParameterUnmarshalExpressionForAnnotation ( clazz , method , parameterType , annotation ) ; if ( answer != null ) { return answer ; } } return strategy . getDefaultParameterTypeExpression ( parameterType ) ; } protected Expression createParameterUnmarshalExpressionForAnnotation ( Class clazz , Method method , Class parameterType , Annotation annotation ) { if ( annotation instanceof Property ) { Property propertyAnnotation = ( Property ) annotation ; return ExpressionBuilder . propertyExpression ( propertyAnnotation . name ( ) ) ; } else if ( annotation instanceof Header ) { Header headerAnnotation = ( Header ) annotation ; return ExpressionBuilder . headerExpression ( headerAnnotation . name ( ) ) ; } else if ( annotation instanceof Body ) { Body content = ( Body ) annotation ; return ExpressionBuilder . bodyExpression ( parameterType ) ; } return null ; } } 	0
package org . apache . camel . component . http ; import java . io . IOException ; import java . util . concurrent . ConcurrentHashMap ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class CamelServlet extends HttpServlet { private ConcurrentHashMap < String , HttpConsumer > consumers = new ConcurrentHashMap < String , HttpConsumer > ( ) ; public CamelServlet ( ) { } @ Override protected void service ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { try { HttpConsumer consumer = resolve ( request ) ; if ( consumer == null ) { response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; return ; } HttpExchange exchange = new HttpExchange ( consumer . getEndpoint ( ) , request , response ) ; consumer . getProcessor ( ) . process ( exchange ) ; consumer . getBinding ( ) . writeResponse ( exchange ) ; } catch ( Exception e ) { throw new ServletException ( e ) ; } } protected HttpConsumer resolve ( HttpServletRequest request ) { String path = request . getPathInfo ( ) ; return consumers . get ( path ) ; } public void connect ( HttpConsumer consumer ) { consumers . put ( consumer . getPath ( ) , consumer ) ; } public void disconnect ( HttpConsumer consumer ) { consumers . remove ( consumer . getPath ( ) ) ; } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPathVariableResolver ; import java . util . HashMap ; import java . util . Map ; public class MessageVariableResolver implements XPathVariableResolver { public static final String SYSTEM_PROPERTIES_NAMESPACE = "http://camel.apache.org/xml/variables/system-properties" ; public static final String ENVIRONMENT_VARIABLES = "http://camel.apache.org/xml/variables/environment-variables" ; public static final String EXCHANGE_PROPERTY = "http://camel.apache.org/xml/variables/exchange-property" ; public static final String IN_HEADER = "http://camel.apache.org/xml/variables/in-header" ; public static final String OUT_HEADER = "http://camel.apache.org/xml/variables/out-header" ; private static final transient Log log = LogFactory . getLog ( MessageVariableResolver . class ) ; private Exchange exchange ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public Object resolveVariable ( QName name ) { String uri = name . getNamespaceURI ( ) ; String localPart = name . getLocalPart ( ) ; Object answer = null ; if ( uri == null || uri . length ( ) == 0 ) { answer = variables . get ( localPart ) ; if ( answer == null ) { Message message = exchange . getIn ( ) ; if ( message != null ) { answer = message . getHeader ( localPart ) ; } if ( answer == null ) { answer = exchange . getProperty ( localPart ) ; } } } else if ( uri . equals ( SYSTEM_PROPERTIES_NAMESPACE ) ) { try { answer = System . getProperty ( localPart ) ; } catch ( Exception e ) { log . debug ( "Security exception evaluating system property: " + localPart + ". Reason: " + e , e ) ; } } else if ( uri . equals ( ENVIRONMENT_VARIABLES ) ) { answer = System . getenv ( ) . get ( localPart ) ; } else if ( uri . equals ( EXCHANGE_PROPERTY ) ) { answer = exchange . getProperty ( localPart ) ; } else if ( uri . equals ( IN_HEADER ) ) { answer = exchange . getIn ( ) . getHeader ( localPart ) ; } else if ( uri . equals ( OUT_HEADER ) ) { answer = exchange . getOut ( ) . getHeader ( localPart ) ; } return answer ; } public void addVariable ( String localPart , Object value ) { variables . put ( localPart , value ) ; } } 	0
package org . apache . camel . spring ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . util . ResolverUtil ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class RouteBuilderFinder implements ApplicationContextAware { private String [ ] packages = { } ; private ApplicationContext applicationContext ; private ResolverUtil resolver = new ResolverUtil ( ) ; public RouteBuilderFinder ( ApplicationContext applicationContext , String [ ] packages ) { this . applicationContext = applicationContext ; this . packages = packages ; } public RouteBuilderFinder ( CamelContextFactoryBean factoryBean ) { this . applicationContext = factoryBean . getApplicationContext ( ) ; this . packages = factoryBean . getPackages ( ) ; } public String [ ] getPackages ( ) { return packages ; } public void setPackages ( String [ ] packages ) { this . packages = packages ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public void appendBuilders ( List < RouteBuilder > list ) throws IllegalAccessException , InstantiationException { resolver . findImplementations ( RouteBuilder . class , packages ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class aClass : classes ) { if ( shouldIgnoreBean ( aClass ) ) { continue ; } if ( isValidClass ( aClass ) ) { list . add ( instantiateBuilder ( aClass ) ) ; } } } public void destroy ( ) throws Exception { } protected boolean shouldIgnoreBean ( Class type ) { Map beans = applicationContext . getBeansOfType ( type , true , true ) ; if ( beans == null || beans . isEmpty ( ) ) { return false ; } return true ; } protected boolean isValidClass ( Class type ) { if ( ! Modifier . isAbstract ( type . getModifiers ( ) ) && ! type . isInterface ( ) ) { Constructor [ ] constructors = type . getDeclaredConstructors ( ) ; for ( Constructor constructor : constructors ) { Class [ ] classes = constructor . getParameterTypes ( ) ; if ( classes . length == 0 ) { return true ; } } } return false ; } protected RouteBuilder instantiateBuilder ( Class type ) throws IllegalAccessException , InstantiationException { return ( RouteBuilder ) type . newInstance ( ) ; } } 	0
package org . apache . camel . util ; import java . util . concurrent . TimeUnit ; import java . util . Date ; public class Time { private long number ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; public static Time millis ( long value ) { return new Time ( value , TimeUnit . MILLISECONDS ) ; } public static Time micros ( long value ) { return new Time ( value , TimeUnit . MICROSECONDS ) ; } public static Time nanos ( long value ) { return new Time ( value , TimeUnit . NANOSECONDS ) ; } public static Time seconds ( long value ) { return new Time ( value , TimeUnit . SECONDS ) ; } public static Time minutes ( long value ) { return new Time ( minutesAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time hours ( long value ) { return new Time ( hoursAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time days ( long value ) { return new Time ( daysAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public Time ( long number , TimeUnit timeUnit ) { this . number = number ; this . timeUnit = timeUnit ; } public long toMillis ( ) { return timeUnit . toMillis ( number ) ; } public Date toDate ( ) { return new Date ( toMillis ( ) ) ; } public long getNumber ( ) { return number ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } protected static long minutesAsSeconds ( long value ) { return value * 60 ; } protected static long hoursAsSeconds ( long value ) { return minutesAsSeconds ( value ) * 60 ; } protected static long daysAsSeconds ( long value ) { return hoursAsSeconds ( value ) * 24 ; } } 	0
package org . apache . camel . bam . model ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; public class EntitySupport { private Long id ; @ Id @ GeneratedValue public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + id + "]" ; } } 	0
package org . apache . camel ; public class ResolveEndpointFailedException extends RuntimeCamelException { private final String uri ; public ResolveEndpointFailedException ( String uri , Throwable cause ) { super ( "Failed to resolve endpoint: " + uri + " due to: " + cause , cause ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ObjectHelper ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer102 ; import org . springframework . jms . listener . SimpleMessageListenerContainer ; import org . springframework . jms . listener . SimpleMessageListenerContainer102 ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer102 ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . transaction . PlatformTransactionManager ; import javax . jms . ConnectionFactory ; import javax . jms . ExceptionListener ; public class JmsConfiguration implements Cloneable { protected static final String TRANSACTED = "TRANSACTED" ; protected static final String CLIENT_ACKNOWLEDGE = "CLIENT_ACKNOWLEDGE" ; protected static final String AUTO_ACKNOWLEDGE = "AUTO_ACKNOWLEDGE" ; protected static final String DUPS_OK_ACKNOWLEDGE = "DUPS_OK_ACKNOWLEDGE" ; private ConnectionFactory connectionFactory ; private ConnectionFactory templateConnectionFactory ; private ConnectionFactory listenerConnectionFactory ; private int acknowledgementMode = - 1 ; private String acknowledgementModeName = AUTO_ACKNOWLEDGE ; private ExceptionListener exceptionListener ; private ConsumerType consumerType = ConsumerType . Default ; private boolean autoStartup = true ; private boolean acceptMessagesWhileStopping ; private String clientId ; private String durableSubscriptionName ; private boolean subscriptionDurable ; private boolean exposeListenerSession = true ; private TaskExecutor taskExecutor ; private boolean pubSubNoLocal ; private int concurrentConsumers = 1 ; private int maxMessagesPerTask = 1 ; private ServerSessionFactory serverSessionFactory ; private int cacheLevel = - 1 ; private String cacheLevelName = "CACHE_CONSUMER" ; private long recoveryInterval = - 1 ; private long receiveTimeout = - 1 ; private int idleTaskExecutionLimit = 1 ; private int maxConcurrentConsumers = 1 ; private boolean useVersion102 = false ; private boolean explicitQosEnabled = false ; private boolean deliveryPersistent = true ; private long timeToLive = - 1 ; private MessageConverter messageConverter ; private boolean messageIdEnabled = true ; private boolean messageTimestampEnabled = true ; private int priority = - 1 ; private boolean transacted ; private PlatformTransactionManager transactionManager ; private String transactionName ; private int transactionTimeout = - 1 ; public JmsConfiguration ( ) { } public JmsConfiguration ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public JmsConfiguration copy ( ) { try { return ( JmsConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public JmsOperations createJmsOperations ( boolean pubSubDomain , String destination ) { ConnectionFactory factory = getTemplateConnectionFactory ( ) ; JmsTemplate template = useVersion102 ? new JmsTemplate102 ( factory , pubSubDomain ) : new JmsTemplate ( factory ) ; template . setPubSubDomain ( pubSubDomain ) ; template . setDefaultDestinationName ( destination ) ; template . setExplicitQosEnabled ( explicitQosEnabled ) ; template . setDeliveryPersistent ( deliveryPersistent ) ; if ( messageConverter != null ) { template . setMessageConverter ( messageConverter ) ; } template . setMessageIdEnabled ( messageIdEnabled ) ; template . setMessageTimestampEnabled ( messageTimestampEnabled ) ; if ( priority >= 0 ) { template . setPriority ( priority ) ; } template . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { template . setReceiveTimeout ( receiveTimeout ) ; } if ( timeToLive >= 0 ) { template . setTimeToLive ( timeToLive ) ; } template . setSessionTransacted ( transacted ) ; if ( acknowledgementMode >= 0 ) { template . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { template . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } return template ; } public AbstractMessageListenerContainer createMessageListenerContainer ( ) { AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation ( ) ; configureMessageListenerContainer ( container ) ; return container ; } protected void configureMessageListenerContainer ( AbstractMessageListenerContainer container ) { container . setConnectionFactory ( getListenerConnectionFactory ( ) ) ; if ( autoStartup ) { container . setAutoStartup ( true ) ; } if ( clientId != null ) { container . setClientId ( clientId ) ; } container . setSubscriptionDurable ( subscriptionDurable ) ; if ( durableSubscriptionName != null ) { container . setDurableSubscriptionName ( durableSubscriptionName ) ; } if ( durableSubscriptionName != null && clientId != null ) { container . setSubscriptionDurable ( true ) ; } if ( exceptionListener != null ) { container . setExceptionListener ( exceptionListener ) ; } container . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; container . setExposeListenerSession ( exposeListenerSession ) ; container . setSessionTransacted ( transacted ) ; if ( acknowledgementMode >= 0 ) { container . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { container . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } if ( container instanceof DefaultMessageListenerContainer ) { DefaultMessageListenerContainer listenerContainer = ( DefaultMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } if ( cacheLevel >= 0 ) { listenerContainer . setCacheLevel ( cacheLevel ) ; } else if ( cacheLevelName != null ) { listenerContainer . setCacheLevelName ( cacheLevelName ) ; } else { listenerContainer . setCacheLevel ( DefaultMessageListenerContainer . CACHE_CONSUMER ) ; } if ( idleTaskExecutionLimit >= 0 ) { listenerContainer . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } if ( maxConcurrentConsumers >= 0 ) { listenerContainer . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { listenerContainer . setReceiveTimeout ( receiveTimeout ) ; } if ( recoveryInterval >= 0 ) { listenerContainer . setRecoveryInterval ( recoveryInterval ) ; } if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } if ( transactionManager != null ) { listenerContainer . setTransactionManager ( transactionManager ) ; } if ( transactionName != null ) { listenerContainer . setTransactionName ( transactionName ) ; } if ( transactionTimeout >= 0 ) { listenerContainer . setTransactionTimeout ( transactionTimeout ) ; } } else if ( container instanceof ServerSessionMessageListenerContainer ) { ServerSessionMessageListenerContainer listenerContainer = ( ServerSessionMessageListenerContainer ) container ; if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } if ( serverSessionFactory != null ) { listenerContainer . setServerSessionFactory ( serverSessionFactory ) ; } } else if ( container instanceof SimpleMessageListenerContainer ) { SimpleMessageListenerContainer listenerContainer = ( SimpleMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } } } public ConnectionFactory getConnectionFactory ( ) { if ( connectionFactory == null ) { connectionFactory = createConnectionFactory ( ) ; } return connectionFactory ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public ConnectionFactory getListenerConnectionFactory ( ) { if ( listenerConnectionFactory == null ) { listenerConnectionFactory = createListenerConnectionFactory ( ) ; } return listenerConnectionFactory ; } public void setListenerConnectionFactory ( ConnectionFactory listenerConnectionFactory ) { this . listenerConnectionFactory = listenerConnectionFactory ; } public ConnectionFactory getTemplateConnectionFactory ( ) { if ( templateConnectionFactory == null ) { templateConnectionFactory = createTemplateConnectionFactory ( ) ; } return templateConnectionFactory ; } public void setTemplateConnectionFactory ( ConnectionFactory templateConnectionFactory ) { this . templateConnectionFactory = templateConnectionFactory ; } public boolean isUseVersion102 ( ) { return useVersion102 ; } public void setUseVersion102 ( boolean useVersion102 ) { this . useVersion102 = useVersion102 ; } public boolean isAutoStartup ( ) { return autoStartup ; } public void setAutoStartup ( boolean autoStartup ) { this . autoStartup = autoStartup ; } public boolean isAcceptMessagesWhileStopping ( ) { return acceptMessagesWhileStopping ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { this . acceptMessagesWhileStopping = acceptMessagesWhileStopping ; } public String getClientId ( ) { return clientId ; } public void setClientId ( String consumerClientId ) { this . clientId = consumerClientId ; } public String getDurableSubscriptionName ( ) { return durableSubscriptionName ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { this . durableSubscriptionName = durableSubscriptionName ; } public ExceptionListener getExceptionListener ( ) { return exceptionListener ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { this . exceptionListener = exceptionListener ; } public boolean isSubscriptionDurable ( ) { return subscriptionDurable ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { this . subscriptionDurable = subscriptionDurable ; } public String getAcknowledgementModeName ( ) { return acknowledgementModeName ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { this . acknowledgementModeName = consumerAcknowledgementMode ; this . acknowledgementMode = - 1 ; } public boolean isExposeListenerSession ( ) { return exposeListenerSession ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { this . exposeListenerSession = exposeListenerSession ; } public TaskExecutor getTaskExecutor ( ) { return taskExecutor ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { this . taskExecutor = taskExecutor ; } public boolean isPubSubNoLocal ( ) { return pubSubNoLocal ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { this . pubSubNoLocal = pubSubNoLocal ; } public int getConcurrentConsumers ( ) { return concurrentConsumers ; } public void setConcurrentConsumers ( int concurrentConsumers ) { this . concurrentConsumers = concurrentConsumers ; } public int getMaxMessagesPerTask ( ) { return maxMessagesPerTask ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { this . maxMessagesPerTask = maxMessagesPerTask ; } public ServerSessionFactory getServerSessionFactory ( ) { return serverSessionFactory ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { this . serverSessionFactory = serverSessionFactory ; } public int getCacheLevel ( ) { return cacheLevel ; } public void setCacheLevel ( int cacheLevel ) { this . cacheLevel = cacheLevel ; } public String getCacheLevelName ( ) { return cacheLevelName ; } public void setCacheLevelName ( String cacheName ) { this . cacheLevelName = cacheName ; } public long getRecoveryInterval ( ) { return recoveryInterval ; } public void setRecoveryInterval ( long recoveryInterval ) { this . recoveryInterval = recoveryInterval ; } public long getReceiveTimeout ( ) { return receiveTimeout ; } public void setReceiveTimeout ( long receiveTimeout ) { this . receiveTimeout = receiveTimeout ; } public PlatformTransactionManager getTransactionManager ( ) { return transactionManager ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { this . transactionManager = transactionManager ; } public String getTransactionName ( ) { return transactionName ; } public void setTransactionName ( String transactionName ) { this . transactionName = transactionName ; } public int getTransactionTimeout ( ) { return transactionTimeout ; } public void setTransactionTimeout ( int transactionTimeout ) { this . transactionTimeout = transactionTimeout ; } public int getIdleTaskExecutionLimit ( ) { return idleTaskExecutionLimit ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { this . idleTaskExecutionLimit = idleTaskExecutionLimit ; } public int getMaxConcurrentConsumers ( ) { return maxConcurrentConsumers ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { this . maxConcurrentConsumers = maxConcurrentConsumers ; } public boolean isExplicitQosEnabled ( ) { return explicitQosEnabled ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { this . explicitQosEnabled = explicitQosEnabled ; } public boolean isDeliveryPersistent ( ) { return deliveryPersistent ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { this . deliveryPersistent = deliveryPersistent ; } public long getTimeToLive ( ) { return timeToLive ; } public void setTimeToLive ( long timeToLive ) { this . timeToLive = timeToLive ; } public MessageConverter getMessageConverter ( ) { return messageConverter ; } public void setMessageConverter ( MessageConverter messageConverter ) { this . messageConverter = messageConverter ; } public boolean isMessageIdEnabled ( ) { return messageIdEnabled ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { this . messageIdEnabled = messageIdEnabled ; } public boolean isMessageTimestampEnabled ( ) { return messageTimestampEnabled ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { this . messageTimestampEnabled = messageTimestampEnabled ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public ConsumerType getConsumerType ( ) { return consumerType ; } public void setConsumerType ( ConsumerType consumerType ) { this . consumerType = consumerType ; } public int getAcknowledgementMode ( ) { return acknowledgementMode ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { this . acknowledgementMode = consumerAcknowledgementMode ; this . acknowledgementModeName = null ; } public boolean isTransacted ( ) { return transacted ; } public void setTransacted ( boolean consumerTransacted ) { this . transacted = consumerTransacted ; } protected AbstractMessageListenerContainer chooseMessageListenerContainerImplementation ( ) { switch ( consumerType ) { case Simple : return isUseVersion102 ( ) ? new SimpleMessageListenerContainer102 ( ) : new SimpleMessageListenerContainer ( ) ; case ServerSessionPool : return isUseVersion102 ( ) ? new ServerSessionMessageListenerContainer102 ( ) : new ServerSessionMessageListenerContainer ( ) ; case Default : return isUseVersion102 ( ) ? new DefaultMessageListenerContainer102 ( ) : new DefaultMessageListenerContainer ( ) ; default : throw new IllegalArgumentException ( "Unknown consumer type: " + consumerType ) ; } } protected ConnectionFactory createConnectionFactory ( ) { ObjectHelper . notNull ( connectionFactory , "connectionFactory" ) ; return null ; } protected ConnectionFactory createListenerConnectionFactory ( ) { return getConnectionFactory ( ) ; } protected ConnectionFactory createTemplateConnectionFactory ( ) { return getConnectionFactory ( ) ; } } 	0
package org . apache . camel . component . file ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ScheduledPollEndpoint ; import java . io . File ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private File file ; private boolean autoCreate = true ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor file ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , file ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getContext ( ) , file ) ; } public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } public File getFile ( ) { if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } } 	1
package org . apache . camel . spring . xml ; import org . apache . camel . spring . CamelContextFactoryBean ; import org . apache . camel . spring . EndpointFactoryBean ; import org . apache . camel . spring . CamelBeanPostProcessor ; import static org . apache . camel . util . ObjectHelper . isNotNullOrBlank ; import org . apache . camel . builder . xml . XPathBuilder ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . parsing . BeanComponentDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . xml . DomUtils ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import java . util . Set ; import java . util . HashSet ; public class CamelNamespaceHandler extends NamespaceHandlerSupport { protected CamelBeanDefinitionParser routesParser = new CamelBeanDefinitionParser ( this ) ; protected BeanDefinitionParser endpointParser = new BeanDefinitionParser ( EndpointFactoryBean . class ) ; protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser ( CamelBeanPostProcessor . class ) ; protected Set < String > parserElementNames = new HashSet < String > ( ) ; public void init ( ) { registerParser ( "routes" , routesParser ) ; registerParser ( "routeBuilder" , routesParser ) ; registerParser ( "endpoint" , endpointParser ) ; registerParser ( "camelContext" , new BeanDefinitionParser ( CamelContextFactoryBean . class ) { @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { super . doParse ( element , parserContext , builder ) ; String contextId = element . getAttribute ( "id" ) ; Element routes = element . getOwnerDocument ( ) . createElement ( "routes" ) ; NodeList list = element . getChildNodes ( ) ; for ( int size = list . getLength ( ) , i = 0 ; i < size ; i ++ ) { Node child = list . item ( i ) ; if ( child instanceof Element ) { Element childElement = ( Element ) child ; if ( child . getLocalName ( ) . equals ( "beanPostProcessor" ) ) { String beanPostProcessorId = contextId + ":beanPostProcessor" ; childElement . setAttribute ( "id" , beanPostProcessorId ) ; BeanDefinition definition = beanPostProcessorParser . parse ( childElement , parserContext ) ; definition . getPropertyValues ( ) . addPropertyValue ( "camelContext" , new RuntimeBeanReference ( contextId ) ) ; } else { element . removeChild ( child ) ; routes . appendChild ( child ) ; } } } String routeId = contextId + ":routes" ; routes . setAttribute ( "id" , routeId ) ; BeanDefinition definition = routesParser . parse ( routes , parserContext ) ; definition . getPropertyValues ( ) . addPropertyValue ( "context" , new RuntimeBeanReference ( contextId ) ) ; parserContext . registerComponent ( new BeanComponentDefinition ( definition , routeId ) ) ; list = routes . getElementsByTagName ( "endpoint" ) ; for ( int size = list . getLength ( ) , i = 0 ; i < size ; i ++ ) { Element node = ( Element ) list . item ( i ) ; definition = endpointParser . parse ( node , parserContext ) ; String id = node . getAttribute ( "id" ) ; if ( isNotNullOrBlank ( id ) ) { definition . getPropertyValues ( ) . addPropertyValue ( "context" , new RuntimeBeanReference ( contextId ) ) ; parserContext . registerComponent ( new BeanComponentDefinition ( definition , id ) ) ; } } } } ) ; registerParser ( "xpath" , new BeanDefinitionParser ( XPathBuilder . class ) { @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String xpath = DomUtils . getTextValue ( element ) ; builder . addConstructorArg ( xpath ) ; super . doParse ( element , parserContext , builder ) ; builder . addPropertyValue ( "namespacesFromDom" , element ) ; } } ) ; registerScriptParser ( "script" , null ) ; registerScriptParser ( "groovy" , "groovy" ) ; registerScriptParser ( "ruby" , "jruby" ) ; registerScriptParser ( "javaScript" , "js" ) ; registerScriptParser ( "python" , "python" ) ; registerScriptParser ( "php" , "php" ) ; } protected void registerScriptParser ( String elementName , String engineName ) { registerParser ( elementName , new ScriptDefinitionParser ( engineName ) ) ; } protected void registerParser ( String name , org . springframework . beans . factory . xml . BeanDefinitionParser parser ) { parserElementNames . add ( name ) ; registerBeanDefinitionParser ( name , parser ) ; } public Set < String > getParserElementNames ( ) { return parserElementNames ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingErrorHandler ; import org . apache . camel . processor . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandlerBuilder implements ErrorHandlerBuilder { private Log log = LogFactory . getLog ( Logger . class ) ; private LoggingLevel level = LoggingLevel . INFO ; public LoggingErrorHandlerBuilder ( ) { } public LoggingErrorHandlerBuilder ( Log log ) { this . log = log ; } public LoggingErrorHandlerBuilder ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public ErrorHandlerBuilder copy ( ) { LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder ( ) ; answer . setLog ( getLog ( ) ) ; answer . setLevel ( getLevel ( ) ) ; return answer ; } public Processor createErrorHandler ( Processor processor ) { return new LoggingErrorHandler ( processor , log , level ) ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; public class ProcessorBuilder { public static Processor setBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setBody(" + expression + ")" ; } } ; } public static Processor setOutBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setOutBody(" + expression + ")" ; } } ; } public static Processor setHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setOutHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setOutHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setProperty ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . setProperty ( name , value ) ; } @ Override public String toString ( ) { return "setProperty(" + name + ", " + expression + ")" ; } } ; } } 	0
package org . apache . camel . builder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface Fluent { String value ( ) default "" ; boolean nestedActions ( ) default false ; boolean callOnElementEnd ( ) default false ; } 	0
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . context . ApplicationContext ; public abstract class SpringRouteBuilder extends RouteBuilder { private ApplicationContext applicationContext ; public < T > T bean ( Class < T > type , String beanName ) { ApplicationContext context = getApplicationContext ( ) ; return ( T ) context . getBean ( beanName , type ) ; } public < T > T bean ( Class < T > type ) { ApplicationContext context = getApplicationContext ( ) ; String [ ] names = context . getBeanNamesForType ( type , true , true ) ; if ( names != null ) { int count = names . length ; if ( count == 1 ) { return ( T ) context . getBean ( names [ 0 ] ) ; } else if ( count > 1 ) { throw new IllegalArgumentException ( "Too many beans in the application context of type: " + type + ". Found: " + count ) ; } } throw new IllegalArgumentException ( "No bean available in the application context of type: " + type ) ; } public ApplicationContext getApplicationContext ( ) { if ( applicationContext == null ) { CamelContext camelContext = getContext ( ) ; if ( camelContext instanceof SpringCamelContext ) { SpringCamelContext springCamelContext = ( SpringCamelContext ) camelContext ; return springCamelContext . getApplicationContext ( ) ; } else { throw new IllegalArgumentException ( "This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured" ) ; } } return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId = defaultIdGenerator . generateId ( ) ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , getBody ( ) ) ; } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object body , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T value = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , body ) ; if ( value != null ) { body = value ; } } setBody ( body ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . setMessageId ( getMessageId ( ) ) ; answer . setBody ( getBody ( ) ) ; answer . getHeaders ( ) . putAll ( getHeaders ( ) ) ; return answer ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } } 	1
package org . apache . camel . component . mina ; import org . apache . camel . Producer ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . ConnectFuture ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoHandler ; import org . apache . mina . common . IoHandlerAdapter ; import org . apache . mina . common . IoSession ; import java . net . SocketAddress ; public class MinaProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( MinaProducer . class ) ; private IoSession session ; private MinaEndpoint endpoint ; public MinaProducer ( MinaEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) { if ( session == null ) { throw new IllegalStateException ( "Not started yet!" ) ; } Object body = exchange . getIn ( ) . getBody ( ) ; if ( body == null ) { log . warn ( "No payload for exchange: " + exchange ) ; } else { session . write ( body ) ; } } @ Override protected void doStart ( ) throws Exception { SocketAddress address = endpoint . getAddress ( ) ; IoConnector connector = endpoint . getConnector ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Creating connector to address: " + address + " using connector: " + connector ) ; } IoHandler ioHandler = new IoHandlerAdapter ( ) { @ Override public void messageReceived ( IoSession ioSession , Object object ) throws Exception { super . messageReceived ( ioSession , object ) ; } } ; ConnectFuture future = connector . connect ( address , ioHandler , endpoint . getConfig ( ) ) ; future . join ( ) ; session = future . getSession ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( session != null ) { session . close ( ) . join ( 2000 ) ; } } } 	0
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; public class StringSource extends StreamSource implements Serializable { private final String text ; private String encoding = "UTF-8" ; public StringSource ( String text ) { if ( text == null ) { throw new NullPointerException ( "text can not be null" ) ; } this . text = text ; } public StringSource ( String text , String systemId ) { this ( text ) ; setSystemId ( systemId ) ; } public StringSource ( String text , String systemId , String encoding ) { this . text = text ; this . encoding = encoding ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { try { return new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public Reader getReader ( ) { return new StringReader ( text ) ; } public String toString ( ) { return "StringSource[" + text + "]" ; } public String getText ( ) { return text ; } } 	0
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MockEndpoint extends DefaultEndpoint < Exchange > { private static final transient Log log = LogFactory . getLog ( MockEndpoint . class ) ; private int expectedCount = - 1 ; private Map < Integer , Processor > processors = new HashMap < Integer , Processor > ( ) ; private List < Exchange > receivedExchanges = new ArrayList < Exchange > ( ) ; private List < Throwable > failures = new ArrayList < Throwable > ( ) ; private List < Runnable > tests = new ArrayList < Runnable > ( ) ; private CountDownLatch latch ; private long sleepForEmptyTest = 0L ; private int expectedMinimumCount = - 1 ; public static void assertWait ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; long left = unit . toMillis ( timeout ) ; long end = start + left ; for ( MockEndpoint endpoint : endpoints ) { if ( ! endpoint . await ( left , TimeUnit . MILLISECONDS ) ) throw new AssertionError ( "Timeout waiting for endpoints to receive enough messages. " + endpoint . getEndpointUri ( ) + " timed out." ) ; left = end - System . currentTimeMillis ( ) ; if ( left <= 0 ) left = 0 ; } } public static void assertIsSatisfied ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { assertWait ( timeout , unit , endpoints ) ; for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void expectsMessageCount ( int count , MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . expectsMessageCount ( count ) ; } } public MockEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } public Exchange createExchange ( ) { return new DefaultExchange ( getContext ( ) ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "You cannot consume from this endpoint" ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) { onExchange ( exchange ) ; } } ; } public void assertIsSatisfied ( ) throws InterruptedException { assertIsSatisfied ( sleepForEmptyTest ) ; } public void assertIsSatisfied ( long timeoutForEmptyEndpoints ) throws InterruptedException { if ( latch != null ) { latch . await ( 10 , TimeUnit . SECONDS ) ; } else if ( expectedCount == 0 ) { if ( timeoutForEmptyEndpoints > 0 ) { Thread . sleep ( timeoutForEmptyEndpoints ) ; } } if ( expectedCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertEquals ( "Received message count" , expectedCount , receivedCounter ) ; } if ( expectedMinimumCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertTrue ( "Received message count " + receivedCounter + ", expected at least " + expectedCount , expectedCount <= receivedCounter ) ; } for ( Runnable test : tests ) { test . run ( ) ; } for ( Throwable failure : failures ) { if ( failure != null ) { log . error ( "Caught on " + getEndpointUri ( ) + " Exception: " + failure , failure ) ; fail ( "Failed due to caught exception: " + failure ) ; } } } public void expectedMessageCount ( int expectedCount ) { this . expectedCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedCount ) ; } } public void expectedMinimumMessageCount ( int expectedCount ) { this . expectedMinimumCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedMinimumCount ) ; } } public void expectedBodiesReceived ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; expects ( new Runnable ( ) { public void run ( ) { int counter = 0 ; for ( Object expectedBody : bodies ) { Exchange exchange = getReceivedExchanges ( ) . get ( counter ++ ) ; assertTrue ( "No exchange received for counter: " + counter , exchange != null ) ; Message in = exchange . getIn ( ) ; Object actualBody = ( expectedBody != null ) ? in . getBody ( expectedBody . getClass ( ) ) : in . getBody ( ) ; assertEquals ( "Body of message: " + counter , expectedBody , actualBody ) ; log . debug ( getEndpointUri ( ) + " >>>> message: " + counter + " with body: " + actualBody ) ; } } } ) ; } public void expectedBodiesReceived ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; for ( Object body : bodies ) { bodyList . add ( body ) ; } expectedBodiesReceived ( bodyList ) ; } public void expects ( Runnable runnable ) { tests . add ( runnable ) ; } public AssertionClause message ( final int messageIndex ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; return clause ; } public AssertionClause allMessages ( ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { applyAssertionOn ( MockEndpoint . this , index ++ , exchange ) ; } } } ; expects ( clause ) ; return clause ; } public Exchange assertExchangeReceived ( int index ) { int count = getReceivedCounter ( ) ; assertTrue ( "Not enough messages received. Was: " + count , count > index ) ; return getReceivedExchanges ( ) . get ( index ) ; } public List < Throwable > getFailures ( ) { return failures ; } public int getReceivedCounter ( ) { return getReceivedExchanges ( ) . size ( ) ; } public List < Exchange > getReceivedExchanges ( ) { return receivedExchanges ; } public int getExpectedCount ( ) { return expectedCount ; } public long getSleepForEmptyTest ( ) { return sleepForEmptyTest ; } public void setSleepForEmptyTest ( long sleepForEmptyTest ) { this . sleepForEmptyTest = sleepForEmptyTest ; } protected synchronized void onExchange ( Exchange exchange ) { try { log . debug ( getEndpointUri ( ) + " >>>> " + exchange ) ; receivedExchanges . add ( exchange ) ; Processor processor = processors . get ( getReceivedCounter ( ) ) ; if ( processor != null ) { processor . process ( exchange ) ; } if ( latch != null ) { latch . countDown ( ) ; } } catch ( Exception e ) { failures . add ( e ) ; } } protected void assertEquals ( String message , Object expectedValue , Object actualValue ) { if ( ! ObjectHelper . equals ( expectedValue , actualValue ) ) { fail ( message + ". Expected: <" + expectedValue + "> but was: <" + actualValue + ">" ) ; } } protected void assertTrue ( String message , boolean predicate ) { if ( ! predicate ) { fail ( message ) ; } } protected void fail ( Object message ) { throw new AssertionError ( getEndpointUri ( ) + " " + message ) ; } public int getExpectedMinimumCount ( ) { return expectedMinimumCount ; } public void await ( ) throws InterruptedException { if ( latch != null ) { latch . await ( ) ; } } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch != null ) { return latch . await ( timeout , unit ) ; } return true ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . spring . xml ; import org . springframework . beans . SimpleTypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import java . lang . reflect . InvocationTargetException ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class BuilderAction { private final MethodInfo methodInfo ; private final HashMap < String , Object > parameterValues ; public BuilderAction ( MethodInfo methodInfo , HashMap < String , Object > parameterValues ) { this . methodInfo = methodInfo ; this . parameterValues = parameterValues ; } public Object invoke ( BeanFactory beanFactory , Object rootBuilder , Object contextBuilder ) { SimpleTypeConverter converter = new SimpleTypeConverter ( ) ; Object args [ ] = new Object [ methodInfo . parameters . size ( ) ] ; int pos = 0 ; for ( Map . Entry < String , Class > entry : methodInfo . parameters . entrySet ( ) ) { String paramName = entry . getKey ( ) ; Class paramClass = entry . getValue ( ) ; Object value = parameterValues . get ( paramName ) ; if ( value != null ) { value = replaceBeanReferences ( beanFactory , rootBuilder , value ) ; args [ pos ] = converter . convertIfNecessary ( value , paramClass ) ; } } try { return methodInfo . method . invoke ( contextBuilder , args ) ; } catch ( InvocationTargetException e ) { throw new IllegalArgumentException ( e . getCause ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new IllegalArgumentException ( e ) ; } } protected Object replaceBeanReferences ( BeanFactory beanFactory , Object rootBuilder , Object value ) { if ( value . getClass ( ) == RuntimeBeanReference . class ) { String beanName = ( ( RuntimeBeanReference ) value ) . getBeanName ( ) ; value = beanFactory . getBean ( beanName ) ; } if ( value . getClass ( ) == BuilderStatement . class ) { BuilderStatement bs = ( BuilderStatement ) value ; value = bs . create ( beanFactory , rootBuilder ) ; } if ( value instanceof List ) { List list = ( List ) value ; for ( int i = 0 , size = list . size ( ) ; i < size ; i ++ ) { list . set ( i , replaceBeanReferences ( beanFactory , rootBuilder , list . get ( i ) ) ) ; } } return value ; } public String getName ( ) { return methodInfo . getName ( ) ; } public MethodInfo getMethodInfo ( ) { return methodInfo ; } } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . ReflectionInjector ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class DefaultTypeConverter implements TypeConverter , TypeConverterRegistry { private static final transient Log log = LogFactory . getLog ( DefaultTypeConverter . class ) ; private Map < TypeMapping , TypeConverter > typeMappings = new HashMap < TypeMapping , TypeConverter > ( ) ; private Injector injector ; private List < TypeConverterLoader > typeConverterLoaders = new ArrayList < TypeConverterLoader > ( ) ; private List < TypeConverter > fallbackConverters = new ArrayList < TypeConverter > ( ) ; private boolean loaded ; public DefaultTypeConverter ( ) { typeConverterLoaders . add ( new AnnotationTypeConverterLoader ( ) ) ; fallbackConverters . add ( new PropertyEditorTypeConverter ( ) ) ; fallbackConverters . add ( new ToStringTypeConverter ( ) ) ; fallbackConverters . add ( new ArrayTypeConverter ( ) ) ; } public DefaultTypeConverter ( Injector injector ) { this ( ) ; this . injector = injector ; } public < T > T convertTo ( Class < T > toType , Object value ) { if ( toType . isInstance ( value ) ) { return toType . cast ( value ) ; } checkLoaded ( ) ; TypeConverter converter = getOrFindTypeConverter ( toType , value ) ; if ( converter != null ) { return converter . convertTo ( toType , value ) ; } for ( TypeConverter fallback : fallbackConverters ) { T rc = fallback . convertTo ( toType , value ) ; if ( rc != null ) { return rc ; } } if ( boolean . class . isAssignableFrom ( toType ) ) { return ( T ) Boolean . FALSE ; } return null ; } public void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; synchronized ( typeMappings ) { TypeConverter converter = typeMappings . get ( key ) ; if ( converter != null ) { log . warn ( "Overriding type converter from: " + converter + " to: " + typeConverter ) ; } typeMappings . put ( key , typeConverter ) ; } } public TypeConverter getTypeConverter ( Class toType , Class fromType ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; synchronized ( typeMappings ) { return typeMappings . get ( key ) ; } } public Injector getInjector ( ) { if ( injector == null ) { injector = new ReflectionInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } protected < T > TypeConverter getOrFindTypeConverter ( Class toType , Object value ) { Class fromType = null ; if ( value != null ) { fromType = value . getClass ( ) ; } TypeMapping key = new TypeMapping ( toType , fromType ) ; TypeConverter converter ; synchronized ( typeMappings ) { converter = typeMappings . get ( key ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromType , value ) ; if ( converter != null ) { typeMappings . put ( key , converter ) ; } } } return converter ; } protected TypeConverter findTypeConverter ( Class toType , Class fromType , Object value ) { if ( fromType != null ) { Class fromSuperClass = fromType . getSuperclass ( ) ; if ( fromSuperClass != null && ! fromSuperClass . equals ( Object . class ) ) { TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } for ( Class type : fromType . getInterfaces ( ) ) { TypeConverter converter = getTypeConverter ( toType , type ) ; if ( converter != null ) { return converter ; } } if ( fromType . isArray ( ) && ! fromType . getComponentType ( ) . isPrimitive ( ) ) { if ( ! fromType . equals ( Object [ ] . class ) ) { fromSuperClass = Object [ ] . class ; TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } } } if ( fromType != null ) { Set < Map . Entry < TypeMapping , TypeConverter > > entries = typeMappings . entrySet ( ) ; for ( Map . Entry < TypeMapping , TypeConverter > entry : entries ) { TypeMapping key = entry . getKey ( ) ; Class aToType = key . getToType ( ) ; if ( toType . isAssignableFrom ( aToType ) ) { if ( fromType . isAssignableFrom ( key . getFromType ( ) ) ) { return entry . getValue ( ) ; } } } } return null ; } protected synchronized void checkLoaded ( ) { if ( ! loaded ) { loaded = true ; for ( TypeConverterLoader typeConverterLoader : typeConverterLoaders ) { try { typeConverterLoader . load ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } } protected static class TypeMapping { Class toType ; Class fromType ; public TypeMapping ( Class toType , Class fromType ) { this . toType = toType ; this . fromType = fromType ; } public Class getFromType ( ) { return fromType ; } public Class getToType ( ) { return toType ; } @ Override public boolean equals ( Object object ) { if ( object instanceof TypeMapping ) { TypeMapping that = ( TypeMapping ) object ; return ObjectHelper . equals ( this . fromType , that . fromType ) && ObjectHelper . equals ( this . toType , that . toType ) ; } return false ; } @ Override public int hashCode ( ) { int answer = toType . hashCode ( ) ; if ( fromType != null ) { answer *= 37 + fromType . hashCode ( ) ; } return answer ; } @ Override public String toString ( ) { return "[" + fromType + "=>" + toType + "]" ; } } } 	0
package org . apache . camel . processor . idempotent ; public interface MessageIdRepository { boolean contains ( String messageId ) ; } 	0
package org . apache . camel . spring . spi ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . spi . ComponentResolver ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . context . ApplicationContext ; public class SpringComponentResolver implements ComponentResolver { private final ApplicationContext applicationContext ; private final ComponentResolver nextResolver ; public SpringComponentResolver ( ApplicationContext applicationContext , ComponentResolver nextResolver ) { notNull ( applicationContext , "applicationContext" ) ; this . applicationContext = applicationContext ; this . nextResolver = nextResolver ; } public Component resolveComponent ( String name , CamelContext context ) throws Exception { Object bean = null ; try { bean = applicationContext . getBean ( name ) ; } catch ( NoSuchBeanDefinitionException e ) { } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } else { throw new IllegalArgumentException ( "Bean with name: " + name + " in spring context is not a Component: " + bean ) ; } } if ( nextResolver == null ) { return null ; } return nextResolver . resolveComponent ( name , context ) ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . transport . local . LocalTransportFactory ; public class CxfConsumer extends DefaultConsumer < CxfExchange > { private CxfEndpoint endpoint ; private final LocalTransportFactory transportFactory ; private Destination destination ; public CxfConsumer ( CxfEndpoint endpoint , Processor processor , LocalTransportFactory transportFactory ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . transportFactory = transportFactory ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; destination = transportFactory . getDestination ( endpoint . getEndpointInfo ( ) ) ; destination . setMessageObserver ( new MessageObserver ( ) { public void onMessage ( Message message ) { incomingCxfMessage ( message ) ; } } ) ; } @ Override protected void doStop ( ) throws Exception { if ( destination != null ) { destination . shutdown ( ) ; } super . doStop ( ) ; } protected void incomingCxfMessage ( Message message ) { try { CxfExchange exchange = endpoint . createExchange ( message ) ; getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	0
package org . apache . camel . component . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . Consumer ; import org . apache . camel . Producer ; import org . apache . camel . Component ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; public class ProcessorEndpoint extends DefaultEndpoint < Exchange > { private final Processor processor ; private final LoadBalancer loadBalancer ; protected ProcessorEndpoint ( String endpointUri , Component component , Processor processor , LoadBalancer loadBalancer ) { super ( endpointUri , component ) ; this . processor = processor ; this . loadBalancer = loadBalancer ; } public Exchange createExchange ( ) { return new DefaultExchange ( getContext ( ) ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new ProcessorEndpointConsumer ( this , processor ) ; } public Processor getProcessor ( ) { return processor ; } public LoadBalancer getLoadBalancer ( ) { return loadBalancer ; } protected void onExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; loadBalancer . process ( exchange ) ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . builder . xml ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class NamespaceBuilder { private Map < String , String > namespaces = new HashMap < String , String > ( ) ; public static NamespaceBuilder namespaceContext ( ) { return new NamespaceBuilder ( ) ; } public static NamespaceBuilder namespaceContext ( String prefix , String uri ) { return new NamespaceBuilder ( ) . namespace ( prefix , uri ) ; } public NamespaceBuilder namespace ( String prefix , String uri ) { namespaces . put ( prefix , uri ) ; return this ; } public XPathBuilder xpath ( String xpath ) { XPathBuilder answer = XPathBuilder . xpath ( xpath ) ; Set < Map . Entry < String , String > > entries = namespaces . entrySet ( ) ; for ( Map . Entry < String , String > entry : entries ) { answer . namespace ( entry . getKey ( ) , entry . getValue ( ) ) ; } return answer ; } } 	0
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . Collections ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Policy ; public class PolicyBuilder implements ProcessorFactory { private final ArrayList < Policy > policies = new ArrayList < Policy > ( ) ; private final FromBuilder parent ; private FromBuilder target ; public PolicyBuilder ( FromBuilder parent ) { this . parent = parent ; } @ Fluent ( "policy" ) public PolicyBuilder add ( @ FluentArg ( "ref" ) Policy interceptor ) { policies . add ( interceptor ) ; return this ; } @ Fluent ( callOnElementEnd = true ) public FromBuilder target ( ) { this . target = new FromBuilder ( parent ) ; return target ; } public Processor createProcessor ( ) throws Exception { if ( target == null ) throw new RuntimeCamelException ( "target not provided." ) ; Processor last = target . createProcessor ( ) ; Collections . reverse ( policies ) ; for ( Policy p : policies ) { last = p . wrap ( last ) ; } return last ; } } 	0
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . ProcessRules ; public class ProcessContext { private Exchange exchange ; private ProcessRules processRules ; private ActivityRules activityRules ; private ProcessInstance processInstance ; private ActivityState activityState ; public ProcessContext ( Exchange exchange , ActivityRules activityRules , ActivityState activityState ) { this . exchange = exchange ; this . activityRules = activityRules ; this . activityState = activityState ; this . processRules = activityRules . getProcessRules ( ) ; this . processInstance = activityState . getProcessInstance ( ) ; } public ActivityRules getActivity ( ) { return activityRules ; } public void setActivity ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public ActivityState getActivityState ( ) { return activityState ; } public void setActivityState ( ActivityState activityState ) { this . activityState = activityState ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public ProcessRules getProcessDefinition ( ) { return processRules ; } public void setProcessDefinition ( ProcessRules processRules ) { this . processRules = processRules ; } public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; } public ActivityState getActivityState ( ActivityRules activityRules ) { return getProcessInstance ( ) . getActivityState ( activityRules ) ; } public void onStarted ( ActivityState activityState ) { } public void onCompleted ( ActivityState activityState ) { } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; import java . util . HashMap ; import java . util . Map ; public class DefaultExchange implements Exchange { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > headers ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId = DefaultExchange . defaultIdGenerator . generateId ( ) ; public DefaultExchange ( CamelContext context ) { this . context = context ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setHeaders ( safeCopy ( exchange . getProperties ( ) ) ) ; setIn ( safeCopy ( exchange . getIn ( ) ) ) ; setOut ( safeCopy ( exchange . getOut ( ) ) ) ; setFault ( safeCopy ( exchange . getFault ( ) ) ) ; setException ( exchange . getException ( ) ) ; } static private Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) return null ; return new HashMap < String , Object > ( properties ) ; } static private Message safeCopy ( Message message ) { if ( message == null ) return null ; return message . copy ( ) ; } public Exchange newInstance ( ) { return new DefaultExchange ( context ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( headers != null ) { return headers . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { getProperties ( ) . put ( name , value ) ; } public Map < String , Object > getProperties ( ) { if ( headers == null ) { headers = new HashMap < String , Object > ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Message getFault ( ) { return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1
package org . apache . camel . util ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import java . util . Comparator ; import java . util . List ; public class ExpressionListComparator < E extends Exchange > implements Comparator < E > { private final List < Expression < E > > expressions ; public ExpressionListComparator ( List < Expression < E > > expressions ) { this . expressions = expressions ; } public int compare ( E e1 , E e2 ) { for ( Expression < E > expression : expressions ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; int answer = ObjectHelper . compare ( o1 , o2 ) ; if ( answer != 0 ) { return answer ; } } return 0 ; } } 	0
package org . apache . camel ; public class RuntimeCamelException extends RuntimeException { private static final long serialVersionUID = 8046489554418284257L ; public RuntimeCamelException ( ) { } public RuntimeCamelException ( String message ) { super ( message ) ; } public RuntimeCamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeCamelException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; public abstract class ScheduledPollConsumer < E extends Exchange > extends DefaultConsumer < E > implements Runnable { private static final transient Log log = LogFactory . getLog ( ScheduledPollConsumer . class ) ; private final ScheduledExecutorService executor ; private long initialDelay = 1000 ; private long delay = 500 ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; private boolean useFixedDelay ; private ScheduledFuture < ? > future ; public ScheduledPollConsumer ( DefaultEndpoint < E > endpoint , Processor processor ) { this ( endpoint , processor , endpoint . getExecutorService ( ) ) ; } public ScheduledPollConsumer ( Endpoint < E > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor ) ; this . executor = executor ; if ( executor == null ) { throw new IllegalArgumentException ( "A non null ScheduledExecutorService must be provided." ) ; } } public void run ( ) { log . debug ( "Starting to poll" ) ; try { poll ( ) ; } catch ( Exception e ) { log . warn ( "Caught: " + e , e ) ; } } public long getInitialDelay ( ) { return initialDelay ; } public void setInitialDelay ( long initialDelay ) { this . initialDelay = initialDelay ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } public void setTimeUnit ( TimeUnit timeUnit ) { this . timeUnit = timeUnit ; } public boolean isUseFixedDelay ( ) { return useFixedDelay ; } public void setUseFixedDelay ( boolean useFixedDelay ) { this . useFixedDelay = useFixedDelay ; } protected abstract void poll ( ) throws Exception ; @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( isUseFixedDelay ( ) ) { future = executor . scheduleWithFixedDelay ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } else { future = executor . scheduleAtFixedRate ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } } @ Override protected void doStop ( ) throws Exception { if ( future != null ) { future . cancel ( false ) ; } super . doStop ( ) ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import java . util . Collection ; public class CompositeProcessor extends ServiceSupport implements Processor { private final Collection < Processor > processors ; public CompositeProcessor ( Collection < Processor > processors ) { this . processors = processors ; } public void process ( Exchange exchange ) throws Exception { for ( Processor processor : processors ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "[ " ) ; boolean first = true ; for ( Processor processor : processors ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( processor . toString ( ) ) ; } builder . append ( " ]" ) ; return builder . toString ( ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } } 	0
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class RuntimeJmsException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeJmsException ( String message , JMSException cause ) { super ( message , cause ) ; } } 	0
package org . apache . camel . impl . converter ; public interface TypeConverterLoader { void load ( TypeConverterRegistry registry ) throws Exception ; } 	0
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; public class JMXExchange extends DefaultExchange { public JMXExchange ( CamelContext camelContext , Notification notification ) { super ( camelContext ) ; setIn ( new JMXMessage ( notification ) ) ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import javax . jms . Message ; public class JmsExchange extends DefaultExchange { private JmsBinding binding ; public JmsExchange ( CamelContext context , JmsBinding binding ) { super ( context ) ; this . binding = binding ; } public JmsExchange ( CamelContext context , JmsBinding binding , Message message ) { this ( context , binding ) ; setIn ( new JmsMessage ( message ) ) ; } @ Override public JmsMessage getIn ( ) { return ( JmsMessage ) super . getIn ( ) ; } @ Override public JmsMessage getOut ( ) { return ( JmsMessage ) super . getOut ( ) ; } @ Override public JmsMessage getOut ( boolean lazyCreate ) { return ( JmsMessage ) super . getOut ( lazyCreate ) ; } @ Override public JmsMessage getFault ( ) { return ( JmsMessage ) super . getFault ( ) ; } public JmsBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new JmsExchange ( getContext ( ) , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getJmsMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } @ Override protected JmsMessage createInMessage ( ) { return new JmsMessage ( ) ; } @ Override protected JmsMessage createOutMessage ( ) { return new JmsMessage ( ) ; } } 	0
package org . apache . camel ; public interface TypeConverter { < T > T convertTo ( Class < T > type , Object value ) ; } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Transformer transformer ; private ResultHandler resultHandler = new StringResultHandler ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Transformer transformer ) { this . transformer = transformer ; } @ Override public String toString ( ) { return "XSLT[" + transformer + "]" ; } public synchronized void process ( Exchange exchange ) throws Exception { Transformer transformer = getTransformer ( ) ; if ( transformer == null ) { throw new IllegalArgumentException ( "No transformer configured!" ) ; } configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; Result result = resultHandler . getResult ( ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( exchange . getIn ( ) ) ; } public static XsltBuilder xslt ( Transformer transformer ) { return new XsltBuilder ( transformer ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandler ( new StreamResultHandler ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandler ( new StringResultHandler ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandler ( new DomResultHandler ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Transformer getTransformer ( ) { return transformer ; } public void setTransformer ( Transformer transformer ) { this . transformer = transformer ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandler getResultHandler ( ) { return resultHandler ; } public void setResultHandler ( ResultHandler resultHandler ) { this . resultHandler = resultHandler ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { setTransformer ( converter . getTransformerFactory ( ) . newTransformer ( source ) ) ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { transformer . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	1
package org . apache . camel . impl ; import org . apache . camel . Route ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import java . util . List ; public class PollingConsumerRoute < E extends Exchange > extends Route < E > { private Processor processor ; public PollingConsumerRoute ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } @ Override public String toString ( ) { return "PollingConsumerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } public Processor getProcessor ( ) { return processor ; } public void setProcessor ( Processor processor ) { this . processor = processor ; } protected void addServices ( List < Service > services ) throws Exception { Processor processor = getProcessor ( ) ; if ( processor instanceof Service ) { Service service = ( Service ) processor ; services . add ( service ) ; } Endpoint < E > endpoint = getEndpoint ( ) ; PollingConsumer < E > consumer = endpoint . createPollingConsumer ( ) ; if ( consumer != null ) { services . add ( consumer ) ; } } } 	0
package org . apache . camel . util ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class CollectionHelper { public static void appendValue ( Map map , Object key , Object value ) { Object oldValue = map . get ( key ) ; if ( oldValue != null ) { List list ; if ( oldValue instanceof List ) { list = ( List ) oldValue ; } else { list = new ArrayList ( ) ; list . add ( oldValue ) ; } list . add ( value ) ; } else { map . put ( key , value ) ; } } } 	0
package org . apache . camel . spi ; public interface Provider < T > { T get ( ) ; } 	0
package org . apache . camel . component . queue ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import java . util . concurrent . TimeUnit ; public class QueueEndpointConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > , Runnable { private QueueEndpoint < E > endpoint ; private Processor processor ; private Thread thread ; public QueueEndpointConsumer ( QueueEndpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "QueueEndpointConsumer: " + endpoint . getEndpointUri ( ) ; } public void run ( ) { while ( ! isStopping ( ) ) { E exchange ; try { exchange = endpoint . getQueue ( ) . poll ( 1000 , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { break ; } if ( exchange != null && ! isStopping ( ) ) { try { processor . process ( exchange ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } } } protected void doStart ( ) throws Exception { thread = new Thread ( this , endpoint . getEndpointUri ( ) ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { thread . join ( ) ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public interface ProcessorFactory { public Processor createProcessor ( ) throws Exception ; } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; public class DefaultComponentResolver < E extends Exchange > implements ComponentResolver < E > { protected static final FactoryFinder componentFactory = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; public Component < E > resolveComponent ( String name , CamelContext context ) { Class type ; try { type = componentFactory . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { return null ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no EndpointResolver registered for scheme : " + name , e ) ; } if ( type == null ) { return null ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component < E > ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	0
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . CamelTemplate ; import org . apache . cxf . Bus ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; public class CamelTransportBase { private String replyDestination ; CamelTemplate < Exchange > template ; private final CamelContext camelContext ; Bus bus ; EndpointInfo endpointInfo ; public CamelTransportBase ( CamelContext camelContext , Bus bus , EndpointInfo endpointInfo , boolean b , String baseBeanNameSuffix ) { this . camelContext = camelContext ; this . bus = bus ; this . endpointInfo = endpointInfo ; this . template = new CamelTemplate < Exchange > ( camelContext ) ; } public void populateIncomingContext ( Exchange exchange , MessageImpl inMessage , String camelServerRequestHeaders ) { } public String getReplyDestination ( ) { return replyDestination ; } public void setMessageProperties ( Message inMessage , Exchange reply ) { } public void close ( ) { if ( template != null ) { try { template . stop ( ) ; } catch ( Exception e ) { } } } protected void marshal ( Object payload , String replyTo , Exchange exchange ) { org . apache . camel . Message message = exchange . getIn ( ) ; message . setBody ( payload ) ; if ( replyTo != null ) { message . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , replyTo ) ; } } public byte [ ] unmarshal ( Exchange exchange ) { return exchange . getIn ( ) . getBody ( byte [ ] . class ) ; } } 	0
package org . apache . camel . util ; import org . apache . camel . spi . Injector ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import java . util . concurrent . ConcurrentHashMap ; public class FactoryFinder { private final String path ; private final ConcurrentHashMap classMap = new ConcurrentHashMap ( ) ; public FactoryFinder ( ) { this ( "META-INF/services/org/apache/camel/" ) ; } public FactoryFinder ( String path ) { this . path = path ; } public Object newInstance ( String key ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { return newInstance ( key , ( String ) null ) ; } public Object newInstance ( String key , String propertyPrefix ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { Class clazz = findClass ( key , propertyPrefix ) ; return clazz . newInstance ( ) ; } public Object newInstance ( String key , Injector injector ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , null ) ; } public Object newInstance ( String key , Injector injector , String propertyPrefix ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; return injector . newInstance ( type ) ; } public Class findClass ( String key ) throws ClassNotFoundException , IOException { return findClass ( key , null ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; if ( clazz == null ) { clazz = newInstance ( doFindFactoryProperies ( key ) , propertyPrefix ) ; classMap . put ( propertyPrefix + key , clazz ) ; } return clazz ; } private Class newInstance ( Properties properties , String propertyPrefix ) throws ClassNotFoundException , IOException { String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } Class clazz = null ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { clazz = loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { } } if ( clazz == null ) { clazz = FactoryFinder . class . getClassLoader ( ) . loadClass ( className ) ; } return clazz ; } private Properties doFindFactoryProperies ( String key ) throws IOException { String uri = path + key ; ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = getClass ( ) . getClassLoader ( ) ; } InputStream in = classLoader . getResourceAsStream ( uri ) ; if ( in == null ) { in = FactoryFinder . class . getClassLoader ( ) . getResourceAsStream ( uri ) ; if ( in == null ) { throw new NoFactoryAvailableException ( uri ) ; } } BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; } finally { try { reader . close ( ) ; } catch ( Exception e ) { } } } } 	0
package org . apache . camel ; public interface Processor { void process ( Exchange exchange ) throws Exception ; } 	1
package org . apache . camel . spring ; import org . apache . camel . impl . ServiceSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . ClassPathXmlApplicationContext ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; public class Main extends ServiceSupport { private static final Log log = LogFactory . getLog ( Main . class ) ; private String applicationContextUri = "META-INF/spring/*.xml" ; private AbstractApplicationContext applicationContext ; private List < Option > options = new ArrayList < Option > ( ) ; private CountDownLatch latch = new CountDownLatch ( 1 ) ; private AtomicBoolean completed = new AtomicBoolean ( false ) ; public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . parseArguments ( args ) ; main . run ( ) ; } public Main ( ) { addOption ( new Option ( "h" , "help" , "Displays the help screen" ) { protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { showOptions ( ) ; completed ( ) ; } } ) ; addOption ( new ParameterOption ( "a" , "applicationContext" , "Sets the classpath based pring ApplicationContext" , "applicationContext" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setApplicationContextUri ( parameter ) ; } } ) ; } public void run ( ) { if ( ! completed . get ( ) ) { try { start ( ) ; waitUntilCompleted ( ) ; stop ( ) ; } catch ( Exception e ) { log . error ( "Failed: " + e , e ) ; } } } public void completed ( ) { completed . set ( true ) ; latch . countDown ( ) ; } public void showOptions ( ) { System . out . println ( "Apache Camel Runner takes the following options" ) ; System . out . println ( ) ; for ( Option option : options ) { System . out . println ( "  " + option . getAbbreviation ( ) + " or " + option . getFullName ( ) + " = " + option . getDescription ( ) ) ; } } public void parseArguments ( String [ ] arguments ) { LinkedList < String > args = new LinkedList < String > ( Arrays . asList ( arguments ) ) ; boolean valid = true ; while ( ! args . isEmpty ( ) ) { String arg = args . removeFirst ( ) ; boolean handled = false ; for ( Option option : options ) { if ( option . processOption ( arg , args ) ) { handled = true ; break ; } } if ( ! handled ) { System . out . println ( "Unknown option: " + arg ) ; System . out . println ( ) ; valid = false ; break ; } } if ( ! valid ) { showOptions ( ) ; completed ( ) ; } } public void addOption ( Option option ) { options . add ( option ) ; } public abstract class Option { private String abbreviation ; private String fullName ; private String description ; protected Option ( String abbreviation , String fullName , String description ) { this . abbreviation = "-" + abbreviation ; this . fullName = "-" + fullName ; this . description = description ; } public boolean processOption ( String arg , LinkedList < String > remainingArgs ) { if ( arg . equalsIgnoreCase ( abbreviation ) || fullName . startsWith ( arg ) ) { doProcess ( arg , remainingArgs ) ; return true ; } return false ; } public String getAbbreviation ( ) { return abbreviation ; } public String getDescription ( ) { return description ; } public String getFullName ( ) { return fullName ; } protected abstract void doProcess ( String arg , LinkedList < String > remainingArgs ) ; } public abstract class ParameterOption extends Option { private String parameterName ; protected ParameterOption ( String abbreviation , String fullName , String description , String parameterName ) { super ( abbreviation , fullName , description ) ; this . parameterName = parameterName ; } protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { if ( remainingArgs . isEmpty ( ) ) { System . err . println ( "Expected fileName for " ) ; showOptions ( ) ; completed ( ) ; } else { String parameter = remainingArgs . removeFirst ( ) ; doProcess ( arg , parameter , remainingArgs ) ; } } protected abstract void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) ; } public AbstractApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( AbstractApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String getApplicationContextUri ( ) { return applicationContextUri ; } public void setApplicationContextUri ( String applicationContextUri ) { this . applicationContextUri = applicationContextUri ; } protected void doStart ( ) throws Exception { log . info ( "Apache Camel " + getVersion ( ) + " starting" ) ; if ( applicationContext == null ) { applicationContext = createDefaultApplicationContext ( ) ; } applicationContext . start ( ) ; } protected AbstractApplicationContext createDefaultApplicationContext ( ) { return new ClassPathXmlApplicationContext ( getApplicationContextUri ( ) ) ; } protected void doStop ( ) throws Exception { log . info ( "Apache Camel terminating" ) ; if ( applicationContext != null ) { applicationContext . close ( ) ; } } protected void waitUntilCompleted ( ) { while ( ! completed . get ( ) ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { } } } protected String getVersion ( ) { Package aPackage = Package . getPackage ( "org.apache.camel" ) ; if ( aPackage != null ) { String version = aPackage . getImplementationVersion ( ) ; if ( version == null ) { version = aPackage . getSpecificationVersion ( ) ; if ( version == null ) { version = "" ; } } return version ; } return "" ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import javax . jbi . messaging . MessageExchange ; import javax . jbi . messaging . NormalizedMessage ; public class JbiExchange extends DefaultExchange { private final JbiBinding binding ; private MessageExchange messageExchange ; public JbiExchange ( CamelContext context , JbiBinding binding ) { super ( context ) ; this . binding = binding ; } public JbiExchange ( CamelContext context , JbiBinding binding , MessageExchange messageExchange ) { super ( context ) ; this . binding = binding ; this . messageExchange = messageExchange ; setIn ( new JbiMessage ( messageExchange . getMessage ( "in" ) ) ) ; setOut ( new JbiMessage ( messageExchange . getMessage ( "out" ) ) ) ; setFault ( new JbiMessage ( messageExchange . getMessage ( "fault" ) ) ) ; } @ Override public JbiMessage getIn ( ) { return ( JbiMessage ) super . getIn ( ) ; } @ Override public JbiMessage getOut ( ) { return ( JbiMessage ) super . getOut ( ) ; } @ Override public JbiMessage getOut ( boolean lazyCreate ) { return ( JbiMessage ) super . getOut ( lazyCreate ) ; } @ Override public JbiMessage getFault ( ) { return ( JbiMessage ) super . getFault ( ) ; } public JbiBinding getBinding ( ) { return binding ; } public MessageExchange getMessageExchange ( ) { return messageExchange ; } public NormalizedMessage getInMessage ( ) { return getIn ( ) . getNormalizedMessage ( ) ; } public NormalizedMessage getOutMessage ( ) { return getOut ( ) . getNormalizedMessage ( ) ; } public NormalizedMessage getFaultMessage ( ) { return getFault ( ) . getNormalizedMessage ( ) ; } @ Override protected JbiMessage createInMessage ( ) { return new JbiMessage ( ) ; } @ Override protected JbiMessage createOutMessage ( ) { return new JbiMessage ( ) ; } } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . impl . CachingInjector ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public synchronized < T > T convertTo ( Class < T > type , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate aninstance of: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	0
package org . apache . camel . spi ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; public abstract class XmlUnmarshaller implements Unmarshaller { public Object unmarshal ( InputStream stream ) throws IOException { return unmarshal ( new StreamSource ( stream ) ) ; } abstract public Object unmarshal ( Source stream ) throws IOException ; } 	0
package org . apache . camel . builder . script ; import org . apache . camel . RuntimeCamelException ; public class ScriptEvaluationException extends RuntimeCamelException { public ScriptEvaluationException ( String message ) { super ( message ) ; } public ScriptEvaluationException ( String message , Throwable cause ) { super ( message , cause ) ; } public ScriptEvaluationException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . spi ; import org . apache . camel . Component ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponentResolver ; public interface ComponentResolver < E extends Exchange > { Component < E > resolveComponent ( String name , CamelContext context ) throws Exception ; } 	0
package org . apache . camel . component . http ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class HttpComponent extends DefaultComponent < HttpExchange > { private CamelServlet camelServlet ; public void connect ( HttpConsumer consumer ) throws Exception { camelServlet . connect ( consumer ) ; } public void disconnect ( HttpConsumer consumer ) throws Exception { camelServlet . disconnect ( consumer ) ; } public CamelServlet getCamelServlet ( ) { return camelServlet ; } public void setCamelServlet ( CamelServlet camelServlet ) { this . camelServlet = camelServlet ; } @ Override protected Endpoint < HttpExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new HttpEndpoint ( uri , this ) ; } } 	0
package org . apache . camel . component . mail ; import org . springframework . mail . MailAuthenticationException ; import org . springframework . mail . MailException ; import org . springframework . mail . MailSendException ; import org . springframework . mail . javamail . JavaMailSenderImpl ; import javax . mail . AuthenticationFailedException ; import javax . mail . MessagingException ; import javax . mail . Transport ; import javax . mail . Folder ; import javax . mail . Store ; public class JavaMailConnection extends JavaMailSenderImpl { public Folder getFolder ( String protocol , String folderName ) { try { Store store = getSession ( ) . getStore ( protocol ) ; store . connect ( getHost ( ) , getPort ( ) , getUsername ( ) , getPassword ( ) ) ; return store . getFolder ( folderName ) ; } catch ( MessagingException e ) { throw new MailSendException ( "Mail server connection failed" , e ) ; } } } 	0
package org . apache . camel . builder ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . Pipeline ; import java . util . Collection ; public class PipelineBuilder extends FromBuilder { private final Collection < Endpoint > endpoints ; public PipelineBuilder ( FromBuilder parent , Collection < Endpoint > endpoints ) { super ( parent ) ; this . endpoints = endpoints ; } @ Override public Processor createProcessor ( ) throws Exception { return new Pipeline ( endpoints ) ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . ObjectHelper ; import java . net . URI ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; public abstract class DefaultComponent < E extends Exchange > extends ServiceSupport implements Component < E > { private int defaultThreadPoolSize = 5 ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; public DefaultComponent ( ) { } public DefaultComponent ( CamelContext context ) { this . camelContext = context ; } public Endpoint < E > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( uri ) ; String path = u . getHost ( ) ; if ( path == null ) { path = u . getSchemeSpecificPart ( ) ; } Map parameters = URISupport . parseParamters ( u ) ; Endpoint < E > endpoint = createEndpoint ( uri , path , parameters ) ; if ( endpoint == null ) { return null ; } if ( parameters != null ) { if ( endpoint instanceof ScheduledPollEndpoint ) { ScheduledPollEndpoint scheduledPollEndpoint = ( ScheduledPollEndpoint ) endpoint ; scheduledPollEndpoint . configureProperties ( parameters ) ; } IntrospectionSupport . setProperties ( endpoint , parameters ) ; } return endpoint ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext context ) { this . camelContext = context ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = createExecutorService ( ) ; } return executorService ; } public void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } protected ScheduledExecutorService createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( defaultThreadPoolSize , new ThreadFactory ( ) { int counter ; public synchronized Thread newThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setName ( "Thread" + ( ++ counter ) + " " + DefaultComponent . this . toString ( ) ) ; return thread ; } } ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { if ( executorService != null ) { executorService . shutdown ( ) ; } } abstract protected Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception ; } 	0
package org . apache . camel . bam ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . TemporalRule ; import org . apache . camel . util . ObjectHelper ; import java . util . Date ; public abstract class TimeExpression { private ActivityRules activityRules ; private ActivityBuilder builder ; private ActivityLifecycle lifecycle ; public TimeExpression ( ActivityBuilder builder , ActivityLifecycle lifecycle ) { this . lifecycle = lifecycle ; this . builder = builder ; this . activityRules = builder . getActivityRules ( ) ; } public boolean isActivityLifecycle ( ActivityRules activityRules , ActivityLifecycle lifecycle ) { return ObjectHelper . equals ( activityRules , this . activityRules ) && ObjectHelper . equals ( lifecycle , this . lifecycle ) ; } public TemporalRule after ( TimeExpression expression ) { TemporalRule rule = new TemporalRule ( expression , this ) ; rule . getSecond ( ) . getActivityRules ( ) . addRule ( rule ) ; return rule ; } public Date evaluate ( ProcessInstance processInstance ) { ActivityState state = processInstance . getActivityState ( activityRules ) ; if ( state != null ) { return evaluate ( processInstance , state ) ; } return null ; } public abstract Date evaluate ( ProcessInstance instance , ActivityState state ) ; public ActivityBuilder getBuilder ( ) { return builder ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ActivityLifecycle getLifecycle ( ) { return lifecycle ; } public ActivityState getActivityState ( ProcessInstance instance ) { return instance . getActivityState ( activityRules ) ; } public ActivityState getOrCreateActivityState ( ProcessInstance instance ) { return instance . getOrCreateActivityState ( activityRules ) ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . MulticastProcessor ; import java . util . Collection ; public class MulticastBuilder extends FromBuilder { private final Collection < Endpoint > endpoints ; public MulticastBuilder ( FromBuilder parent , Collection < Endpoint > endpoints ) { super ( parent ) ; this . endpoints = endpoints ; } @ Override public Processor createProcessor ( ) throws Exception { return new MulticastProcessor ( endpoints ) ; } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . mail . Flags ; import javax . mail . Folder ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Transport ; import javax . mail . event . MessageCountEvent ; import javax . mail . event . MessageCountListener ; public class MailConsumer extends ScheduledPollConsumer < MailExchange > implements MessageCountListener { private static final transient Log log = LogFactory . getLog ( MailConsumer . class ) ; private final MailEndpoint endpoint ; private final Folder folder ; public MailConsumer ( MailEndpoint endpoint , Processor processor , Folder folder ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . folder = folder ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; ensureFolderIsOpen ( ) ; folder . addMessageCountListener ( this ) ; } @ Override protected void doStop ( ) throws Exception { folder . removeMessageCountListener ( this ) ; folder . close ( true ) ; super . doStop ( ) ; } public void messagesAdded ( MessageCountEvent event ) { Message [ ] messages = event . getMessages ( ) ; for ( Message message : messages ) { try { if ( ! message . getFlags ( ) . contains ( Flags . Flag . DELETED ) ) { processMessage ( message ) ; flagMessageDeleted ( message ) ; } } catch ( MessagingException e ) { handleException ( e ) ; } } } public void messagesRemoved ( MessageCountEvent event ) { Message [ ] messages = event . getMessages ( ) ; for ( Message message : messages ) { if ( log . isDebugEnabled ( ) ) { try { log . debug ( "Removing message: " + message . getSubject ( ) ) ; } catch ( MessagingException e ) { log . debug ( "Ignored: " + e ) ; } } } } protected void poll ( ) throws Exception { ensureFolderIsOpen ( ) ; int count = folder . getMessageCount ( ) ; if ( count > 0 ) { Message [ ] messages = folder . getMessages ( ) ; MessageCountEvent event = new MessageCountEvent ( folder , MessageCountEvent . ADDED , true , messages ) ; messagesAdded ( event ) ; } else if ( count == - 1 ) { throw new MessagingException ( "Folder: " + folder . getFullName ( ) + " is closed" ) ; } folder . close ( true ) ; } protected void processMessage ( Message message ) { try { MailExchange exchange = endpoint . createExchange ( message ) ; getProcessor ( ) . process ( exchange ) ; } catch ( Throwable e ) { handleException ( e ) ; } } protected void ensureFolderIsOpen ( ) throws MessagingException { if ( ! folder . isOpen ( ) ) { folder . open ( Folder . READ_WRITE ) ; } } protected void flagMessageDeleted ( Message message ) throws MessagingException { if ( endpoint . getConfiguration ( ) . isDeleteProcessedMessages ( ) ) { message . setFlag ( Flags . Flag . DELETED , true ) ; } else { message . setFlag ( Flags . Flag . SEEN , true ) ; } } } 	0
package org . apache . camel . view ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . EventDrivenConsumerRoute ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . List ; public class RouteDotGenerator { private static final transient Log log = LogFactory . getLog ( RouteDotGenerator . class ) ; private String file = "CamelRoutes.dot" ; public String getFile ( ) { return file ; } public void setFile ( String file ) { this . file = file ; } public void drawRoutes ( CamelContext context ) throws IOException { PrintWriter writer = new PrintWriter ( new FileWriter ( file ) ) ; generateFile ( writer , context ) ; } protected void generateFile ( PrintWriter writer , CamelContext context ) { writer . println ( "digraph \"Camel Routes\" {" ) ; writer . println ( ) ; writer . println ( "label=\"Camel Container: " + context + "\"];" ) ; writer . println ( ) ; writer . println ( "node [style = \"rounded,filled\", fillcolor = yellow, fontname=\"Helvetica-Oblique\"];" ) ; writer . println ( ) ; printRoutes ( writer , context . getRoutes ( ) ) ; } protected void printRoutes ( PrintWriter writer , List < Route > routes ) { for ( Route r : routes ) { Endpoint end = r . getEndpoint ( ) ; writer . print ( end . getEndpointUri ( ) ) ; writer . print ( " -> " ) ; writer . print ( r ) ; writer . print ( " -> " ) ; if ( r instanceof EventDrivenConsumerRoute ) { EventDrivenConsumerRoute consumerRoute = ( EventDrivenConsumerRoute ) r ; Processor p = consumerRoute . getProcessor ( ) ; writer . println ( p ) ; } } } } 	0
package org . apache . camel . spring . util ; import org . apache . camel . Expression ; public interface MethodInvocationStrategy { Expression getDefaultParameterTypeExpression ( Class parameterType ) ; } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . cxf . Bus ; import org . apache . cxf . bus . CXFBusFactory ; import java . net . URI ; import java . util . Map ; import java . util . Properties ; public class CxfInvokeComponent extends DefaultComponent < CxfExchange > { private Bus bus ; public CxfInvokeComponent ( ) { bus = CXFBusFactory . getDefaultBus ( ) ; } public CxfInvokeComponent ( CamelContext context ) { super ( context ) ; bus = CXFBusFactory . getDefaultBus ( ) ; } @ Override protected Endpoint < CxfExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new CxfInvokeEndpoint ( getAddress ( remaining ) , this , getQueryAsProperties ( new URI ( remaining ) ) ) ; } protected Properties getQueryAsProperties ( URI u ) { Properties retval = new Properties ( ) ; if ( u . getQuery ( ) != null ) { String [ ] parameters = u . getQuery ( ) . split ( "&" ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { String [ ] s = parameters [ i ] . split ( "=" ) ; retval . put ( s [ 0 ] , s [ 1 ] ) ; } } return retval ; } protected String getAddress ( String uri ) { int index = uri . indexOf ( "?" ) ; if ( - 1 != index ) { return uri . substring ( 0 , index ) ; } return uri ; } public Bus getBus ( ) { return bus ; } } 	0
package org . apache . camel . component . rmi ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . impl . DefaultComponent ; public class RmiComponent extends DefaultComponent < PojoExchange > { public RmiComponent ( ) { } public RmiComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < PojoExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new RmiEndpoint ( uri , this ) ; } } 	0
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class URISupport { public static class CompositeData { String scheme ; String path ; URI components [ ] ; Map parameters ; String fragment ; public String host ; public URI [ ] getComponents ( ) { return components ; } public String getFragment ( ) { return fragment ; } public Map getParameters ( ) { return parameters ; } public String getScheme ( ) { return scheme ; } public String getPath ( ) { return path ; } public String getHost ( ) { return host ; } public URI toURI ( ) throws URISyntaxException { StringBuffer sb = new StringBuffer ( ) ; if ( scheme != null ) { sb . append ( scheme ) ; sb . append ( ':' ) ; } if ( host != null && host . length ( ) != 0 ) { sb . append ( host ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( ',' ) ; } sb . append ( components [ i ] . toString ( ) ) ; } sb . append ( ')' ) ; } if ( path != null ) { sb . append ( '/' ) ; sb . append ( path ) ; } if ( ! parameters . isEmpty ( ) ) { sb . append ( "?" ) ; sb . append ( createQueryString ( parameters ) ) ; } if ( fragment != null ) { sb . append ( "#" ) ; sb . append ( fragment ) ; } return new URI ( sb . toString ( ) ) ; } } public static Map parseQuery ( String uri ) throws URISyntaxException { try { Map rc = new HashMap ( ) ; if ( uri != null ) { String [ ] parameters = uri . split ( "&" ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { int p = parameters [ i ] . indexOf ( "=" ) ; if ( p >= 0 ) { String name = URLDecoder . decode ( parameters [ i ] . substring ( 0 , p ) , "UTF-8" ) ; String value = URLDecoder . decode ( parameters [ i ] . substring ( p + 1 ) , "UTF-8" ) ; rc . put ( name , value ) ; } else { rc . put ( parameters [ i ] , null ) ; } } } return rc ; } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static Map parseParamters ( URI uri ) throws URISyntaxException { String query = uri . getQuery ( ) ; if ( query == null ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; int idx = schemeSpecificPart . lastIndexOf ( '?' ) ; if ( idx < 0 ) { return Collections . EMPTY_MAP ; } else { query = schemeSpecificPart . substring ( idx + 1 ) ; } } else { query = stripPrefix ( query , "?" ) ; } return parseQuery ( query ) ; } public static URI removeQuery ( URI uri ) throws URISyntaxException { return createURIWithQuery ( uri , null ) ; } public static URI createURIWithQuery ( URI uri , String query ) throws URISyntaxException { return new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , query , uri . getFragment ( ) ) ; } public static CompositeData parseComposite ( URI uri ) throws URISyntaxException { CompositeData rc = new CompositeData ( ) ; rc . scheme = uri . getScheme ( ) ; String ssp = stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) . trim ( ) ; parseComposite ( uri , rc , ssp ) ; rc . fragment = uri . getFragment ( ) ; return rc ; } private static void parseComposite ( URI uri , CompositeData rc , String ssp ) throws URISyntaxException { String componentString ; String params ; if ( ! checkParenthesis ( ssp ) ) { throw new URISyntaxException ( uri . toString ( ) , "Not a matching number of '(' and ')' parenthesis" ) ; } int p ; int intialParen = ssp . indexOf ( "(" ) ; if ( intialParen == 0 ) { rc . host = ssp . substring ( 0 , intialParen ) ; p = rc . host . indexOf ( "/" ) ; if ( p >= 0 ) { rc . path = rc . host . substring ( p ) ; rc . host = rc . host . substring ( 0 , p ) ; } p = ssp . lastIndexOf ( ")" ) ; componentString = ssp . substring ( intialParen + 1 , p ) ; params = ssp . substring ( p + 1 ) . trim ( ) ; } else { componentString = ssp ; params = "" ; } String components [ ] = splitComponents ( componentString ) ; rc . components = new URI [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { rc . components [ i ] = new URI ( components [ i ] . trim ( ) ) ; } p = params . indexOf ( "?" ) ; if ( p >= 0 ) { if ( p > 0 ) { rc . path = stripPrefix ( params . substring ( 0 , p ) , "/" ) ; } rc . parameters = parseQuery ( params . substring ( p + 1 ) ) ; } else { if ( params . length ( ) > 0 ) { rc . path = stripPrefix ( params , "/" ) ; } rc . parameters = Collections . EMPTY_MAP ; } } private static String [ ] splitComponents ( String str ) { ArrayList l = new ArrayList ( ) ; int last = 0 ; int depth = 0 ; char chars [ ] = str . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '(' : depth ++ ; break ; case ')' : depth -- ; break ; case ',' : if ( depth == 0 ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + 1 ; } } } String s = str . substring ( last ) ; if ( s . length ( ) != 0 ) { l . add ( s ) ; } String rc [ ] = new String [ l . size ( ) ] ; l . toArray ( rc ) ; return rc ; } public static String stripPrefix ( String value , String prefix ) { if ( value . startsWith ( prefix ) ) { return value . substring ( prefix . length ( ) ) ; } return value ; } public static URI stripScheme ( URI uri ) throws URISyntaxException { return new URI ( stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) ) ; } public static String createQueryString ( Map options ) throws URISyntaxException { try { if ( options . size ( ) > 0 ) { StringBuffer rc = new StringBuffer ( ) ; boolean first = true ; for ( Iterator iter = options . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { if ( first ) { first = false ; } else { rc . append ( "&" ) ; } String key = ( String ) iter . next ( ) ; String value = ( String ) options . get ( key ) ; rc . append ( URLEncoder . encode ( key , "UTF-8" ) ) ; rc . append ( "=" ) ; rc . append ( URLEncoder . encode ( value , "UTF-8" ) ) ; } return rc . toString ( ) ; } else { return "" ; } } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static URI createRemainingURI ( URI originalURI , Map params ) throws URISyntaxException { String s = createQueryString ( params ) ; if ( s . length ( ) == 0 ) { s = null ; } return createURIWithQuery ( originalURI , s ) ; } static public URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; } public static boolean checkParenthesis ( String str ) { boolean result = true ; if ( str != null ) { int open = 0 ; int closed = 0 ; int i = 0 ; while ( ( i = str . indexOf ( '(' , i ) ) >= 0 ) { i ++ ; open ++ ; } i = 0 ; while ( ( i = str . indexOf ( ')' , i ) ) >= 0 ) { i ++ ; closed ++ ; } result = open == closed ; } return result ; } public int indexOfParenthesisMatch ( String str ) { int result = - 1 ; return result ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . Predicate ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class FilterBuilder extends FromBuilder { private Predicate predicate ; public FilterBuilder ( FromBuilder builder , Predicate predicate ) { super ( builder ) ; this . predicate = predicate ; } public FilterBuilder and ( Predicate predicate ) { this . predicate = PredicateBuilder . and ( this . predicate , predicate ) ; return this ; } public FilterBuilder or ( Predicate predicate ) { this . predicate = PredicateBuilder . or ( this . predicate , predicate ) ; return this ; } public Predicate getPredicate ( ) { return predicate ; } public FilterProcessor createProcessor ( ) throws Exception { Processor childProcessor = super . createProcessor ( ) ; return new FilterProcessor ( predicate , childProcessor ) ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . Exchange ; import javax . jbi . messaging . MessageExchange ; import javax . jbi . messaging . MessageExchangeFactory ; import javax . jbi . messaging . MessagingException ; import javax . jbi . messaging . NormalizedMessage ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; import java . io . StringReader ; import java . util . Map ; import java . util . Set ; public class JbiBinding { public Object extractBodyFromJbi ( JbiExchange exchange , NormalizedMessage normalizedMessage ) { return normalizedMessage . getContent ( ) ; } public MessageExchange makeJbiMessageExchange ( Exchange camelExchange , MessageExchangeFactory exchangeFactory ) throws MessagingException { MessageExchange jbiExchange = createJbiMessageExchange ( camelExchange , exchangeFactory ) ; NormalizedMessage normalizedMessage = jbiExchange . getMessage ( "in" ) ; if ( normalizedMessage == null ) { normalizedMessage = jbiExchange . createMessage ( ) ; jbiExchange . setMessage ( normalizedMessage , "in" ) ; } normalizedMessage . setContent ( getJbiInContent ( camelExchange ) ) ; addJbiHeaders ( jbiExchange , normalizedMessage , camelExchange ) ; return jbiExchange ; } protected MessageExchange createJbiMessageExchange ( Exchange camelExchange , MessageExchangeFactory exchangeFactory ) throws MessagingException { return exchangeFactory . createInOnlyExchange ( ) ; } protected Source getJbiInContent ( Exchange camelExchange ) { Object value = camelExchange . getIn ( ) . getBody ( ) ; if ( value instanceof String ) { return new StreamSource ( new StringReader ( value . toString ( ) ) ) ; } return camelExchange . getIn ( ) . getBody ( Source . class ) ; } protected void addJbiHeaders ( MessageExchange jbiExchange , NormalizedMessage normalizedMessage , Exchange camelExchange ) { Set < Map . Entry < String , Object > > entries = camelExchange . getIn ( ) . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { normalizedMessage . setProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	0
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . ServiceSupport ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . apache . camel . util . ServiceHelper ; import java . util . Iterator ; public class Splitter extends ServiceSupport implements Processor { private final Processor processor ; private final Expression expression ; public Splitter ( Processor destination , Expression expression ) { this . processor = destination ; this . expression = expression ; notNull ( destination , "destination" ) ; notNull ( expression , "expression" ) ; } @ Override public String toString ( ) { return "Splitter[on: " + expression + " to: " + processor + "]" ; } public void process ( Exchange exchange ) throws Exception { Object value = expression . evaluate ( exchange ) ; Iterator iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { Object part = iter . next ( ) ; Exchange newExchange = exchange . copy ( ) ; newExchange . getIn ( ) . setBody ( part ) ; processor . process ( newExchange ) ; } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } } 	0
package org . apache . camel ; public class RuntimeTransformException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; public RuntimeTransformException ( String message ) { super ( message ) ; } public RuntimeTransformException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeTransformException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . spring . util ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public class MethodInfo { private Class type ; private Method method ; private Expression parametersExpression ; public MethodInfo ( Class type , Method method , Expression parametersExpression ) { this . type = type ; this . method = method ; this . parametersExpression = parametersExpression ; } public MethodInvocation createMethodInvocation ( final Object pojo , final Exchange messageExchange ) { final Object [ ] arguments = ( Object [ ] ) parametersExpression . evaluate ( messageExchange ) ; return new MethodInvocation ( ) { public Method getMethod ( ) { return method ; } public Object [ ] getArguments ( ) { return arguments ; } public Object proceed ( ) throws Throwable { return invoke ( method , pojo , arguments , messageExchange ) ; } public Object getThis ( ) { return pojo ; } public AccessibleObject getStaticPart ( ) { return method ; } } ; } public Class getType ( ) { return type ; } public Method getMethod ( ) { return method ; } public Expression getParametersExpression ( ) { return parametersExpression ; } protected Object invoke ( Method mth , Object pojo , Object [ ] arguments , Exchange exchange ) throws IllegalAccessException , InvocationTargetException { return mth . invoke ( pojo , arguments ) ; } } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; @ Converter public class CollectionConverter { @ Converter public static Object [ ] toArray ( Collection value ) { if ( value == null ) { return null ; } return value . toArray ( ) ; } @ Converter public static List toList ( Object [ ] array ) { return Arrays . asList ( array ) ; } @ Converter public static Set toSet ( Object [ ] array ) { Set answer = new HashSet ( ) ; for ( Object element : array ) { answer . add ( element ) ; } return answer ; } @ Converter public static Set toSet ( Collection collection ) { return new HashSet ( collection ) ; } @ Converter public static Set toSet ( Map map ) { return map . entrySet ( ) ; } } 	0
package org . apache . camel . component . mail ; public class RuntimeMailException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeMailException ( String message , Throwable cause ) { super ( message , cause ) ; } } 	0
package org . apache . camel ; public class ExpectedBodyTypeException extends RuntimeCamelException { private final Exchange exchange ; private final Class expectedBodyType ; public ExpectedBodyTypeException ( Exchange exchange , Class expectedBodyType ) { super ( "Could not extract IN message body as type: " + expectedBodyType + " body is: " + exchange . getIn ( ) . getBody ( ) ) ; this . exchange = exchange ; this . expectedBodyType = expectedBodyType ; } public Exchange getExchange ( ) { return exchange ; } public Class getExpectedBodyType ( ) { return expectedBodyType ; } } 	0
package org . apache . camel . component . mock ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import static org . apache . camel . builder . ExpressionBuilder . bodyExpression ; import static org . apache . camel . builder . ExpressionBuilder . headerExpression ; import org . apache . camel . builder . Fluent ; import org . apache . camel . builder . FluentArg ; import org . apache . camel . builder . ValueBuilder ; import java . util . ArrayList ; import java . util . List ; public abstract class AssertionClause < E extends Exchange > implements Runnable { private List < Predicate < E > > predicates = new ArrayList < Predicate < E > > ( ) ; public AssertionClause < E > predicate ( Predicate < E > predicate ) { addPredicate ( predicate ) ; return this ; } @ Fluent public ValueBuilder < E > header ( @ FluentArg ( "name" ) String name ) { Expression < E > expression = headerExpression ( name ) ; return new PredicateValueBuilder ( expression ) ; } @ Fluent public PredicateValueBuilder body ( ) { Expression < E > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } @ Fluent public < T > PredicateValueBuilder bodyAs ( @ FluentArg ( "class" ) Class < T > type ) { Expression < E > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } @ Fluent public PredicateValueBuilder outBody ( ) { Expression < E > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } @ Fluent public < T > PredicateValueBuilder outBody ( @ FluentArg ( "class" ) Class < T > type ) { Expression < E > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } protected void applyAssertionOn ( MockEndpoint endpoint , int index , E exchange ) { for ( Predicate < E > predicate : predicates ) { predicate . assertMatches ( endpoint . getEndpointUri ( ) + " " , exchange ) ; } } protected void addPredicate ( Predicate < E > predicate ) { predicates . add ( predicate ) ; } public class PredicateValueBuilder extends ValueBuilder < E > { public PredicateValueBuilder ( Expression < E > expression ) { super ( expression ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { addPredicate ( predicate ) ; return predicate ; } } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . Exchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . mail . javamail . JavaMailSender ; import org . springframework . mail . javamail . MimeMessagePreparator ; import javax . mail . internet . MimeMessage ; public class MailProducer extends DefaultProducer < MailExchange > { private static final transient Log log = LogFactory . getLog ( MailProducer . class ) ; private final MailEndpoint endpoint ; private final JavaMailSender sender ; public MailProducer ( MailEndpoint endpoint , JavaMailSender sender ) { super ( endpoint ) ; this . endpoint = endpoint ; this . sender = sender ; } public void process ( final Exchange exchange ) { sender . send ( new MimeMessagePreparator ( ) { public void prepare ( MimeMessage mimeMessage ) throws Exception { endpoint . getBinding ( ) . populateMailMessage ( endpoint , mimeMessage , exchange ) ; } } ) ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultMessage ; import javax . jbi . messaging . NormalizedMessage ; import java . util . Iterator ; import java . util . Map ; public class JbiMessage extends DefaultMessage { private NormalizedMessage normalizedMessage ; public JbiMessage ( ) { } public JbiMessage ( NormalizedMessage normalizedMessage ) { this . normalizedMessage = normalizedMessage ; } @ Override public String toString ( ) { if ( normalizedMessage != null ) { return "JbiMessage: " + normalizedMessage ; } else { return "JbiMessage: " + getBody ( ) ; } } @ Override public JbiExchange getExchange ( ) { return ( JbiExchange ) super . getExchange ( ) ; } public NormalizedMessage getNormalizedMessage ( ) { return normalizedMessage ; } public void setNormalizedMessage ( NormalizedMessage normalizedMessage ) { this . normalizedMessage = normalizedMessage ; } public Object getHeader ( String name ) { Object answer = null ; if ( normalizedMessage != null ) { answer = normalizedMessage . getProperty ( name ) ; } if ( answer == null ) { answer = super . getHeader ( name ) ; } return answer ; } @ Override public JbiMessage newInstance ( ) { return new JbiMessage ( ) ; } @ Override protected Object createBody ( ) { if ( normalizedMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromJbi ( getExchange ( ) , normalizedMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( normalizedMessage != null ) { Iterator iter = normalizedMessage . getPropertyNames ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String name = iter . next ( ) . toString ( ) ; Object value = normalizedMessage . getProperty ( name ) ; map . put ( name , value ) ; } } } } 	0
package org . apache . camel . component . activemq ; import org . apache . activemq . pool . PooledConnectionFactory ; import org . apache . activemq . spring . ActiveMQConnectionFactory ; import org . apache . camel . component . jms . JmsConfiguration ; import javax . jms . ConnectionFactory ; public class ActiveMQConfiguration extends JmsConfiguration { private String brokerURL = ActiveMQConnectionFactory . DEFAULT_BROKER_URL ; public ActiveMQConfiguration ( ) { } public String getBrokerURL ( ) { return brokerURL ; } public void setBrokerURL ( String brokerURL ) { this . brokerURL = brokerURL ; } @ Override public ActiveMQConnectionFactory getListenerConnectionFactory ( ) { return ( ActiveMQConnectionFactory ) super . getListenerConnectionFactory ( ) ; } @ Override public void setListenerConnectionFactory ( ConnectionFactory listenerConnectionFactory ) { if ( listenerConnectionFactory instanceof ActiveMQConnectionFactory ) { super . setListenerConnectionFactory ( listenerConnectionFactory ) ; } else { throw new IllegalArgumentException ( "ConnectionFactory " + listenerConnectionFactory + " is not an instanceof " + ActiveMQConnectionFactory . class . getName ( ) ) ; } } @ Override protected ConnectionFactory createListenerConnectionFactory ( ) { ActiveMQConnectionFactory answer = new ActiveMQConnectionFactory ( ) ; answer . setBrokerURL ( getBrokerURL ( ) ) ; return answer ; } @ Override protected ConnectionFactory createTemplateConnectionFactory ( ) { return new PooledConnectionFactory ( getListenerConnectionFactory ( ) ) ; } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Message ; import javax . xml . transform . Result ; public interface ResultHandler { Result getResult ( ) ; void setBody ( Message in ) ; } 	0
package org . apache . camel . builder . xml ; import static org . apache . camel . converter . ObjectConverter . toBoolean ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import org . apache . camel . Message ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpression ; import javax . xml . xpath . XPathExpressionException ; import javax . xml . xpath . XPathFactory ; import javax . xml . xpath . XPathFactoryConfigurationException ; import javax . xml . xpath . XPathFunctionResolver ; import java . io . StringReader ; public class XPathBuilder < E extends Exchange > implements Expression < E > , Predicate < E > { private final String text ; private XPathFactory xpathFactory ; private Class documentType = Document . class ; private QName resultType = null ; private String objectModelUri = null ; private DefaultNamespaceContext namespaceContext ; private XPathFunctionResolver functionResolver ; private XPathExpression expression ; private MessageVariableResolver variableResolver = new MessageVariableResolver ( ) ; public static XPathBuilder xpath ( String text ) { return new XPathBuilder ( text ) ; } public XPathBuilder ( String text ) { this . text = text ; } @ Override public String toString ( ) { return "XPath: " + text ; } public boolean matches ( E exchange ) { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; return toBoolean ( booleanResult ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; if ( ! toBoolean ( booleanResult ) ) { throw new AssertionError ( this + " failed on " + exchange + " as returned <" + booleanResult + ">" ) ; } } public Object evaluate ( E exchange ) { return evaluateAs ( exchange , resultType ) ; } public XPathBuilder < E > booleanResult ( ) { resultType = XPathConstants . BOOLEAN ; return this ; } public XPathBuilder < E > nodeResult ( ) { resultType = XPathConstants . NODE ; return this ; } public XPathBuilder < E > nodeSetResult ( ) { resultType = XPathConstants . NODESET ; return this ; } public XPathBuilder < E > numberResult ( ) { resultType = XPathConstants . NUMBER ; return this ; } public XPathBuilder < E > stringResult ( ) { resultType = XPathConstants . STRING ; return this ; } public XPathBuilder < E > objectModel ( String uri ) { this . objectModelUri = uri ; return this ; } public XPathBuilder < E > functionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; return this ; } public XPathBuilder < E > namespace ( String prefix , String uri ) { getNamespaceContext ( ) . add ( prefix , uri ) ; return this ; } public XPathBuilder < E > variable ( String name , Object value ) { variableResolver . addVariable ( name , value ) ; return this ; } public XPathFactory getXPathFactory ( ) throws XPathFactoryConfigurationException { if ( xpathFactory == null ) { if ( objectModelUri != null ) { xpathFactory = XPathFactory . newInstance ( objectModelUri ) ; } xpathFactory = XPathFactory . newInstance ( ) ; } return xpathFactory ; } public void setXPathFactory ( XPathFactory xpathFactory ) { this . xpathFactory = xpathFactory ; } public Class getDocumentType ( ) { return documentType ; } public void setDocumentType ( Class documentType ) { this . documentType = documentType ; } public String getText ( ) { return text ; } public QName getResultType ( ) { return resultType ; } public DefaultNamespaceContext getNamespaceContext ( ) { if ( namespaceContext == null ) { try { namespaceContext = new DefaultNamespaceContext ( getXPathFactory ( ) ) ; } catch ( XPathFactoryConfigurationException e ) { throw new RuntimeExpressionException ( e ) ; } } return namespaceContext ; } public void setNamespaceContext ( DefaultNamespaceContext namespaceContext ) { this . namespaceContext = namespaceContext ; } public XPathFunctionResolver getFunctionResolver ( ) { return functionResolver ; } public void setFunctionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; } public XPathExpression getExpression ( ) throws XPathFactoryConfigurationException , XPathExpressionException { if ( expression == null ) { expression = createXPathExpression ( ) ; } return expression ; } public void setNamespacesFromDom ( Element node ) { getNamespaceContext ( ) . setNamespacesFromDom ( node ) ; } protected synchronized Object evaluateAs ( E exchange , QName resultType ) { variableResolver . setExchange ( exchange ) ; try { Object document = getDocument ( exchange ) ; if ( resultType != null ) { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource , resultType ) ; } else { return getExpression ( ) . evaluate ( document , resultType ) ; } } else { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource ) ; } else { return getExpression ( ) . evaluate ( document ) ; } } } catch ( XPathExpressionException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } catch ( XPathFactoryConfigurationException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } } protected XPathExpression createXPathExpression ( ) throws XPathExpressionException , XPathFactoryConfigurationException { XPath xPath = getXPathFactory ( ) . newXPath ( ) ; xpathFactory = null ; xPath . setNamespaceContext ( getNamespaceContext ( ) ) ; xPath . setXPathVariableResolver ( variableResolver ) ; if ( functionResolver != null ) { xPath . setXPathFunctionResolver ( functionResolver ) ; } return xPath . compile ( text ) ; } protected Object getDocument ( E exchange ) { Message in = exchange . getIn ( ) ; Class type = getDocumentType ( ) ; Object answer = null ; if ( type != null ) { answer = in . getBody ( type ) ; } if ( answer == null ) { answer = in . getBody ( ) ; } if ( answer instanceof String ) { answer = new InputSource ( new StringReader ( answer . toString ( ) ) ) ; } return answer ; } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . Exchange ; import org . apache . camel . converter . ObjectConverter ; import javax . mail . Address ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; public class MailBinding { public void populateMailMessage ( MailEndpoint endpoint , MimeMessage mimeMessage , Exchange exchange ) { try { appendHeadersFromCamel ( mimeMessage , exchange , exchange . getIn ( ) ) ; String destination = endpoint . getConfiguration ( ) . getDestination ( ) ; if ( destination != null ) { mimeMessage . setRecipients ( Message . RecipientType . TO , destination ) ; } if ( empty ( mimeMessage . getFrom ( ) ) ) { String from = endpoint . getConfiguration ( ) . getFrom ( ) ; mimeMessage . setFrom ( new InternetAddress ( from ) ) ; } mimeMessage . setText ( exchange . getIn ( ) . getBody ( String . class ) ) ; } catch ( Exception e ) { throw new RuntimeMailException ( "Failed to populate body due to: " + e + ". Exchange: " + exchange , e ) ; } } protected boolean empty ( Address [ ] addresses ) { return addresses == null || addresses . length == 0 ; } public Object extractBodyFromMail ( MailExchange exchange , Message message ) { try { return message . getContent ( ) ; } catch ( Exception e ) { throw new RuntimeMailException ( "Failed to extract body due to: " + e + ". Message: " + message , e ) ; } } protected void appendHeadersFromCamel ( MimeMessage mimeMessage , Exchange exchange , org . apache . camel . Message camelMessage ) throws MessagingException { Set < Map . Entry < String , Object > > entries = camelMessage . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String headerName = entry . getKey ( ) ; Object headerValue = entry . getValue ( ) ; if ( headerValue != null ) { if ( shouldOutputHeader ( camelMessage , headerName , headerValue ) ) { if ( ObjectConverter . isCollection ( headerValue ) ) { Iterator iter = ObjectConverter . iterator ( headerValue ) ; while ( iter . hasNext ( ) ) { Object value = iter . next ( ) ; mimeMessage . addHeader ( headerName , asString ( exchange , value ) ) ; } } else { mimeMessage . setHeader ( headerName , asString ( exchange , headerValue ) ) ; } } } } } protected String asString ( Exchange exchange , Object value ) { return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , value ) ; } protected boolean shouldOutputHeader ( org . apache . camel . Message camelMessage , String headerName , Object headerValue ) { return true ; } } 	0
package org . apache . camel . converter . jaxp ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . lang . reflect . Constructor ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . Converter ; @ Converter public class XmlConverter { public static final String DEFAULT_CHARSET_PROPERTY = "org.apache.camel.default.charset" ; public static String defaultCharset = ObjectHelper . getSystemProperty ( DEFAULT_CHARSET_PROPERTY , "UTF-8" ) ; private DocumentBuilderFactory documentBuilderFactory ; private TransformerFactory transformerFactory ; private static final Class dom2SaxClass ; static { Class cl = null ; try { cl = Class . forName ( "org.apache.xalan.xsltc.trax.DOM2SAX" ) ; } catch ( Throwable t ) { } dom2SaxClass = cl ; } public XmlConverter ( ) { } public XmlConverter ( DocumentBuilderFactory documentBuilderFactory ) { this . documentBuilderFactory = documentBuilderFactory ; } public void toResult ( Source source , Result result ) throws TransformerException { if ( source == null ) { return ; } Transformer transformer = createTransfomer ( ) ; if ( transformer == null ) { throw new TransformerException ( "Could not create a transformer - JAXP is misconfigured!" ) ; } transformer . setOutputProperty ( OutputKeys . ENCODING , defaultCharset ) ; transformer . transform ( source , result ) ; } @ Converter public BytesSource toSource ( byte [ ] data ) { return new BytesSource ( data ) ; } @ Converter public StringSource toSource ( String data ) { return new StringSource ( data ) ; } @ Converter public DOMSource toSource ( Document document ) { return new DOMSource ( document ) ; } @ Converter public String toString ( Source source ) throws TransformerException { if ( source == null ) { return null ; } else if ( source instanceof StringSource ) { return ( ( StringSource ) source ) . getText ( ) ; } else if ( source instanceof BytesSource ) { return new String ( ( ( BytesSource ) source ) . getData ( ) ) ; } else { StringWriter buffer = new StringWriter ( ) ; toResult ( source , new StreamResult ( buffer ) ) ; return buffer . toString ( ) ; } } @ Converter public String toString ( Node node ) throws TransformerException { return toString ( new DOMSource ( node ) ) ; } @ Converter public DOMSource toDOMSource ( Source source ) throws ParserConfigurationException , IOException , SAXException , TransformerException { if ( source instanceof DOMSource ) { return ( DOMSource ) source ; } else if ( source instanceof SAXSource ) { return toDOMSourceFromSAX ( ( SAXSource ) source ) ; } else if ( source instanceof StreamSource ) { return toDOMSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public SAXSource toSAXSource ( Source source ) throws IOException , SAXException , TransformerException { if ( source instanceof SAXSource ) { return ( SAXSource ) source ; } else if ( source instanceof DOMSource ) { return toSAXSourceFromDOM ( ( DOMSource ) source ) ; } else if ( source instanceof StreamSource ) { return toSAXSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public StreamSource toStreamSource ( Source source ) throws TransformerException { if ( source instanceof StreamSource ) { return ( StreamSource ) source ; } else if ( source instanceof DOMSource ) { return toStreamSourceFromDOM ( ( DOMSource ) source ) ; } else if ( source instanceof SAXSource ) { return toStreamSourceFromSAX ( ( SAXSource ) source ) ; } else { return null ; } } @ Converter public StreamSource toStreamSourceFromSAX ( SAXSource source ) throws TransformerException { InputSource inputSource = source . getInputSource ( ) ; if ( inputSource != null ) { if ( inputSource . getCharacterStream ( ) != null ) { return new StreamSource ( inputSource . getCharacterStream ( ) ) ; } if ( inputSource . getByteStream ( ) != null ) { return new StreamSource ( inputSource . getByteStream ( ) ) ; } } String result = toString ( source ) ; return new StringSource ( result ) ; } @ Converter public StreamSource toStreamSourceFromDOM ( DOMSource source ) throws TransformerException { String result = toString ( source ) ; return new StringSource ( result ) ; } @ Converter public SAXSource toSAXSourceFromStream ( StreamSource source ) { InputSource inputSource ; if ( source . getReader ( ) != null ) { inputSource = new InputSource ( source . getReader ( ) ) ; } else { inputSource = new InputSource ( source . getInputStream ( ) ) ; } inputSource . setSystemId ( source . getSystemId ( ) ) ; inputSource . setPublicId ( source . getPublicId ( ) ) ; return new SAXSource ( inputSource ) ; } @ Converter public Reader toReaderFromSource ( Source src ) throws TransformerException { StreamSource stSrc = toStreamSource ( src ) ; Reader r = stSrc . getReader ( ) ; if ( r == null ) { r = new InputStreamReader ( stSrc . getInputStream ( ) ) ; } return r ; } @ Converter public DOMSource toDOMSourceFromStream ( StreamSource source ) throws ParserConfigurationException , IOException , SAXException { DocumentBuilder builder = createDocumentBuilder ( ) ; String systemId = source . getSystemId ( ) ; Document document = null ; Reader reader = source . getReader ( ) ; if ( reader != null ) { document = builder . parse ( new InputSource ( reader ) ) ; } else { InputStream inputStream = source . getInputStream ( ) ; if ( inputStream != null ) { InputSource inputsource = new InputSource ( inputStream ) ; inputsource . setSystemId ( systemId ) ; document = builder . parse ( inputsource ) ; } else { throw new IOException ( "No input stream or reader available" ) ; } } return new DOMSource ( document , systemId ) ; } @ Converter public SAXSource toSAXSourceFromDOM ( DOMSource source ) throws TransformerException { if ( dom2SaxClass != null ) { try { Constructor cns = dom2SaxClass . getConstructor ( new Class [ ] { Node . class } ) ; XMLReader converter = ( XMLReader ) cns . newInstance ( new Object [ ] { source . getNode ( ) } ) ; return new SAXSource ( converter , new InputSource ( ) ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } else { String str = toString ( source ) ; StringReader reader = new StringReader ( str ) ; return new SAXSource ( new InputSource ( reader ) ) ; } } @ Converter public DOMSource toDOMSourceFromSAX ( SAXSource source ) throws IOException , SAXException , ParserConfigurationException , TransformerException { return new DOMSource ( toDOMNodeFromSAX ( source ) ) ; } @ Converter public Node toDOMNodeFromSAX ( SAXSource source ) throws ParserConfigurationException , IOException , SAXException , TransformerException { DOMResult result = new DOMResult ( ) ; toResult ( source , result ) ; return result . getNode ( ) ; } @ Converter public Node toDOMNode ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { DOMSource domSrc = toDOMSource ( source ) ; return domSrc != null ? domSrc . getNode ( ) : null ; } @ Converter public Element toDOMElement ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { Node node = toDOMNode ( source ) ; return toDOMElement ( node ) ; } @ Converter public Element toDOMElement ( Node node ) throws TransformerException { if ( node instanceof Document ) { return ( ( Document ) node ) . getDocumentElement ( ) ; } else if ( node instanceof Element ) { return ( Element ) node ; } else { throw new TransformerException ( "Unable to convert DOM node to an Element" ) ; } } @ Converter public Document toDOMDocument ( byte [ ] data ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( new ByteArrayInputStream ( data ) ) ; } @ Converter public Document toDOMDocument ( InputStream in ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( in ) ; } @ Converter public Document toDOMDocument ( InputSource in ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( in ) ; } @ Converter public Document toDOMDocument ( String text ) throws IOException , SAXException , ParserConfigurationException { return toDOMDocument ( text . getBytes ( ) ) ; } @ Converter public Document toDOMDocument ( File file ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( file ) ; } @ Converter public Document toDOMDocument ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { Node node = toDOMNode ( source ) ; return toDOMDocument ( node ) ; } @ Converter public Document toDOMDocument ( Node node ) throws ParserConfigurationException , TransformerException { if ( node instanceof Document ) { return ( Document ) node ; } else if ( node instanceof Element ) { Element elem = ( Element ) node ; if ( elem . getOwnerDocument ( ) . getDocumentElement ( ) == elem ) { return elem . getOwnerDocument ( ) ; } else { Document doc = createDocument ( ) ; doc . appendChild ( doc . importNode ( node , true ) ) ; return doc ; } } else { throw new TransformerException ( "Unable to convert DOM node to a Document" ) ; } } public DocumentBuilderFactory getDocumentBuilderFactory ( ) { if ( documentBuilderFactory == null ) { documentBuilderFactory = createDocumentBuilderFactory ( ) ; } return documentBuilderFactory ; } public void setDocumentBuilderFactory ( DocumentBuilderFactory documentBuilderFactory ) { this . documentBuilderFactory = documentBuilderFactory ; } public DocumentBuilderFactory createDocumentBuilderFactory ( ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; factory . setIgnoringElementContentWhitespace ( true ) ; factory . setIgnoringComments ( true ) ; return factory ; } public DocumentBuilder createDocumentBuilder ( ) throws ParserConfigurationException { DocumentBuilderFactory factory = getDocumentBuilderFactory ( ) ; return factory . newDocumentBuilder ( ) ; } public Document createDocument ( ) throws ParserConfigurationException { DocumentBuilder builder = createDocumentBuilder ( ) ; return builder . newDocument ( ) ; } public TransformerFactory getTransformerFactory ( ) { if ( transformerFactory == null ) { transformerFactory = createTransformerFactory ( ) ; } return transformerFactory ; } public void setTransformerFactory ( TransformerFactory transformerFactory ) { this . transformerFactory = transformerFactory ; } public Transformer createTransfomer ( ) throws TransformerConfigurationException { TransformerFactory factory = getTransformerFactory ( ) ; return factory . newTransformer ( ) ; } public TransformerFactory createTransformerFactory ( ) { TransformerFactory answer = TransformerFactory . newInstance ( ) ; return answer ; } } 	0
package org . apache . camel ; import org . apache . camel . processor . RecipientList ; public class NoSuchEndpointException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final String uri ; public NoSuchEndpointException ( String uri ) { super ( "No endpoint could be found for: " + uri ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . builder . RouteBuilder ; public class NoRouteBuilder extends RouteBuilder { private static final NoRouteBuilder instance = new NoRouteBuilder ( ) ; public static NoRouteBuilder getInstance ( ) { return instance ; } public void configure ( ) throws Exception { } } 	0
package org . apache . camel . component . xmpp ; import org . jivesoftware . smack . packet . Message ; import org . apache . camel . Exchange ; import java . util . Map ; import java . util . Set ; public class XmppBinding { public void populateXmppMessage ( Message message , Exchange exchange ) { message . setBody ( exchange . getIn ( ) . getBody ( String . class ) ) ; Set < Map . Entry < String , Object > > entries = exchange . getIn ( ) . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( shouldOutputHeader ( exchange , name , value ) ) { message . setProperty ( name , value ) ; } } String id = exchange . getExchangeId ( ) ; if ( id != null ) { message . setProperty ( "exchangeId" , id ) ; } } public Object extractBodyFromXmpp ( XmppExchange exchange , Message message ) { return message . getBody ( ) ; } protected boolean shouldOutputHeader ( Exchange exchange , String headerName , Object headerValue ) { return true ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . servicemix . common . ServiceUnit ; import org . apache . servicemix . common . endpoints . ProviderEndpoint ; import javax . jbi . messaging . MessageExchange ; import javax . jbi . messaging . NormalizedMessage ; import javax . xml . namespace . QName ; public class CamelJbiEndpoint extends ProviderEndpoint { private static final transient Log log = LogFactory . getLog ( CamelJbiEndpoint . class ) ; private static final QName SERVICE_NAME = new QName ( "http://camel.apache.org/service" , "CamelEndpointComponent" ) ; private Endpoint camelEndpoint ; private JbiBinding binding ; private Processor processor ; public CamelJbiEndpoint ( ServiceUnit serviceUnit , QName service , String endpoint , Endpoint camelEndpoint , JbiBinding binding , Processor processor ) { super ( serviceUnit , service , endpoint ) ; this . processor = processor ; this . camelEndpoint = camelEndpoint ; this . binding = binding ; } public CamelJbiEndpoint ( ServiceUnit serviceUnit , Endpoint camelEndpoint , JbiBinding binding , Processor processor ) { this ( serviceUnit , SERVICE_NAME , camelEndpoint . getEndpointUri ( ) , camelEndpoint , binding , processor ) ; } protected void processInOnly ( MessageExchange exchange , NormalizedMessage in ) throws Exception { if ( log . isDebugEnabled ( ) ) { log . debug ( "Received exchange: " + exchange ) ; } JbiExchange camelExchange = new JbiExchange ( camelEndpoint . getContext ( ) , binding , exchange ) ; processor . process ( camelExchange ) ; } protected void processInOut ( MessageExchange exchange , NormalizedMessage in , NormalizedMessage out ) throws Exception { if ( log . isDebugEnabled ( ) ) { log . debug ( "Received exchange: " + exchange ) ; } } } 	0
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Body { } 	0
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ExchangeConverter ; public class DefaultExchangeConverter implements ExchangeConverter { public < T > T convertTo ( Class < T > type , Exchange exchange ) { return null ; } } 	0
package org . apache . camel . spring . converter ; import org . apache . camel . Converter ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; @ Converter public class ResourceConverter { @ Converter public static InputStream toInputStream ( Resource resource ) throws IOException { return resource . getInputStream ( ) ; } @ Converter public static File toFile ( Resource resource ) throws IOException { return resource . getFile ( ) ; } @ Converter public static URL toUrl ( Resource resource ) throws IOException { return resource . getURL ( ) ; } @ Converter public static UrlResource toResource ( String uri ) throws IOException { return new UrlResource ( uri ) ; } @ Converter public static UrlResource toResource ( URL uri ) throws IOException { return new UrlResource ( uri ) ; } @ Converter public static FileSystemResource toResource ( File file ) throws IOException { return new FileSystemResource ( file ) ; } @ Converter public static ByteArrayResource toResource ( byte [ ] data ) throws IOException { return new ByteArrayResource ( data ) ; } } 	0
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . processor . ChoiceProcessor ; import org . apache . camel . processor . FilterProcessor ; public class ChoiceBuilder extends FromBuilder { private final FromBuilder parent ; private List < WhenBuilder > predicateBuilders = new ArrayList < WhenBuilder > ( ) ; private FromBuilder otherwise ; public ChoiceBuilder ( FromBuilder parent ) { super ( parent ) ; this . parent = parent ; } @ Fluent ( nestedActions = true ) public WhenBuilder when ( @ FluentArg ( value = "predicate" , element = true ) Predicate predicate ) { WhenBuilder answer = new WhenBuilder ( this , predicate ) ; predicateBuilders . add ( answer ) ; return answer ; } @ Fluent ( nestedActions = true ) public FromBuilder otherwise ( ) { this . otherwise = new FromBuilder ( parent ) ; return otherwise ; } public List < WhenBuilder > getPredicateBuilders ( ) { return predicateBuilders ; } public FromBuilder getOtherwise ( ) { return otherwise ; } @ Override public Processor createProcessor ( ) throws Exception { List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; for ( WhenBuilder predicateBuilder : predicateBuilders ) { filters . add ( predicateBuilder . createProcessor ( ) ) ; } Processor otherwiseProcessor = null ; if ( otherwise != null ) { otherwiseProcessor = otherwise . createProcessor ( ) ; } return new ChoiceProcessor ( filters , otherwiseProcessor ) ; } } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . io . * ; import java . nio . ByteBuffer ; @ Converter public class NIOConverter { @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } } 	1
package org . apache . camel . spring ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . EndpointInject ; import org . apache . camel . Exchange ; import org . apache . camel . MessageDriven ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . CamelTemplate ; import org . apache . camel . spring . util . BeanInfo ; import org . apache . camel . spring . util . DefaultMethodInvocationStrategy ; import org . apache . camel . spring . util . MethodInvocationStrategy ; import org . apache . camel . spring . util . ReflectionUtils ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . isNotNullOrBlank ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . List ; public class CamelBeanPostProcessor implements BeanPostProcessor , ApplicationContextAware { private static final transient Log log = LogFactory . getLog ( CamelBeanPostProcessor . class ) ; private CamelContext camelContext ; private ApplicationContext applicationContext ; private MethodInvocationStrategy invocationStrategy = new DefaultMethodInvocationStrategy ( ) ; public CamelBeanPostProcessor ( ) { } public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { injectFields ( bean ) ; injectMethods ( bean ) ; return bean ; } public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { return bean ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public MethodInvocationStrategy getInvocationStrategy ( ) { return invocationStrategy ; } public void setInvocationStrategy ( MethodInvocationStrategy invocationStrategy ) { this . invocationStrategy = invocationStrategy ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } protected void injectFields ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { EndpointInject annotation = field . getAnnotation ( EndpointInject . class ) ; if ( annotation != null ) { ReflectionUtils . setField ( field , bean , getEndpointInjectionValue ( annotation , field . getType ( ) ) ) ; } } } ) ; } protected void injectMethods ( final Object bean ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { setterInjection ( method , bean ) ; consumerInjection ( method , bean ) ; } } ) ; } protected void setterInjection ( Method method , Object bean ) { EndpointInject annoation = method . getAnnotation ( EndpointInject . class ) ; if ( annoation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes != null ) { if ( parameterTypes . length != 1 ) { log . warn ( "Ignoring badly annotated method for injection due to incorrect number of parameters: " + method ) ; } else { Object value = getEndpointInjectionValue ( annoation , parameterTypes [ 0 ] ) ; ObjectHelper . invokeMethod ( method , bean , value ) ; } } } } protected void consumerInjection ( final Object bean ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { } } ) ; } protected void consumerInjection ( Method method , Object bean ) { MessageDriven annotation = method . getAnnotation ( MessageDriven . class ) ; if ( annotation != null ) { log . info ( "Creating a consumer for: " + annotation ) ; Endpoint endpoint = getEndpointInjection ( annotation . uri ( ) , annotation . name ( ) ) ; if ( endpoint != null ) { try { Processor processor = createConsumerProcessor ( bean , method , endpoint ) ; log . info ( "Created processor: " + processor ) ; Consumer consumer = endpoint . createConsumer ( processor ) ; consumer . start ( ) ; addConsumer ( consumer ) ; } catch ( Exception e ) { log . warn ( e ) ; throw new RuntimeCamelException ( e ) ; } } } } protected Processor createConsumerProcessor ( final Object pojo , final Method method , final Endpoint endpoint ) { final BeanInfo beanInfo = new BeanInfo ( pojo . getClass ( ) , invocationStrategy ) ; return new Processor ( ) { @ Override public String toString ( ) { return "Processor on " + endpoint ; } public void process ( Exchange exchange ) throws Exception { if ( log . isDebugEnabled ( ) ) { log . debug ( ">>>> invoking method for: " + exchange ) ; } MethodInvocation invocation = beanInfo . createInvocation ( method , pojo , exchange ) ; if ( invocation == null ) { throw new IllegalStateException ( "No method invocation could be created" ) ; } try { invocation . proceed ( ) ; } catch ( Exception e ) { throw e ; } catch ( Throwable throwable ) { throw new Exception ( throwable ) ; } } } ; } protected void addConsumer ( Consumer consumer ) { log . debug ( "Adding consumer: " + consumer ) ; } protected Object getEndpointInjectionValue ( EndpointInject annotation , Class < ? > type ) { Endpoint endpoint = getEndpointInjection ( annotation . uri ( ) , annotation . name ( ) ) ; if ( endpoint != null ) { if ( type . isInstance ( endpoint ) ) { return endpoint ; } else if ( type . isAssignableFrom ( Producer . class ) ) { try { return endpoint . createProducer ( ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } else if ( type . isAssignableFrom ( CamelTemplate . class ) ) { return new CamelTemplate ( getCamelContext ( ) , endpoint ) ; } } return null ; } protected Endpoint getEndpointInjection ( String uri , String name ) { Endpoint endpoint = null ; if ( isNotNullOrBlank ( uri ) ) { endpoint = camelContext . getEndpoint ( uri ) ; } else { if ( isNotNullOrBlank ( name ) ) { endpoint = ( Endpoint ) applicationContext . getBean ( name ) ; if ( endpoint == null ) { throw new NoSuchBeanDefinitionException ( name ) ; } } else { log . warn ( "No uri or name specified on @EndpointInject annotation!" ) ; } } return endpoint ; } } 	0
package org . apache . camel ; public interface Service { void start ( ) throws Exception ; void stop ( ) throws Exception ; } 	0
package org . apache . camel . impl ; import org . apache . camel . Route ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import java . util . List ; public class EventDrivenConsumerRoute < E extends Exchange > extends Route < E > { private Processor processor ; public EventDrivenConsumerRoute ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } @ Override public String toString ( ) { return "EventDrivenConsumerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } public Processor getProcessor ( ) { return processor ; } public void setProcessor ( Processor processor ) { this . processor = processor ; } protected void addServices ( List < Service > services ) throws Exception { Processor processor = getProcessor ( ) ; if ( processor instanceof Service ) { Service service = ( Service ) processor ; services . add ( service ) ; } Endpoint < E > endpoint = getEndpoint ( ) ; Consumer < E > consumer = endpoint . createConsumer ( processor ) ; if ( consumer != null ) { services . add ( consumer ) ; } } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . springframework . mail . javamail . JavaMailSender ; import javax . mail . Message ; import javax . mail . Folder ; public class MailEndpoint extends ScheduledPollEndpoint < MailExchange > { private MailBinding binding ; private MailConfiguration configuration ; public MailEndpoint ( String uri , MailComponent component , MailConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; } public Producer < MailExchange > createProducer ( ) throws Exception { JavaMailSender sender = configuration . createJavaMailConnection ( this ) ; return createProducer ( sender ) ; } public Producer < MailExchange > createProducer ( JavaMailSender sender ) throws Exception { return new MailProducer ( this , sender ) ; } public Consumer < MailExchange > createConsumer ( Processor processor ) throws Exception { JavaMailConnection connection = configuration . createJavaMailConnection ( this ) ; String protocol = getConfiguration ( ) . getProtocol ( ) ; if ( protocol . equals ( "smtp" ) ) { protocol = "pop3" ; } String folderName = getConfiguration ( ) . getFolderName ( ) ; Folder folder = connection . getFolder ( protocol , folderName ) ; if ( folder == null ) { throw new IllegalArgumentException ( "No folder for protocol: " + protocol + " and name: " + folderName ) ; } return createConsumer ( processor , folder ) ; } public Consumer < MailExchange > createConsumer ( Processor processor , Folder folder ) throws Exception { MailConsumer answer = new MailConsumer ( this , processor , folder ) ; configureConsumer ( answer ) ; return answer ; } public MailExchange createExchange ( ) { return new MailExchange ( getContext ( ) , getBinding ( ) ) ; } public MailExchange createExchange ( Message message ) { return new MailExchange ( getContext ( ) , getBinding ( ) , message ) ; } public MailBinding getBinding ( ) { if ( binding == null ) { binding = new MailBinding ( ) ; } return binding ; } public void setBinding ( MailBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return false ; } public MailConfiguration getConfiguration ( ) { return configuration ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandler extends ServiceSupport implements ErrorHandler { private Processor output ; private Log log ; private LoggingLevel level ; public LoggingErrorHandler ( Processor output ) { this ( output , LogFactory . getLog ( LoggingErrorHandler . class ) , LoggingLevel . INFO ) ; } public LoggingErrorHandler ( Processor output , Log log , LoggingLevel level ) { this . output = output ; this . log = log ; this . level = level ; } @ Override public String toString ( ) { return "LoggingErrorHandler[" + output + "]" ; } public void process ( Exchange exchange ) throws Exception { try { output . process ( exchange ) ; } catch ( RuntimeException e ) { logError ( exchange , e ) ; } } public Processor getOutput ( ) { return output ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } protected void logError ( Exchange exchange , RuntimeException e ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange , e ) , e ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange , e ) , e ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange , e ) , e ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( logMessage ( exchange , e ) , e ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange , e ) , e ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange , e ) , e ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange , e ) , e ) ; } } protected Object logMessage ( Exchange exchange , RuntimeException e ) { return e + " while processing exchange: " + exchange ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( output ) ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . Exchange ; import javax . jms . BytesMessage ; import javax . jms . JMSException ; import javax . jms . MapMessage ; import javax . jms . Message ; import javax . jms . ObjectMessage ; import javax . jms . Session ; import javax . jms . StreamMessage ; import javax . jms . TextMessage ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class JmsBinding { public Object extractBodyFromJms ( JmsExchange exchange , Message message ) { try { if ( message instanceof ObjectMessage ) { ObjectMessage objectMessage = ( ObjectMessage ) message ; return objectMessage . getObject ( ) ; } else if ( message instanceof TextMessage ) { TextMessage textMessage = ( TextMessage ) message ; return textMessage . getText ( ) ; } else if ( message instanceof MapMessage ) { return createMapFromMapMessage ( ( MapMessage ) message ) ; } else if ( message instanceof BytesMessage || message instanceof StreamMessage ) { return message ; } else { return null ; } } catch ( JMSException e ) { throw new RuntimeJmsException ( "Failed to extract body due to: " + e + ". Message: " + message , e ) ; } } public Message makeJmsMessage ( Exchange exchange , Session session ) throws JMSException { Message answer = createJmsMessage ( exchange . getIn ( ) . getBody ( ) , session ) ; appendJmsProperties ( answer , exchange , session ) ; return answer ; } protected void appendJmsProperties ( Message jmsMessage , Exchange exchange , Session session ) throws JMSException { org . apache . camel . Message in = exchange . getIn ( ) ; Set < Map . Entry < String , Object > > entries = in . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String headerName = entry . getKey ( ) ; Object headerValue = entry . getValue ( ) ; if ( shouldOutputHeader ( in , headerName , headerValue ) ) { jmsMessage . setObjectProperty ( headerName , headerValue ) ; } } } protected Message createJmsMessage ( Object body , Session session ) throws JMSException { if ( body instanceof String ) { return session . createTextMessage ( ( String ) body ) ; } else if ( body instanceof Serializable ) { return session . createObjectMessage ( ( Serializable ) body ) ; } else { return session . createMessage ( ) ; } } public Map < String , Object > createMapFromMapMessage ( MapMessage message ) throws JMSException { Map < String , Object > answer = new HashMap < String , Object > ( ) ; Enumeration names = message . getPropertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = names . nextElement ( ) . toString ( ) ; Object value = message . getObject ( name ) ; answer . put ( name , value ) ; } return answer ; } protected boolean shouldOutputHeader ( org . apache . camel . Message camelMessage , String headerName , Object headerValue ) { return true ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . impl . DefaultMessage ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import java . util . Map ; public class CxfMessage extends DefaultMessage { private Message cxfMessage ; public CxfMessage ( ) { this ( new MessageImpl ( ) ) ; } public CxfMessage ( Message cxfMessage ) { this . cxfMessage = cxfMessage ; } @ Override public String toString ( ) { if ( cxfMessage != null ) { return "CxfMessage: " + cxfMessage ; } else { return "CxfMessage: " + getBody ( ) ; } } @ Override public CxfExchange getExchange ( ) { return ( CxfExchange ) super . getExchange ( ) ; } public Message getMessage ( ) { return cxfMessage ; } public void setMessage ( Message cxfMessage ) { this . cxfMessage = cxfMessage ; } public Object getHeader ( String name ) { return cxfMessage . get ( name ) ; } @ Override public void setHeader ( String name , Object value ) { cxfMessage . put ( name , value ) ; } @ Override public Map < String , Object > getHeaders ( ) { return cxfMessage ; } @ Override public CxfMessage newInstance ( ) { return new CxfMessage ( ) ; } @ Override protected Object createBody ( ) { return getExchange ( ) . getBinding ( ) . extractBodyFromCxf ( getExchange ( ) , cxfMessage ) ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ExchangeHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . apache . camel . util . ProducerCache ; import java . util . Iterator ; public class RecipientList extends ServiceSupport implements Processor { private final Expression < Exchange > expression ; private ProducerCache < Exchange > producerCache = new ProducerCache < Exchange > ( ) ; public RecipientList ( Expression < Exchange > expression ) { notNull ( expression , "expression" ) ; this . expression = expression ; } @ Override public String toString ( ) { return "RecipientList[" + expression + "]" ; } public void process ( Exchange exchange ) throws Exception { Object receipientList = expression . evaluate ( exchange ) ; Iterator iter = ObjectConverter . iterator ( receipientList ) ; while ( iter . hasNext ( ) ) { Object recipient = iter . next ( ) ; Endpoint < Exchange > endpoint = resolveEndpoint ( exchange , recipient ) ; producerCache . getProducer ( endpoint ) . process ( exchange ) ; } } protected Endpoint < Exchange > resolveEndpoint ( Exchange exchange , Object recipient ) { return ExchangeHelper . resolveEndpoint ( exchange , recipient ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected void doStart ( ) throws Exception { } } 	0
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . camel . Processor ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . io . AbstractCachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . AttributedURIType ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; public class CamelConduit extends AbstractConduit implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-conduit-base" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelConduit . class ) ; private final CamelTransportBase base ; private String targetCamelEndpointUri ; public CamelConduit ( CamelContext camelContext , Bus bus , EndpointInfo endpointInfo , EndpointReferenceType targetReference ) { super ( targetReference ) ; AttributedURIType address = targetReference . getAddress ( ) ; if ( address != null ) { this . targetCamelEndpointUri = address . getValue ( ) ; } base = new CamelTransportBase ( camelContext , bus , endpointInfo , false , BASE_BEAN_NAME_SUFFIX ) ; initConfig ( ) ; } public void prepare ( Message message ) throws IOException { getLogger ( ) . log ( Level . FINE , "CamelConduit send message" ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( message ) ) ; } public void close ( ) { getLogger ( ) . log ( Level . FINE , "CamelConduit closed " ) ; base . close ( ) ; } protected Logger getLogger ( ) { return LOG ; } public String getBeanName ( ) { EndpointInfo info = base . endpointInfo ; if ( info == null ) { return "default.camel-conduit" ; } return info . getName ( ) + ".camel-conduit" ; } private void initConfig ( ) { Configurer configurer = base . bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( this ) ; } } private class CamelOutputStream extends AbstractCachedOutputStream { private Message outMessage ; private boolean isOneWay ; public CamelOutputStream ( Message m ) { outMessage = m ; } protected void doFlush ( ) throws IOException { } protected void doClose ( ) throws IOException { isOneWay = outMessage . getExchange ( ) . isOneWay ( ) ; commitOutputMessage ( ) ; if ( ! isOneWay ) { handleResponse ( ) ; } } protected void onWrite ( ) throws IOException { } private void commitOutputMessage ( ) { base . template . send ( targetCamelEndpointUri , new Processor ( ) { public void process ( org . apache . camel . Exchange reply ) { Object request = null ; if ( isTextPayload ( ) ) { request = currentStream . toString ( ) ; } else { request = ( ( ByteArrayOutputStream ) currentStream ) . toByteArray ( ) ; } getLogger ( ) . log ( Level . FINE , "Conduit Request is :[" + request + "]" ) ; String replyTo = base . getReplyDestination ( ) ; base . marshal ( request , replyTo , reply ) ; base . setMessageProperties ( outMessage , reply ) ; String correlationID = null ; if ( ! isOneWay ) { String id = null ; if ( id != null ) { if ( correlationID != null ) { String error = "User cannot set CamelCorrelationID when " + "making a request/reply invocation using " + "a static replyTo Queue." ; } correlationID = id ; } } if ( correlationID != null ) { reply . getIn ( ) . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , correlationID ) ; } else { } getLogger ( ) . log ( Level . FINE , "template sending request: " , reply . getIn ( ) ) ; } } ) ; } private void handleResponse ( ) throws IOException { Object response = null ; Message inMessage = new MessageImpl ( ) ; outMessage . getExchange ( ) . setInMessage ( inMessage ) ; getLogger ( ) . log ( Level . FINE , "The Response Message is : [" + response + "]" ) ; byte [ ] bytes = null ; if ( response instanceof String ) { String requestString = ( String ) response ; bytes = requestString . getBytes ( ) ; } else { bytes = ( byte [ ] ) response ; } inMessage . setContent ( InputStream . class , new ByteArrayInputStream ( bytes ) ) ; getLogger ( ) . log ( Level . FINE , "incoming observer is " + incomingObserver ) ; incomingObserver . onMessage ( inMessage ) ; } } private boolean isTextPayload ( ) { return true ; } protected class DecoupledDestination implements Destination { protected MessageObserver decoupledMessageObserver ; private EndpointReferenceType address ; DecoupledDestination ( EndpointReferenceType ref , MessageObserver incomingObserver ) { address = ref ; decoupledMessageObserver = incomingObserver ; } public EndpointReferenceType getAddress ( ) { return address ; } public Conduit getBackChannel ( Message inMessage , Message partialResponse , EndpointReferenceType addr ) throws IOException { return null ; } public void shutdown ( ) { } public synchronized void setMessageObserver ( MessageObserver observer ) { decoupledMessageObserver = observer ; } public synchronized MessageObserver getMessageObserver ( ) { return decoupledMessageObserver ; } } } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . Converter ; import org . apache . camel . impl . CachingInjector ; import org . apache . camel . util . ResolverUtil ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . reflect . Method ; import static java . lang . reflect . Modifier . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . StringTokenizer ; public class AnnotationTypeConverterLoader implements TypeConverterLoader { public static final String META_INF_SERVICES = "META-INF/services/org/apache/camel/TypeConverter" ; private static final transient Log log = LogFactory . getLog ( AnnotationTypeConverterLoader . class ) ; private ResolverUtil resolver = new ResolverUtil ( ) ; private Set < Class > visitedClasses = new HashSet < Class > ( ) ; public void load ( TypeConverterRegistry registry ) throws Exception { String [ ] packageNames = findPackageNames ( ) ; resolver . findAnnotated ( Converter . class , packageNames ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class type : classes ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Loading converter class: " + ObjectHelper . name ( type ) ) ; } loadConverterMethods ( registry , type ) ; } } protected String [ ] findPackageNames ( ) throws IOException { Set < String > packages = new HashSet < String > ( ) ; findPackages ( packages , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; findPackages ( packages , getClass ( ) . getClassLoader ( ) ) ; return packages . toArray ( new String [ packages . size ( ) ] ) ; } protected void findPackages ( Set < String > packages , ClassLoader classLoader ) throws IOException { Enumeration < URL > resources = classLoader . getResources ( META_INF_SERVICES ) ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; if ( url != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; try { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) { continue ; } tokenize ( packages , line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { log . warn ( "Caught exception closing stream: " + e , e ) ; } } } } } protected void tokenize ( Set < String > packages , String line ) { StringTokenizer iter = new StringTokenizer ( line , "," ) ; while ( iter . hasMoreTokens ( ) ) { String name = iter . nextToken ( ) . trim ( ) ; if ( name . length ( ) > 0 ) { packages . add ( name ) ; } } } protected void loadConverterMethods ( TypeConverterRegistry registry , Class type ) { if ( visitedClasses . contains ( type ) ) { return ; } visitedClasses . add ( type ) ; Method [ ] methods = type . getDeclaredMethods ( ) ; CachingInjector injector = null ; for ( Method method : methods ) { Converter annotation = method . getAnnotation ( Converter . class ) ; if ( annotation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes == null || parameterTypes . length != 1 ) { log . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method should have one parameter" ) ; } else { int modifiers = method . getModifiers ( ) ; if ( isAbstract ( modifiers ) || ! isPublic ( modifiers ) ) { log . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method is not a public and concrete method" ) ; } else { Class toType = method . getReturnType ( ) ; if ( toType . equals ( Void . class ) ) { log . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method returns a void method" ) ; } else { Class fromType = parameterTypes [ 0 ] ; if ( isStatic ( modifiers ) ) { registry . addTypeConverter ( toType , fromType , new StaticMethodTypeConverter ( method ) ) ; } else { if ( injector == null ) { injector = new CachingInjector ( registry , type ) ; } registry . addTypeConverter ( toType , fromType , new InstanceMethodTypeConverter ( injector , method ) ) ; } } } } } } Class superclass = type . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { loadConverterMethods ( registry , superclass ) ; } } } 	0
package org . apache . camel . spring . xml ; import org . springframework . beans . factory . xml . AbstractSimpleBeanDefinitionParser ; import org . w3c . dom . Element ; public class BeanDefinitionParser extends AbstractSimpleBeanDefinitionParser { private Class type ; protected BeanDefinitionParser ( ) { } public BeanDefinitionParser ( Class type ) { this . type = type ; } protected Class getBeanClass ( Element element ) { if ( type == null ) { type = loadType ( ) ; } return type ; } protected Class loadType ( ) { throw new IllegalArgumentException ( "No type specified!" ) ; } @ Override protected boolean isEligibleAttribute ( String attributeName ) { return attributeName != null && super . isEligibleAttribute ( attributeName ) && ! attributeName . equals ( "xmlns" ) ; } } 	0
package org . apache . camel . bam ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . builder . ProcessorFactory ; import org . apache . camel . impl . EventDrivenConsumerRoute ; import java . util . Date ; public class ActivityBuilder implements ProcessorFactory { private ProcessBuilder processBuilder ; private Endpoint endpoint ; private ActivityRules activityRules ; private Expression correlationExpression ; public ActivityBuilder ( ProcessBuilder processBuilder , Endpoint endpoint ) { this . processBuilder = processBuilder ; this . endpoint = endpoint ; this . activityRules = new ActivityRules ( processBuilder ) ; this . activityRules . setActivityName ( endpoint . getEndpointUri ( ) ) ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Processor createProcessor ( ) throws Exception { return processBuilder . createActivityProcessor ( this ) ; } public Route createRoute ( ) throws Exception { Processor processor = createProcessor ( ) ; if ( processor == null ) { throw new IllegalArgumentException ( "No processor created for ActivityBuilder: " + this ) ; } return new EventDrivenConsumerRoute ( getEndpoint ( ) , processor ) ; } public ActivityBuilder correlate ( Expression correlationExpression ) { this . correlationExpression = correlationExpression ; return this ; } public ActivityBuilder name ( String name ) { activityRules . setActivityName ( name ) ; return this ; } public TimeExpression starts ( ) { return new TimeExpression ( this , ActivityLifecycle . Started ) { public Date evaluate ( ProcessInstance instance , ActivityState state ) { return state . getTimeStarted ( ) ; } } ; } public TimeExpression completes ( ) { return new TimeExpression ( this , ActivityLifecycle . Completed ) { public Date evaluate ( ProcessInstance instance , ActivityState state ) { return state . getTimeCompleted ( ) ; } } ; } public Expression getCorrelationExpression ( ) { return correlationExpression ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ProcessBuilder getProcessBuilder ( ) { return processBuilder ; } } 	0
package org . apache . camel . component . cxf ; public interface CxfConstants { String METHOD = "method" ; String SEI = "sei" ; String IMPL = "impl" ; } 	0
package org . apache . camel . converter ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface HasAnnotation { Class value ( ) ; } 	0
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public interface ErrorHandler extends Processor { } 	0
package org . apache . camel . impl ; import org . apache . camel . Predicate ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public abstract class BinaryPredicateSupport < E extends Exchange > implements Predicate < E > { private final Expression < E > left ; private final Expression < E > right ; protected BinaryPredicateSupport ( Expression < E > left , Expression < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; this . left = left ; this . right = right ; } @ Override public String toString ( ) { return left + " " + getOperationText ( ) + " " + right ; } public boolean matches ( E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; return matches ( exchange , leftValue , rightValue ) ; } public void assertMatches ( String text , E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; if ( ! matches ( exchange , leftValue , rightValue ) ) { throw new AssertionError ( assertionFailureMessage ( exchange , leftValue , rightValue ) ) ; } } protected abstract boolean matches ( E exchange , Object leftValue , Object rightValue ) ; protected abstract String getOperationText ( ) ; protected String assertionFailureMessage ( E exchange , Object leftValue , Object rightValue ) { return this + " failed on " + exchange + " with left value <" + leftValue + "> right value <" + rightValue + ">" ; } } 	0
package org . apache . camel . spi ; import java . io . IOException ; import java . io . InputStream ; public interface Unmarshaller { Object unmarshal ( InputStream stream ) throws IOException ; } 	0
package org . apache . camel . component . pojo ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; import org . apache . camel . spi . Provider ; import org . apache . camel . impl . DefaultComponent ; public class PojoComponent extends DefaultComponent < PojoExchange > { protected final HashMap < String , Object > services = new HashMap < String , Object > ( ) ; public void addService ( String uri , Object pojo ) { services . put ( uri , pojo ) ; } public void removeService ( String uri ) { services . remove ( uri ) ; } public Object getService ( String uri ) { return services . get ( uri ) ; } @ Override protected Endpoint < PojoExchange > createEndpoint ( String uri , final String remaining , Map parameters ) throws Exception { Object pojo = getService ( remaining ) ; return new PojoEndpoint ( uri , this , pojo ) ; } static public Object createProxy ( final Endpoint endpoint , ClassLoader cl , Class interfaces [ ] ) throws Exception { final Producer producer = endpoint . createProducer ( ) ; return Proxy . newProxyInstance ( cl , interfaces , new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { PojoInvocation invocation = new PojoInvocation ( proxy , method , args ) ; PojoExchange exchange = new PojoExchange ( endpoint . getContext ( ) ) ; exchange . setInvocation ( invocation ) ; producer . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( ) . getBody ( ) ; } } ) ; } static public Object createProxy ( Endpoint endpoint , Class interfaces [ ] ) throws Exception { if ( interfaces . length < 1 ) { throw new IllegalArgumentException ( "You must provide at least 1 interface class." ) ; } return createProxy ( endpoint , interfaces [ 0 ] . getClassLoader ( ) , interfaces ) ; } @ SuppressWarnings ( "unchecked" ) static public < T > T createProxy ( Endpoint endpoint , ClassLoader cl , Class < T > interfaceClass ) throws Exception { return ( T ) createProxy ( endpoint , cl , new Class [ ] { interfaceClass } ) ; } @ SuppressWarnings ( "unchecked" ) static public < T > T createProxy ( Endpoint endpoint , Class < T > interfaceClass ) throws Exception { return ( T ) createProxy ( endpoint , new Class [ ] { interfaceClass } ) ; } } 	0
package org . apache . camel . component . activemq ; import org . apache . camel . CamelContext ; import org . apache . camel . component . jms . JmsComponent ; import org . apache . camel . component . jms . JmsConfiguration ; public class ActiveMQComponent extends JmsComponent { public static ActiveMQComponent activeMQComponent ( ) { return new ActiveMQComponent ( ) ; } public static ActiveMQComponent activeMQComponent ( String brokerURL ) { ActiveMQComponent answer = new ActiveMQComponent ( ) ; answer . getConfiguration ( ) . setBrokerURL ( brokerURL ) ; return answer ; } public ActiveMQComponent ( ) { } public ActiveMQComponent ( CamelContext context ) { super ( context ) ; } public ActiveMQComponent ( ActiveMQConfiguration configuration ) { super ( configuration ) ; } @ Override public ActiveMQConfiguration getConfiguration ( ) { return ( ActiveMQConfiguration ) super . getConfiguration ( ) ; } public void setBrokerURL ( String brokerURL ) { getConfiguration ( ) . setBrokerURL ( brokerURL ) ; } @ Override protected JmsConfiguration createConfiguration ( ) { return new ActiveMQConfiguration ( ) ; } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Message ; import javax . xml . transform . Result ; import javax . xml . transform . stream . StreamResult ; import java . io . ByteArrayOutputStream ; public class StreamResultHandler implements ResultHandler { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; StreamResult result = new StreamResult ( buffer ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( buffer . toByteArray ( ) ) ; } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . Pipeline ; import java . util . List ; public class TopicLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; for ( Processor processor : list ) { Exchange copy = copyExchangeStrategy ( processor , exchange ) ; processor . process ( copy ) ; } } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	0
package org . apache . camel . spring . util ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; public class ReflectionUtils extends org . springframework . util . ReflectionUtils { public static < T extends Annotation > void callLifecycleMethod ( final Object bean , final Class < T > annotation ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( method . getAnnotation ( annotation ) != null ) { try { method . invoke ( bean , ( Object [ ] ) null ) ; } catch ( IllegalArgumentException ex ) { throw new IllegalStateException ( "Failure to invoke " + method + " on " + bean . getClass ( ) + ": args=[]" , ex ) ; } catch ( IllegalAccessException ex ) { throw new UnsupportedOperationException ( ex . toString ( ) ) ; } catch ( InvocationTargetException ex ) { throw new UnsupportedOperationException ( "PostConstruct method on bean threw exception" , ex . getTargetException ( ) ) ; } } } } ) ; } public static void setField ( Field f , Object instance , Object value ) { try { boolean oldAccessible = f . isAccessible ( ) ; boolean shouldSetAccessible = ! Modifier . isPublic ( f . getModifiers ( ) ) && ! oldAccessible ; if ( shouldSetAccessible ) { f . setAccessible ( true ) ; } f . set ( instance , value ) ; if ( shouldSetAccessible ) { f . setAccessible ( oldAccessible ) ; } } catch ( IllegalArgumentException ex ) { throw new UnsupportedOperationException ( "Cannot inject value of class '" + value . getClass ( ) + "' into " + f ) ; } catch ( IllegalAccessException ex ) { ReflectionUtils . handleReflectionException ( ex ) ; } } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Message ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . Result ; import java . io . StringWriter ; public class StringResultHandler implements ResultHandler { StringWriter buffer = new StringWriter ( ) ; StreamResult result = new StreamResult ( buffer ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( buffer . toString ( ) ) ; } } 	0
package org . apache . camel ; public interface Predicate < E > { boolean matches ( E exchange ) ; void assertMatches ( String text , E exchange ) throws AssertionError ; } 	0
package org . apache . camel . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . util . Set ; import java . util . HashSet ; import java . util . Enumeration ; import java . util . jar . JarEntry ; import java . util . jar . JarInputStream ; import java . net . URL ; import java . net . URLDecoder ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; public class ResolverUtil < T > { private static final transient Log log = LogFactory . getLog ( ResolverUtil . class ) ; public static interface Test { boolean matches ( Class type ) ; } public static class IsA implements Test { private Class parent ; public IsA ( Class parentType ) { this . parent = parentType ; } public boolean matches ( Class type ) { return type != null && parent . isAssignableFrom ( type ) ; } @ Override public String toString ( ) { return "is assignable to " + parent . getSimpleName ( ) ; } } public static class AnnotatedWith implements Test { private Class < ? extends Annotation > annotation ; public AnnotatedWith ( Class < ? extends Annotation > annotation ) { this . annotation = annotation ; } public boolean matches ( Class type ) { return type != null && type . isAnnotationPresent ( annotation ) ; } @ Override public String toString ( ) { return "annotated with @" + annotation . getSimpleName ( ) ; } } private Set < Class < ? extends T > > matches = new HashSet < Class < ? extends T > > ( ) ; private ClassLoader classloader ; public Set < Class < ? extends T > > getClasses ( ) { return matches ; } public ClassLoader getClassLoader ( ) { return classloader == null ? Thread . currentThread ( ) . getContextClassLoader ( ) : classloader ; } public void setClassLoader ( ClassLoader classloader ) { this . classloader = classloader ; } public void findImplementations ( Class parent , String ... packageNames ) { if ( packageNames == null ) return ; Test test = new IsA ( parent ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } } public void findAnnotated ( Class < ? extends Annotation > annotation , String ... packageNames ) { if ( packageNames == null ) return ; Test test = new AnnotatedWith ( annotation ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } } public void find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; ClassLoader loader = getClassLoader ( ) ; Enumeration < URL > urls ; try { urls = loader . getResources ( packageName ) ; } catch ( IOException ioe ) { log . warn ( "Could not read package: " + packageName , ioe ) ; return ; } while ( urls . hasMoreElements ( ) ) { try { String urlPath = urls . nextElement ( ) . getFile ( ) ; urlPath = URLDecoder . decode ( urlPath , "UTF-8" ) ; if ( urlPath . startsWith ( "file:" ) ) { urlPath = urlPath . substring ( 5 ) ; } if ( urlPath . indexOf ( '!' ) > 0 ) { urlPath = urlPath . substring ( 0 , urlPath . indexOf ( '!' ) ) ; } log . debug ( "Scanning for classes in [" + urlPath + "] matching criteria: " + test ) ; File file = new File ( urlPath ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageName , file ) ; } else { loadImplementationsInJar ( test , packageName , file ) ; } } catch ( IOException ioe ) { log . warn ( "could not read entries" , ioe ) ; } } } private void loadImplementationsInDirectory ( Test test , String parent , File location ) { File [ ] files = location . listFiles ( ) ; StringBuilder builder = null ; for ( File file : files ) { builder = new StringBuilder ( 100 ) ; builder . append ( parent ) . append ( "/" ) . append ( file . getName ( ) ) ; String packageOrClass = ( parent == null ? file . getName ( ) : builder . toString ( ) ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageOrClass , file ) ; } else if ( file . getName ( ) . endsWith ( ".class" ) ) { addIfMatching ( test , packageOrClass ) ; } } } private void loadImplementationsInJar ( Test test , String parent , File jarfile ) { try { JarEntry entry ; JarInputStream jarStream = new JarInputStream ( new FileInputStream ( jarfile ) ) ; while ( ( entry = jarStream . getNextJarEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( ! entry . isDirectory ( ) && name . startsWith ( parent ) && name . endsWith ( ".class" ) ) { addIfMatching ( test , name ) ; } } } catch ( IOException ioe ) { log . error ( "Could not search jar file '" + jarfile + "' for classes matching criteria: " + test + "due to an IOException: " + ioe . getMessage ( ) ) ; } } protected void addIfMatching ( Test test , String fqn ) { try { String externalName = fqn . substring ( 0 , fqn . indexOf ( '.' ) ) . replace ( '/' , '.' ) ; ClassLoader loader = getClassLoader ( ) ; log . trace ( "Checking to see if class " + externalName + " matches criteria [" + test + "]" ) ; Class type = loader . loadClass ( externalName ) ; if ( test . matches ( type ) ) { matches . add ( ( Class < T > ) type ) ; } } catch ( Throwable t ) { log . warn ( "Could not examine class '" + fqn + "' due to a " + t . getClass ( ) . getName ( ) + " with message: " + t . getMessage ( ) ) ; } } } 	0
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Property { String name ( ) ; } 	0
package org . apache . camel . impl ; import org . apache . camel . spi . Policy ; import org . apache . camel . Processor ; public class NoPolicy < E > implements Policy < E > { public Processor wrap ( Processor processor ) { return processor ; } } 	0
package org . apache . camel . util ; import org . apache . camel . Service ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Collection ; public class ServiceHelper { private static final transient Log log = LogFactory . getLog ( ServiceHelper . class ) ; public static void startServices ( Object ... services ) throws Exception { for ( Object value : services ) { startService ( value ) ; } } public static void startServices ( Collection services ) throws Exception { for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; service . start ( ) ; } } } public static void startService ( Object value ) throws Exception { if ( value instanceof Service ) { Service service = ( Service ) value ; service . start ( ) ; } else if ( value instanceof Collection ) { startServices ( ( Collection ) value ) ; } } public static void stopServices ( Object ... services ) throws Exception { Exception firstException = null ; for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; try { service . stop ( ) ; } catch ( Exception e ) { log . debug ( "Caught exception shutting down: " + e , e ) ; if ( firstException == null ) { firstException = e ; } } } } if ( firstException != null ) { throw firstException ; } } public static void stopServices ( Collection services ) throws Exception { Exception firstException = null ; for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; try { service . stop ( ) ; } catch ( Exception e ) { log . debug ( "Caught exception shutting down: " + e , e ) ; if ( firstException == null ) { firstException = e ; } } } } if ( firstException != null ) { throw firstException ; } } } 	0
package org . apache . camel . component . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class ProcessorEndpointConsumer extends DefaultConsumer < Exchange > { private final ProcessorEndpoint endpoint ; public ProcessorEndpointConsumer ( ProcessorEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . getLoadBalancer ( ) . addProcessor ( getProcessor ( ) ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . getLoadBalancer ( ) . removeProcessor ( getProcessor ( ) ) ; super . doStop ( ) ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . util . ObjectHelper ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; public abstract class DefaultEndpoint < E extends Exchange > implements Endpoint < E > { private String endpointUri ; private final Component component ; private CamelContext context ; private ScheduledExecutorService executorService ; protected DefaultEndpoint ( String endpointUri , Component component ) { this . endpointUri = endpointUri ; this . component = component ; this . context = component . getCamelContext ( ) ; } public int hashCode ( ) { return endpointUri . hashCode ( ) * 37 + 1 ; } @ Override public boolean equals ( Object object ) { if ( object instanceof DefaultEndpoint ) { DefaultEndpoint that = ( DefaultEndpoint ) object ; return ObjectHelper . equals ( this . endpointUri , that . endpointUri ) ; } return false ; } @ Override public String toString ( ) { return "Endpoint[" + endpointUri + "]" ; } public String getEndpointUri ( ) { return endpointUri ; } public CamelContext getContext ( ) { return context ; } public Component getComponent ( ) { return component ; } public synchronized ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { Component c = getComponent ( ) ; if ( c != null && c instanceof DefaultComponent ) { DefaultComponent dc = ( DefaultComponent ) c ; executorService = dc . getExecutorService ( ) ; } if ( executorService == null ) { executorService = createExecutorService ( ) ; } } return executorService ; } public synchronized void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } public PollingConsumer < E > createPollingConsumer ( ) throws Exception { return new DefaultPollingConsumer < E > ( this ) ; } public E convertTo ( Class < E > type , Exchange exchange ) { if ( type . isInstance ( exchange ) ) { return type . cast ( exchange ) ; } return getContext ( ) . getExchangeConverter ( ) . convertTo ( type , exchange ) ; } public E createExchange ( Exchange exchange ) { Class < E > exchangeType = getExchangeType ( ) ; if ( exchangeType != null ) { if ( exchangeType . isInstance ( exchange ) ) { return exchangeType . cast ( exchange ) ; } } E answer = createExchange ( ) ; answer . copyFrom ( exchange ) ; return answer ; } public E toExchangeType ( Exchange exchange ) { return createExchange ( exchange ) ; } public Class < E > getExchangeType ( ) { Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { return ( Class < E > ) argumentType ; } } } return null ; } protected ScheduledThreadPoolExecutor createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( 10 ) ; } } 	0
package org . apache . camel . component . mina ; import org . apache . camel . CamelContext ; import org . apache . camel . Producer ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoSession ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoServiceConfig ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . net . SocketAddress ; public class MinaEndpoint extends DefaultEndpoint < MinaExchange > { private final IoAcceptor acceptor ; private final SocketAddress address ; private final IoConnector connector ; private final IoServiceConfig config ; public MinaEndpoint ( String endpointUri , MinaComponent component , SocketAddress address , IoAcceptor acceptor , IoConnector connector , IoServiceConfig config ) { super ( endpointUri , component ) ; this . config = config ; this . address = address ; this . acceptor = acceptor ; this . connector = connector ; } public Producer < MinaExchange > createProducer ( ) throws Exception { return new MinaProducer ( this ) ; } public Consumer < MinaExchange > createConsumer ( Processor processor ) throws Exception { return new MinaConsumer ( this , processor ) ; } public MinaExchange createExchange ( ) { return new MinaExchange ( getContext ( ) ) ; } public MinaExchange createExchange ( IoSession session , Object object ) { MinaExchange exchange = new MinaExchange ( getContext ( ) ) ; exchange . getIn ( ) . setBody ( object ) ; return exchange ; } public IoAcceptor getAcceptor ( ) { return acceptor ; } public SocketAddress getAddress ( ) { return address ; } public IoConnector getConnector ( ) { return connector ; } public IoServiceConfig getConfig ( ) { return config ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel ; public interface Component < E extends Exchange > { CamelContext getCamelContext ( ) ; void setCamelContext ( CamelContext context ) ; Endpoint < E > createEndpoint ( String uri ) throws Exception ; } 	0
package org . apache . camel . component . quartz ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class QuartzConsumer extends DefaultConsumer < QuartzExchange > { public QuartzConsumer ( QuartzEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; } @ Override public QuartzEndpoint getEndpoint ( ) { return ( QuartzEndpoint ) super . getEndpoint ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getEndpoint ( ) . consumerStarted ( this ) ; } @ Override protected void doStop ( ) throws Exception { getEndpoint ( ) . consumerStopped ( this ) ; super . doStop ( ) ; } } 	0
package org . apache . camel . bam . rules ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import java . util . ArrayList ; import java . util . List ; public class ProcessRules extends ServiceSupport { private ProcessDefinition processDefinition ; private List < ActivityRules > activities = new ArrayList < ActivityRules > ( ) ; public void processExpired ( ActivityState activityState ) throws Exception { for ( ActivityRules activityRules : activities ) { activityRules . processExpired ( activityState ) ; } } public void processExchange ( Exchange exchange , ProcessInstance process ) { for ( ActivityRules activityRules : activities ) { activityRules . processExchange ( exchange , process ) ; } } public List < ActivityRules > getActivities ( ) { return activities ; } public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( activities ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( activities ) ; } } 	0
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . SendProcessor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class BuilderSupport { private CamelContext context ; private ErrorHandlerBuilder errorHandlerBuilder ; private boolean inheritErrorHandler = true ; protected BuilderSupport ( CamelContext context ) { this . context = context ; } protected BuilderSupport ( BuilderSupport parent ) { this . context = parent . getContext ( ) ; this . inheritErrorHandler = parent . inheritErrorHandler ; if ( inheritErrorHandler && parent . errorHandlerBuilder != null ) { this . errorHandlerBuilder = parent . errorHandlerBuilder . copy ( ) ; } } @ Fluent public ValueBuilder header ( @ FluentArg ( "name" ) String name ) { return Builder . header ( name ) ; } @ Fluent public ValueBuilder body ( ) { return Builder . body ( ) ; } @ Fluent public < T > ValueBuilder bodyAs ( @ FluentArg ( "class" ) Class < T > type ) { return Builder . bodyAs ( type ) ; } @ Fluent public ValueBuilder outBody ( ) { return Builder . outBody ( ) ; } @ Fluent public < T > ValueBuilder outBody ( @ FluentArg ( "class" ) Class < T > type ) { return Builder . outBody ( type ) ; } @ Fluent public ValueBuilder systemProperty ( @ FluentArg ( "name" ) String name ) { return Builder . systemProperty ( name ) ; } @ Fluent public ValueBuilder systemProperty ( @ FluentArg ( "name" ) String name , @ FluentArg ( "defaultValue" ) String defaultValue ) { return Builder . systemProperty ( name , defaultValue ) ; } @ Fluent public Endpoint endpoint ( @ FluentArg ( "uri" ) String uri ) { return getContext ( ) . getEndpoint ( uri ) ; } @ Fluent public List < Endpoint > endpoints ( @ FluentArg ( "uris" ) String ... uris ) { List < Endpoint > endpoints = new ArrayList < Endpoint > ( ) ; for ( String uri : uris ) { endpoints . add ( endpoint ( uri ) ) ; } return endpoints ; } @ Fluent public List < Endpoint > endpoints ( @ FluentArg ( "endpoints" ) Endpoint ... endpoints ) { List < Endpoint > answer = new ArrayList < Endpoint > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint ) ; } return answer ; } @ Fluent public NoErrorHandlerBuilder noErrorHandler ( ) { return new NoErrorHandlerBuilder ( ) ; } @ Fluent public LoggingErrorHandlerBuilder loggingErrorHandler ( ) { return new LoggingErrorHandlerBuilder ( ) ; } @ Fluent public LoggingErrorHandlerBuilder loggingErrorHandler ( @ FluentArg ( "log" ) String log ) { return loggingErrorHandler ( LogFactory . getLog ( log ) ) ; } @ Fluent public LoggingErrorHandlerBuilder loggingErrorHandler ( @ FluentArg ( "log" ) Log log ) { return new LoggingErrorHandlerBuilder ( log ) ; } @ Fluent public LoggingErrorHandlerBuilder loggingErrorHandler ( @ FluentArg ( "log" ) Log log , @ FluentArg ( "level" ) LoggingLevel level ) { return new LoggingErrorHandlerBuilder ( log , level ) ; } @ Fluent public DeadLetterChannelBuilder deadLetterChannel ( ) { return new DeadLetterChannelBuilder ( ) ; } @ Fluent public DeadLetterChannelBuilder deadLetterChannel ( @ FluentArg ( "uri" ) String deadLetterUri ) { return deadLetterChannel ( endpoint ( deadLetterUri ) ) ; } @ Fluent public DeadLetterChannelBuilder deadLetterChannel ( @ FluentArg ( "ref" ) Endpoint deadLetterEndpoint ) { return new DeadLetterChannelBuilder ( new SendProcessor ( deadLetterEndpoint ) ) ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public boolean isInheritErrorHandler ( ) { return inheritErrorHandler ; } public void setInheritErrorHandler ( boolean inheritErrorHandler ) { this . inheritErrorHandler = inheritErrorHandler ; } } 	0
package org . apache . camel . component . rmi ; import java . net . URI ; import java . net . URISyntaxException ; import java . rmi . RemoteException ; import java . rmi . registry . LocateRegistry ; import java . rmi . registry . Registry ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . impl . DefaultEndpoint ; public class RmiEndpoint extends DefaultEndpoint < PojoExchange > { private List < Class > remoteInterfaces ; private ClassLoader classLoader ; private URI uri ; private int port ; protected RmiEndpoint ( String endpointUri , RmiComponent component ) throws URISyntaxException { super ( endpointUri , component ) ; this . uri = new URI ( endpointUri ) ; } public boolean isSingleton ( ) { return false ; } public PojoExchange createExchange ( ) { return new PojoExchange ( getContext ( ) ) ; } public Consumer < PojoExchange > createConsumer ( Processor processor ) throws Exception { if ( remoteInterfaces == null || remoteInterfaces . size ( ) == 0 ) throw new RuntimeCamelException ( "To create an RMI consumer, the RMI endpoint's remoteInterfaces property must be be configured." ) ; return new RmiConsumer ( this , processor ) ; } public Producer < PojoExchange > createProducer ( ) throws Exception { return new RmiProducer ( this ) ; } public String getName ( ) { String path = uri . getPath ( ) ; if ( path == null ) path = uri . getSchemeSpecificPart ( ) ; return path ; } public Registry getRegistry ( ) throws RemoteException { if ( uri . getHost ( ) != null ) { if ( uri . getPort ( ) == - 1 ) { return LocateRegistry . getRegistry ( uri . getHost ( ) ) ; } else { return LocateRegistry . getRegistry ( uri . getHost ( ) , uri . getPort ( ) ) ; } } else { return LocateRegistry . getRegistry ( ) ; } } public List < Class > getRemoteInterfaces ( ) { return remoteInterfaces ; } public void setRemoteInterfaces ( List < Class > remoteInterfaces ) { this . remoteInterfaces = remoteInterfaces ; if ( classLoader == null && ! remoteInterfaces . isEmpty ( ) ) { classLoader = remoteInterfaces . get ( 0 ) . getClassLoader ( ) ; } } public void setRemoteInterfaces ( Class ... remoteInterfaces ) { setRemoteInterfaces ( Arrays . asList ( remoteInterfaces ) ) ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . transport . local . LocalConduit ; import org . apache . cxf . transport . local . LocalTransportFactory ; import java . io . IOException ; import java . util . concurrent . CountDownLatch ; public class CxfProducer extends DefaultProducer { private CxfEndpoint endpoint ; private final LocalTransportFactory transportFactory ; private Destination destination ; private Conduit conduit ; private ResultFuture future = new ResultFuture ( ) ; public CxfProducer ( CxfEndpoint endpoint , LocalTransportFactory transportFactory ) { super ( endpoint ) ; this . endpoint = endpoint ; this . transportFactory = transportFactory ; } public void process ( Exchange exchange ) { CxfExchange cxfExchange = endpoint . toExchangeType ( exchange ) ; process ( cxfExchange ) ; } public void process ( CxfExchange exchange ) { try { CxfBinding binding = endpoint . getBinding ( ) ; MessageImpl m = binding . createCxfMessage ( exchange ) ; ExchangeImpl e = new ExchangeImpl ( ) ; e . setInMessage ( m ) ; m . put ( LocalConduit . DIRECT_DISPATCH , Boolean . TRUE ) ; m . setDestination ( destination ) ; synchronized ( conduit ) { conduit . prepare ( m ) ; if ( endpoint . isInOut ( ) ) { Message response = future . getResponse ( ) ; response = e . getOutMessage ( ) ; binding . storeCxfResponse ( exchange , response ) ; } } } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; EndpointInfo endpointInfo = endpoint . getEndpointInfo ( ) ; destination = transportFactory . getDestination ( endpointInfo ) ; conduit = transportFactory . getConduit ( endpointInfo ) ; conduit . setMessageObserver ( future ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( conduit != null ) { conduit . close ( ) ; } } protected class ResultFuture implements MessageObserver { Message response ; CountDownLatch latch = new CountDownLatch ( 1 ) ; public Message getResponse ( ) { while ( response == null ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { } } return response ; } public synchronized void onMessage ( Message message ) { try { message . remove ( LocalConduit . DIRECT_DISPATCH ) ; this . response = message ; } finally { latch . countDown ( ) ; } } } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public abstract class QueueLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; if ( list . isEmpty ( ) ) { throw new IllegalStateException ( "No processors available to process " + exchange ) ; } Processor processor = chooseProcessor ( list , exchange ) ; if ( processor == null ) { throw new IllegalStateException ( "No processors could be chosen to process " + exchange ) ; } else { processor . process ( exchange ) ; } } protected abstract Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) ; } 	0
package org . apache . camel . component . pojo . timer ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . Timer ; import java . util . TimerTask ; import org . apache . camel . Processor ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . component . pojo . PojoInvocation ; import org . apache . camel . impl . DefaultConsumer ; public class TimerConsumer extends DefaultConsumer < PojoExchange > implements InvocationHandler { private final TimerEndpoint endpoint ; private Timer timer ; public TimerConsumer ( TimerEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { TimerComponent component = endpoint . getComponent ( ) ; component . addConsumer ( this ) ; timer = createTimerAndTask ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( timer != null ) { timer . cancel ( ) ; } TimerComponent component = endpoint . getComponent ( ) ; component . removeConsumer ( this ) ; } private Timer createTimerAndTask ( ) { final Runnable proxy = createProxy ( ) ; TimerTask task = new TimerTask ( ) { @ Override public void run ( ) { proxy . run ( ) ; } } ; Timer result = new Timer ( endpoint . getTimerName ( ) , endpoint . isDaemon ( ) ) ; if ( endpoint . isFixedRate ( ) ) { if ( endpoint . getTime ( ) != null ) { result . scheduleAtFixedRate ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { result . scheduleAtFixedRate ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } } else { if ( endpoint . getTime ( ) != null ) { if ( endpoint . getPeriod ( ) >= 0 ) { result . schedule ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { result . schedule ( task , endpoint . getTime ( ) ) ; } } else { if ( endpoint . getPeriod ( ) >= 0 ) { result . schedule ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } else { result . schedule ( task , endpoint . getDelay ( ) ) ; } } } return result ; } public Runnable createProxy ( ) { return ( Runnable ) Proxy . newProxyInstance ( Runnable . class . getClassLoader ( ) , new Class [ ] { Runnable . class } , this ) ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( ! isStarted ( ) ) { throw new IllegalStateException ( "The endpoint is not active: " + getEndpoint ( ) . getEndpointUri ( ) ) ; } PojoInvocation invocation = new PojoInvocation ( proxy , method , args ) ; PojoExchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . setInvocation ( invocation ) ; getProcessor ( ) . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( ) . getBody ( ) ; } } 	0
package org . apache . camel . bam ; public enum ActivityLifecycle { Started , Completed } 	0
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallback ; import org . springframework . transaction . support . TransactionTemplate ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; public abstract class BamProcessorSupport < T > implements Processor { private static final transient Log log = LogFactory . getLog ( BamProcessorSupport . class ) ; private Class < T > entityType ; private Expression < Exchange > correlationKeyExpression ; private TransactionTemplate transactionTemplate ; protected BamProcessorSupport ( TransactionTemplate transactionTemplate , Expression < Exchange > correlationKeyExpression ) { this . transactionTemplate = transactionTemplate ; this . correlationKeyExpression = correlationKeyExpression ; Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { this . entityType = ( Class < T > ) argumentType ; } } } if ( entityType == null ) { throw new IllegalArgumentException ( "Could not infer the entity type!" ) ; } } protected BamProcessorSupport ( TransactionTemplate transactionTemplate , Expression < Exchange > correlationKeyExpression , Class < T > entitytype ) { this . transactionTemplate = transactionTemplate ; this . entityType = entitytype ; this . correlationKeyExpression = correlationKeyExpression ; } public void process ( final Exchange exchange ) { transactionTemplate . execute ( new TransactionCallback ( ) { public Object doInTransaction ( TransactionStatus status ) { try { Object key = getCorrelationKey ( exchange ) ; T entity = loadEntity ( exchange , key ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Correlation key: " + key + " with entity: " + entity ) ; } processEntity ( exchange , entity ) ; return entity ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } ) ; } public Expression < Exchange > getCorrelationKeyExpression ( ) { return correlationKeyExpression ; } public Class < T > getEntityType ( ) { return entityType ; } protected abstract void processEntity ( Exchange exchange , T entity ) throws Exception ; protected abstract T loadEntity ( Exchange exchange , Object key ) ; protected Object getCorrelationKey ( Exchange exchange ) throws NoCorrelationKeyException { Object value = correlationKeyExpression . evaluate ( exchange ) ; if ( value == null ) { throw new NoCorrelationKeyException ( this , exchange ) ; } return value ; } } 	0
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; public class JpaBamProcessor extends JpaBamProcessorSupport < ProcessInstance > { private static final transient Log log = LogFactory . getLog ( JpaBamProcessor . class ) ; public JpaBamProcessor ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , template , correlationKeyExpression , activityRules ) ; } public JpaBamProcessor ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < ProcessInstance > entitytype ) { super ( transactionTemplate , template , correlationKeyExpression , activityRules , entitytype ) ; } protected void processEntity ( Exchange exchange , ProcessInstance process ) throws Exception { if ( log . isDebugEnabled ( ) ) { log . debug ( "Processing process instance: " + process ) ; } ActivityRules rules = getActivityRules ( ) ; ActivityState state = process . getOrCreateActivityState ( rules ) ; state . processExchange ( rules , new ProcessContext ( exchange , rules , state ) ) ; rules . getProcessRules ( ) . processExchange ( exchange , process ) ; } } 	0
package org . apache . camel . component . pojo ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; public class PojoExchange extends DefaultExchange { public PojoExchange ( CamelContext context ) { super ( context ) ; } public PojoInvocation getInvocation ( ) { return getIn ( ) . getBody ( PojoInvocation . class ) ; } public void setInvocation ( PojoInvocation invocation ) { getIn ( ) . setBody ( invocation ) ; } @ Override public Exchange newInstance ( ) { return new PojoExchange ( getContext ( ) ) ; } } 	0
package org . apache . camel . util ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import java . util . Comparator ; public class ExpressionComparator < E extends Exchange > implements Comparator < E > { private final Expression < E > expression ; public ExpressionComparator ( Expression < E > expression ) { this . expression = expression ; } public int compare ( E e1 , E e2 ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; return ObjectHelper . compare ( o1 , o2 ) ; } } 	0
package org . apache . camel . component . file ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . channels . FileChannel ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log log = LogFactory . getLog ( FileConsumer . class ) ; private final FileEndpoint endpoint ; private boolean recursive = true ; private boolean attemptFileLock = false ; private String regexPattern = "" ; private long lastPollTime = 0l ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected void poll ( ) throws Exception { pollFileOrDirectory ( endpoint . getFile ( ) , isRecursive ( ) ) ; lastPollTime = System . currentTimeMillis ( ) ; } protected void pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { pollFile ( fileOrDirectory ) ; } else if ( processDir ) { log . debug ( "Polling directory " + fileOrDirectory ) ; File [ ] files = fileOrDirectory . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { pollFileOrDirectory ( files [ i ] , isRecursive ( ) ) ; } } else { log . debug ( "Skipping directory " + fileOrDirectory ) ; } } protected void pollFile ( final File file ) { if ( file . exists ( ) && file . lastModified ( ) > lastPollTime ) { if ( isValidFile ( file ) ) { processFile ( file ) ; } } } protected void processFile ( File file ) { try { getProcessor ( ) . process ( endpoint . createExchange ( file ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) ) { if ( isAttemptFileLock ( ) ) { FileChannel fc = null ; try { fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . lock ( ) ; result = true ; } catch ( Throwable e ) { log . debug ( "Failed to get the lock on file: " + file , e ) ; } finally { if ( fc != null ) { try { fc . close ( ) ; } catch ( IOException e ) { } } } } else { result = true ; } } } return result ; } protected boolean isMatched ( File file ) { boolean result = true ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { result = file . getName ( ) . matches ( getRegexPattern ( ) ) ; } return result ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public boolean isAttemptFileLock ( ) { return this . attemptFileLock ; } public void setAttemptFileLock ( boolean attemptFileLock ) { this . attemptFileLock = attemptFileLock ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } } 	1
package org . apache . camel . component . jmx ; import javax . management . MBeanServer ; import javax . management . Notification ; import javax . management . ObjectName ; import javax . management . monitor . CounterMonitor ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JMXEndpoint extends DefaultEndpoint < JMXExchange > { private static final Log log = LogFactory . getLog ( JMXEndpoint . class ) ; private String name ; private ObjectName ourName ; private String observedObjectName ; private String attributeName ; private long granularityPeriod = 5000 ; private Number threshold ; private Number offset ; private MBeanServer mbeanServer ; private CounterMonitor counterMonitor = new CounterMonitor ( ) ; protected JMXEndpoint ( String endpointUri , JMXComponent component ) { super ( endpointUri , component ) ; observedObjectName = endpointUri ; } public Producer < JMXExchange > createProducer ( ) throws Exception { throw new RuntimeException ( "Not supported" ) ; } public Consumer < JMXExchange > createConsumer ( Processor proc ) throws Exception { ObjectName observedName = new ObjectName ( observedObjectName ) ; if ( name == null ) { String type = observedName . getKeyProperty ( "type" ) ; type = type != null ? type : "UNKNOWN" ; name = mbeanServer . getDefaultDomain ( ) + ":type=CounterMonitor_" + type ; } JMXConsumer result = new JMXConsumer ( this , proc ) ; ourName = new ObjectName ( name ) ; counterMonitor . setNotify ( true ) ; counterMonitor . addObservedObject ( observedName ) ; counterMonitor . setObservedAttribute ( attributeName ) ; counterMonitor . setGranularityPeriod ( granularityPeriod ) ; counterMonitor . setDifferenceMode ( false ) ; counterMonitor . setInitThreshold ( threshold ) ; counterMonitor . setOffset ( offset ) ; mbeanServer . registerMBean ( counterMonitor , ourName ) ; mbeanServer . addNotificationListener ( ourName , result , null , new Object ( ) ) ; return result ; } public boolean isSingleton ( ) { return true ; } public JMXExchange createExchange ( Notification notification ) { return new JMXExchange ( getContext ( ) , notification ) ; } public JMXExchange createExchange ( ) { return new JMXExchange ( getContext ( ) , null ) ; } public String getAttributeName ( ) { return attributeName ; } public void setAttributeName ( String attributeName ) { this . attributeName = attributeName ; } public long getGranularityPeriod ( ) { return granularityPeriod ; } public void setGranularityPeriod ( long granularityPeriod ) { this . granularityPeriod = granularityPeriod ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Number getOffset ( ) { return offset ; } public void setOffset ( Number offset ) { this . offset = offset ; } public Number getThreshold ( ) { return threshold ; } public void setThreshold ( Number threshold ) { this . threshold = threshold ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	0
package org . apache . camel . impl ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . Service ; public abstract class ServiceSupport implements Service { private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { doStart ( ) ; } } public void stop ( ) throws Exception { if ( stopped . compareAndSet ( false , true ) ) { stopping . set ( true ) ; try { doStop ( ) ; } finally { stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; } 	1
package org . apache . camel . spring . xml ; public class IllegalActionException extends IllegalArgumentException { private static final long serialVersionUID = - 2166507687211986107L ; private final String actionName ; private final String previousAction ; public IllegalActionException ( String actionName , String previousAction ) { super ( "Illegal route." ) ; this . actionName = actionName ; this . previousAction = previousAction ; } @ Override public String getMessage ( ) { String errorContext = previousAction == null ? "as the starting action." : "after action '" + previousAction + "'." ; return super . getMessage ( ) + "The action '" + actionName + "' cannot be used " + errorContext ; } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Message ; import javax . xml . transform . Result ; import javax . xml . transform . dom . DOMResult ; public class DomResultHandler implements ResultHandler { private DOMResult result = new DOMResult ( ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( result . getNode ( ) ) ; } } 	0
package org . apache . camel . converter . jaxp ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; public class BytesSource extends StreamSource { private byte [ ] data ; public BytesSource ( byte [ ] data ) { this . data = data ; } public BytesSource ( byte [ ] data , String systemId ) { this . data = data ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { return new ByteArrayInputStream ( data ) ; } public Reader getReader ( ) { return new InputStreamReader ( getInputStream ( ) ) ; } public byte [ ] getData ( ) { return data ; } public String toString ( ) { return "BytesSource[" + new String ( data ) + "]" ; } } 	0
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . DefaultCamelContext ; public abstract class RouteBuilder extends BuilderSupport { private List < FromBuilder > fromBuilders = new ArrayList < FromBuilder > ( ) ; private AtomicBoolean initalized = new AtomicBoolean ( false ) ; private List < Route > routes = new ArrayList < Route > ( ) ; protected RouteBuilder ( ) { this ( null ) ; } protected RouteBuilder ( CamelContext context ) { super ( context ) ; } public abstract void configure ( ) throws Exception ; @ Fluent public FromBuilder from ( @ FluentArg ( "uri" ) String uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "uri parameter cannot be null" ) ; } Endpoint endpoint = endpoint ( uri ) ; if ( endpoint == null ) { throw new IllegalArgumentException ( "uri '" + uri + "' could not be resolved." ) ; } return from ( endpoint ) ; } @ Fluent public FromBuilder from ( @ FluentArg ( "ref" ) Endpoint endpoint ) { FromBuilder answer = new FromBuilder ( this , endpoint ) ; addFromBuilder ( answer ) ; return answer ; } public RouteBuilder errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } public RouteBuilder inheritErrorHandler ( boolean value ) { setInheritErrorHandler ( value ) ; return this ; } public CamelContext getContext ( ) { CamelContext context = super . getContext ( ) ; if ( context == null ) { context = createContainer ( ) ; setContext ( context ) ; } return context ; } public List < Route > getRouteList ( ) throws Exception { checkInitialized ( ) ; return routes ; } public List < FromBuilder > getFromBuilders ( ) throws Exception { checkInitialized ( ) ; return fromBuilders ; } public void addFromBuilder ( FromBuilder answer ) { fromBuilders . add ( answer ) ; } protected void checkInitialized ( ) throws Exception { if ( initalized . compareAndSet ( false , true ) ) { configure ( ) ; populateRoutes ( routes ) ; } } protected void populateRoutes ( List < Route > routes ) throws Exception { for ( FromBuilder builder : fromBuilders ) { Route route = builder . createRoute ( ) ; routes . add ( route ) ; } } protected CamelContext createContainer ( ) { return new DefaultCamelContext ( ) ; } } 	0
package org . apache . camel ; public class NoTypeConversionAvailableException extends RuntimeCamelException { private final Object value ; private final Class type ; public NoTypeConversionAvailableException ( Object value , Class type ) { super ( "No converter available to convert value: " + value + " to the required type: " + type . getName ( ) ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class getType ( ) { return type ; } } 	0
package org . apache . camel . spring . xml ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . xml . DomUtils ; import org . w3c . dom . Element ; public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser { private final String scriptEngineName ; public ScriptDefinitionParser ( String scriptEngineName ) { super ( "org.apache.camel.builder.script.ScriptBuilder" , "camel-script" ) ; this . scriptEngineName = scriptEngineName ; } @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String engine = scriptEngineName ; if ( engine == null ) { engine = element . getAttribute ( "language" ) ; } builder . addConstructorArg ( engine ) ; super . doParse ( element , parserContext , builder ) ; String scriptText = DomUtils . getTextValue ( element ) . trim ( ) ; if ( scriptText . length ( ) > 0 ) { builder . addPropertyValue ( "scriptText" , scriptText ) ; } } } 	0
package org . apache . camel . builder ; import org . apache . camel . RuntimeCamelException ; public class UndefinedDestinationException extends RuntimeCamelException { private static final long serialVersionUID = - 5980888207885995222L ; public UndefinedDestinationException ( ) { super ( "No destination defined for this routing rule" ) ; } } 	0
package org . apache . camel . util ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . FailedToCreateProducerException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . ServiceSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . HashMap ; import java . util . Map ; public class ProducerCache < E extends Exchange > extends ServiceSupport { private static final Log log = LogFactory . getLog ( ProducerCache . class ) ; private Map < String , Producer < E > > producers = new HashMap < String , Producer < E > > ( ) ; public synchronized Producer < E > getProducer ( Endpoint < E > endpoint ) { String key = endpoint . getEndpointUri ( ) ; Producer < E > answer = producers . get ( key ) ; if ( answer == null ) { try { answer = endpoint . createProducer ( ) ; answer . start ( ) ; } catch ( Exception e ) { throw new FailedToCreateProducerException ( endpoint , e ) ; } producers . put ( key , answer ) ; } return answer ; } public void send ( Endpoint < E > endpoint , E exchange ) { try { Producer < E > producer = getProducer ( endpoint ) ; producer . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public E send ( Endpoint < E > endpoint , Processor processor ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( ) ; processor . process ( exchange ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( ">>>> " + endpoint + " " + exchange ) ; } producer . process ( exchange ) ; return exchange ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( producers . values ( ) ) ; } protected void doStart ( ) throws Exception { } } 	0
package org . apache . camel . component . xmpp ; import org . jivesoftware . smack . XMPPException ; public class RuntimeXmppException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeXmppException ( XMPPException cause ) { super ( cause ) ; } public RuntimeXmppException ( String message , XMPPException cause ) { super ( message , cause ) ; } } 	0
package org . apache . camel . component . xmpp ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . GroupChat ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; public class XmppGroupChatProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( XmppGroupChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String room ; private GroupChat chat ; public XmppGroupChatProducer ( XmppEndpoint endpoint , String room ) { super ( endpoint ) ; this . endpoint = endpoint ; this . room = room ; if ( room == null ) { throw new IllegalArgumentException ( "No room property specified" ) ; } } public void process ( Exchange exchange ) { Message message = chat . createMessage ( ) ; message . setTo ( room ) ; message . setFrom ( endpoint . getUser ( ) ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( ">>>> message: " + message . getBody ( ) ) ; } try { chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( chat == null ) { chat = endpoint . getConnection ( ) . createGroupChat ( room ) ; } } @ Override protected void doStop ( ) throws Exception { if ( chat != null ) { chat . leave ( ) ; chat = null ; } super . doStop ( ) ; } public GroupChat getChat ( ) { return chat ; } public void setChat ( GroupChat chat ) { this . chat = chat ; } public String getRoom ( ) { return room ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannelBuilder implements ErrorHandlerBuilder { private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy ( ) ; private ProcessorFactory deadLetterFactory ; private Processor defaultDeadLetterEndpoint ; private Expression defaultDeadLetterEndpointExpression ; private String defaultDeadLetterEndpointUri = "log:org.apache.camel.DeadLetterChannel:error" ; private Logger logger = DeadLetterChannel . createDefaultLogger ( ) ; public DeadLetterChannelBuilder ( ) { } public DeadLetterChannelBuilder ( Processor processor ) { this ( new ConstantProcessorBuilder ( processor ) ) ; } public DeadLetterChannelBuilder ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public ErrorHandlerBuilder copy ( ) { DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder ( deadLetterFactory ) ; answer . setRedeliveryPolicy ( getRedeliveryPolicy ( ) . copy ( ) ) ; return answer ; } public Processor createErrorHandler ( Processor processor ) throws Exception { Processor deadLetter = getDeadLetterFactory ( ) . createProcessor ( ) ; return new DeadLetterChannel ( processor , deadLetter , getRedeliveryPolicy ( ) , getLogger ( ) ) ; } public DeadLetterChannelBuilder backOffMultiplier ( double backOffMultiplier ) { getRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public DeadLetterChannelBuilder collisionAvoidancePercent ( short collisionAvoidancePercent ) { getRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public DeadLetterChannelBuilder initialRedeliveryDelay ( long initialRedeliveryDelay ) { getRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveries ( int maximumRedeliveries ) { getRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public DeadLetterChannelBuilder useCollisionAvoidance ( ) { getRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public DeadLetterChannelBuilder useExponentialBackOff ( ) { getRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public DeadLetterChannelBuilder logger ( Logger logger ) { setLogger ( logger ) ; return this ; } public DeadLetterChannelBuilder loggingLevel ( LoggingLevel level ) { getLogger ( ) . setLevel ( level ) ; return this ; } public DeadLetterChannelBuilder log ( Log log ) { getLogger ( ) . setLog ( log ) ; return this ; } public DeadLetterChannelBuilder log ( String log ) { return log ( LogFactory . getLog ( log ) ) ; } public DeadLetterChannelBuilder log ( Class log ) { return log ( LogFactory . getLog ( log ) ) ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public ProcessorFactory getDeadLetterFactory ( ) { if ( deadLetterFactory == null ) { deadLetterFactory = new ProcessorFactory ( ) { public Processor createProcessor ( ) { return getDefaultDeadLetterEndpoint ( ) ; } } ; } return deadLetterFactory ; } public void setDeadLetterFactory ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public Processor getDefaultDeadLetterEndpoint ( ) { if ( defaultDeadLetterEndpoint == null ) { defaultDeadLetterEndpoint = new RecipientList ( getDefaultDeadLetterEndpointExpression ( ) ) ; } return defaultDeadLetterEndpoint ; } public void setDefaultDeadLetterEndpoint ( Processor defaultDeadLetterEndpoint ) { this . defaultDeadLetterEndpoint = defaultDeadLetterEndpoint ; } public Expression getDefaultDeadLetterEndpointExpression ( ) { if ( defaultDeadLetterEndpointExpression == null ) { defaultDeadLetterEndpointExpression = ExpressionBuilder . constantExpression ( getDefaultDeadLetterEndpointUri ( ) ) ; } return defaultDeadLetterEndpointExpression ; } public void setDefaultDeadLetterEndpointExpression ( Expression defaultDeadLetterEndpointExpression ) { this . defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression ; } public String getDefaultDeadLetterEndpointUri ( ) { return defaultDeadLetterEndpointUri ; } public void setDefaultDeadLetterEndpointUri ( String defaultDeadLetterEndpointUri ) { this . defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public interface ErrorHandlerBuilder < E extends Exchange > { ErrorHandlerBuilder < E > copy ( ) ; Processor createErrorHandler ( Processor processor ) throws Exception ; } 	0
package org . apache . camel . component . jms ; import java . io . ByteArrayOutputStream ; import java . io . DataOutputStream ; import java . io . ObjectOutputStream ; import java . nio . ByteBuffer ; import java . util . Enumeration ; import javax . jms . BytesMessage ; import javax . jms . MapMessage ; import javax . jms . Message ; import javax . jms . MessageEOFException ; import javax . jms . ObjectMessage ; import javax . jms . StreamMessage ; import javax . jms . TextMessage ; import org . apache . camel . Converter ; import org . apache . camel . converter . NIOConverter ; @ Converter public class JmsIOConverter { @ Converter public static ByteBuffer toByteBuffer ( final Message message ) throws Exception { if ( message instanceof TextMessage ) { final String text = ( ( TextMessage ) message ) . getText ( ) ; return NIOConverter . toByteBuffer ( text ) ; } if ( message instanceof BytesMessage ) { final BytesMessage bmsg = ( BytesMessage ) message ; final int len = ( int ) bmsg . getBodyLength ( ) ; final byte [ ] data = new byte [ len ] ; bmsg . readBytes ( data , len ) ; return NIOConverter . toByteBuffer ( data ) ; } if ( message instanceof StreamMessage ) { final StreamMessage msg = ( StreamMessage ) message ; final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; final DataOutputStream dataOut = new DataOutputStream ( bytesOut ) ; try { while ( true ) { final Object obj = msg . readObject ( ) ; writeData ( dataOut , obj ) ; } } catch ( MessageEOFException e ) { } dataOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } if ( message instanceof MapMessage ) { final MapMessage msg = ( MapMessage ) message ; final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; final DataOutputStream dataOut = new DataOutputStream ( bytesOut ) ; for ( final Enumeration en = msg . getMapNames ( ) ; en . hasMoreElements ( ) ; ) { final Object obj = msg . getObject ( en . nextElement ( ) . toString ( ) ) ; writeData ( dataOut , obj ) ; } dataOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } if ( message instanceof ObjectMessage ) { ObjectMessage objMessage = ( ObjectMessage ) message ; Object object = objMessage . getObject ( ) ; ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOut = new ObjectOutputStream ( bytesOut ) ; objectOut . writeObject ( object ) ; objectOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } return null ; } private static void writeData ( DataOutputStream dataOut , Object data ) throws Exception { if ( data instanceof byte [ ] ) { dataOut . write ( ( byte [ ] ) data ) ; } else if ( data instanceof String ) { dataOut . writeUTF ( data . toString ( ) ) ; } else if ( data instanceof Double ) { dataOut . writeDouble ( ( ( Double ) data ) . doubleValue ( ) ) ; } else if ( data instanceof Float ) { dataOut . writeFloat ( ( ( Float ) data ) . floatValue ( ) ) ; } else if ( data instanceof Long ) { dataOut . writeLong ( ( ( Long ) data ) . longValue ( ) ) ; } else if ( data instanceof Integer ) { dataOut . writeInt ( ( ( Integer ) data ) . intValue ( ) ) ; } else if ( data instanceof Short ) { dataOut . writeShort ( ( ( Short ) data ) . shortValue ( ) ) ; } else if ( data instanceof Character ) { dataOut . writeChar ( ( ( Character ) data ) . charValue ( ) ) ; } else if ( data instanceof Byte ) { dataOut . writeByte ( ( ( Byte ) data ) . byteValue ( ) ) ; } else if ( data instanceof Boolean ) { dataOut . writeBoolean ( ( ( Boolean ) data ) . booleanValue ( ) ) ; } } } 	0
package org . apache . camel ; public interface Producer < E extends Exchange > extends Processor , Service { Endpoint < E > getEndpoint ( ) ; E createExchange ( ) ; E createExchange ( E exchange ) ; } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . reflect . Method ; import java . lang . reflect . InvocationTargetException ; public class StaticMethodTypeConverter implements TypeConverter { private final Method method ; public StaticMethodTypeConverter ( Method method ) { this . method = method ; } @ Override public String toString ( ) { return "StaticMethodTypeConverter: " + method ; } public < T > T convertTo ( Class < T > type , Object value ) { return ( T ) ObjectHelper . invokeMethod ( method , null , value ) ; } } 	0
package org . apache . camel . builder . xml ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . Attr ; import javax . xml . namespace . NamespaceContext ; import javax . xml . xpath . XPathFactory ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; public class DefaultNamespaceContext implements NamespaceContext { private final Map map ; private final NamespaceContext parent ; public DefaultNamespaceContext ( ) { this ( XPathFactory . newInstance ( ) ) ; } public DefaultNamespaceContext ( XPathFactory factory ) { this . parent = factory . newXPath ( ) . getNamespaceContext ( ) ; this . map = new HashMap ( ) ; } public DefaultNamespaceContext ( NamespaceContext parent , Map map ) { this . parent = parent ; this . map = map ; } public DefaultNamespaceContext add ( String prefix , String uri ) { map . put ( prefix , uri ) ; return this ; } public String getNamespaceURI ( String prefix ) { String answer = ( String ) map . get ( prefix ) ; if ( answer == null && parent != null ) { return parent . getNamespaceURI ( prefix ) ; } return answer ; } public String getPrefix ( String namespaceURI ) { for ( Iterator iter = map . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( namespaceURI . equals ( entry . getValue ( ) ) ) { return ( String ) entry . getKey ( ) ; } } if ( parent != null ) { return parent . getPrefix ( namespaceURI ) ; } return null ; } public Iterator getPrefixes ( String namespaceURI ) { Set set = new HashSet ( ) ; for ( Iterator iter = map . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( namespaceURI . equals ( entry . getValue ( ) ) ) { set . add ( entry . getKey ( ) ) ; } } if ( parent != null ) { Iterator iter = parent . getPrefixes ( namespaceURI ) ; while ( iter . hasNext ( ) ) { set . add ( iter . next ( ) ) ; } } return set . iterator ( ) ; } public void setNamespacesFromDom ( Element element ) { Node parentNode = element . getParentNode ( ) ; if ( parentNode instanceof Element ) { setNamespacesFromDom ( ( Element ) parentNode ) ; } NamedNodeMap attributes = element . getAttributes ( ) ; for ( int i = 0 , size = attributes . getLength ( ) ; i < size ; i ++ ) { Attr node = ( Attr ) attributes . item ( i ) ; String name = node . getName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { String prefix = name . substring ( "xmlns:" . length ( ) ) ; String uri = node . getValue ( ) ; add ( prefix , uri ) ; } } } } 	0
package org . apache . camel . component . rmi ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . rmi . Remote ; import java . rmi . registry . Registry ; import java . rmi . server . UnicastRemoteObject ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . component . pojo . PojoInvocation ; import org . apache . camel . impl . DefaultConsumer ; public class RmiConsumer extends DefaultConsumer < PojoExchange > implements InvocationHandler { private final RmiEndpoint endpoint ; private Remote stub ; private Remote proxy ; public RmiConsumer ( RmiEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { Class [ ] interfaces = new Class [ endpoint . getRemoteInterfaces ( ) . size ( ) ] ; endpoint . getRemoteInterfaces ( ) . toArray ( interfaces ) ; proxy = ( Remote ) Proxy . newProxyInstance ( endpoint . getClassLoader ( ) , interfaces , this ) ; stub = UnicastRemoteObject . exportObject ( proxy , endpoint . getPort ( ) ) ; try { Registry registry = endpoint . getRegistry ( ) ; String name = endpoint . getName ( ) ; registry . bind ( name , stub ) ; } catch ( Exception e ) { try { UnicastRemoteObject . unexportObject ( stub , true ) ; } catch ( Throwable e1 ) { } stub = null ; throw e ; } super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; try { Registry registry = endpoint . getRegistry ( ) ; registry . unbind ( endpoint . getName ( ) ) ; } catch ( Throwable e ) { } UnicastRemoteObject . unexportObject ( proxy , true ) ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( ! isStarted ( ) ) { throw new IllegalStateException ( "The endpoint is not active: " + getEndpoint ( ) . getEndpointUri ( ) ) ; } PojoInvocation invocation = new PojoInvocation ( proxy , method , args ) ; PojoExchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . setInvocation ( invocation ) ; getProcessor ( ) . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( ) . getBody ( ) ; } public Remote getProxy ( ) { return proxy ; } public Remote getStub ( ) { return stub ; } } 	0
package org . apache . camel . spring . spi ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Exchange ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . spi . Policy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . TransactionDefinition ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; public class SpringTransactionPolicy < E > implements Policy < E > { private static final transient Log log = LogFactory . getLog ( SpringTransactionPolicy . class ) ; private TransactionTemplate template ; public SpringTransactionPolicy ( ) { } public SpringTransactionPolicy ( TransactionTemplate template ) { this . template = template ; } public Processor wrap ( Processor processor ) { final TransactionTemplate transactionTemplate = getTemplate ( ) ; if ( transactionTemplate == null ) { log . warn ( "No TransactionTemplate available so transactions will not be enabled!" ) ; return processor ; } return new DelegateProcessor ( processor ) { public void process ( final Exchange exchange ) { transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { try { processNext ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } ) ; } @ Override public String toString ( ) { return "SpringTransactionPolicy:" + propagationBehaviorToString ( transactionTemplate . getPropagationBehavior ( ) ) + "[" + getNext ( ) + "]" ; } private String propagationBehaviorToString ( int propagationBehavior ) { switch ( propagationBehavior ) { case TransactionDefinition . PROPAGATION_MANDATORY : return "PROPAGATION_MANDATORY" ; case TransactionDefinition . PROPAGATION_NESTED : return "PROPAGATION_NESTED" ; case TransactionDefinition . PROPAGATION_NEVER : return "PROPAGATION_NEVER" ; case TransactionDefinition . PROPAGATION_NOT_SUPPORTED : return "PROPAGATION_NOT_SUPPORTED" ; case TransactionDefinition . PROPAGATION_REQUIRED : return "PROPAGATION_REQUIRED" ; case TransactionDefinition . PROPAGATION_REQUIRES_NEW : return "PROPAGATION_REQUIRES_NEW" ; case TransactionDefinition . PROPAGATION_SUPPORTS : return "PROPAGATION_SUPPORTS" ; } return "UNKOWN" ; } } ; } public TransactionTemplate getTemplate ( ) { return template ; } public void setTemplate ( TransactionTemplate template ) { this . template = template ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultProducer ; public class JbiEndpoint extends DefaultEndpoint < Exchange > { private Processor toJbiProcessor ; private final CamelJbiComponent jbiComponent ; public JbiEndpoint ( CamelJbiComponent jbiComponent , String uri ) { super ( uri , jbiComponent ) ; this . jbiComponent = jbiComponent ; toJbiProcessor = new ToJbiProcessor ( jbiComponent . getBinding ( ) , jbiComponent . getComponentContext ( ) , uri ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { toJbiProcessor . process ( exchange ) ; } } ; } public Consumer < Exchange > createConsumer ( final Processor processor ) throws Exception { return new DefaultConsumer < Exchange > ( this , processor ) { CamelJbiEndpoint jbiEndpoint ; @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; jbiEndpoint = jbiComponent . activateJbiEndpoint ( JbiEndpoint . this , processor ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; } } ; } public JbiExchange createExchange ( ) { return new JbiExchange ( getContext ( ) , getBinding ( ) ) ; } public JbiBinding getBinding ( ) { return jbiComponent . getBinding ( ) ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . bam . rules ; import org . apache . camel . Exchange ; import org . apache . camel . bam . ProcessBuilder ; import org . apache . camel . bam . model . ActivityDefinition ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . ArrayList ; import java . util . List ; public class ActivityRules extends ServiceSupport { private static final transient Log log = LogFactory . getLog ( ActivityRules . class ) ; private int expectedMessages = 1 ; private ProcessRules processRules ; private List < TemporalRule > rules = new ArrayList < TemporalRule > ( ) ; private ActivityDefinition activityDefinition ; private String activityName ; private final org . apache . camel . bam . ProcessBuilder builder ; public ActivityRules ( ProcessBuilder builder ) { this . builder = builder ; this . processRules = builder . getProcessRules ( ) ; processRules . getActivities ( ) . add ( this ) ; } public void addRule ( TemporalRule rule ) { rules . add ( rule ) ; } public void processExpired ( ActivityState activityState ) throws Exception { for ( TemporalRule rule : rules ) { rule . processExpired ( activityState ) ; } } public void processExchange ( Exchange exchange , ProcessInstance process ) { for ( TemporalRule rule : rules ) { rule . processExchange ( exchange , process ) ; } } public ActivityDefinition getActivityDefinition ( ) { if ( activityDefinition == null ) { activityDefinition = builder . findOrCreateActivityDefinition ( activityName ) ; } return activityDefinition ; } public void setActivityDefinition ( ActivityDefinition activityDefinition ) { this . activityDefinition = activityDefinition ; } public int getExpectedMessages ( ) { return expectedMessages ; } public void setExpectedMessages ( int expectedMessages ) { this . expectedMessages = expectedMessages ; } public ProcessRules getProcessRules ( ) { return processRules ; } public void setActivityName ( String activityName ) { this . activityName = activityName ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( rules ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( rules ) ; } } 	0
package org . apache . camel . builder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . PARAMETER ) public @ interface FluentArg { String value ( ) ; boolean attribute ( ) default true ; boolean element ( ) default false ; boolean reference ( ) default false ; } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class NoErrorHandlerBuilder < E extends Exchange > implements ErrorHandlerBuilder < E > { public ErrorHandlerBuilder < E > copy ( ) { return this ; } public Processor createErrorHandler ( Processor processor ) { return processor ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . frontend . ClientFactoryBean ; import java . util . List ; public class CxfInvokeProducer extends DefaultProducer { private CxfInvokeEndpoint endpoint ; private Client client ; public CxfInvokeProducer ( CxfInvokeEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) { CxfExchange cxfExchange = endpoint . toExchangeType ( exchange ) ; process ( cxfExchange ) ; exchange . copyFrom ( cxfExchange ) ; } public void process ( CxfExchange exchange ) { List params = exchange . getIn ( ) . getBody ( List . class ) ; Object [ ] response = null ; try { response = client . invoke ( endpoint . getProperty ( CxfConstants . METHOD ) , params . toArray ( ) ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } CxfBinding binding = endpoint . getBinding ( ) ; binding . storeCxfResponse ( exchange , response ) ; } @ Override protected void doStart ( ) throws Exception { if ( client == null ) { ClientFactoryBean cfBean = new ClientFactoryBean ( ) ; cfBean . setAddress ( getEndpoint ( ) . getEndpointUri ( ) ) ; cfBean . setBus ( endpoint . getBus ( ) ) ; cfBean . setServiceClass ( Class . forName ( endpoint . getProperty ( CxfConstants . SEI ) ) ) ; client = cfBean . create ( ) ; } } @ Override protected void doStop ( ) throws Exception { if ( client != null ) { client . getConduit ( ) . close ( ) ; client = null ; } super . doStop ( ) ; } } 	0
package org . apache . camel . spring . remoting ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . component . pojo . PojoComponent ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . remoting . support . UrlBasedRemoteAccessor ; public class CamelProxyFactoryBean extends UrlBasedRemoteAccessor implements FactoryBean { private CamelContext camelContext ; private Endpoint endpoint ; private Object serviceProxy ; @ Override public void afterPropertiesSet ( ) { super . afterPropertiesSet ( ) ; try { if ( endpoint == null ) { if ( getServiceUrl ( ) == null || camelContext == null ) { throw new IllegalArgumentException ( "If endpoint is not specified, the serviceUrl and camelContext must be specified." ) ; } endpoint = camelContext . getEndpoint ( getServiceUrl ( ) ) ; if ( endpoint == null ) { throw new IllegalArgumentException ( "Could not resolve endpoint: " + getServiceUrl ( ) ) ; } } this . serviceProxy = PojoComponent . createProxy ( endpoint , getServiceInterface ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } } public Object getObject ( ) throws Exception { return serviceProxy ; } public Class getObjectType ( ) { return getServiceInterface ( ) ; } public boolean isSingleton ( ) { return true ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } } 	0
package org . apache . camel . spring . component ; import org . apache . camel . Endpoint ; import org . apache . camel . component . pojo . PojoEndpoint ; import org . apache . camel . impl . DefaultComponent ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import java . util . Map ; public class BeanComponent extends DefaultComponent implements ApplicationContextAware { private ApplicationContext applicationContext ; public BeanComponent ( ) { } public BeanComponent ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { notNull ( applicationContext , "applicationContext" ) ; Object object = applicationContext . getBean ( remaining ) ; if ( object != null ) { return new PojoEndpoint ( uri , this , object ) ; } return null ; } } 	0
package org . apache . camel . component . quartz ; import org . apache . camel . impl . DefaultMessage ; import org . quartz . JobExecutionContext ; import org . quartz . Trigger ; import java . util . Map ; public class QuartzMessage extends DefaultMessage { private final JobExecutionContext jobExecutionContext ; public QuartzMessage ( QuartzExchange exchange , JobExecutionContext jobExecutionContext ) { this . jobExecutionContext = jobExecutionContext ; setExchange ( exchange ) ; setBody ( jobExecutionContext . getJobDetail ( ) ) ; } public JobExecutionContext getJobExecutionContext ( ) { return jobExecutionContext ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { super . populateInitialHeaders ( map ) ; if ( jobExecutionContext != null ) { map . put ( "calendar" , jobExecutionContext . getCalendar ( ) ) ; map . put ( "fireTime" , jobExecutionContext . getFireTime ( ) ) ; map . put ( "jobDetail" , jobExecutionContext . getJobDetail ( ) ) ; map . put ( "jobInstance" , jobExecutionContext . getJobInstance ( ) ) ; map . put ( "jobRunTime" , jobExecutionContext . getJobRunTime ( ) ) ; map . put ( "mergedJobDataMap" , jobExecutionContext . getMergedJobDataMap ( ) ) ; map . put ( "nextFireTime" , jobExecutionContext . getNextFireTime ( ) ) ; map . put ( "previousFireTime" , jobExecutionContext . getPreviousFireTime ( ) ) ; map . put ( "refireCount" , jobExecutionContext . getRefireCount ( ) ) ; map . put ( "result" , jobExecutionContext . getResult ( ) ) ; map . put ( "scheduledFireTime" , jobExecutionContext . getScheduledFireTime ( ) ) ; map . put ( "scheduler" , jobExecutionContext . getScheduler ( ) ) ; Trigger trigger = jobExecutionContext . getTrigger ( ) ; map . put ( "trigger" , trigger ) ; map . put ( "triggerName" , trigger . getName ( ) ) ; map . put ( "triggerGroup" , trigger . getGroup ( ) ) ; } } } 	0
package org . apache . camel . processor . idempotent ; import org . apache . camel . util . LRUCache ; import java . util . Set ; import java . util . HashSet ; import java . util . Map ; import java . util . HashMap ; import java . util . LinkedHashMap ; public class MemoryMessageIdRepository implements MessageIdRepository { private Map cache ; public static MessageIdRepository memoryMessageIdRepository ( ) { return memoryMessageIdRepository ( new HashMap ( ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( int cacheSize ) { return memoryMessageIdRepository ( new LRUCache ( cacheSize ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( Map cache ) { return new MemoryMessageIdRepository ( cache ) ; } public MemoryMessageIdRepository ( Map set ) { this . cache = set ; } public boolean contains ( String messageId ) { synchronized ( cache ) { if ( cache . containsKey ( messageId ) ) { return true ; } else { cache . put ( messageId , messageId ) ; return false ; } } } } 	0
package org . apache . camel ; public class InvalidHeaderTypeException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; private Object headerValue ; public InvalidHeaderTypeException ( Throwable cause , Object headerValue ) { super ( cause . getMessage ( ) + " headerValue is: " + headerValue + " of type: " + typeName ( headerValue ) , cause ) ; this . headerValue = headerValue ; } public InvalidHeaderTypeException ( String message , Object headerValue ) { super ( message ) ; this . headerValue = headerValue ; } public Object getHeaderValue ( ) { return headerValue ; } protected static String typeName ( Object headerValue ) { return ( headerValue != null ) ? headerValue . getClass ( ) . getName ( ) : "null" ; } } 	0
package org . apache . camel ; import java . util . Map ; public interface Exchange { String getExchangeId ( ) ; void setExchangeId ( String id ) ; Object getProperty ( String name ) ; < T > T getProperty ( String name , Class < T > type ) ; void setProperty ( String name , Object value ) ; Map < String , Object > getProperties ( ) ; Message getIn ( ) ; Message getOut ( ) ; Message getOut ( boolean lazyCreate ) ; Message getFault ( ) ; Throwable getException ( ) ; void setException ( Throwable e ) ; CamelContext getContext ( ) ; Exchange copy ( ) ; void copyFrom ( Exchange source ) ; } 	0
package org . apache . camel . component . xmpp ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . Chat ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; public class XmppPrivateChatProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( XmppPrivateChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String participant ; private Chat chat ; public XmppPrivateChatProducer ( XmppEndpoint endpoint , String participant ) { super ( endpoint ) ; this . endpoint = endpoint ; this . participant = participant ; if ( participant == null ) { throw new IllegalArgumentException ( "No participant property specified" ) ; } } public void process ( Exchange exchange ) { Message message = chat . createMessage ( ) ; message . setTo ( participant ) ; message . setFrom ( endpoint . getUser ( ) ) ; message . setThread ( exchange . getExchangeId ( ) ) ; message . setType ( Message . Type . NORMAL ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( ">>>> message: " + message . getBody ( ) ) ; } try { chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( chat == null ) { chat = endpoint . getConnection ( ) . createChat ( getParticipant ( ) ) ; } } @ Override protected void doStop ( ) throws Exception { chat = null ; super . doStop ( ) ; } public Chat getChat ( ) { return chat ; } public void setChat ( Chat chat ) { this . chat = chat ; } public String getParticipant ( ) { return participant ; } } 	0
package org . apache . camel . bam . rules ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . bam . TimeExpression ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . builder . FromBuilder ; import org . apache . camel . builder . ProcessorFactory ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . ServiceSupport ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import org . apache . camel . util . Time ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Date ; public class TemporalRule extends ServiceSupport { private static final transient Log log = LogFactory . getLog ( TemporalRule . class ) ; private TimeExpression first ; private TimeExpression second ; private long expectedMillis ; private long overdueMillis ; private Processor overdueAction ; private ProcessorFactory overdueProcessorFactory ; public TemporalRule ( TimeExpression first , TimeExpression second ) { this . first = first ; this . second = second ; } public TemporalRule expectWithin ( Time builder ) { return expectWithin ( builder . toMillis ( ) ) ; } public TemporalRule expectWithin ( long millis ) { expectedMillis = millis ; return this ; } public FromBuilder errorIfOver ( Time builder ) { return errorIfOver ( builder . toMillis ( ) ) ; } public FromBuilder errorIfOver ( long millis ) { overdueMillis = millis ; FromBuilder builder = new FromBuilder ( second . getBuilder ( ) . getProcessBuilder ( ) , null ) ; overdueProcessorFactory = builder ; return builder ; } public TimeExpression getFirst ( ) { return first ; } public TimeExpression getSecond ( ) { return second ; } public Processor getOverdueAction ( ) throws Exception { if ( overdueAction == null && overdueProcessorFactory != null ) { overdueAction = overdueProcessorFactory . createProcessor ( ) ; } return overdueAction ; } public void processExchange ( Exchange exchange , ProcessInstance instance ) { Date firstTime = first . evaluate ( instance ) ; if ( firstTime == null ) { return ; } ActivityState secondState = second . getOrCreateActivityState ( instance ) ; if ( expectedMillis > 0L ) { Date expected = secondState . getTimeExpected ( ) ; if ( expected == null ) { expected = add ( firstTime , expectedMillis ) ; secondState . setTimeExpected ( expected ) ; } } if ( overdueMillis > 0L ) { Date overdue = secondState . getTimeOverdue ( ) ; if ( overdue == null ) { overdue = add ( firstTime , overdueMillis ) ; secondState . setTimeOverdue ( overdue ) ; } } } public void processExpired ( ActivityState activityState ) throws Exception { Processor processor = getOverdueAction ( ) ; if ( processor != null ) { Date now = new Date ( ) ; ActivityState secondState = activityState ; Date overdue = secondState . getTimeOverdue ( ) ; if ( now . compareTo ( overdue ) >= 0 ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( activityState ) ; processor . process ( exchange ) ; } else { log . warn ( "Process has not actually expired; the time is: " + now + " but the overdue time is: " + overdue ) ; } } } protected Exchange createExchange ( ) { return new DefaultExchange ( second . getBuilder ( ) . getProcessBuilder ( ) . getContext ( ) ) ; } protected Date add ( Date date , long millis ) { return new Date ( date . getTime ( ) + millis ) ; } protected void doStart ( ) throws Exception { startServices ( getOverdueAction ( ) ) ; } protected void doStop ( ) throws Exception { stopServices ( getOverdueAction ( ) ) ; } } 	0
package org . apache . camel . spring . xml ; import java . lang . reflect . Method ; import java . util . LinkedHashMap ; import org . apache . camel . builder . Fluent ; import org . apache . camel . builder . FluentArg ; public class MethodInfo { final Method method ; final Fluent methodAnnotation ; final LinkedHashMap < String , Class > parameters ; final LinkedHashMap < String , FluentArg > parameterAnnotations ; public MethodInfo ( Method method , Fluent fluentAnnotation , LinkedHashMap < String , Class > parameters , LinkedHashMap < String , FluentArg > annotations ) { this . method = method ; this . methodAnnotation = fluentAnnotation ; this . parameters = parameters ; this . parameterAnnotations = annotations ; } public String getName ( ) { return method . getName ( ) ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Message ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannel extends ServiceSupport implements ErrorHandler { public static final String REDELIVERY_COUNTER = "org.apache.camel.RedeliveryCounter" ; public static final String REDELIVERED = "org.apache.camel.Redelivered" ; private static final transient Log log = LogFactory . getLog ( DeadLetterChannel . class ) ; private Processor output ; private Processor deadLetter ; private RedeliveryPolicy redeliveryPolicy ; private Logger logger ; public static < E extends Exchange > Logger createDefaultLogger ( ) { return new Logger ( log , LoggingLevel . ERROR ) ; } public DeadLetterChannel ( Processor output , Processor deadLetter ) { this ( output , deadLetter , new RedeliveryPolicy ( ) , DeadLetterChannel . createDefaultLogger ( ) ) ; } public DeadLetterChannel ( Processor output , Processor deadLetter , RedeliveryPolicy redeliveryPolicy , Logger logger ) { this . deadLetter = deadLetter ; this . output = output ; this . redeliveryPolicy = redeliveryPolicy ; this . logger = logger ; } @ Override public String toString ( ) { return "DeadLetterChannel[" + output + ", " + deadLetter + ", " + redeliveryPolicy + "]" ; } public void process ( Exchange exchange ) throws Exception { int redeliveryCounter = 0 ; long redeliveryDelay = 0 ; do { if ( redeliveryCounter > 0 ) { redeliveryDelay = redeliveryPolicy . getRedeliveryDelay ( redeliveryDelay ) ; sleep ( redeliveryDelay ) ; } try { output . process ( exchange ) ; return ; } catch ( RuntimeException e ) { logger . log ( "On delivery attempt: " + redeliveryCounter + " caught: " + e , e ) ; } redeliveryCounter = incrementRedeliveryCounter ( exchange ) ; } while ( redeliveryPolicy . shouldRedeliver ( redeliveryCounter ) ) ; deadLetter . process ( exchange ) ; } public Processor getOutput ( ) { return output ; } public Processor getDeadLetter ( ) { return deadLetter ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } protected int incrementRedeliveryCounter ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Integer counter = in . getHeader ( REDELIVERY_COUNTER , Integer . class ) ; int next = 1 ; if ( counter != null ) { next = counter + 1 ; } in . setHeader ( REDELIVERY_COUNTER , next ) ; in . setHeader ( REDELIVERED , true ) ; return next ; } protected void sleep ( long redeliveryDelay ) { if ( redeliveryDelay > 0 ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sleeping for: " + redeliveryDelay + " until attempting redelivery" ) ; } try { Thread . sleep ( redeliveryDelay ) ; } catch ( InterruptedException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Thread interupted: " + e , e ) ; } } } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output , deadLetter ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( deadLetter , output ) ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import java . io . InputStream ; import java . util . Set ; public class CxfBinding { public Object extractBodyFromCxf ( CxfExchange exchange , Message message ) { return getBody ( message ) ; } protected Object getBody ( Message message ) { Set < Class < ? > > contentFormats = message . getContentFormats ( ) ; for ( Class < ? > contentFormat : contentFormats ) { Object answer = message . getContent ( contentFormat ) ; if ( answer != null ) { return answer ; } } return null ; } public MessageImpl createCxfMessage ( CxfExchange exchange ) { MessageImpl answer = ( MessageImpl ) exchange . getInMessage ( ) ; CxfMessage in = exchange . getIn ( ) ; Object body = in . getBody ( InputStream . class ) ; if ( body == null ) { body = in . getBody ( ) ; } answer . setContent ( InputStream . class , body ) ; return answer ; } public void storeCxfResponse ( CxfExchange exchange , Message response ) { CxfMessage out = exchange . getOut ( ) ; if ( response != null ) { out . setMessage ( response ) ; out . setBody ( getBody ( response ) ) ; } } public void storeCxfResponse ( CxfExchange exchange , Object response ) { CxfMessage out = exchange . getOut ( ) ; if ( response != null ) { out . setBody ( response ) ; } } } 	0
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; public class InterceptorBuilder implements ProcessorFactory { private final List < DelegateProcessor > intercepts = new ArrayList < DelegateProcessor > ( ) ; private final FromBuilder parent ; private FromBuilder target ; public InterceptorBuilder ( FromBuilder parent ) { this . parent = parent ; } @ Fluent ( "interceptor" ) public InterceptorBuilder add ( @ FluentArg ( "ref" ) DelegateProcessor interceptor ) { intercepts . add ( interceptor ) ; return this ; } @ Fluent ( callOnElementEnd = true ) public FromBuilder target ( ) { this . target = new FromBuilder ( parent ) ; return target ; } public Processor createProcessor ( ) throws Exception { if ( target == null ) throw new RuntimeCamelException ( "target provided." ) ; DelegateProcessor first = null ; DelegateProcessor last = null ; for ( DelegateProcessor p : intercepts ) { if ( first == null ) { first = p ; } if ( last != null ) { last . setNext ( p ) ; } last = p ; } Processor p = target . createProcessor ( ) ; if ( last != null ) { last . setNext ( p ) ; } return first == null ? p : first ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . MessageCreator ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Session ; public class JmsProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( JmsProducer . class ) ; private final JmsEndpoint endpoint ; private final JmsOperations template ; public JmsProducer ( JmsEndpoint endpoint , JmsOperations template ) { super ( endpoint ) ; this . endpoint = endpoint ; this . template = template ; } public void process ( final Exchange exchange ) { template . send ( endpoint . getDestination ( ) , new MessageCreator ( ) { public Message createMessage ( Session session ) throws JMSException { Message message = endpoint . getBinding ( ) . makeJmsMessage ( exchange , session ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( endpoint + " sending JMS message: " + message ) ; } return message ; } } ) ; } public JmsOperations getTemplate ( ) { return template ; } } 	0
package org . apache . camel . bam . model ; import org . apache . camel . bam . processor . ProcessContext ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . ObjectHelper ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import java . util . Date ; @ Entity public class ActivityState extends TemporalEntity { private ProcessInstance processInstance ; private Integer receivedMessageCount = 0 ; private ActivityDefinition activityDefinition ; private Date timeExpected ; private Date timeOverdue ; private Integer escalationLevel = 0 ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "ActivityState[" + getId ( ) + " " + getActivityDefinition ( ) + "]" ; } public synchronized void processExchange ( ActivityRules activityRules , ProcessContext context ) throws Exception { int messageCount = 0 ; Integer count = getReceivedMessageCount ( ) ; if ( count != null ) { messageCount = count . intValue ( ) ; } setReceivedMessageCount ( ++ messageCount ) ; if ( messageCount == 1 ) { onFirstMessage ( context ) ; } int expectedMessages = activityRules . getExpectedMessages ( ) ; if ( messageCount == expectedMessages ) { onExpectedMessage ( context ) ; } else if ( messageCount > expectedMessages ) { onExcessMessage ( context ) ; } } public boolean isActivity ( ActivityRules activityRules ) { return ObjectHelper . equals ( getActivityDefinition ( ) , activityRules . getActivityDefinition ( ) ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; processInstance . getActivityStates ( ) . add ( this ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ActivityDefinition getActivityDefinition ( ) { return activityDefinition ; } public void setActivityDefinition ( ActivityDefinition activityDefinition ) { this . activityDefinition = activityDefinition ; } public Integer getEscalationLevel ( ) { return escalationLevel ; } public void setEscalationLevel ( Integer escalationLevel ) { this . escalationLevel = escalationLevel ; } public Integer getReceivedMessageCount ( ) { return receivedMessageCount ; } public void setReceivedMessageCount ( Integer receivedMessageCount ) { this . receivedMessageCount = receivedMessageCount ; } public Date getTimeExpected ( ) { return timeExpected ; } public void setTimeExpected ( Date timeExpected ) { this . timeExpected = timeExpected ; } public Date getTimeOverdue ( ) { return timeOverdue ; } public void setTimeOverdue ( Date timeOverdue ) { this . timeOverdue = timeOverdue ; } public void setTimeCompleted ( Date timeCompleted ) { super . setTimeCompleted ( timeCompleted ) ; if ( timeCompleted != null ) { setEscalationLevel ( - 1 ) ; } } protected void onFirstMessage ( ProcessContext context ) { if ( ! isStarted ( ) ) { setTimeStarted ( currentTime ( ) ) ; context . onStarted ( this ) ; } } protected void onExpectedMessage ( ProcessContext context ) { if ( ! isCompleted ( ) ) { setTimeCompleted ( currentTime ( ) ) ; context . onCompleted ( this ) ; } } protected void onExcessMessage ( ProcessContext context ) { } protected Date currentTime ( ) { return new Date ( ) ; } } 	0
package org . apache . camel . component . cxf ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultExchange ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; public class CxfExchange extends DefaultExchange { private final CxfBinding binding ; private Exchange exchange ; public CxfExchange ( CamelContext context , CxfBinding binding ) { super ( context ) ; this . binding = binding ; } public CxfExchange ( CamelContext context , CxfBinding binding , Exchange exchange ) { super ( context ) ; this . binding = binding ; this . exchange = exchange ; setIn ( new CxfMessage ( exchange . getInMessage ( ) ) ) ; setOut ( new CxfMessage ( exchange . getOutMessage ( ) ) ) ; setFault ( new CxfMessage ( exchange . getInFaultMessage ( ) ) ) ; } public CxfExchange ( CamelContext context , CxfBinding binding , Message inMessage ) { super ( context ) ; this . binding = binding ; this . exchange = inMessage . getExchange ( ) ; setIn ( new CxfMessage ( inMessage ) ) ; if ( exchange != null ) { setOut ( new CxfMessage ( exchange . getOutMessage ( ) ) ) ; setFault ( new CxfMessage ( exchange . getInFaultMessage ( ) ) ) ; } } @ Override public CxfMessage getIn ( ) { return ( CxfMessage ) super . getIn ( ) ; } @ Override public CxfMessage getOut ( ) { return ( CxfMessage ) super . getOut ( ) ; } @ Override public CxfMessage getOut ( boolean lazyCreate ) { return ( CxfMessage ) super . getOut ( lazyCreate ) ; } @ Override public CxfMessage getFault ( ) { return ( CxfMessage ) super . getFault ( ) ; } public CxfBinding getBinding ( ) { return binding ; } public Exchange getExchange ( ) { return exchange ; } public Message getInMessage ( ) { return getIn ( ) . getMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getMessage ( ) ; } public Message getOutFaultMessage ( ) { return getExchange ( ) . getOutFaultMessage ( ) ; } public Message getInFaultMessage ( ) { return getExchange ( ) . getInFaultMessage ( ) ; } public Destination getDestination ( ) { return getExchange ( ) . getDestination ( ) ; } public Conduit getConduit ( Message message ) { return getExchange ( ) . getConduit ( message ) ; } @ Override protected CxfMessage createInMessage ( ) { return new CxfMessage ( ) ; } @ Override protected CxfMessage createOutMessage ( ) { return new CxfMessage ( ) ; } } 	0
package org . apache . camel . spring . spi ; import org . apache . camel . spi . Injector ; import org . apache . camel . impl . ReflectionInjector ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . context . support . AbstractRefreshableApplicationContext ; import org . springframework . beans . factory . config . AutowireCapableBeanFactory ; public class SpringInjector extends ReflectionInjector { private static final transient Log log = LogFactory . getLog ( SpringInjector . class ) ; private final AbstractRefreshableApplicationContext applicationContext ; private int autowireMode = AutowireCapableBeanFactory . AUTOWIRE_CONSTRUCTOR ; private boolean dependencyCheck = false ; public SpringInjector ( AbstractRefreshableApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public Object newInstance ( Class type ) { return applicationContext . getBeanFactory ( ) . createBean ( type , autowireMode , dependencyCheck ) ; } public int getAutowireMode ( ) { return autowireMode ; } public void setAutowireMode ( int autowireMode ) { this . autowireMode = autowireMode ; } public boolean isDependencyCheck ( ) { return dependencyCheck ; } public void setDependencyCheck ( boolean dependencyCheck ) { this . dependencyCheck = dependencyCheck ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import javax . jms . Message ; import javax . jms . MessageListener ; public class MessageListenerProcessor implements MessageListener { private final JmsEndpoint endpoint ; private final Processor processor ; public MessageListenerProcessor ( JmsEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } public void onMessage ( Message message ) { try { Exchange exchange = endpoint . createExchange ( message ) ; processor . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } 	0
package org . apache . camel . component . http ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultExchange ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class HttpExchange extends DefaultExchange { private final HttpEndpoint endpoint ; private HttpServletRequest request ; private HttpServletResponse response ; public HttpExchange ( HttpEndpoint endpoint ) { super ( endpoint . getContext ( ) ) ; this . endpoint = endpoint ; } public HttpExchange ( HttpEndpoint endpoint , HttpServletRequest request , HttpServletResponse response ) { this ( endpoint ) ; this . request = request ; this . response = response ; setIn ( new HttpMessage ( this , request ) ) ; } public HttpServletRequest getRequest ( ) { return request ; } public HttpServletResponse getResponse ( ) { return response ; } public HttpEndpoint getEndpoint ( ) { return endpoint ; } } 	0
package org . apache . camel . component . pojo ; import org . apache . camel . CamelException ; public class NoPojoAvailableException extends CamelException { private final PojoEndpoint endpoint ; public NoPojoAvailableException ( PojoEndpoint endpoint ) { super ( "No POJO available for endpoint: " + endpoint ) ; this . endpoint = endpoint ; } public PojoEndpoint getEndpoint ( ) { return endpoint ; } } 	0
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessagePropertyAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 3996286386119163309L ; private String propertyName ; public MessagePropertyAccessException ( String propertyName , JMSException e ) { super ( "Error accessing header: " + propertyName , e ) ; this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0
package org . apache . camel . component . pojo ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . Component ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . spi . Provider ; import java . lang . reflect . InvocationTargetException ; public class PojoEndpoint extends DefaultEndpoint < PojoExchange > { private Object pojo ; public PojoEndpoint ( String uri , Component component , Object pojo ) { super ( uri , component ) ; this . pojo = pojo ; } public Producer < PojoExchange > createProducer ( ) throws Exception { final Object pojo = getPojo ( ) ; if ( pojo == null ) { throw new NoPojoAvailableException ( this ) ; } return new DefaultProducer ( this ) { public void process ( Exchange exchange ) { PojoExchange pojoExchange = toExchangeType ( exchange ) ; invoke ( pojo , pojoExchange ) ; exchange . copyFrom ( pojoExchange ) ; } } ; } public Consumer < PojoExchange > createConsumer ( Processor processor ) throws Exception { throw new Exception ( "You cannot consume from pojo endpoints." ) ; } public static void invoke ( Object pojo , PojoExchange exchange ) { PojoInvocation invocation = exchange . getInvocation ( ) ; try { Object response = invocation . getMethod ( ) . invoke ( pojo , invocation . getArgs ( ) ) ; exchange . getOut ( ) . setBody ( response ) ; } catch ( InvocationTargetException e ) { exchange . setException ( e . getCause ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } } public PojoExchange createExchange ( ) { return new PojoExchange ( getContext ( ) ) ; } public boolean isSingleton ( ) { return true ; } public Object getPojo ( ) { return pojo ; } public void setPojo ( Object pojo ) { this . pojo = pojo ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Producer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; public abstract class DefaultProducer < E extends Exchange > extends ServiceSupport implements Producer < E > { private Endpoint < E > endpoint ; public DefaultProducer ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public E createExchange ( ) { return endpoint . createExchange ( ) ; } public E createExchange ( E exchange ) { return endpoint . createExchange ( exchange ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0
package org . apache . camel ; public interface Endpoint < E extends Exchange > { boolean isSingleton ( ) ; String getEndpointUri ( ) ; E createExchange ( ) ; E createExchange ( Exchange exchange ) ; E toExchangeType ( Exchange exchange ) ; CamelContext getContext ( ) ; Producer < E > createProducer ( ) throws Exception ; Consumer < E > createConsumer ( Processor processor ) throws Exception ; PollingConsumer < E > createPollingConsumer ( ) throws Exception ; } 	0
package org . apache . camel . component . mina ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoHandler ; import org . apache . mina . common . IoHandlerAdapter ; import org . apache . mina . common . IoSession ; import java . net . SocketAddress ; public class MinaConsumer extends DefaultConsumer < MinaExchange > { private static final transient Log log = LogFactory . getLog ( MinaConsumer . class ) ; private final MinaEndpoint endpoint ; private final SocketAddress address ; private final IoAcceptor acceptor ; public MinaConsumer ( final MinaEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; address = endpoint . getAddress ( ) ; acceptor = endpoint . getAcceptor ( ) ; } @ Override protected void doStart ( ) throws Exception { if ( log . isDebugEnabled ( ) ) { log . debug ( "Binding to server address: " + address + " using acceptor: " + acceptor ) ; } IoHandler handler = new IoHandlerAdapter ( ) { @ Override public void messageReceived ( IoSession session , Object object ) throws Exception { getProcessor ( ) . process ( endpoint . createExchange ( session , object ) ) ; } } ; acceptor . bind ( address , handler , endpoint . getConfig ( ) ) ; } @ Override protected void doStop ( ) throws Exception { acceptor . unbind ( address ) ; super . doStop ( ) ; } } 	0
package org . apache . camel . converter . jaxb ; import org . apache . camel . converter . HasAnnotation ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . w3c . dom . Document ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . util . JAXBSource ; import javax . xml . parsers . ParserConfigurationException ; public class JaxbConverter { private XmlConverter jaxbConverter ; public XmlConverter getJaxbConverter ( ) { if ( jaxbConverter == null ) { jaxbConverter = new XmlConverter ( ) ; } return jaxbConverter ; } public void setJaxbConverter ( XmlConverter jaxbConverter ) { this . jaxbConverter = jaxbConverter ; } public static JAXBSource toSource ( @ HasAnnotation ( XmlRootElement . class ) Object value ) throws JAXBException { JAXBContext context = createJaxbContext ( value ) ; return new JAXBSource ( context , value ) ; } public Document toDocument ( @ HasAnnotation ( XmlRootElement . class ) Object value ) throws JAXBException , ParserConfigurationException { JAXBContext context = createJaxbContext ( value ) ; Marshaller marshaller = context . createMarshaller ( ) ; Document doc = getJaxbConverter ( ) . createDocument ( ) ; marshaller . marshal ( value , doc ) ; return doc ; } protected static JAXBContext createJaxbContext ( Object value ) throws JAXBException { if ( value == null ) { throw new IllegalArgumentException ( "Cannot convert from null value to JAXBSource" ) ; } JAXBContext context = JAXBContext . newInstance ( value . getClass ( ) ) ; return context ; } } 	0
package org . apache . camel . component . xmpp ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . AccountManager ; import org . jivesoftware . smack . XMPPConnection ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . filter . PacketFilter ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smack . packet . Presence ; public class XmppEndpoint extends DefaultEndpoint < XmppExchange > { private static final transient Log log = LogFactory . getLog ( XmppEndpoint . class ) ; private XmppBinding binding ; private XMPPConnection connection ; private String host ; private int port ; private String user ; private String password ; private String resource = "Camel" ; private boolean login = true ; private PacketFilter filter ; private boolean createAccount ; private String room ; private String participant ; public XmppEndpoint ( String uri , XmppComponent component ) { super ( uri , component ) ; } public Producer < XmppExchange > createProducer ( ) throws Exception { if ( room != null ) { return createGroupChatProducer ( room ) ; } else { if ( participant == null ) { throw new IllegalArgumentException ( "No room or participant configured on this endpoint: " + this ) ; } return createPrivateChatProducer ( participant ) ; } } public Producer < XmppExchange > createGroupChatProducer ( String room ) throws Exception { return new XmppGroupChatProducer ( this , room ) ; } public Producer < XmppExchange > createPrivateChatProducer ( String participant ) throws Exception { return new XmppPrivateChatProducer ( this , participant ) ; } public Consumer < XmppExchange > createConsumer ( Processor processor ) throws Exception { return new XmppConsumer ( this , processor ) ; } public XmppExchange createExchange ( ) { return new XmppExchange ( getContext ( ) , getBinding ( ) ) ; } public XmppExchange createExchange ( Message message ) { return new XmppExchange ( getContext ( ) , getBinding ( ) , message ) ; } public XmppBinding getBinding ( ) { if ( binding == null ) { binding = new XmppBinding ( ) ; } return binding ; } public void setBinding ( XmppBinding binding ) { this . binding = binding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getUser ( ) { return user ; } public void setUser ( String user ) { this . user = user ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getResource ( ) { return resource ; } public void setResource ( String resource ) { this . resource = resource ; } public boolean isLogin ( ) { return login ; } public void setLogin ( boolean login ) { this . login = login ; } public PacketFilter getFilter ( ) { return filter ; } public void setFilter ( PacketFilter filter ) { this . filter = filter ; } public boolean isCreateAccount ( ) { return createAccount ; } public void setCreateAccount ( boolean createAccount ) { this . createAccount = createAccount ; } public String getRoom ( ) { return room ; } public void setRoom ( String room ) { this . room = room ; } public String getParticipant ( ) { return participant ; } public void setParticipant ( String participant ) { this . participant = participant ; } public XMPPConnection getConnection ( ) throws XMPPException { if ( connection == null ) { connection = createConnection ( ) ; } return connection ; } public void setConnection ( XMPPConnection connection ) { this . connection = connection ; } protected XMPPConnection createConnection ( ) throws XMPPException { XMPPConnection connection ; if ( port > 0 ) { connection = new XMPPConnection ( host , port ) ; } else { connection = new XMPPConnection ( host ) ; } if ( login && ! connection . isAuthenticated ( ) ) { if ( user != null ) { log . info ( "Logging in to XMPP as user: " + user + " on connection: " + connection ) ; if ( password == null ) { log . warn ( "No password configured for user: " + user ) ; } if ( createAccount ) { AccountManager accountManager = new AccountManager ( connection ) ; accountManager . createAccount ( user , password ) ; } if ( resource != null ) { connection . login ( user , password , resource ) ; } else { connection . login ( user , password ) ; } } else { log . info ( "Logging in anonymously to XMPP on connection: " + connection ) ; connection . loginAnonymously ( ) ; } connection . sendPacket ( new Presence ( Presence . Type . AVAILABLE ) ) ; } return connection ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Logger implements Processor { private Log log ; private LoggingLevel level ; public Logger ( ) { this ( LogFactory . getLog ( Logger . class ) ) ; } public Logger ( Log log ) { this ( log , LoggingLevel . INFO ) ; } public Logger ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } @ Override public String toString ( ) { return "Logger[" + log + "]" ; } public void process ( Exchange exchange ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange ) ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange ) ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange ) ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( logMessage ( exchange ) ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange ) ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange ) ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange ) ) ; } } public void log ( String message ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message ) ; } } public void log ( String message , Throwable exception ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message , exception ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message , exception ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message , exception ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message , exception ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message , exception ) ; } } protected Object logMessage ( Exchange exchange ) { return exchange ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import java . util . Collection ; public class Pipeline extends MulticastProcessor implements Processor { public Pipeline ( Collection < Endpoint > endpoints ) throws Exception { super ( endpoints ) ; } public void process ( Exchange exchange ) throws Exception { Exchange nextExchange = exchange ; boolean first = true ; for ( Producer producer : getProducers ( ) ) { if ( first ) { first = false ; } else { nextExchange = createNextExchange ( producer , nextExchange ) ; } producer . process ( nextExchange ) ; } } protected Exchange createNextExchange ( Producer producer , Exchange previousExchange ) { Exchange answer = producer . createExchange ( previousExchange ) ; Object output = previousExchange . getOut ( ) . getBody ( ) ; if ( output != null ) { answer . getIn ( ) . setBody ( output ) ; } return answer ; } protected Exchange copyExchangeStrategy ( Exchange exchange ) { return exchange . copy ( ) ; } @ Override public String toString ( ) { return "Pipeline" + getEndpoints ( ) ; } } 	0
package org . apache . camel . component . jmx ; import java . util . Map ; import javax . management . MBeanServer ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; public class JMXComponent extends DefaultComponent < JMXExchange > { private MBeanServer mbeanServer ; public JMXComponent ( ) { } public JMXComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < JMXExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { JMXEndpoint result = new JMXEndpoint ( remaining , this ) ; IntrospectionSupport . setProperties ( result , parameters ) ; result . setMbeanServer ( getMbeanServer ( ) ) ; return result ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	0
package org . apache . camel . util ; import java . io . IOException ; public class NoFactoryAvailableException extends IOException { private final String uri ; public NoFactoryAvailableException ( String uri ) { super ( "Could not find factory class for resource: " + uri ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . SendProcessor ; public class ToBuilder < E extends Exchange > extends FromBuilder { private Endpoint destination ; public ToBuilder ( FromBuilder parent , Endpoint endpoint ) { super ( parent ) ; this . destination = endpoint ; } @ Override public Processor createProcessor ( ) { return new SendProcessor ( destination ) ; } } 	0
package org . apache . camel . component . jms ; import java . beans . DesignMode ; import java . io . File ; import java . util . Enumeration ; import java . util . Map ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Queue ; import javax . jms . TemporaryTopic ; import javax . jms . Topic ; import org . apache . camel . impl . DefaultMessage ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JmsMessage extends DefaultMessage { private static final transient Log log = LogFactory . getLog ( JmsMessage . class ) ; private Message jmsMessage ; public JmsMessage ( ) { } public JmsMessage ( Message jmsMessage ) { setJmsMessage ( jmsMessage ) ; } @ Override public String toString ( ) { if ( jmsMessage != null ) { return "JmsMessage: " + jmsMessage ; } else { return "JmsMessage: " + getBody ( ) ; } } public Message getJmsMessage ( ) { return jmsMessage ; } public void setJmsMessage ( Message jmsMessage ) { this . jmsMessage = jmsMessage ; try { String id = getDestinationAsString ( jmsMessage . getJMSDestination ( ) ) ; id += getSanitizedString ( jmsMessage . getJMSMessageID ( ) ) ; setMessageId ( id ) ; } catch ( JMSException e ) { log . error ( "Failed to get message id from message " + jmsMessage , e ) ; } } public Object getHeader ( String name ) { Object answer = null ; if ( jmsMessage != null ) { try { answer = jmsMessage . getObjectProperty ( name ) ; } catch ( JMSException e ) { throw new MessagePropertyAccessException ( name , e ) ; } } if ( answer == null ) { answer = super . getHeader ( name ) ; } return answer ; } @ Override public JmsMessage newInstance ( ) { return new JmsMessage ( ) ; } @ Override protected Object createBody ( ) { if ( jmsMessage != null && getExchange ( ) instanceof JmsExchange ) { JmsExchange exchange = ( JmsExchange ) getExchange ( ) ; return ( exchange . getBinding ( ) . extractBodyFromJms ( exchange , jmsMessage ) ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( jmsMessage != null ) { Enumeration names ; try { names = jmsMessage . getPropertyNames ( ) ; } catch ( JMSException e ) { throw new MessagePropertyNamesAccessException ( e ) ; } while ( names . hasMoreElements ( ) ) { String name = names . nextElement ( ) . toString ( ) ; try { Object value = jmsMessage . getObjectProperty ( name ) ; map . put ( name , value ) ; } catch ( JMSException e ) { throw new MessagePropertyAccessException ( name , e ) ; } } } } private String getDestinationAsString ( Destination destination ) throws JMSException { String result = "" ; if ( destination instanceof Topic ) { result += "topic" + File . separator + getSanitizedString ( ( ( Topic ) destination ) . getTopicName ( ) ) ; } else { result += "queue" + File . separator + getSanitizedString ( ( ( Queue ) destination ) . getQueueName ( ) ) ; } result += File . separator ; return result ; } private String getSanitizedString ( Object value ) { return value != null ? value . toString ( ) . replaceAll ( "[^a-zA-Z0-9\\.\\_\\-]" , "_" ) : "" ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Endpoint ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . util . IntrospectionSupport ; import java . util . Map ; public abstract class ScheduledPollEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private Map consumerProperties ; protected ScheduledPollEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } public Map getConsumerProperties ( ) { return consumerProperties ; } public void setConsumerProperties ( Map consumerProperties ) { this . consumerProperties = consumerProperties ; } protected void configureConsumer ( Consumer < E > consumer ) { if ( consumerProperties != null ) { IntrospectionSupport . setProperties ( consumer , consumerProperties ) ; } } public void configureProperties ( Map options ) { Map consumerProperties = IntrospectionSupport . extractProperties ( options , "consumer." ) ; if ( consumerProperties != null ) { setConsumerProperties ( consumerProperties ) ; } } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import java . util . Map ; import java . net . URI ; import java . net . URL ; public class MailComponent extends DefaultComponent < MailExchange > { public static final String QUEUE_PREFIX = "queue:" ; public static final String TOPIC_PREFIX = "topic:" ; private MailConfiguration configuration ; public static MailComponent mailComponent ( ) { return new MailComponent ( ) ; } public static MailComponent mailComponent ( MailConfiguration configuration ) { return new MailComponent ( configuration ) ; } public MailComponent ( ) { this . configuration = new MailConfiguration ( ) ; } public MailComponent ( MailConfiguration configuration ) { this . configuration = configuration ; } public MailComponent ( CamelContext context ) { super ( context ) ; this . configuration = new MailConfiguration ( ) ; } @ Override protected Endpoint < MailExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { MailConfiguration config = getConfiguration ( ) . copy ( ) ; config . configure ( new URI ( uri ) ) ; MailEndpoint endpoint = new MailEndpoint ( uri , this , config ) ; IntrospectionSupport . setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public MailConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( MailConfiguration configuration ) { this . configuration = configuration ; } protected String convertPathToActualDestination ( String path ) { return path ; } } 	0
package org . apache . camel . component . cxf ; import java . util . Properties ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . cxf . Bus ; import org . apache . cxf . message . Message ; public class CxfInvokeEndpoint extends DefaultEndpoint < CxfExchange > { private CxfBinding binding ; private final CxfInvokeComponent component ; private boolean inOut = true ; private Properties properties ; public CxfInvokeEndpoint ( String uri , CxfInvokeComponent component , Properties properties ) { super ( uri , component ) ; this . component = component ; this . properties = properties ; } public Producer < CxfExchange > createProducer ( ) throws Exception { return new CxfInvokeProducer ( this ) ; } public Consumer < CxfExchange > createConsumer ( Processor processor ) throws Exception { return new CxfInvokeConsumer ( this , processor ) ; } public CxfExchange createExchange ( ) { return new CxfExchange ( getContext ( ) , getBinding ( ) ) ; } public CxfExchange createExchange ( Message inMessage ) { return new CxfExchange ( getContext ( ) , getBinding ( ) , inMessage ) ; } public CxfBinding getBinding ( ) { if ( binding == null ) { binding = new CxfBinding ( ) ; } return binding ; } public void setBinding ( CxfBinding binding ) { this . binding = binding ; } public boolean isInOut ( ) { return inOut ; } public void setInOut ( boolean inOut ) { this . inOut = inOut ; } public CxfInvokeComponent getComponent ( ) { return component ; } public String getProperty ( String key ) { return properties . getProperty ( key ) ; } public Bus getBus ( ) { return component . getBus ( ) ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . spring . xml ; import org . apache . camel . util . ObjectHelper ; public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser { private String className ; private String moduleName ; public LazyLoadingBeanDefinitionParser ( String className , String moduleName ) { this . className = className ; this . moduleName = moduleName ; } @ Override protected Class loadType ( ) { Class < ? > answer = ObjectHelper . loadClass ( className , getClass ( ) . getClassLoader ( ) ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Class: " + className + " could not be found. You need to add Camel module: " + moduleName + " to your classpath" ) ; } return answer ; } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . RuntimeCamelException ; import javax . mail . Session ; import java . net . URI ; import java . util . Properties ; public class MailConfiguration implements Cloneable { private String defaultEncoding ; private String host ; private Properties javaMailProperties ; private String password ; private String protocol ; private Session session ; private String username ; private int port = - 1 ; private String destination ; private String from = "camel@localhost" ; private boolean deleteProcessedMessages = true ; private String folderName = "INBOX" ; public MailConfiguration ( ) { } public MailConfiguration copy ( ) { try { return ( MailConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public void configure ( URI uri ) { String value = uri . getHost ( ) ; if ( value != null ) { setHost ( value ) ; } String scheme = uri . getScheme ( ) ; if ( scheme != null ) { setProtocol ( scheme ) ; } String userInfo = uri . getUserInfo ( ) ; if ( userInfo != null ) { setUsername ( userInfo ) ; } int port = uri . getPort ( ) ; if ( port >= 0 ) { setPort ( port ) ; } String fragment = uri . getFragment ( ) ; if ( fragment == null || fragment . length ( ) == 0 ) { fragment = userInfo + "@" + host ; } else { setFolderName ( fragment ) ; } setDestination ( fragment ) ; } public JavaMailConnection createJavaMailConnection ( MailEndpoint mailEndpoint ) { JavaMailConnection answer = new JavaMailConnection ( ) ; if ( defaultEncoding != null ) { answer . setDefaultEncoding ( defaultEncoding ) ; } if ( host != null ) { answer . setHost ( host ) ; } if ( javaMailProperties != null ) { answer . setJavaMailProperties ( javaMailProperties ) ; } if ( port >= 0 ) { answer . setPort ( port ) ; } if ( password != null ) { answer . setPassword ( password ) ; } if ( protocol != null ) { answer . setProtocol ( protocol ) ; } if ( session != null ) { answer . setSession ( session ) ; } if ( username != null ) { answer . setUsername ( username ) ; } return answer ; } public String getDefaultEncoding ( ) { return defaultEncoding ; } public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public Properties getJavaMailProperties ( ) { return javaMailProperties ; } public void setJavaMailProperties ( Properties javaMailProperties ) { this . javaMailProperties = javaMailProperties ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public Session getSession ( ) { return session ; } public void setSession ( Session session ) { this . session = session ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getDestination ( ) { return destination ; } public void setDestination ( String destination ) { this . destination = destination ; } public String getFrom ( ) { return from ; } public void setFrom ( String from ) { this . from = from ; } public boolean isDeleteProcessedMessages ( ) { return deleteProcessedMessages ; } public void setDeleteProcessedMessages ( boolean deleteProcessedMessages ) { this . deleteProcessedMessages = deleteProcessedMessages ; } public String getFolderName ( ) { return folderName ; } public void setFolderName ( String folderName ) { this . folderName = folderName ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . servicemix . jbi . resolver . URIResolver ; import javax . jbi . component . ComponentContext ; import javax . jbi . messaging . DeliveryChannel ; import javax . jbi . messaging . MessageExchange ; import javax . jbi . messaging . MessageExchangeFactory ; import javax . jbi . messaging . MessagingException ; public class ToJbiProcessor implements Processor { private JbiBinding binding ; private ComponentContext componentContext ; private String destinationUri ; public ToJbiProcessor ( JbiBinding binding , ComponentContext componentContext , String destinationUri ) { this . binding = binding ; this . componentContext = componentContext ; this . destinationUri = destinationUri ; } public void process ( Exchange exchange ) { try { DeliveryChannel deliveryChannel = componentContext . getDeliveryChannel ( ) ; MessageExchangeFactory exchangeFactory = deliveryChannel . createExchangeFactory ( ) ; MessageExchange messageExchange = binding . makeJbiMessageExchange ( exchange , exchangeFactory ) ; URIResolver . configureExchange ( messageExchange , componentContext , destinationUri ) ; deliveryChannel . sendSync ( messageExchange ) ; } catch ( MessagingException e ) { throw new JbiException ( e ) ; } } } 	0
package org . apache . camel . component . jmx ; import javax . management . Notification ; import javax . management . NotificationListener ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class JMXConsumer extends DefaultConsumer implements NotificationListener { JMXEndpoint jmxEndpoint ; public JMXConsumer ( JMXEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . jmxEndpoint = endpoint ; } public void handleNotification ( Notification notification , Object handback ) { try { getProcessor ( ) . process ( jmxEndpoint . createExchange ( notification ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } } 	0
package org . apache . camel . util ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; public class IntrospectionSupport { static public boolean getProperties ( Object target , Map props , String optionPrefix ) { boolean rc = false ; if ( target == null ) throw new IllegalArgumentException ( "target was null." ) ; if ( props == null ) throw new IllegalArgumentException ( "props was null." ) ; if ( optionPrefix == null ) optionPrefix = "" ; Class clazz = target . getClass ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; String name = method . getName ( ) ; Class type = method . getReturnType ( ) ; Class params [ ] = method . getParameterTypes ( ) ; if ( name . startsWith ( "get" ) && params . length == 0 && type != null && isSettableType ( type ) ) { try { Object value = method . invoke ( target , new Object [ ] { } ) ; if ( value == null ) continue ; String strValue = convertToString ( value , type ) ; if ( strValue == null ) continue ; name = name . substring ( 3 , 4 ) . toLowerCase ( ) + name . substring ( 4 ) ; props . put ( optionPrefix + name , strValue ) ; rc = true ; } catch ( Throwable ignore ) { } } } return rc ; } static public boolean setProperties ( Object target , Map props , String optionPrefix ) { boolean rc = false ; if ( target == null ) throw new IllegalArgumentException ( "target was null." ) ; if ( props == null ) throw new IllegalArgumentException ( "props was null." ) ; for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; if ( setProperty ( target , name , value ) ) { iter . remove ( ) ; rc = true ; } } } return rc ; } public static Map extractProperties ( Map props , String optionPrefix ) { if ( props == null ) throw new IllegalArgumentException ( "props was null." ) ; HashMap rc = new HashMap ( props . size ( ) ) ; for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; rc . put ( name , value ) ; iter . remove ( ) ; } } return rc ; } public static boolean setProperties ( Object target , Map props ) { boolean rc = false ; if ( target == null ) throw new IllegalArgumentException ( "target was null." ) ; if ( props == null ) throw new IllegalArgumentException ( "props was null." ) ; for ( Iterator iter = props . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Entry ) iter . next ( ) ; if ( setProperty ( target , ( String ) entry . getKey ( ) , entry . getValue ( ) ) ) { iter . remove ( ) ; rc = true ; } } return rc ; } public static boolean setProperty ( Object target , String name , Object value ) { try { Class clazz = target . getClass ( ) ; Method setter = findSetterMethod ( clazz , name ) ; if ( setter == null ) return false ; if ( value == null || value . getClass ( ) == setter . getParameterTypes ( ) [ 0 ] ) { setter . invoke ( target , new Object [ ] { value } ) ; } else { setter . invoke ( target , new Object [ ] { convert ( value , setter . getParameterTypes ( ) [ 0 ] ) } ) ; } return true ; } catch ( Throwable ignore ) { return false ; } } private static Object convert ( Object value , Class type ) throws URISyntaxException { PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return editor . getValue ( ) ; } if ( type == URI . class ) { return new URI ( value . toString ( ) ) ; } return null ; } private static String convertToString ( Object value , Class type ) throws URISyntaxException { PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setValue ( value ) ; return editor . getAsText ( ) ; } if ( type == URI . class ) { return ( ( URI ) value ) . toString ( ) ; } return null ; } private static Method findSetterMethod ( Class clazz , String name ) { name = "set" + name . substring ( 0 , 1 ) . toUpperCase ( ) + name . substring ( 1 ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; Class params [ ] = method . getParameterTypes ( ) ; if ( method . getName ( ) . equals ( name ) && params . length == 1 && isSettableType ( params [ 0 ] ) ) { return method ; } } return null ; } private static boolean isSettableType ( Class clazz ) { if ( PropertyEditorManager . findEditor ( clazz ) != null ) return true ; if ( clazz == URI . class ) return true ; if ( clazz == Boolean . class ) return true ; return false ; } static public String toString ( Object target ) { return toString ( target , Object . class ) ; } static public String toString ( Object target , Class stopClass ) { LinkedHashMap map = new LinkedHashMap ( ) ; addFields ( target , target . getClass ( ) , stopClass , map ) ; StringBuffer buffer = new StringBuffer ( simpleName ( target . getClass ( ) ) ) ; buffer . append ( " {" ) ; Set entrySet = map . entrySet ( ) ; boolean first = true ; for ( Iterator iter = entrySet . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( first ) { first = false ; } else { buffer . append ( ", " ) ; } buffer . append ( entry . getKey ( ) ) ; buffer . append ( " = " ) ; appendToString ( buffer , entry . getValue ( ) ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } protected static void appendToString ( StringBuffer buffer , Object value ) { buffer . append ( value ) ; } static public String simpleName ( Class clazz ) { String name = clazz . getName ( ) ; int p = name . lastIndexOf ( "." ) ; if ( p >= 0 ) { name = name . substring ( p + 1 ) ; } return name ; } static private void addFields ( Object target , Class startClass , Class stopClass , LinkedHashMap map ) { if ( startClass != stopClass ) addFields ( target , startClass . getSuperclass ( ) , stopClass , map ) ; Field [ ] fields = startClass . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field field = fields [ i ] ; if ( Modifier . isStatic ( field . getModifiers ( ) ) || Modifier . isTransient ( field . getModifiers ( ) ) || Modifier . isPrivate ( field . getModifiers ( ) ) ) { continue ; } try { field . setAccessible ( true ) ; Object o = field . get ( target ) ; if ( o != null && o . getClass ( ) . isArray ( ) ) { try { o = Arrays . asList ( ( Object [ ] ) o ) ; } catch ( Throwable e ) { } } map . put ( field . getName ( ) , o ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } } } 	0
package org . apache . camel . util ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; public class ObjectHelper { private static final transient Log log = LogFactory . getLog ( ObjectHelper . class ) ; public static boolean equals ( Object a , Object b ) { if ( a == b ) { return true ; } return a != null && b != null && a . equals ( b ) ; } public static int compare ( Object a , Object b ) { if ( a == b ) { return 0 ; } if ( a == null ) { return - 1 ; } if ( b == null ) { return 1 ; } if ( a instanceof Comparable ) { Comparable comparable = ( Comparable ) a ; return comparable . compareTo ( b ) ; } else { int answer = a . getClass ( ) . getName ( ) . compareTo ( b . getClass ( ) . getName ( ) ) ; if ( answer == 0 ) { answer = a . hashCode ( ) - b . hashCode ( ) ; } return answer ; } } public static void notNull ( Object value , String name ) { if ( value == null ) { throw new IllegalArgumentException ( "No " + name + " specified" ) ; } } public static String [ ] splitOnCharacter ( String value , String needle , int count ) { String rc [ ] = new String [ count ] ; rc [ 0 ] = value ; for ( int i = 1 ; i < count ; i ++ ) { String v = rc [ i - 1 ] ; int p = v . indexOf ( needle ) ; if ( p < 0 ) { return rc ; } rc [ i - 1 ] = v . substring ( 0 , p ) ; rc [ i ] = v . substring ( p + 1 ) ; } return rc ; } public static String removeStartingCharacters ( String text , char ch ) { int idx = 0 ; while ( text . charAt ( idx ) == ch ) { idx ++ ; } if ( idx > 0 ) { return text . substring ( idx ) ; } return text ; } public static boolean contains ( Object collectionOrArray , Object value ) { if ( collectionOrArray instanceof Collection ) { Collection collection = ( Collection ) collectionOrArray ; return collection . contains ( value ) ; } else { Iterator iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { if ( equals ( value , iter . next ( ) ) ) { return true ; } } return false ; } } public static boolean matches ( List list ) { if ( ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value instanceof Boolean ) { Boolean flag = ( Boolean ) value ; return flag . booleanValue ( ) ; } else { return true ; } } return false ; } public static boolean isNotNullOrBlank ( String text ) { return text != null && text . trim ( ) . length ( ) > 0 ; } public static String getSystemProperty ( String name , String defaultValue ) { try { return System . getProperty ( name , defaultValue ) ; } catch ( Exception e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Caught security exception accessing system property: " + name + ". Reason: " + e , e ) ; } return defaultValue ; } } public static String name ( Class type ) { return type != null ? type . getName ( ) : null ; } public static String className ( Object value ) { return name ( value != null ? value . getClass ( ) : null ) ; } public static Class < ? > loadClass ( String name ) { return loadClass ( name , ObjectHelper . class . getClassLoader ( ) ) ; } public static Class < ? > loadClass ( String name , ClassLoader loader ) { ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( contextClassLoader != null ) { try { return contextClassLoader . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { try { return loader . loadClass ( name ) ; } catch ( ClassNotFoundException e1 ) { log . debug ( "Could not find class: " + name + ". Reason: " + e ) ; } } } return null ; } public static Object invokeMethod ( Method method , Object instance , Object ... parameters ) { try { return method . invoke ( instance , parameters ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } } public static List < Method > findMethodsWithAnnotation ( Class < ? > type , Class < ? extends Annotation > annotationType ) { List < Method > answer = new ArrayList < Method > ( ) ; do { Method [ ] methods = type . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotationType ) != null ) { answer . add ( method ) ; } } type = type . getSuperclass ( ) ; } while ( type != null ) ; return answer ; } public static String asString ( Object [ ] objects ) { if ( objects == null ) { return "null" ; } else { StringBuffer buffer = new StringBuffer ( "{" ) ; int counter = 0 ; for ( Object object : objects ) { if ( counter ++ > 0 ) { buffer . append ( ", " ) ; } String text = ( object == null ) ? "null" : object . toString ( ) ; buffer . append ( text ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } } } 	0
package org . apache . camel . component . http ; import org . apache . camel . Processor ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultConsumer ; public class HttpConsumer extends DefaultConsumer < HttpExchange > { private final HttpEndpoint endpoint ; public HttpConsumer ( HttpEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override public HttpEndpoint getEndpoint ( ) { return ( HttpEndpoint ) super . getEndpoint ( ) ; } public HttpBinding getBinding ( ) { return endpoint . getBinding ( ) ; } public String getPath ( ) { return endpoint . getPath ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . connect ( this ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . disconnect ( this ) ; super . doStop ( ) ; } } 	0
package org . apache . camel . builder . script ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; import javax . script . Compilable ; import javax . script . CompiledScript ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptEngineManager ; import javax . script . ScriptException ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; public class ScriptBuilder < E extends Exchange > implements Expression < E > , Predicate < E > , Processor { private static final transient Log log = LogFactory . getLog ( ScriptBuilder . class ) ; private String scriptEngineName ; private Resource scriptResource ; private String scriptText ; private ScriptEngine engine ; private CompiledScript compiledScript ; public ScriptBuilder ( String scriptEngineName ) { this . scriptEngineName = scriptEngineName ; } public ScriptBuilder ( String scriptEngineName , String scriptText ) { this ( scriptEngineName ) ; this . scriptText = scriptText ; } public ScriptBuilder ( String scriptEngineName , Resource scriptResource ) { this ( scriptEngineName ) ; this . scriptResource = scriptResource ; } @ Override public String toString ( ) { return getScriptDescription ( ) ; } public Object evaluate ( E exchange ) { return evaluateScript ( exchange ) ; } public boolean matches ( E exchange ) { Object scriptValue = evaluateScript ( exchange ) ; return matches ( exchange , scriptValue ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object scriptValue = evaluateScript ( exchange ) ; if ( ! matches ( exchange , scriptValue ) ) { throw new AssertionError ( this + " failed on " + exchange + " as script returned <" + scriptValue + ">" ) ; } } public void process ( Exchange exchange ) { evaluateScript ( exchange ) ; } public ScriptBuilder attribute ( String name , Object value ) { getScriptContext ( ) . setAttribute ( name , value , ScriptContext . ENGINE_SCOPE ) ; return this ; } public static ScriptBuilder script ( String language , String scriptText ) { return new ScriptBuilder ( language , scriptText ) ; } public static ScriptBuilder script ( String language , Resource scriptResource ) { return new ScriptBuilder ( language , scriptResource ) ; } public static ScriptBuilder script ( String language , File scriptFile ) { return new ScriptBuilder ( language , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder script ( String language , URL scriptURL ) { return new ScriptBuilder ( language , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder groovy ( String scriptText ) { return new ScriptBuilder ( "groovy" , scriptText ) ; } public static ScriptBuilder groovy ( Resource scriptResource ) { return new ScriptBuilder ( "groovy" , scriptResource ) ; } public static ScriptBuilder groovy ( File scriptFile ) { return new ScriptBuilder ( "groovy" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder groovy ( URL scriptURL ) { return new ScriptBuilder ( "groovy" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder javaScript ( String scriptText ) { return new ScriptBuilder ( "js" , scriptText ) ; } public static ScriptBuilder javaScript ( Resource scriptResource ) { return new ScriptBuilder ( "js" , scriptResource ) ; } public static ScriptBuilder javaScript ( File scriptFile ) { return new ScriptBuilder ( "js" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder javaScript ( URL scriptURL ) { return new ScriptBuilder ( "js" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder php ( String scriptText ) { return new ScriptBuilder ( "php" , scriptText ) ; } public static ScriptBuilder php ( Resource scriptResource ) { return new ScriptBuilder ( "php" , scriptResource ) ; } public static ScriptBuilder php ( File scriptFile ) { return new ScriptBuilder ( "php" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder php ( URL scriptURL ) { return new ScriptBuilder ( "php" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder python ( String scriptText ) { return new ScriptBuilder ( "python" , scriptText ) ; } public static ScriptBuilder python ( Resource scriptResource ) { return new ScriptBuilder ( "python" , scriptResource ) ; } public static ScriptBuilder python ( File scriptFile ) { return new ScriptBuilder ( "python" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder python ( URL scriptURL ) { return new ScriptBuilder ( "python" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder ruby ( String scriptText ) { return new ScriptBuilder ( "jruby" , scriptText ) ; } public static ScriptBuilder ruby ( Resource scriptResource ) { return new ScriptBuilder ( "jruby" , scriptResource ) ; } public static ScriptBuilder ruby ( File scriptFile ) { return new ScriptBuilder ( "jruby" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder ruby ( URL scriptURL ) { return new ScriptBuilder ( "jruby" , new UrlResource ( scriptURL ) ) ; } public ScriptEngine getEngine ( ) { checkInitialised ( ) ; return engine ; } public CompiledScript getCompiledScript ( ) { return compiledScript ; } public String getScriptText ( ) { return scriptText ; } public void setScriptText ( String scriptText ) { this . scriptText = scriptText ; } public String getScriptEngineName ( ) { return scriptEngineName ; } public String getScriptDescription ( ) { if ( scriptText != null ) { return scriptEngineName + ": " + scriptText ; } else if ( scriptResource != null ) { return scriptEngineName + ": " + scriptResource . getDescription ( ) ; } else { return scriptEngineName + ": null script" ; } } public ScriptContext getScriptContext ( ) { return getEngine ( ) . getContext ( ) ; } public void setScriptContext ( ScriptContext scriptContext ) { getEngine ( ) . setContext ( scriptContext ) ; } public Resource getScriptResource ( ) { return scriptResource ; } public void setScriptResource ( Resource scriptResource ) { this . scriptResource = scriptResource ; } protected void checkInitialised ( ) { if ( scriptText == null && scriptResource == null ) { throw new IllegalArgumentException ( "Neither scriptText or scriptResource are specified" ) ; } if ( engine == null ) { engine = createScriptEngine ( ) ; } if ( compiledScript == null ) { if ( engine instanceof Compilable ) { compileScript ( ( Compilable ) engine ) ; } } } protected boolean matches ( E exchange , Object scriptValue ) { return ObjectConverter . toBoolean ( scriptValue ) ; } protected ScriptEngine createScriptEngine ( ) { ScriptEngineManager manager = new ScriptEngineManager ( ) ; return manager . getEngineByName ( scriptEngineName ) ; } protected void compileScript ( Compilable compilable ) { try { if ( scriptText != null ) { compiledScript = compilable . compile ( scriptText ) ; } else if ( scriptResource != null ) { compiledScript = compilable . compile ( createScriptReader ( ) ) ; } } catch ( ScriptException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Script compile failed: " + e , e ) ; } throw createScriptCompileException ( e ) ; } catch ( IOException e ) { throw createScriptCompileException ( e ) ; } } protected synchronized Object evaluateScript ( Exchange exchange ) { try { getScriptContext ( ) ; populateBindings ( getEngine ( ) , exchange ) ; return runScript ( ) ; } catch ( ScriptException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Script evaluation failed: " + e , e ) ; } throw createScriptEvaluationException ( e . getCause ( ) ) ; } catch ( IOException e ) { throw createScriptEvaluationException ( e ) ; } } protected Object runScript ( ) throws ScriptException , IOException { checkInitialised ( ) ; if ( compiledScript != null ) { return compiledScript . eval ( ) ; } else { if ( scriptText != null ) { return getEngine ( ) . eval ( scriptText ) ; } else { return getEngine ( ) . eval ( createScriptReader ( ) ) ; } } } protected void populateBindings ( ScriptEngine engine , Exchange exchange ) { ScriptContext context = engine . getContext ( ) ; int scope = ScriptContext . ENGINE_SCOPE ; context . setAttribute ( "context" , exchange . getContext ( ) , scope ) ; context . setAttribute ( "exchange" , exchange , scope ) ; context . setAttribute ( "request" , exchange . getIn ( ) , scope ) ; context . setAttribute ( "response" , exchange . getOut ( ) , scope ) ; } protected InputStreamReader createScriptReader ( ) throws IOException { return new InputStreamReader ( scriptResource . getInputStream ( ) ) ; } protected ScriptEvaluationException createScriptCompileException ( Exception e ) { return new ScriptEvaluationException ( "Failed to compile: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } protected ScriptEvaluationException createScriptEvaluationException ( Throwable e ) { return new ScriptEvaluationException ( "Failed to evaluate: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . LoggingExceptionHandler ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ExpressionListComparator ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; public class Resequencer extends ServiceSupport implements Runnable { private static final transient Log log = LogFactory . getLog ( Resequencer . class ) ; private Endpoint endpoint ; private Processor processor ; private Set < Exchange > set ; private long batchTimeout = 1000L ; private int batchSize = 100 ; private PollingConsumer consumer ; private ExceptionHandler exceptionHandler ; public Resequencer ( Endpoint endpoint , Processor processor , Expression < Exchange > expression ) { this ( endpoint , processor , createSet ( expression ) ) ; } public Resequencer ( Endpoint endpoint , Processor processor , List < Expression < Exchange > > expressions ) { this ( endpoint , processor , createSet ( expressions ) ) ; } public Resequencer ( Endpoint endpoint , Processor processor , Set < Exchange > set ) { this . endpoint = endpoint ; this . processor = processor ; this . set = set ; } @ Override public String toString ( ) { return "Resequencer[to: " + processor + "]" ; } public void run ( ) { log . debug ( "Starting thread for " + this ) ; while ( ! isStopped ( ) && ! isStopping ( ) ) { try { processBatch ( ) ; } catch ( Exception e ) { getExceptionHandler ( ) . handleException ( e ) ; } } set . clear ( ) ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } protected synchronized void processBatch ( ) throws Exception { long start = System . currentTimeMillis ( ) ; long end = start + batchTimeout ; for ( int i = 0 ; i < batchSize ; i ++ ) { long timeout = end - System . currentTimeMillis ( ) ; Exchange exchange = consumer . receive ( timeout ) ; if ( exchange == null ) { break ; } set . add ( exchange ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Finsihed batch size: " + batchSize + " timeout: " + batchTimeout + " so sending set: " + set ) ; } Iterator < Exchange > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { Exchange exchange = iter . next ( ) ; iter . remove ( ) ; processor . process ( exchange ) ; } } protected void doStart ( ) throws Exception { consumer = endpoint . createPollingConsumer ( ) ; ServiceHelper . startServices ( processor , consumer ) ; Thread thread = new Thread ( this , this + " Polling Thread" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( consumer , processor ) ; consumer = null ; } protected static Set < Exchange > createSet ( Expression < Exchange > expression ) { return createSet ( new ExpressionComparator < Exchange > ( expression ) ) ; } protected static Set < Exchange > createSet ( List < Expression < Exchange > > expressions ) { if ( expressions . size ( ) == 1 ) { return createSet ( expressions . get ( 0 ) ) ; } return createSet ( new ExpressionListComparator < Exchange > ( expressions ) ) ; } protected static Set < Exchange > createSet ( Comparator < ? super Exchange > comparator ) { return new TreeSet < Exchange > ( comparator ) ; } } 	0
package org . apache . camel . component . http ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . httpclient . Header ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . HttpMethod ; import org . apache . commons . httpclient . methods . ByteArrayRequestEntity ; import org . apache . commons . httpclient . methods . GetMethod ; import org . apache . commons . httpclient . methods . PostMethod ; import org . apache . commons . httpclient . methods . RequestEntity ; import java . io . InputStream ; public class HttpProducer extends DefaultProducer < HttpExchange > implements Producer < HttpExchange > { private HttpClient httpClient = new HttpClient ( ) ; public HttpProducer ( HttpEndpoint endpoint ) { super ( endpoint ) ; } public void process ( Exchange exchange ) throws Exception { HttpMethod method = createMethod ( exchange ) ; int responseCode = httpClient . executeMethod ( method ) ; InputStream in = method . getResponseBodyAsStream ( ) ; Message out = exchange . getOut ( true ) ; out . setBody ( in ) ; Header [ ] headers = method . getResponseHeaders ( ) ; for ( Header header : headers ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; out . setHeader ( name , value ) ; } out . setHeader ( "http.responseCode" , responseCode ) ; } protected HttpMethod createMethod ( Exchange exchange ) { String uri = getEndpoint ( ) . getEndpointUri ( ) ; RequestEntity requestEntity = createRequestEntity ( exchange ) ; if ( requestEntity == null ) { return new GetMethod ( uri ) ; } PostMethod method = new PostMethod ( uri ) ; method . setRequestEntity ( requestEntity ) ; return method ; } protected RequestEntity createRequestEntity ( Exchange exchange ) { Message in = exchange . getIn ( ) ; RequestEntity entity = in . getBody ( RequestEntity . class ) ; if ( entity == null ) { byte [ ] data = in . getBody ( byte [ ] . class ) ; String contentType = in . getHeader ( "Content-Type" , String . class ) ; if ( contentType != null ) { return new ByteArrayRequestEntity ( data , contentType ) ; } else { return new ByteArrayRequestEntity ( data ) ; } } return entity ; } } 	0
package org . apache . camel . spi ; public interface Injector < T > { T newInstance ( Class < T > type ) ; } 	0
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . spi . ExceptionHandler ; public abstract class PollingConsumerSupport < E extends Exchange > extends ServiceSupport implements PollingConsumer < E > { private final Endpoint < E > endpoint ; private ExceptionHandler exceptionHandler ; public PollingConsumerSupport ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "PullConsumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	0
package org . apache . camel . component . pojo . timer ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Date ; import java . util . Map ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; public class TimerEndpoint extends DefaultEndpoint < PojoExchange > { private final TimerComponent component ; private final String timerName ; private Date time ; private long period = - 1 ; private long delay = - 1 ; private boolean fixedRate ; private boolean daemon = true ; public TimerEndpoint ( String fullURI , TimerComponent component , String timerPartURI ) throws URISyntaxException { super ( fullURI , component ) ; this . component = component ; URI u = new URI ( timerPartURI ) ; Map options = URISupport . parseParamters ( u ) ; IntrospectionSupport . setProperties ( this , options ) ; this . timerName = u . getPath ( ) ; } public Producer < PojoExchange > createProducer ( ) throws Exception { throw new RuntimeCamelException ( "Cannot produce to a TimerEndpoint: " + getEndpointUri ( ) ) ; } public Consumer < PojoExchange > createConsumer ( Processor processor ) throws Exception { return new TimerConsumer ( this , processor ) ; } public PojoExchange createExchange ( ) { return new PojoExchange ( getContext ( ) ) ; } public TimerComponent getComponent ( ) { return component ; } public String getTimerName ( ) { return timerName ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public boolean isFixedRate ( ) { return fixedRate ; } public void setFixedRate ( boolean fixedRate ) { this . fixedRate = fixedRate ; } public long getPeriod ( ) { return period ; } public void setPeriod ( long period ) { this . period = period ; } public Date getTime ( ) { return time ; } public void setTime ( Date time ) { this . time = time ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . component . jbi ; import org . apache . camel . CamelContext ; import org . apache . camel . Processor ; import org . apache . servicemix . MessageExchangeListener ; import javax . jbi . messaging . MessageExchange ; import javax . jbi . messaging . MessagingException ; public class FromJbiProcessor implements MessageExchangeListener { private CamelContext context ; private JbiBinding binding ; private Processor processor ; public FromJbiProcessor ( CamelContext context , JbiBinding binding , Processor processor ) { this . context = context ; this . binding = binding ; this . processor = processor ; } public void onMessageExchange ( MessageExchange messageExchange ) throws MessagingException { try { JbiExchange exchange = new JbiExchange ( context , binding , messageExchange ) ; processor . process ( exchange ) ; } catch ( Exception e ) { throw new MessagingException ( e ) ; } } } 	0
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultMessage ; public class JMXMessage extends DefaultMessage { private Notification notification ; public JMXMessage ( ) { this ( null ) ; } public JMXMessage ( Notification notification ) { this . notification = notification ; } @ Override public String toString ( ) { return "JMXMessage: " + notification ; } @ Override public JMXExchange getExchange ( ) { return ( JMXExchange ) super . getExchange ( ) ; } @ Override public JMXMessage newInstance ( ) { return new JMXMessage ( ) ; } public Notification getNotification ( ) { return notification ; } } 	0
package org . apache . camel . spi ; import java . io . IOException ; import java . io . OutputStream ; import javax . xml . transform . Result ; import javax . xml . transform . stream . StreamResult ; public abstract class XmlMarshaller implements Marshaller { public void marshal ( Object object , OutputStream result ) throws IOException { marshal ( object , new StreamResult ( result ) ) ; } abstract public void marshal ( Object object , Result result ) ; } 	0
package org . apache . camel . bam ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . model . ActivityDefinition ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . processor . ActivityMonitorEngine ; import org . apache . camel . bam . processor . JpaBamProcessor ; import org . apache . camel . bam . rules . ProcessRules ; import org . apache . camel . builder . RouteBuilder ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; import java . util . ArrayList ; import java . util . List ; public abstract class ProcessBuilder extends RouteBuilder { private static int processCounter ; private JpaTemplate jpaTemplate ; private final TransactionTemplate transactionTemplate ; private final String processName ; private List < ActivityBuilder > activityBuilders = new ArrayList < ActivityBuilder > ( ) ; private Class entityType = ProcessInstance . class ; private ProcessRules processRules = new ProcessRules ( ) ; private ProcessDefinition processDefinition ; protected ProcessBuilder ( JpaTemplate jpaTemplate , TransactionTemplate transactionTemplate ) { this ( jpaTemplate , transactionTemplate , createProcessName ( ) ) ; } protected static synchronized String createProcessName ( ) { return "Process-" + ( ++ processCounter ) ; } protected ProcessBuilder ( JpaTemplate jpaTemplate , TransactionTemplate transactionTemplate , String processName ) { this . jpaTemplate = jpaTemplate ; this . transactionTemplate = transactionTemplate ; this . processName = processName ; } public ActivityBuilder activity ( String endpointUri ) { return activity ( endpoint ( endpointUri ) ) ; } public ActivityBuilder activity ( Endpoint endpoint ) { ActivityBuilder answer = new ActivityBuilder ( this , endpoint ) ; activityBuilders . add ( answer ) ; return answer ; } public ProcessBuilder entityType ( Class entityType ) { this . entityType = entityType ; return this ; } public Processor createActivityProcessor ( ActivityBuilder activityBuilder ) { notNull ( jpaTemplate , "jpaTemplate" ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { processRules . setProcessDefinition ( getProcessDefinition ( ) ) ; } } ) ; return new JpaBamProcessor ( getTransactionTemplate ( ) , getJpaTemplate ( ) , activityBuilder . getCorrelationExpression ( ) , activityBuilder . getActivityRules ( ) , getEntityType ( ) ) ; } public List < ActivityBuilder > getActivityBuilders ( ) { return activityBuilders ; } public Class getEntityType ( ) { return entityType ; } public JpaTemplate getJpaTemplate ( ) { return jpaTemplate ; } public void setJpaTemplate ( JpaTemplate jpaTemplate ) { this . jpaTemplate = jpaTemplate ; } public TransactionTemplate getTransactionTemplate ( ) { return transactionTemplate ; } public ProcessRules getProcessRules ( ) { return processRules ; } public String getProcessName ( ) { return processName ; } public ProcessDefinition getProcessDefinition ( ) { if ( processDefinition == null ) { processDefinition = findOrCreateProcessDefinition ( ) ; } return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } protected void populateRoutes ( List < Route > routes ) throws Exception { boolean first = true ; for ( ActivityBuilder builder : activityBuilders ) { Route route = builder . createRoute ( ) ; if ( first ) { route . getServices ( ) . add ( new ActivityMonitorEngine ( getJpaTemplate ( ) , getTransactionTemplate ( ) , getProcessRules ( ) ) ) ; first = false ; } routes . add ( route ) ; } } public ActivityDefinition findOrCreateActivityDefinition ( String activityName ) { ProcessDefinition definition = getProcessDefinition ( ) ; List < ActivityDefinition > list = jpaTemplate . find ( "select x from " + ActivityDefinition . class . getName ( ) + " x where x.processDefinition = ?1 and x.name = ?2" , definition , activityName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ActivityDefinition answer = new ActivityDefinition ( ) ; answer . setName ( activityName ) ; answer . setProcessDefinition ( ProcessDefinition . getRefreshedProcessDefinition ( jpaTemplate , definition ) ) ; jpaTemplate . persist ( answer ) ; return answer ; } } protected ProcessDefinition findOrCreateProcessDefinition ( ) { List < ProcessDefinition > list = jpaTemplate . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; jpaTemplate . persist ( answer ) ; return answer ; } } } 	0
package org . apache . camel . component . mina ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; public class MinaExchange extends DefaultExchange { public MinaExchange ( CamelContext camelContext ) { super ( camelContext ) ; } } 	0
package org . apache . camel ; public interface PollingConsumer < E extends Exchange > extends Consumer < E > { E receive ( ) ; E receiveNoWait ( ) ; E receive ( long timeout ) ; } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; @ Converter public class ObjectConverter { public static boolean isCollection ( Object value ) { return value instanceof Collection || ( value != null && value . getClass ( ) . isArray ( ) ) ; } @ Converter public static Iterator iterator ( Object value ) { if ( value == null ) { return Collections . EMPTY_LIST . iterator ( ) ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { return Arrays . asList ( value ) . iterator ( ) ; } else { return Collections . singletonList ( value ) . iterator ( ) ; } } @ Converter public static boolean toBool ( Object value ) { Boolean answer = toBoolean ( value ) ; if ( answer != null ) { return answer . booleanValue ( ) ; } return false ; } @ Converter public static Boolean toBoolean ( Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ; } if ( value instanceof String ) { return "true" . equalsIgnoreCase ( value . toString ( ) ) ? Boolean . TRUE : Boolean . FALSE ; } return null ; } } 	0
package org . apache . camel . component . quartz ; import org . quartz . Job ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; public class CamelJob implements Job { public void execute ( JobExecutionContext context ) throws JobExecutionException { QuartzEndpoint component = ( QuartzEndpoint ) context . getJobDetail ( ) . getJobDataMap ( ) . get ( QuartzEndpoint . ENDPOINT_KEY ) ; if ( component == null ) { throw new JobExecutionException ( "No quartz endpoint available for key: " + QuartzEndpoint . ENDPOINT_KEY + ". Bad job data map" ) ; } component . onJobExecute ( context ) ; } } 	0
package org . apache . camel . component . xmpp ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . PacketListener ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smack . packet . Packet ; import org . jivesoftware . smack . packet . RosterPacket ; import java . util . Iterator ; public class XmppConsumer extends DefaultConsumer < XmppExchange > implements PacketListener { private static final transient Log log = LogFactory . getLog ( XmppConsumer . class ) ; private final XmppEndpoint endpoint ; public XmppConsumer ( XmppEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . getConnection ( ) . addPacketListener ( this , endpoint . getFilter ( ) ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . getConnection ( ) . removePacketListener ( this ) ; super . doStop ( ) ; } public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message message = ( Message ) packet ; if ( log . isDebugEnabled ( ) ) { log . debug ( "<<<< message: " + message . getBody ( ) ) ; } XmppExchange exchange = endpoint . createExchange ( message ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( packet instanceof RosterPacket ) { RosterPacket rosterPacket = ( RosterPacket ) packet ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Roster packet with : " + rosterPacket . getRosterItemCount ( ) + " item(s)" ) ; Iterator rosterItems = rosterPacket . getRosterItems ( ) ; while ( rosterItems . hasNext ( ) ) { Object item = rosterItems . next ( ) ; log . debug ( "Roster item: " + item ) ; } } } else { if ( log . isDebugEnabled ( ) ) { log . debug ( "<<<< ignored packet: " + packet ) ; } } } } 	0
package org . apache . camel . spring . xml ; import static org . apache . camel . util . ObjectHelper . notNull ; import java . util . ArrayList ; import org . apache . camel . CamelContext ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; public class RouteBuilderFactoryBean implements FactoryBean , BeanFactoryAware , InitializingBean { private ArrayList < BuilderStatement > routes ; private BeanFactory beanFactory ; private CamelContext context ; private StatementRouteBuilder builder = new StatementRouteBuilder ( ) ; public Object getObject ( ) throws Exception { return builder ; } public Class getObjectType ( ) { return StatementRouteBuilder . class ; } public boolean isSingleton ( ) { return true ; } public ArrayList < BuilderStatement > getRoutes ( ) { return routes ; } public void setRoutes ( ArrayList < BuilderStatement > routes ) { this . routes = routes ; } public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { this . beanFactory = beanFactory ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public void afterPropertiesSet ( ) throws Exception { notNull ( context , "context" ) ; notNull ( routes , "routes" ) ; builder . setBeanFactory ( beanFactory ) ; builder . setRoutes ( routes ) ; context . addRoutes ( builder ) ; } } 	0
package org . apache . camel . component . queue ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; public class QueueEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private BlockingQueue < E > queue ; public QueueEndpoint ( String uri , QueueComponent < E > component ) { super ( uri , component ) ; this . queue = component . createQueue ( ) ; } public Producer < E > createProducer ( ) throws Exception { return new DefaultProducer ( this ) { public void process ( Exchange exchange ) { queue . add ( toExchangeType ( exchange ) ) ; } } ; } public Consumer < E > createConsumer ( Processor processor ) throws Exception { return new QueueEndpointConsumer < E > ( this , processor ) ; } public E createExchange ( ) { return ( E ) new DefaultExchange ( getContext ( ) ) ; } public BlockingQueue < E > getQueue ( ) { return queue ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Injector ; public class ReflectionInjector < T > implements Injector < T > { public T newInstance ( Class < T > type ) { try { return type . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } } 	0
package org . apache . camel . component . pojo . timer ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . Endpoint ; import java . util . ArrayList ; import java . util . Map ; public class TimerComponent extends DefaultComponent < PojoExchange > { protected final ArrayList < TimerConsumer > timers = new ArrayList < TimerConsumer > ( ) ; boolean addConsumer ( TimerConsumer consumer ) { return timers . add ( consumer ) ; } boolean removeConsumer ( TimerConsumer consumer ) { return timers . remove ( consumer ) ; } @ Override protected Endpoint < PojoExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new TimerEndpoint ( uri , this , remaining ) ; } } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . * ; import java . nio . ByteBuffer ; @ Converter public class IOConverter { private static final transient Log log = LogFactory . getLog ( IOConverter . class ) ; @ Converter public static InputStream toInputStream ( File file ) throws FileNotFoundException { return new BufferedInputStream ( new FileInputStream ( file ) ) ; } @ Converter public static BufferedReader toReader ( File file ) throws FileNotFoundException { return new BufferedReader ( new FileReader ( file ) ) ; } @ Converter public static OutputStream toOutputStream ( File file ) throws FileNotFoundException { return new BufferedOutputStream ( new FileOutputStream ( file ) ) ; } @ Converter public static BufferedWriter toWriter ( File file ) throws IOException { return new BufferedWriter ( new FileWriter ( file ) ) ; } @ Converter public static Reader toReader ( InputStream in ) throws FileNotFoundException { return new InputStreamReader ( in ) ; } @ Converter public static Writer toWriter ( OutputStream out ) throws FileNotFoundException { return new OutputStreamWriter ( out ) ; } @ Converter public static StringReader toReader ( String text ) { return new StringReader ( text ) ; } @ Converter public static InputStream toInputStream ( String text ) { return toInputStream ( text . getBytes ( ) ) ; } @ Converter public static byte [ ] toByteArray ( String text ) { return text . getBytes ( ) ; } @ Converter public static String toString ( byte [ ] data ) { return new String ( data ) ; } @ Converter public static String toString ( Reader reader ) throws IOException { if ( reader instanceof BufferedReader ) { return toString ( ( BufferedReader ) reader ) ; } else { return toString ( new BufferedReader ( reader ) ) ; } } @ Converter public static String toString ( BufferedReader reader ) throws IOException { if ( reader == null ) { return null ; } try { StringBuilder builder = new StringBuilder ( ) ; boolean first = true ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { return builder . toString ( ) ; } if ( first ) { first = false ; } else { builder . append ( "\n" ) ; } builder . append ( line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { log . warn ( "Failed to close stream: " + e , e ) ; } } } @ Converter public static String toString ( InputStream in ) throws IOException { return toString ( toReader ( in ) ) ; } @ Converter public static InputStream toInputStream ( byte [ ] data ) { return new ByteArrayInputStream ( data ) ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . spi . Policy ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class DelegateProcessor extends ServiceSupport implements Processor { protected Processor next ; public DelegateProcessor ( ) { } public DelegateProcessor ( Processor next ) { this . next = next ; } public void process ( Exchange exchange ) throws Exception { processNext ( exchange ) ; } protected void processNext ( Exchange exchange ) throws Exception { if ( next != null ) { next . process ( exchange ) ; } } @ Override public String toString ( ) { return "delegate(" + next + ")" ; } public Processor getNext ( ) { return next ; } public void setNext ( Processor next ) { this . next = next ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( next ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( next ) ; } } 	0
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Header { String name ( ) ; } 	0
package org . apache . camel . component . http ; import org . apache . camel . impl . DefaultMessage ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Enumeration ; import java . io . IOException ; public class HttpMessage extends DefaultMessage { private HttpServletRequest request ; public HttpMessage ( HttpExchange exchange , HttpServletRequest request ) { setExchange ( exchange ) ; this . request = request ; getBody ( ) ; getHeaders ( ) ; } @ Override public HttpExchange getExchange ( ) { return ( HttpExchange ) super . getExchange ( ) ; } public HttpServletRequest getRequest ( ) { return request ; } @ Override protected Object createBody ( ) { try { return getExchange ( ) . getEndpoint ( ) . getBinding ( ) . parseBody ( this ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { Enumeration names = request . getHeaderNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Object value = request . getHeader ( name ) ; map . put ( name , value ) ; } } } 	0
package org . apache . camel . processor . idempotent ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ExpressionHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class IdempotentConsumer extends ServiceSupport implements Processor { private static final transient Log log = LogFactory . getLog ( IdempotentConsumer . class ) ; private Expression < Exchange > messageIdExpression ; private Processor nextProcessor ; private MessageIdRepository messageIdRepository ; public IdempotentConsumer ( Expression < Exchange > messageIdExpression , MessageIdRepository messageIdRepository , Processor nextProcessor ) { this . messageIdExpression = messageIdExpression ; this . messageIdRepository = messageIdRepository ; this . nextProcessor = nextProcessor ; } @ Override public String toString ( ) { return "IdempotentConsumer[expression=" + messageIdExpression + ", repository=" + messageIdRepository + ", processor=" + nextProcessor + "]" ; } public void process ( Exchange exchange ) throws Exception { String messageId = ExpressionHelper . evaluateAsString ( messageIdExpression , exchange ) ; if ( messageId == null ) { throw new NoMessageIdException ( exchange , messageIdExpression ) ; } if ( ! messageIdRepository . contains ( messageId ) ) { nextProcessor . process ( exchange ) ; } else { onDuplicateMessage ( exchange , messageId ) ; } } public Expression < Exchange > getMessageIdExpression ( ) { return messageIdExpression ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public Processor getNextProcessor ( ) { return nextProcessor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( nextProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( nextProcessor ) ; } protected void onDuplicateMessage ( Exchange exchange , String messageId ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Ignoring duplicate message with id: " + messageId + " for exchange: " + exchange ) ; } } } 	0
package org . apache . camel . component . queue ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueComponent < E extends Exchange > extends DefaultComponent < E > { public BlockingQueue < E > createQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; } @ Override protected Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new QueueEndpoint < E > ( uri , this ) ; } } 	0
package org . apache . camel . component . direct ; import java . net . URI ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; public class DirectComponent < E extends Exchange > implements Component < E > { private CamelContext context ; public CamelContext getCamelContext ( ) { return context ; } public ScheduledExecutorService getExecutorService ( ) { return null ; } public Endpoint < E > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( uri ) ; Map parameters = URISupport . parseParamters ( u ) ; Endpoint < E > endpoint = new DirectEndpoint < E > ( uri , this ) ; if ( parameters != null ) { IntrospectionSupport . setProperties ( endpoint , parameters ) ; } return endpoint ; } public void setCamelContext ( CamelContext context ) { this . context = context ; } } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; public class ToStringTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( String . class ) ) { return ( T ) value . toString ( ) ; } } return null ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ServiceSupport ; import java . util . ArrayList ; import java . util . Collection ; public class MulticastProcessor extends ServiceSupport implements Processor { private Collection < Producer > producers ; public static < E extends Exchange > Collection < Producer > toProducers ( Collection < Endpoint > endpoints ) throws Exception { Collection < Producer > answer = new ArrayList < Producer > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint . createProducer ( ) ) ; } return answer ; } public MulticastProcessor ( Collection < Endpoint > endpoints ) throws Exception { this . producers = toProducers ( endpoints ) ; } @ Override public String toString ( ) { return "Multicast" + getEndpoints ( ) ; } public void process ( Exchange exchange ) throws Exception { for ( Producer producer : producers ) { Exchange copy = copyExchangeStrategy ( producer , exchange ) ; producer . process ( copy ) ; } } protected void doStop ( ) throws Exception { for ( Producer producer : producers ) { producer . stop ( ) ; } } protected void doStart ( ) throws Exception { for ( Producer producer : producers ) { producer . start ( ) ; } } public Collection < Producer > getProducers ( ) { return producers ; } public Collection < Endpoint > getEndpoints ( ) { Collection < Endpoint > answer = new ArrayList < Endpoint > ( ) ; for ( Producer producer : producers ) { answer . add ( producer . getEndpoint ( ) ) ; } return answer ; } protected Exchange copyExchangeStrategy ( Producer producer , Exchange exchange ) { return producer . createExchange ( exchange ) ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import javax . jms . MessageListener ; public class JmsConsumer extends DefaultConsumer < JmsExchange > { private final AbstractMessageListenerContainer listenerContainer ; public JmsConsumer ( JmsEndpoint endpoint , Processor processor , AbstractMessageListenerContainer listenerContainer ) { super ( endpoint , processor ) ; this . listenerContainer = listenerContainer ; MessageListener messageListener = createMessageListener ( endpoint , processor ) ; this . listenerContainer . setMessageListener ( messageListener ) ; } public AbstractMessageListenerContainer getListenerContainer ( ) { return listenerContainer ; } protected MessageListener createMessageListener ( JmsEndpoint endpoint , Processor processor ) { EndpointMessageListener < JmsExchange > messageListener = new EndpointMessageListener < JmsExchange > ( endpoint , processor ) ; messageListener . setBinding ( endpoint . getBinding ( ) ) ; return messageListener ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; listenerContainer . afterPropertiesSet ( ) ; listenerContainer . start ( ) ; } @ Override protected void doStop ( ) throws Exception { listenerContainer . stop ( ) ; listenerContainer . destroy ( ) ; super . doStop ( ) ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] == null ) { throw new IllegalArgumentException ( "Invalid URI, it did not contain a scheme: " + uri ) ; } String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && answer . isSingleton ( ) ) { if ( answer != null ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; } } } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } if ( isStarted ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; addRoutes ( builder . getRouteList ( ) ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } protected void doStart ( ) throws Exception { if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRoutes ( routes ) ; } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } } 	1
package org . apache . camel . spi ; public interface ExceptionHandler { void handleException ( Throwable exception ) ; } 	0
package org . apache . camel . component . mock ; import org . apache . camel . Exchange ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import java . util . Map ; public class MockComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new MockEndpoint ( uri , this ) ; } } 	0
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import java . util . ArrayList ; import java . util . List ; public class CamelContextFactoryBean implements FactoryBean , InitializingBean , DisposableBean , ApplicationContextAware { private CamelContext context ; private RouteBuilder routeBuilder ; private List < RouteBuilder > additionalBuilders = new ArrayList < RouteBuilder > ( ) ; private String [ ] packages = { } ; private ApplicationContext applicationContext ; public Object getObject ( ) throws Exception { return getContext ( ) ; } public Class getObjectType ( ) { return SpringCamelContext . class ; } public boolean isSingleton ( ) { return true ; } public void afterPropertiesSet ( ) throws Exception { getContext ( ) ; findRouteBuiders ( ) ; installRoutes ( ) ; getContext ( ) . start ( ) ; } public void destroy ( ) throws Exception { getContext ( ) . stop ( ) ; } public CamelContext getContext ( ) throws Exception { if ( context == null ) { context = new SpringCamelContext ( getApplicationContext ( ) ) ; } return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public RouteBuilder getRouteBuilder ( ) { return routeBuilder ; } public void setRouteBuilder ( RouteBuilder routeBuilder ) { this . routeBuilder = routeBuilder ; } public void setRouteBuilders ( RouteBuilder [ ] builders ) { for ( RouteBuilder builder : builders ) { additionalBuilders . add ( builder ) ; } } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String [ ] getPackages ( ) { return packages ; } public void setPackages ( String [ ] packages ) { this . packages = packages ; } protected void installRoutes ( ) throws Exception { for ( RouteBuilder routeBuilder : additionalBuilders ) { getContext ( ) . addRoutes ( routeBuilder ) ; } if ( routeBuilder != null ) { getContext ( ) . addRoutes ( routeBuilder ) ; } } protected void findRouteBuiders ( ) throws IllegalAccessException , InstantiationException { if ( packages != null && packages . length > 0 ) { RouteBuilderFinder finder = new RouteBuilderFinder ( this ) ; finder . appendBuilders ( additionalBuilders ) ; } } } 	0
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . io . AbstractCachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . AbstractDestination ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import org . apache . cxf . wsdl . EndpointReferenceUtils ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; public class CamelDestination extends AbstractDestination implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-destination-base" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelDestination . class ) ; CamelContext camelContext ; String camelUri ; final ConduitInitiator conduitInitiator ; private CamelTransportBase base ; private Endpoint endpoint ; public CamelDestination ( CamelContext camelContext , Bus bus , ConduitInitiator ci , EndpointInfo info ) throws IOException { super ( getTargetReference ( info , bus ) , info ) ; this . camelContext = camelContext ; base = new CamelTransportBase ( camelContext , bus , endpointInfo , true , BASE_BEAN_NAME_SUFFIX ) ; conduitInitiator = ci ; initConfig ( ) ; } protected Logger getLogger ( ) { return LOG ; } protected Conduit getInbuiltBackChannel ( Message inMessage ) { return new BackChannelConduit ( EndpointReferenceUtils . getAnonymousEndpointReference ( ) , inMessage ) ; } public void activate ( ) { getLogger ( ) . log ( Level . INFO , "CamelDestination activate().... " ) ; try { getLogger ( ) . log ( Level . FINE , "establishing Camel connection" ) ; endpoint = camelContext . getEndpoint ( camelUri ) ; } catch ( Exception ex ) { getLogger ( ) . log ( Level . SEVERE , "Camel connect failed with EException : " , ex ) ; } } public void deactivate ( ) { base . close ( ) ; } public void shutdown ( ) { getLogger ( ) . log ( Level . FINE , "CamelDestination shutdown()" ) ; this . deactivate ( ) ; } protected void incoming ( Exchange exchange ) { getLogger ( ) . log ( Level . FINE , "server received request: " , exchange ) ; byte [ ] bytes = base . unmarshal ( exchange ) ; MessageImpl inMessage = new MessageImpl ( ) ; inMessage . setContent ( InputStream . class , new ByteArrayInputStream ( bytes ) ) ; base . populateIncomingContext ( exchange , inMessage , CamelConstants . CAMEL_SERVER_REQUEST_HEADERS ) ; inMessage . put ( CamelConstants . CAMEL_REQUEST_MESSAGE , exchange ) ; inMessage . setDestination ( this ) ; incomingObserver . onMessage ( inMessage ) ; } public String getBeanName ( ) { return endpointInfo . getName ( ) . toString ( ) + ".camel-destination" ; } private void initConfig ( ) { } protected class ConsumerProcessor implements Processor { public void process ( Exchange exchange ) { try { incoming ( exchange ) ; } catch ( Throwable ex ) { getLogger ( ) . log ( Level . WARNING , "Failed to process incoming message : " , ex ) ; } } } protected class BackChannelConduit extends AbstractConduit { protected Message inMessage ; BackChannelConduit ( EndpointReferenceType ref , Message message ) { super ( ref ) ; inMessage = message ; } public void setMessageObserver ( MessageObserver observer ) { } public void prepare ( Message message ) throws IOException { message . put ( CamelConstants . CAMEL_REQUEST_MESSAGE , inMessage . get ( CamelConstants . CAMEL_REQUEST_MESSAGE ) ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( inMessage ) ) ; } protected Logger getLogger ( ) { return LOG ; } } private class CamelOutputStream extends AbstractCachedOutputStream { private Message inMessage ; private Producer < Exchange > replyTo ; private Producer < Exchange > sender ; public CamelOutputStream ( Message m ) { super ( ) ; inMessage = m ; } private void commitOutputMessage ( ) throws IOException { final String replyToUri = getReplyToDestination ( inMessage ) ; base . template . send ( replyToUri , new Processor ( ) { public void process ( Exchange reply ) { base . marshal ( currentStream . toString ( ) , replyToUri , reply ) ; setReplyCorrelationID ( inMessage , reply ) ; base . setMessageProperties ( inMessage , reply ) ; getLogger ( ) . log ( Level . FINE , "just server sending reply: " , reply ) ; } } ) ; } @ Override protected void doFlush ( ) throws IOException { } @ Override protected void doClose ( ) throws IOException { commitOutputMessage ( ) ; } @ Override protected void onWrite ( ) throws IOException { } } protected String getReplyToDestination ( Message inMessage ) { if ( inMessage . get ( CamelConstants . CAMEL_REBASED_REPLY_TO ) != null ) { return ( String ) inMessage . get ( CamelConstants . CAMEL_REBASED_REPLY_TO ) ; } else { return base . getReplyDestination ( ) ; } } protected void setReplyCorrelationID ( Message inMessage , Exchange reply ) { Object value = inMessage . get ( CamelConstants . CAMEL_CORRELATION_ID ) ; if ( value != null ) { reply . getIn ( ) . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , value ) ; } } } 	0
package org . apache . camel . component . xmpp ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . jivesoftware . smack . packet . Message ; public class XmppExchange extends DefaultExchange { private XmppBinding binding ; public XmppExchange ( CamelContext context , XmppBinding binding ) { super ( context ) ; this . binding = binding ; } public XmppExchange ( CamelContext context , XmppBinding binding , Message message ) { this ( context , binding ) ; setIn ( new XmppMessage ( message ) ) ; } @ Override public XmppMessage getIn ( ) { return ( XmppMessage ) super . getIn ( ) ; } @ Override public XmppMessage getOut ( ) { return ( XmppMessage ) super . getOut ( ) ; } @ Override public XmppMessage getOut ( boolean lazyCreate ) { return ( XmppMessage ) super . getOut ( lazyCreate ) ; } @ Override public XmppMessage getFault ( ) { return ( XmppMessage ) super . getFault ( ) ; } public XmppBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new XmppExchange ( getContext ( ) , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getXmppMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } @ Override protected XmppMessage createInMessage ( ) { return new XmppMessage ( ) ; } @ Override protected XmppMessage createOutMessage ( ) { return new XmppMessage ( ) ; } } 	0
package org . apache . camel . component . http ; import java . util . HashMap ; import org . mortbay . jetty . Connector ; import org . mortbay . jetty . Server ; import org . mortbay . jetty . nio . SelectChannelConnector ; import org . mortbay . jetty . security . SslSocketConnector ; import org . mortbay . jetty . servlet . Context ; import org . mortbay . jetty . servlet . ServletHolder ; public class JettyHttpComponent extends HttpComponent { Server server ; class ConnectorRef { Connector connector ; int refCount = 0 ; public ConnectorRef ( Connector connector ) { this . connector = connector ; increment ( ) ; } public int increment ( ) { return ++ refCount ; } public int decrement ( ) { return -- refCount ; } } final HashMap < String , ConnectorRef > connectors = new HashMap < String , ConnectorRef > ( ) ; @ Override protected void doStart ( ) throws Exception { server = createServer ( ) ; super . doStart ( ) ; } private Server createServer ( ) throws Exception { setCamelServlet ( new CamelServlet ( ) ) ; Server server = new Server ( ) ; Context context = new Context ( Context . NO_SECURITY | Context . NO_SESSIONS ) ; context . setContextPath ( "/" ) ; ServletHolder holder = new ServletHolder ( ) ; holder . setServlet ( getCamelServlet ( ) ) ; context . addServlet ( holder , "/*" ) ; server . setHandler ( context ) ; server . start ( ) ; return server ; } @ Override protected void doStop ( ) throws Exception { for ( ConnectorRef connectorRef : connectors . values ( ) ) { connectorRef . connector . stop ( ) ; } connectors . clear ( ) ; server . stop ( ) ; super . doStop ( ) ; } @ Override public void connect ( HttpConsumer consumer ) throws Exception { HttpEndpoint endpoint = ( HttpEndpoint ) consumer . getEndpoint ( ) ; String connectorKey = endpoint . getProtocol ( ) + ":" + endpoint . getPort ( ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef == null ) { Connector connector ; if ( "https" . equals ( endpoint . getProtocol ( ) ) ) { connector = new SslSocketConnector ( ) ; } else { connector = new SelectChannelConnector ( ) ; } connector . setPort ( endpoint . getPort ( ) ) ; server . addConnector ( connector ) ; connector . start ( ) ; connectorRef = new ConnectorRef ( connector ) ; } else { connectorRef . increment ( ) ; } } super . connect ( consumer ) ; } @ Override public void disconnect ( HttpConsumer consumer ) throws Exception { super . disconnect ( consumer ) ; HttpEndpoint endpoint = ( HttpEndpoint ) consumer . getEndpoint ( ) ; String connectorKey = endpoint . getProtocol ( ) + ":" + endpoint . getPort ( ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef != null ) { if ( connectorRef . decrement ( ) == 0 ) { server . removeConnector ( connectorRef . connector ) ; connectorRef . connector . stop ( ) ; connectors . remove ( connectorKey ) ; } } } } } 	0
package org . apache . camel ; public class CamelException extends Exception { public CamelException ( ) { } public CamelException ( String message ) { super ( message ) ; } public CamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public CamelException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public class RoundRobinLoadBalancer extends QueueLoadBalancer { private int counter = - 1 ; protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; if ( ++ counter >= size ) { counter = 0 ; } return processors . get ( counter ) ; } } 	0
package org . apache . camel . bam . model ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; @ Entity public class ActivityDefinition extends EntitySupport { private String name ; private ProcessDefinition processDefinition ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "Activity[" + getId ( ) + " name: " + getName ( ) + "]" ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } } 	0
package org . apache . camel . component . http ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; public class HttpBinding { public void writeResponse ( HttpExchange exchange ) { } public Object parseBody ( HttpMessage httpMessage ) throws IOException { HttpServletRequest request = httpMessage . getRequest ( ) ; return request . getReader ( ) ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; public class SendProcessor extends ServiceSupport implements Processor , Service { private Endpoint destination ; private Producer producer ; public SendProcessor ( Endpoint destination ) { this . destination = destination ; } protected void doStop ( ) throws Exception { if ( producer != null ) { try { producer . stop ( ) ; } finally { producer = null ; } } } protected void doStart ( ) throws Exception { this . producer = destination . createProducer ( ) ; } public void process ( Exchange exchange ) throws Exception { if ( producer == null ) { throw new IllegalStateException ( "No producer, this processor has not been started!" ) ; } producer . process ( exchange ) ; } public Endpoint getDestination ( ) { return destination ; } @ Override public String toString ( ) { return "sendTo(" + destination + ")" ; } } 	0
package org . apache . camel . component . http ; import java . net . URI ; import java . net . URISyntaxException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultEndpoint ; public class HttpEndpoint extends DefaultEndpoint < HttpExchange > { private HttpBinding binding ; private HttpComponent component ; private URI httpUri ; protected HttpEndpoint ( String uri , HttpComponent component ) throws URISyntaxException { super ( uri , component ) ; this . component = component ; this . httpUri = new URI ( uri ) ; } public HttpProducer createProducer ( ) throws Exception { return new HttpProducer ( this ) ; } public Consumer < HttpExchange > createConsumer ( Processor processor ) throws Exception { return new HttpConsumer ( this , processor ) ; } public HttpExchange createExchange ( ) { return new HttpExchange ( this ) ; } public HttpExchange createExchange ( HttpServletRequest request , HttpServletResponse response ) { return new HttpExchange ( this , request , response ) ; } public HttpBinding getBinding ( ) { if ( binding == null ) { binding = new HttpBinding ( ) ; } return binding ; } public void setBinding ( HttpBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return true ; } public void connect ( HttpConsumer consumer ) throws Exception { component . connect ( consumer ) ; } public void disconnect ( HttpConsumer consumer ) throws Exception { component . disconnect ( consumer ) ; } public String getPath ( ) { return httpUri . getPath ( ) ; } public int getPort ( ) { if ( httpUri . getPort ( ) == - 1 ) { if ( "https" . equals ( getProtocol ( ) ) ) { return 443 ; } else { return 80 ; } } return httpUri . getPort ( ) ; } public String getProtocol ( ) { return httpUri . getScheme ( ) ; } } 	0
package org . apache . camel . processor ; public enum LoggingLevel { DEBUG , ERROR , FATAL , INFO , TRACE , WARN ; } 	0
package org . apache . camel . component . quartz ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . JobDetail ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . Trigger ; import org . quartz . SimpleTrigger ; import java . util . Date ; import java . util . Map ; import java . util . Set ; public class QuartzEndpoint extends DefaultEndpoint < QuartzExchange > { public static final String ENDPOINT_KEY = "org.apache.camel.quartz" ; private static final transient Log log = LogFactory . getLog ( QuartzEndpoint . class ) ; private Scheduler scheduler ; private LoadBalancer loadBalancer ; private Trigger trigger ; private JobDetail jobDetail ; private boolean started ; public QuartzEndpoint ( String endpointUri , QuartzComponent component , Scheduler scheduler ) { super ( endpointUri , component ) ; this . scheduler = scheduler ; } public void addTriggers ( Map < Trigger , JobDetail > triggerMap ) throws SchedulerException { if ( triggerMap != null ) { Set < Map . Entry < Trigger , JobDetail > > entries = triggerMap . entrySet ( ) ; for ( Map . Entry < Trigger , JobDetail > entry : entries ) { Trigger key = entry . getKey ( ) ; JobDetail value = entry . getValue ( ) ; ObjectHelper . notNull ( key , "key" ) ; ObjectHelper . notNull ( value , "value" ) ; addTrigger ( key , value ) ; } } } public void addTrigger ( Trigger trigger , JobDetail detail ) throws SchedulerException { if ( trigger . getName ( ) == null ) { trigger . setName ( detail . getName ( ) ) ; } if ( trigger . getGroup ( ) == null ) { trigger . setGroup ( detail . getGroup ( ) ) ; } if ( trigger . getStartTime ( ) == null ) { trigger . setStartTime ( new Date ( ) ) ; } detail . getJobDataMap ( ) . put ( ENDPOINT_KEY , this ) ; Class jobClass = detail . getJobClass ( ) ; if ( jobClass == null ) { detail . setJobClass ( CamelJob . class ) ; } if ( detail . getName ( ) == null ) { detail . setName ( getEndpointUri ( ) ) ; } getScheduler ( ) . scheduleJob ( detail , trigger ) ; } public void removeTrigger ( Trigger trigger , JobDetail jobDetail ) throws SchedulerException { getScheduler ( ) . unscheduleJob ( trigger . getName ( ) , trigger . getGroup ( ) ) ; } public void onJobExecute ( JobExecutionContext jobExecutionContext ) throws JobExecutionException { if ( log . isDebugEnabled ( ) ) { log . debug ( "Firing Quartz Job with context: " + jobExecutionContext ) ; } QuartzExchange exchange = createExchange ( jobExecutionContext ) ; try { getLoadBalancer ( ) . process ( exchange ) ; } catch ( JobExecutionException e ) { throw e ; } catch ( Exception e ) { throw new JobExecutionException ( e ) ; } } public QuartzExchange createExchange ( ) { return new QuartzExchange ( getContext ( ) , null ) ; } public QuartzExchange createExchange ( JobExecutionContext jobExecutionContext ) { return new QuartzExchange ( getContext ( ) , jobExecutionContext ) ; } public Producer < QuartzExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "You cannot send messages to this endpoint" ) ; } public QuartzConsumer createConsumer ( Processor processor ) throws Exception { return new QuartzConsumer ( this , processor ) ; } @ Override public QuartzComponent getComponent ( ) { return ( QuartzComponent ) super . getComponent ( ) ; } public boolean isSingleton ( ) { return true ; } public Scheduler getScheduler ( ) { return scheduler ; } public LoadBalancer getLoadBalancer ( ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( ) ; } return loadBalancer ; } public void setLoadBalancer ( LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } public JobDetail getJobDetail ( ) { if ( jobDetail == null ) { jobDetail = createJobDetail ( ) ; } return jobDetail ; } public void setJobDetail ( JobDetail jobDetail ) { this . jobDetail = jobDetail ; } public Trigger getTrigger ( ) { if ( trigger == null ) { trigger = createTrigger ( ) ; } return trigger ; } public void setTrigger ( Trigger trigger ) { this . trigger = trigger ; } public synchronized void consumerStarted ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . addProcessor ( consumer . getProcessor ( ) ) ; if ( ! started ) { addTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = true ; } } public synchronized void consumerStopped ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . removeProcessor ( consumer . getProcessor ( ) ) ; if ( getLoadBalancer ( ) . getProcessors ( ) . isEmpty ( ) && started ) { removeTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = false ; } } protected LoadBalancer createLoadBalancer ( ) { return new RoundRobinLoadBalancer ( ) ; } protected JobDetail createJobDetail ( ) { return new JobDetail ( ) ; } protected Trigger createTrigger ( ) { return new SimpleTrigger ( ) ; } } 	0
package org . apache . camel . util ; import java . util . LinkedHashMap ; import java . util . Map ; public class LRUCache < K , V > extends LinkedHashMap < K , V > { private static final long serialVersionUID = - 342098639681884413L ; private int maxCacheSize = 10000 ; public LRUCache ( int maximumCacheSize ) { this ( maximumCacheSize , maximumCacheSize , 0.75f , true ) ; } public LRUCache ( int initialCapacity , int maximumCacheSize , float loadFactor , boolean accessOrder ) { super ( initialCapacity , loadFactor , accessOrder ) ; this . maxCacheSize = maximumCacheSize ; } public int getMaxCacheSize ( ) { return maxCacheSize ; } protected boolean removeEldestEntry ( Map . Entry entry ) { return size ( ) > maxCacheSize ; } } 	0
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface EndpointInject { String uri ( ) default "" ; String name ( ) default "" ; } 	0
package org . apache . camel . builder ; import static org . apache . camel . util . ObjectHelper . compare ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . impl . PredicateSupport ; import org . apache . camel . impl . BinaryPredicateSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class PredicateBuilder { public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	1
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . Injector ; public interface TypeConverterRegistry { void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) ; Injector getInjector ( ) ; } 	0
package org . apache . camel . spring . xml ; import java . util . ArrayList ; import org . springframework . beans . factory . BeanFactory ; public class BuilderStatement { private ArrayList < BuilderAction > actions ; private Class returnType ; public Object create ( BeanFactory beanFactory , Object rootBuilder ) { Object currentBuilder = rootBuilder ; BuilderAction lastAction = null ; for ( BuilderAction action : actions ) { if ( currentBuilder == null ) { throw new IllegalArgumentException ( "Invalid configuration.  The '" + lastAction . getName ( ) + "' action cannot be followed by the '" + action . getName ( ) + "' action." ) ; } currentBuilder = action . invoke ( beanFactory , rootBuilder , currentBuilder ) ; lastAction = action ; } return currentBuilder ; } public ArrayList < BuilderAction > getActions ( ) { return actions ; } public void setActions ( ArrayList < BuilderAction > actions ) { this . actions = actions ; } public Class getReturnType ( ) { return returnType ; } public void setReturnType ( Class returnType ) { this . returnType = returnType ; } } 	0
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface ExchangeConverter { < T > T convertTo ( Class < T > type , Exchange exchange ) ; } 	0
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessagePropertyNamesAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 6744171518099741324L ; public MessagePropertyNamesAccessException ( JMSException e ) { super ( "Failed to acess the JMS message property names" , e ) ; } } 	0
package org . apache . camel . component . rmi ; import java . rmi . AccessException ; import java . rmi . NotBoundException ; import java . rmi . Remote ; import java . rmi . RemoteException ; import java . rmi . registry . Registry ; import org . apache . camel . component . pojo . PojoEndpoint ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . Exchange ; public class RmiProducer extends DefaultProducer { private final RmiEndpoint endpoint ; private Remote remote ; public RmiProducer ( RmiEndpoint endpoint ) throws AccessException , RemoteException , NotBoundException { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) throws AccessException , RemoteException , NotBoundException { PojoExchange pojoExchange = endpoint . toExchangeType ( exchange ) ; PojoEndpoint . invoke ( getRemote ( ) , pojoExchange ) ; exchange . copyFrom ( pojoExchange ) ; } public Remote getRemote ( ) throws AccessException , RemoteException , NotBoundException { if ( remote == null ) { Registry registry = endpoint . getRegistry ( ) ; remote = registry . lookup ( endpoint . getName ( ) ) ; } return remote ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . EventDrivenConsumerRoute ; import org . apache . camel . processor . CompositeProcessor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . MulticastProcessor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . Policy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; public class FromBuilder extends BuilderSupport implements ProcessorFactory { public static final String DEFAULT_TRACE_CATEGORY = "org.apache.camel.TRACE" ; private RouteBuilder builder ; private Endpoint from ; private List < Processor > processors = new ArrayList < Processor > ( ) ; private List < ProcessorFactory > processFactories = new ArrayList < ProcessorFactory > ( ) ; private FromBuilder routeBuilder ; public FromBuilder ( RouteBuilder builder , Endpoint from ) { super ( builder ) ; this . builder = builder ; this . from = from ; } public FromBuilder ( FromBuilder parent ) { super ( parent ) ; this . builder = parent . getBuilder ( ) ; this . from = parent . getFrom ( ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( "uri" ) String uri ) { return to ( endpoint ( uri ) ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( "ref" ) Endpoint endpoint ) { ToBuilder answer = new ToBuilder ( this , endpoint ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public ProcessorFactory to ( String ... uris ) { return to ( endpoints ( uris ) ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( value = "endpoint" , attribute = false , element = true ) Endpoint ... endpoints ) { return to ( endpoints ( endpoints ) ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( value = "endpoint" , attribute = false , element = true ) Collection < Endpoint > endpoints ) { return addProcessBuilder ( new MulticastBuilder ( this , endpoints ) ) ; } @ Fluent public ProcessorFactory pipeline ( @ FluentArg ( "uris" ) String ... uris ) { return pipeline ( endpoints ( uris ) ) ; } @ Fluent public ProcessorFactory pipeline ( @ FluentArg ( "endpoints" ) Endpoint ... endpoints ) { return pipeline ( endpoints ( endpoints ) ) ; } @ Fluent public ProcessorFactory pipeline ( @ FluentArg ( "endpoints" ) Collection < Endpoint > endpoints ) { return addProcessBuilder ( new PipelineBuilder ( this , endpoints ) ) ; } @ Fluent public IdempotentConsumerBuilder idempotentConsumer ( @ FluentArg ( "messageIdExpression" ) Expression messageIdExpression , @ FluentArg ( "MessageIdRepository" ) MessageIdRepository messageIdRepository ) { return ( IdempotentConsumerBuilder ) addProcessBuilder ( new IdempotentConsumerBuilder ( this , messageIdExpression , messageIdRepository ) ) ; } @ Fluent public FilterBuilder filter ( @ FluentArg ( value = "predicate" , element = true ) Predicate predicate ) { FilterBuilder answer = new FilterBuilder ( this , predicate ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent ( nestedActions = true ) public ChoiceBuilder choice ( ) { ChoiceBuilder answer = new ChoiceBuilder ( this ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public RecipientListBuilder recipientList ( @ FluentArg ( value = "recipients" , element = true ) Expression receipients ) { RecipientListBuilder answer = new RecipientListBuilder ( this , receipients ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public SplitterBuilder splitter ( @ FluentArg ( value = "recipients" , element = true ) Expression receipients ) { SplitterBuilder answer = new SplitterBuilder ( this , receipients ) ; addProcessBuilder ( answer ) ; return answer ; } public ResequencerBuilder resequencer ( Expression < Exchange > expression ) { return resequencer ( Collections . < Expression < Exchange > > singletonList ( expression ) ) ; } @ Fluent public ResequencerBuilder resequencer ( @ FluentArg ( value = "expressions" ) List < Expression < Exchange > > expressions ) { ResequencerBuilder answer = new ResequencerBuilder ( this , expressions ) ; setRouteBuilder ( answer ) ; return answer ; } @ Fluent public ResequencerBuilder resequencer ( Expression < Exchange > ... expressions ) { List < Expression < Exchange > > list = new ArrayList < Expression < Exchange > > ( ) ; for ( Expression < Exchange > expression : expressions ) { list . add ( expression ) ; } return resequencer ( list ) ; } @ Fluent public FromBuilder errorHandler ( @ FluentArg ( "handler" ) ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } @ Fluent public FromBuilder inheritErrorHandler ( @ FluentArg ( "condition" ) boolean condition ) { setInheritErrorHandler ( condition ) ; return this ; } @ Fluent ( nestedActions = true ) public InterceptorBuilder intercept ( ) { InterceptorBuilder answer = new InterceptorBuilder ( this ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public FromBuilder trace ( ) { return trace ( DEFAULT_TRACE_CATEGORY ) ; } @ Fluent public FromBuilder trace ( @ FluentArg ( "category" ) String category ) { final Log log = LogFactory . getLog ( category ) ; return intercept ( new DelegateProcessor ( ) { @ Override public void process ( Exchange exchange ) throws Exception { log . trace ( exchange ) ; processNext ( exchange ) ; } } ) ; } @ Fluent public FromBuilder intercept ( @ FluentArg ( "interceptor" ) DelegateProcessor interceptor ) { InterceptorBuilder answer = new InterceptorBuilder ( this ) ; answer . add ( interceptor ) ; addProcessBuilder ( answer ) ; return answer . target ( ) ; } @ Fluent ( nestedActions = true ) public PolicyBuilder policies ( ) { PolicyBuilder answer = new PolicyBuilder ( this ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public FromBuilder policy ( @ FluentArg ( "policy" ) Policy policy ) { PolicyBuilder answer = new PolicyBuilder ( this ) ; answer . add ( policy ) ; addProcessBuilder ( answer ) ; return answer . target ( ) ; } @ Fluent public FromBuilder process ( @ FluentArg ( "ref" ) Processor processor ) { addProcessorBuilder ( processor ) ; return this ; } @ Fluent public FromBuilder setBody ( Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setBody ( expression ) ) ; return this ; } @ Fluent public FromBuilder setOutBody ( Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setOutBody ( expression ) ) ; return this ; } @ Fluent public FromBuilder setHeader ( String name , Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setHeader ( name , expression ) ) ; return this ; } @ Fluent public FromBuilder setOutHeader ( String name , Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setOutHeader ( name , expression ) ) ; return this ; } @ Fluent public FromBuilder setProperty ( String name , Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setProperty ( name , expression ) ) ; return this ; } @ Fluent public FromBuilder convertBodyTo ( Class type ) { addProcessorBuilder ( ProcessorBuilder . setBody ( Builder . body ( ) . convertTo ( type ) ) ) ; return this ; } @ Fluent public FromBuilder convertOutBodyTo ( Class type ) { addProcessorBuilder ( ProcessorBuilder . setOutBody ( Builder . outBody ( ) . convertTo ( type ) ) ) ; return this ; } public RouteBuilder getBuilder ( ) { return builder ; } public Endpoint getFrom ( ) { return from ; } public List < Processor > getProcessors ( ) { return processors ; } public ProcessorFactory addProcessBuilder ( ProcessorFactory processFactory ) { processFactories . add ( processFactory ) ; return processFactory ; } protected void addProcessorBuilder ( Processor processor ) { addProcessBuilder ( new ConstantProcessorBuilder ( processor ) ) ; } public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public Route createRoute ( ) throws Exception { if ( routeBuilder != null ) { return routeBuilder . createRoute ( ) ; } Processor processor = createProcessor ( ) ; if ( processor == null ) { throw new IllegalArgumentException ( "No processor created for: " + this ) ; } return new EventDrivenConsumerRoute ( getFrom ( ) , processor ) ; } public Processor createProcessor ( ) throws Exception { List < Processor > answer = new ArrayList < Processor > ( ) ; for ( ProcessorFactory processFactory : processFactories ) { Processor processor = makeProcessor ( processFactory ) ; if ( processor == null ) { throw new IllegalArgumentException ( "No processor created for processBuilder: " + processFactory ) ; } answer . add ( processor ) ; } if ( answer . size ( ) == 0 ) { return null ; } Processor processor = null ; if ( answer . size ( ) == 1 ) { processor = answer . get ( 0 ) ; } else { processor = new CompositeProcessor ( answer ) ; } return processor ; } protected Processor makeProcessor ( ProcessorFactory processFactory ) throws Exception { Processor processor = processFactory . createProcessor ( ) ; processor = wrapProcessor ( processor ) ; return wrapInErrorHandler ( processor ) ; } protected Processor wrapInErrorHandler ( Processor processor ) throws Exception { return getErrorHandlerBuilder ( ) . createErrorHandler ( processor ) ; } protected Processor wrapProcessor ( Processor processor ) { return processor ; } protected FromBuilder getRouteBuilder ( ) { return routeBuilder ; } protected void setRouteBuilder ( FromBuilder routeBuilder ) { this . routeBuilder = routeBuilder ; } } 	0
package org . apache . camel . bam . processor ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . rules . ProcessRules ; import org . apache . camel . impl . ServiceSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaCallback ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; import javax . persistence . EntityManager ; import javax . persistence . LockModeType ; import javax . persistence . PersistenceException ; import java . util . Date ; import java . util . List ; public class ActivityMonitorEngine extends ServiceSupport implements Runnable { private static final Log log = LogFactory . getLog ( ActivityMonitorEngine . class ) ; private JpaTemplate template ; private TransactionTemplate transactionTemplate ; private ProcessRules rules ; private int escalateLevel = 0 ; private long windowMillis = 1000L ; private Thread thread ; private boolean useLocking = false ; public ActivityMonitorEngine ( JpaTemplate template , TransactionTemplate transactionTemplate , ProcessRules rules ) { this . template = template ; this . transactionTemplate = transactionTemplate ; this . rules = rules ; } public boolean isUseLocking ( ) { return useLocking ; } public void setUseLocking ( boolean useLocking ) { this . useLocking = useLocking ; } public void run ( ) { log . debug ( "Starting to poll for timeout events" ) ; while ( ! isStopped ( ) ) { try { long now = System . currentTimeMillis ( ) ; long nextPoll = now + windowMillis ; final Date timeNow = new Date ( now ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { List < ActivityState > list = template . find ( "select x from " + ActivityState . class . getName ( ) + " x where x.escalationLevel = ?1 and x.timeOverdue < ?2" , escalateLevel , timeNow ) ; for ( ActivityState activityState : list ) { fireExpiredEvent ( activityState ) ; } } } ) ; long timeToSleep = nextPoll - System . currentTimeMillis ( ) ; if ( timeToSleep > 0 ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sleeping for " + timeToSleep + " millis" ) ; } try { Thread . sleep ( timeToSleep ) ; } catch ( InterruptedException e ) { log . debug ( "Caught: " + e , e ) ; } } } catch ( Exception e ) { log . error ( "Caught: " + e , e ) ; } } } protected void fireExpiredEvent ( final ActivityState activityState ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Trying to fire expiration of: " + activityState ) ; } template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { if ( isUseLocking ( ) ) { log . info ( "Attempting to lock: " + activityState ) ; entityManager . lock ( activityState , LockModeType . WRITE ) ; log . info ( "Grabbed lock: " + activityState ) ; } try { rules . processExpired ( activityState ) ; } catch ( Exception e ) { log . error ( "Failed to process expiration of: " + activityState + ". Reason: " + e , e ) ; } activityState . setEscalationLevel ( escalateLevel + 1 ) ; return null ; } } ) ; } protected void doStart ( ) throws Exception { rules . start ( ) ; thread = new Thread ( this , "ActivityMonitorEngine" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { if ( thread != null ) { thread = null ; } rules . stop ( ) ; } } 	0
package org . apache . camel . component . jms ; import javax . jms . Message ; import javax . jms . MessageListener ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class EndpointMessageListener < E extends Exchange > implements MessageListener { private static final transient Log log = LogFactory . getLog ( EndpointMessageListener . class ) ; private Endpoint < E > endpoint ; private Processor processor ; private JmsBinding binding ; public EndpointMessageListener ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } public void onMessage ( Message message ) { try { if ( log . isDebugEnabled ( ) ) { log . debug ( endpoint + " receiving JMS message: " + message ) ; } JmsExchange exchange = createExchange ( message ) ; processor . process ( ( E ) exchange ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public JmsExchange createExchange ( Message message ) { return new JmsExchange ( endpoint . getContext ( ) , getBinding ( ) , message ) ; } public JmsBinding getBinding ( ) { if ( binding == null ) { binding = new JmsBinding ( ) ; } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } } 	0
package org . apache . camel ; public interface Expression < E extends Exchange > { Object evaluate ( E exchange ) ; } 	0
package org . apache . camel . component . jms ; public enum ConsumerType { Simple , Default , ServerSessionPool } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; public interface PredicateFactory < E extends Exchange > { public Predicate < E > createPredicate ( ) ; } 	0
package org . apache . camel . processor ; import java . io . Serializable ; import java . util . Random ; public class RedeliveryPolicy implements Cloneable , Serializable { protected static transient Random randomNumberGenerator ; protected int maximumRedeliveries = 6 ; protected long initialRedeliveryDelay = 1000L ; protected double backOffMultiplier = 2 ; protected boolean useExponentialBackOff = false ; protected double collisionAvoidanceFactor = 0.15d ; protected boolean useCollisionAvoidance = false ; public RedeliveryPolicy ( ) { } @ Override public String toString ( ) { return "RedeliveryPolicy[maximumRedeliveries=" + maximumRedeliveries + "]" ; } public RedeliveryPolicy copy ( ) { try { return ( RedeliveryPolicy ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( "Could not clone: " + e , e ) ; } } public boolean shouldRedeliver ( int redeliveryCounter ) { return redeliveryCounter < getMaximumRedeliveries ( ) ; } public RedeliveryPolicy maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicy initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicy useCollisionAvoidance ( ) { setUseCollisionAvoidance ( true ) ; return this ; } public RedeliveryPolicy useExponentialBackOff ( ) { setUseExponentialBackOff ( true ) ; return this ; } public RedeliveryPolicy backOffMultiplier ( double backOffMultiplier ) { useExponentialBackOff ( ) ; setBackOffMultiplier ( backOffMultiplier ) ; return this ; } public RedeliveryPolicy collisionAvoidancePercent ( short collisionAvoidancePercent ) { useCollisionAvoidance ( ) ; setCollisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public short getCollisionAvoidancePercent ( ) { return ( short ) Math . round ( collisionAvoidanceFactor * 100 ) ; } public void setCollisionAvoidancePercent ( short collisionAvoidancePercent ) { this . collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d ; } public double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public int getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( int maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public long getRedeliveryDelay ( long previousDelay ) { long redeliveryDelay ; if ( previousDelay == 0 ) { redeliveryDelay = initialRedeliveryDelay ; } else if ( useExponentialBackOff && backOffMultiplier > 1 ) { redeliveryDelay = Math . round ( backOffMultiplier * previousDelay ) ; } else { redeliveryDelay = previousDelay ; } if ( useCollisionAvoidance ) { Random random = getRandomNumberGenerator ( ) ; double variance = ( random . nextBoolean ( ) ? collisionAvoidanceFactor : - collisionAvoidanceFactor ) * random . nextDouble ( ) ; redeliveryDelay += redeliveryDelay * variance ; } return redeliveryDelay ; } public boolean isUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public boolean isUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } protected static synchronized Random getRandomNumberGenerator ( ) { if ( randomNumberGenerator == null ) { randomNumberGenerator = new Random ( ) ; } return randomNumberGenerator ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; public class WhenBuilder extends FilterBuilder { private final ChoiceBuilder parent ; public WhenBuilder ( ChoiceBuilder parent , Predicate predicate ) { super ( parent , predicate ) ; this . parent = parent ; } @ Override @ Fluent public ChoiceBuilder to ( @ FluentArg ( "ref" ) Endpoint endpoint ) { super . to ( endpoint ) ; return parent ; } @ Override @ Fluent public ChoiceBuilder to ( @ FluentArg ( "uri" ) String uri ) { super . to ( uri ) ; return parent ; } @ Override @ Fluent public ChoiceBuilder process ( @ FluentArg ( "ref" ) Processor processor ) { super . process ( processor ) ; return parent ; } } 	0
package org . apache . camel . builder . sql ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import org . apache . camel . util . ObjectHelper ; import org . josql . Query ; import org . josql . QueryExecutionException ; import org . josql . QueryParseException ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . HashMap ; public class SqlBuilder < E extends Exchange > implements Expression < E > , Predicate < E > { private Query query ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public SqlBuilder ( Query query ) { this . query = query ; } public Object evaluate ( E exchange ) { return evaluateQuery ( exchange ) ; } public boolean matches ( E exchange ) { List list = evaluateQuery ( exchange ) ; return matches ( exchange , list ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { List list = evaluateQuery ( exchange ) ; if ( ! matches ( exchange , list ) ) { throw new AssertionError ( this + " failed on " + exchange + " as found " + list ) ; } } public static < E extends Exchange > SqlBuilder < E > sql ( String sql ) throws QueryParseException { Query q = new Query ( ) ; q . parse ( sql ) ; return new SqlBuilder ( q ) ; } public SqlBuilder < E > variable ( String name , Object value ) { getVariables ( ) . put ( name , value ) ; return this ; } public Map < String , Object > getVariables ( ) { return variables ; } public void setVariables ( Map < String , Object > properties ) { this . variables = properties ; } protected boolean matches ( E exchange , List list ) { return ObjectHelper . matches ( list ) ; } protected List evaluateQuery ( E exchange ) { configureQuery ( exchange ) ; Message in = exchange . getIn ( ) ; List list = in . getBody ( List . class ) ; if ( list == null ) { list = Collections . singletonList ( in . getBody ( ) ) ; } try { return query . execute ( list ) . getResults ( ) ; } catch ( QueryExecutionException e ) { throw new RuntimeExpressionException ( e ) ; } } protected void configureQuery ( E exchange ) { addVariables ( exchange . getProperties ( ) ) ; addVariables ( exchange . getIn ( ) . getHeaders ( ) ) ; addVariables ( getVariables ( ) ) ; query . setVariable ( "exchange" , exchange ) ; query . setVariable ( "in" , exchange . getIn ( ) ) ; query . setVariable ( "out" , exchange . getOut ( ) ) ; } protected void addVariables ( Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { query . setVariable ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	0
package org . apache . camel . component . mail ; import org . apache . camel . Converter ; import javax . mail . BodyPart ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import java . io . IOException ; @ Converter public class MailConverters { @ Converter public String toString ( Message message ) throws MessagingException , IOException { Object content = message . getContent ( ) ; if ( content instanceof MimeMultipart ) { MimeMultipart multipart = ( MimeMultipart ) content ; if ( multipart . getCount ( ) > 0 ) { BodyPart part = multipart . getBodyPart ( 0 ) ; content = part . getContent ( ) ; } } if ( content != null ) { return content . toString ( ) ; } return null ; } @ Converter public static String toString ( Multipart multipart ) throws MessagingException , IOException { for ( int i = 0 , size = multipart . getCount ( ) ; i < size ; i ++ ) { BodyPart part = multipart . getBodyPart ( i ) ; if ( part . getContentType ( ) . startsWith ( "text" ) ) { return part . getContent ( ) . toString ( ) ; } } return null ; } } 	0
package org . apache . camel . util ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . NoSuchEndpointException ; public class ExchangeHelper { @ SuppressWarnings ( { "unchecked" } ) public static < E extends Exchange > Endpoint < E > resolveEndpoint ( E exchange , Object value ) throws NoSuchEndpointException { Endpoint < E > endpoint ; if ( value instanceof Endpoint ) { endpoint = ( Endpoint < E > ) value ; } else { String uri = value . toString ( ) ; endpoint = ( Endpoint < E > ) exchange . getContext ( ) . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } } return endpoint ; } } 	0
package org . apache . camel ; public class RuntimeExpressionException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; public RuntimeExpressionException ( String message ) { super ( message ) ; } public RuntimeExpressionException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeExpressionException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; import java . util . Arrays ; import java . util . regex . Pattern ; public class ExpressionBuilder { public static < E extends Exchange > Expression < E > headerExpression ( final String headerName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object header = exchange . getIn ( ) . getHeader ( headerName ) ; if ( header == null ) { header = exchange . getProperty ( headerName ) ; } return header ; } @ Override public String toString ( ) { return "header(" + headerName + ")" ; } } ; } public static < E extends Exchange > Expression < E > propertyExpression ( final String propertyName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getProperty ( propertyName ) ; } @ Override public String toString ( ) { return "property(" + propertyName + ")" ; } } ; } public static < E extends Exchange > Expression < E > constantExpression ( final Object value ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return value ; } @ Override public String toString ( ) { return "" + value ; } } ; } public static < E extends Exchange > Expression < E > bodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "body" ; } } ; } public static < E extends Exchange , T > Expression < E > bodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "bodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > outBodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getOut ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "outBody" ; } } ; } public static < E extends Exchange > Expression < E > exchangeExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange ; } @ Override public String toString ( ) { return "exchange" ; } } ; } public static < E extends Exchange > Expression < E > inMessageExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) ; } @ Override public String toString ( ) { return "inMessage" ; } } ; } public static < E extends Exchange > Expression < E > convertTo ( final Expression expression , final Class type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } @ Override public String toString ( ) { return "convertTo(" + expression + ", " + type + ")" ; } } ; } public static < E extends Exchange > Expression < E > tokenizeExpression ( final Expression < E > expression , final String token ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } StringTokenizer iter = new StringTokenizer ( text , token ) ; List < String > answer = new ArrayList < String > ( ) ; while ( iter . hasMoreTokens ( ) ) { answer . add ( iter . nextToken ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "tokenize(" + expression + ", " + token + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexTokenize ( final Expression < E > expression , String regexTokenizer ) { final Pattern pattern = Pattern . compile ( regexTokenizer ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } return Arrays . asList ( pattern . split ( text ) ) ; } @ Override public String toString ( ) { return "regexTokenize(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , String regex , final String replacement ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , String regex , final Expression < E > replacementExpression ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; String replacement = evaluateStringExpression ( replacementExpression , exchange ) ; ; if ( text == null || replacement == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > append ( final Expression < E > left , final Expression < E > right ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return evaluateStringExpression ( left , exchange ) + evaluateStringExpression ( right , exchange ) ; } @ Override public String toString ( ) { return "append(" + left + ", " + right + ")" ; } } ; } public static < E extends Exchange > String evaluateStringExpression ( Expression < E > expression , E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , value ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name , final String defaultValue ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return System . getProperty ( name , defaultValue ) ; } } ; } } 	0
